From d7eb897cd901dd853190f73e8e664f88485b5f71 Mon Sep 17 00:00:00 2001
From: Brett Mastbergen <bmastbergen@untangle.com>
Date: Fri, 9 Feb 2018 14:14:03 -0500
Subject: [PATCH] netfilter: Add conndict

Netfilter conndict support allows arbitrary field/value pairs to
be attached to conntrack entries.  Those field/value pairs can then
be matched via iptables and/or nftables.  conndict support can be
configured as a conntrack extension built into the kernel binary or
as a module via livepatching.
---
 include/net/netfilter/nf_conntrack_dict.h   |  51 +++
 include/net/netfilter/nf_conntrack_extend.h |   4 +
 include/uapi/linux/netfilter/Kbuild         |   1 +
 include/uapi/linux/netfilter/nf_tables.h    |  10 +
 include/uapi/linux/netfilter/xt_conndict.h  |  25 ++
 net/netfilter/Kconfig                       |  45 +++
 net/netfilter/Makefile                      |   6 +
 net/netfilter/nf_conntrack_core.c           |   9 +
 net/netfilter/nf_conntrack_dict_core.c      | 597 ++++++++++++++++++++++++++++
 net/netfilter/nf_conntrack_dict_ext.c       |  56 +++
 net/netfilter/nf_conntrack_dict_livepatch.c | 269 +++++++++++++
 net/netfilter/nft_dict.c                    | 165 ++++++++
 net/netfilter/xt_conndict.c                 | 103 +++++
 13 files changed, 1341 insertions(+)
 create mode 100644 include/net/netfilter/nf_conntrack_dict.h
 create mode 100644 include/uapi/linux/netfilter/xt_conndict.h
 create mode 100644 net/netfilter/nf_conntrack_dict_core.c
 create mode 100644 net/netfilter/nf_conntrack_dict_ext.c
 create mode 100644 net/netfilter/nf_conntrack_dict_livepatch.c
 create mode 100644 net/netfilter/nft_dict.c
 create mode 100644 net/netfilter/xt_conndict.c

diff --git a/include/net/netfilter/nf_conntrack_dict.h b/include/net/netfilter/nf_conntrack_dict.h
new file mode 100644
index 000000000000..cdfcbd89030c
--- /dev/null
+++ b/include/net/netfilter/nf_conntrack_dict.h
@@ -0,0 +1,51 @@
+#include <linux/types.h>
+#include <linux/rhashtable.h>
+#include <linux/netfilter/nf_conntrack_common.h>
+#include <linux/netfilter/nf_conntrack_tuple_common.h>
+#include <net/net_namespace.h>
+#include <net/netfilter/nf_conntrack.h>
+#include <net/netfilter/nf_conntrack_extend.h>
+
+struct nf_conn_dict {
+	struct rhash_head node;
+	struct nf_conn * key;
+	struct rhashtable pair_ht;
+};
+
+struct nf_conn_dict_pair_string {
+	char * str;
+	int len;
+	u32 hash;
+};
+
+struct nf_conn_dict_pair {
+	struct rhash_head node;
+	struct nf_conn_dict_pair_string * field;
+	struct nf_conn_dict_pair_string * value;
+	unsigned int ct_id;
+};
+
+#ifdef CONFIG_NF_CONNTRACK_DICT
+struct nf_conn_dict *nf_ct_dict_ext_add(struct nf_conn *ct);
+#else
+static inline struct nf_conn_dict *nf_ct_dict_ext_add(struct nf_conn *ct)
+{
+	return NULL;
+}
+#endif
+
+void nf_conntrack_dict_disable(void);
+int nf_conntrack_dict_enable(void);
+void new_dict(struct nf_conn *ct);
+void destroy_dict(struct nf_conn *ct);
+struct nf_conn_dict * find_conntrack_dict(struct nf_conn *ct);
+struct nf_conn_dict_pair * find_conntrack_dict_pair(struct nf_conn_dict * dict, u32 * hash);
+void new_dict_pair(struct nf_conn_dict *dict, char * field, char * value);
+
+#ifdef CONFIG_NF_CONNTRACK_DICT
+int nf_conntrack_dict_init(void);
+void nf_conntrack_dict_fini(void);
+#else
+static inline int nf_conntrack_dict_init(void) { return 0; }
+static inline void nf_conntrack_dict_fini(void) {}
+#endif
diff --git a/include/net/netfilter/nf_conntrack_extend.h b/include/net/netfilter/nf_conntrack_extend.h
index 1c3035dda31f..c45155e4c627 100644
--- a/include/net/netfilter/nf_conntrack_extend.h
+++ b/include/net/netfilter/nf_conntrack_extend.h
@@ -27,6 +27,9 @@ enum nf_ct_ext_id {
 #if IS_ENABLED(CONFIG_NETFILTER_SYNPROXY)
 	NF_CT_EXT_SYNPROXY,
 #endif
+#ifdef CONFIG_NF_CONNTRACK_DICT
+	NF_CT_EXT_DICT,
+#endif
 	NF_CT_EXT_NUM,
 };
 
@@ -39,6 +42,7 @@ enum nf_ct_ext_id {
 #define NF_CT_EXT_TIMEOUT_TYPE struct nf_conn_timeout
 #define NF_CT_EXT_LABELS_TYPE struct nf_conn_labels
 #define NF_CT_EXT_SYNPROXY_TYPE struct nf_conn_synproxy
+#define NF_CT_EXT_DICT_TYPE struct nf_conn_dict
 
 /* Extensions: optional stuff which isn't permanently in struct. */
 struct nf_ct_ext {
diff --git a/include/uapi/linux/netfilter/Kbuild b/include/uapi/linux/netfilter/Kbuild
index 03f194aeadc5..c3b1906b80e6 100644
--- a/include/uapi/linux/netfilter/Kbuild
+++ b/include/uapi/linux/netfilter/Kbuild
@@ -45,6 +45,7 @@ header-y += xt_cgroup.h
 header-y += xt_cluster.h
 header-y += xt_comment.h
 header-y += xt_connbytes.h
+header-y += xt_conndict.h
 header-y += xt_connlabel.h
 header-y += xt_connlimit.h
 header-y += xt_connmark.h
diff --git a/include/uapi/linux/netfilter/nf_tables.h b/include/uapi/linux/netfilter/nf_tables.h
index c6c4477c136b..88bf44e90d17 100644
--- a/include/uapi/linux/netfilter/nf_tables.h
+++ b/include/uapi/linux/netfilter/nf_tables.h
@@ -1186,4 +1186,14 @@ enum nft_ng_types {
 };
 #define NFT_NG_MAX	(__NFT_NG_MAX - 1)
 
+enum nft_dict_attributes {
+	NFTA_DICT_UNSPEC,
+	NFTA_DICT_FIELD,
+	NFTA_DICT_VALUE,
+	NFTA_DICT_SET,
+	__NFTA_DICT_MAX,
+};
+
+#define NFTA_DICT_MAX (__NFTA_DICT_MAX - 1)
+
 #endif /* _LINUX_NF_TABLES_H */
diff --git a/include/uapi/linux/netfilter/xt_conndict.h b/include/uapi/linux/netfilter/xt_conndict.h
new file mode 100644
index 000000000000..ca67c84d3785
--- /dev/null
+++ b/include/uapi/linux/netfilter/xt_conndict.h
@@ -0,0 +1,25 @@
+#ifndef _XT_CONNDICT_H
+#define _XT_CONNDICT_H
+
+#include <linux/types.h>
+
+#define XT_CONNDICT_MAX_PATTERN_SIZE 128
+
+enum {
+	XT_CONNDICT_FLAG_INVERT		= 1 << 0,
+	XT_CONNDICT_FLAG_SET		= 1 << 1,
+};
+
+struct xt_dict_info {
+	__u8  flags;
+
+	char	field[XT_CONNDICT_MAX_PATTERN_SIZE];
+	__u8	field_len;
+	char	value[XT_CONNDICT_MAX_PATTERN_SIZE];
+	__u8	value_len;
+
+	__u32	field_hash;
+	__u32	value_hash;
+};
+
+#endif /*_XT_CONNDICT_H*/
diff --git a/net/netfilter/Kconfig b/net/netfilter/Kconfig
index e8d56d9a4df2..c8d361e6e15f 100644
--- a/net/netfilter/Kconfig
+++ b/net/netfilter/Kconfig
@@ -114,6 +114,17 @@ config NF_CONNTRACK_EVENTS
 
 	  If unsure, say `N'.
 
+config NF_CONNTRACK_DICT
+	bool  'Connection tracking dictionary'
+	depends on NETFILTER_ADVANCED
+	depends on !NF_CONNTRACK_DICT_LIVEPATCH || NF_CONNTRACK_DICT_LIVEPATCH
+	help
+	  This option enables support for assigning layer 7 fields such as
+	  username or hostname to connection tracking entries. It is meant
+	  to be enabled with the netfilter dictionary match.
+
+	  If unsure, say `N'.
+
 config NF_CONNTRACK_TIMEOUT
 	bool  'Connection tracking timeout'
 	depends on NETFILTER_ADVANCED
@@ -371,6 +382,20 @@ config NETFILTER_NETLINK_GLUE_CT
 	  Connection Tracking information together with the packet is
 	  the enqueued via NFNETLINK.
 
+config NF_CONNTRACK_DICT_LIVEPATCH
+	tristate  'Connection tracking dictionary via livepatching'
+	depends on NETFILTER_ADVANCED
+	depends on LIVEPATCH
+	depends on !NF_CONNTRACK_DICT || NF_CONNTRACK_DICT
+	help
+	  This option enables support for assigning layer 7 fields such as
+	  username or hostname to connection tracking entries. It is meant
+	  to be enabled with the netfilter dictionary match.  This option relies
+	  on livepatching the kernel's init_conntrack and destroy_conntrack functions
+	  instead of a conntrack extension (like NF_CONNTRACK_DICT).
+
+	  If unsure, say `N'.
+
 config NF_NAT
 	tristate
 
@@ -575,6 +600,14 @@ config NFT_COMPAT
 	  x_tables match/target extensions over the nf_tables
 	  framework.
 
+config NFT_DICT
+	tristate "Netfilter nf_tables conntrack dict module"
+	depends on NETFILTER_XTABLES
+	depends on NF_CONNTRACK_DICT || NF_CONNTRACK_DICT_LIVEPATCH
+	help
+	  This match allows you to test and assign layer 7 fields
+	  such as username or hostname to a connection.
+
 config NFT_HASH
 	tristate "Netfilter nf_tables hash module"
 	help
@@ -1405,6 +1438,18 @@ config NETFILTER_XT_MATCH_SCTP
 	  If you want to compile it as a module, say M here and read
 	  <file:Documentation/kbuild/modules.txt>.  If unsure, say `N'.
 
+config NETFILTER_XT_MATCH_CONNDICT
+	tristate '"conndict" match support'
+	depends on NF_CONNTRACK
+	depends on NETFILTER_ADVANCED
+	depends on NF_CONNTRACK_DICT || NF_CONNTRACK_DICT_LIVEPATCH
+	---help---
+	  This match allows you to test and assign layer 7 fields
+	  such as username or hostname to a connection.
+
+	  If you want to compile it as a module, say M here and read
+	  <file:Documentation/kbuild/modules.txt>.  If unsure, say `N'.
+
 config NETFILTER_XT_MATCH_SOCKET
 	tristate '"socket" match support'
 	depends on NETFILTER_XTABLES
diff --git a/net/netfilter/Makefile b/net/netfilter/Makefile
index c23c3c84416f..175feaba2907 100644
--- a/net/netfilter/Makefile
+++ b/net/netfilter/Makefile
@@ -5,6 +5,10 @@ nf_conntrack-$(CONFIG_NF_CONNTRACK_TIMEOUT) += nf_conntrack_timeout.o
 nf_conntrack-$(CONFIG_NF_CONNTRACK_TIMESTAMP) += nf_conntrack_timestamp.o
 nf_conntrack-$(CONFIG_NF_CONNTRACK_EVENTS) += nf_conntrack_ecache.o
 nf_conntrack-$(CONFIG_NF_CONNTRACK_LABELS) += nf_conntrack_labels.o
+nf_conntrack-$(CONFIG_NF_CONNTRACK_DICT) += nf_conntrack_dict_ext.o nf_conntrack_dict_core.o
+
+nf_conntrack_dict-objs += nf_conntrack_dict_livepatch.o nf_conntrack_dict_core.o
+obj-$(CONFIG_NF_CONNTRACK_DICT_LIVEPATCH) += nf_conntrack_dict.o
 
 obj-$(CONFIG_NETFILTER) = netfilter.o
 
@@ -79,6 +83,7 @@ obj-$(CONFIG_NF_TABLES)		+= nf_tables.o
 obj-$(CONFIG_NF_TABLES_INET)	+= nf_tables_inet.o
 obj-$(CONFIG_NF_TABLES_NETDEV)	+= nf_tables_netdev.o
 obj-$(CONFIG_NFT_COMPAT)	+= nft_compat.o
+obj-$(CONFIG_NFT_DICT)		+= nft_dict.o
 obj-$(CONFIG_NFT_EXTHDR)	+= nft_exthdr.o
 obj-$(CONFIG_NFT_META)		+= nft_meta.o
 obj-$(CONFIG_NFT_NUMGEN)	+= nft_numgen.o
@@ -140,6 +145,7 @@ obj-$(CONFIG_NETFILTER_XT_MATCH_BPF) += xt_bpf.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_CLUSTER) += xt_cluster.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_COMMENT) += xt_comment.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_CONNBYTES) += xt_connbytes.o
+obj-$(CONFIG_NETFILTER_XT_MATCH_CONNDICT) += xt_conndict.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_CONNLABEL) += xt_connlabel.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_CONNLIMIT) += xt_connlimit.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_CONNTRACK) += xt_conntrack.o
diff --git a/net/netfilter/nf_conntrack_core.c b/net/netfilter/nf_conntrack_core.c
index 750b8bf13e60..1b4b5b6764e6 100644
--- a/net/netfilter/nf_conntrack_core.c
+++ b/net/netfilter/nf_conntrack_core.c
@@ -51,6 +51,7 @@
 #include <net/netfilter/nf_conntrack_timeout.h>
 #include <net/netfilter/nf_conntrack_labels.h>
 #include <net/netfilter/nf_conntrack_synproxy.h>
+#include <net/netfilter/nf_conntrack_dict.h>
 #include <net/netfilter/nf_nat.h>
 #include <net/netfilter/nf_nat_core.h>
 #include <net/netfilter/nf_nat_helper.h>
@@ -1172,6 +1173,7 @@ init_conntrack(struct net *net, struct nf_conn *tmpl,
 	nf_ct_acct_ext_add(ct, GFP_ATOMIC);
 	nf_ct_tstamp_ext_add(ct, GFP_ATOMIC);
 	nf_ct_labels_ext_add(ct);
+	nf_ct_dict_ext_add(ct);
 
 	ecache = tmpl ? nf_ct_ecache_find(tmpl) : NULL;
 	nf_ct_ecache_ext_add(ct, ecache ? ecache->ctmask : 0,
@@ -1648,6 +1650,7 @@ void nf_conntrack_cleanup_end(void)
 	cancel_delayed_work_sync(&conntrack_gc_work.dwork);
 	nf_ct_free_hashtable(nf_conntrack_hash, nf_conntrack_htable_size);
 
+	nf_conntrack_dict_fini();
 	nf_conntrack_proto_fini();
 	nf_conntrack_seqadj_fini();
 	nf_conntrack_labels_fini();
@@ -1912,6 +1915,10 @@ int nf_conntrack_init_start(void)
 	if (ret < 0)
 		goto err_proto;
 
+	ret = nf_conntrack_dict_init();
+	if (ret < 0)
+		goto err_dict;
+
 	/* Set up fake conntrack: to never be deleted, not in any hashes */
 	for_each_possible_cpu(cpu) {
 		struct nf_conn *ct = &per_cpu(nf_conntrack_untracked, cpu);
@@ -1926,6 +1933,8 @@ int nf_conntrack_init_start(void)
 
 	return 0;
 
+err_dict:
+	nf_conntrack_proto_fini();
 err_proto:
 	nf_conntrack_seqadj_fini();
 err_seqadj:
diff --git a/net/netfilter/nf_conntrack_dict_core.c b/net/netfilter/nf_conntrack_dict_core.c
new file mode 100644
index 000000000000..bd7f74015751
--- /dev/null
+++ b/net/netfilter/nf_conntrack_dict_core.c
@@ -0,0 +1,597 @@
+#include <linux/module.h>
+#include <linux/proc_fs.h>
+#include <linux/rhashtable.h>
+#include <linux/glob.h>
+#include <linux/jhash.h>
+#include <linux/parser.h>
+#include <net/netfilter/nf_conntrack.h>
+#include <net/netfilter/nf_conntrack_dict.h>
+
+static struct proc_dir_entry *dict_dir;
+static struct rhashtable ht;
+
+static const struct rhashtable_params dict_rhashtable_params = {
+	.head_offset = offsetof(struct nf_conn_dict, node),
+	.key_offset = offsetof(struct nf_conn_dict, key),
+	.key_len = sizeof(struct nf_conn *),
+	.automatic_shrinking = true,
+};
+
+static inline int pair_hash_cmp(struct rhashtable_compare_arg *arg, const void *ptr)
+{
+	struct nf_conn_dict_pair * pair = (struct nf_conn_dict_pair *)ptr;
+	u32 hash = *(u32 *)arg->key;
+
+	return !(hash == pair->field->hash);
+}
+
+static inline u32 pair_hash_obj(const void *data, u32 len, u32 seed)
+{
+	struct nf_conn_dict_pair * pair = (struct nf_conn_dict_pair *) data;
+
+	return pair->field->hash;
+}
+
+static inline u32 pair_hash_key(const void *data, u32 len, u32 seed)
+{
+	u32 hash = *(u32 *)data;
+
+	return hash;
+}
+
+static const struct rhashtable_params pair_rhashtable_params = {
+	.head_offset = offsetof(struct nf_conn_dict_pair, node),
+	.hashfn	= pair_hash_key,
+	.obj_hashfn = pair_hash_obj,
+	.obj_cmpfn = pair_hash_cmp,
+	.automatic_shrinking = true,
+};
+
+static struct nf_conn_dict * find_dict_by_id(unsigned int id)
+{
+	struct rhashtable_iter hti;
+	struct nf_conn_dict *dict, *ret_dict = NULL;
+	unsigned int err;
+
+	err = rhashtable_walk_init(&ht, &hti, GFP_KERNEL);
+	if (err) {
+		pr_err("%s: rhashtable_walk_init failed: allocation error: %d", __func__, err);
+		return NULL;
+	}
+
+	err = rhashtable_walk_start(&hti);
+	if (err && err != -EAGAIN) {
+		pr_err("%s: rhashtable_walk_start failed: %d\n", __func__, err);
+		return NULL;
+	}
+
+	while ((dict = rhashtable_walk_next(&hti)) && !IS_ERR(dict)) {
+		unsigned int ct_id = (unsigned long)dict->key;
+
+		if(ct_id == id) {
+			ret_dict = dict;
+			break;
+		}
+	}
+
+	rhashtable_walk_stop(&hti);
+	rhashtable_walk_exit(&hti);
+
+	return ret_dict;
+}
+
+static int show_dict(struct seq_file *m, struct nf_conn_dict *dict)
+{
+	struct rhashtable *ht = &dict->pair_ht;
+	struct rhashtable_iter hti;
+	struct nf_conn_dict_pair *pair;
+	unsigned int err;
+	unsigned int ct_id;
+
+	ct_id = (unsigned long)dict->key;
+	seq_printf(m, "id: %u\n", ct_id);
+
+	err = rhashtable_walk_init(ht, &hti, GFP_KERNEL);
+	if (err) {
+		pr_err("%s: rhashtable_walk_init failed: allocation error: %d", __func__, err);
+		return err;
+	}
+
+	err = rhashtable_walk_start(&hti);
+	if (err && err != -EAGAIN) {
+		pr_err("%s: rhashtable_walk_start failed: %d\n", __func__, err);
+		return err;
+	}
+
+	while ((pair = rhashtable_walk_next(&hti)) && !IS_ERR(dict)) {
+		seq_printf(m, "%s: %s\n", pair->field->str, pair->value->str);
+	}
+
+	rhashtable_walk_stop(&hti);
+	rhashtable_walk_exit(&hti);
+
+	return 0;
+}
+
+static int all_dict_show(struct seq_file *m, void *v)
+{
+	struct rhashtable *ht = (struct rhashtable *)m->private;
+	struct rhashtable_iter hti;
+	struct nf_conn_dict *dict;
+	unsigned int err;
+
+	err = rhashtable_walk_init(ht, &hti, GFP_KERNEL);
+	if (err) {
+		pr_err("%s: rhashtable_walk_init failed: allocation error: %d", __func__, err);
+		return err;
+	}
+
+	err = rhashtable_walk_start(&hti);
+	if (err && err != -EAGAIN) {
+		pr_err("%s: rhashtable_walk_start failed: %d\n", __func__, err);
+		return err;
+	}
+
+	while ((dict = rhashtable_walk_next(&hti)) && !IS_ERR(dict)) {
+		show_dict(m, dict);
+	}
+
+	rhashtable_walk_stop(&hti);
+	rhashtable_walk_exit(&hti);
+
+	return 0;
+}
+
+static int all_dict_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, all_dict_show, PDE_DATA(inode));
+}
+
+static const struct file_operations all_dict_file_ops = {
+	.owner   = THIS_MODULE,
+	.open    = all_dict_open,
+	.read    = seq_read,
+	.llseek  = seq_lseek,
+	.release = single_release,
+};
+
+static int all_show(struct seq_file *m, void *v)
+{
+	struct nf_conn_dict *dict = (struct nf_conn_dict *)m->private;
+
+	show_dict(m, dict);
+
+	return 0;
+}
+
+static int all_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, all_show, PDE_DATA(inode));
+}
+
+enum {
+	Opt_id,
+	Opt_field,
+	Opt_value,
+	Opt_err,
+};
+
+static const match_table_t tokens = {
+	{Opt_id, "id=%u"},
+	{Opt_field, "field=%s"},
+	{Opt_value, "value=%s"},
+	{Opt_err, NULL},
+};
+
+static int match_uint(substring_t *s, unsigned int *result)
+{
+	char *buf;
+	int ret;
+	unsigned int val;
+	size_t len = s->to - s->from;
+
+	buf = kmalloc(len + 1, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	memcpy(buf, s->from, len);
+	buf[len] = '\0';
+
+	ret = kstrtouint(buf, 0, &val);
+	if(!ret)
+		*result = val;
+
+	kfree(buf);
+	return ret;
+}
+
+static ssize_t top_write(struct file *file, const char __user *buf, size_t size, loff_t *pos)
+{
+	char * orig, * local_buf, * p, * field = NULL, * value = NULL;
+	unsigned int id = 0;
+	struct nf_conn_dict *dict = PDE_DATA(file_inode(file));
+	substring_t args[MAX_OPT_ARGS];
+
+	orig = local_buf = kzalloc(size, GFP_KERNEL);
+	if(!local_buf) {
+		pr_err("%s: Could not allocate local buffer!\n", __func__);
+		goto err;
+	}
+
+	if (copy_from_user(local_buf, buf, size) != 0) {
+		pr_err("%s: copy_from_user failed!\n", __func__);
+		goto free_local_buf;
+	}
+
+	while ((p = strsep(&local_buf, ","))) {
+		int token;
+
+		if (!*p)
+			continue;
+
+		token = match_token(p, tokens, args);
+		switch (token) {
+			case Opt_id:
+				{
+					int ret = 0;
+					ret = match_uint(&args[0], &id);
+					if(ret) {
+						pr_err("%s: Opt_id failed %d\n", __func__, ret);
+						goto free_local_buf;
+					}
+					break;
+				}
+			case Opt_field:
+				{
+					field = match_strdup(&args[0]);
+					break;
+				}
+			case Opt_value:
+				{
+					value = match_strdup(&args[0]);
+					break;
+				}
+
+			default:
+				pr_err("unrecognized option \"%s\" "
+				       "or missing value\n", p);
+				break;
+		}
+	}
+
+	if(id != 0 && field && value) {
+		dict = find_dict_by_id(id);
+		if(dict) {
+			new_dict_pair(dict, field, value);
+		}
+	} else {
+		pr_err("%s: Insuffient input\n", __func__);
+	}
+
+	kfree(field);
+	kfree(value);
+free_local_buf:
+	kfree(orig);
+err:
+	return size;
+}
+
+static const struct file_operations top_write_file_ops = {
+	.owner   = THIS_MODULE,
+	.open    = all_open,
+	.read    = seq_read,
+	.write   = top_write,
+	.llseek  = seq_lseek,
+	.release = single_release,
+};
+
+static unsigned int read_id = 0;
+static int top_show(struct seq_file *m, void *v)
+{
+	struct nf_conn_dict *dict;
+
+	dict = find_dict_by_id(read_id);
+	if(dict) {
+		show_dict(m, dict);
+	}
+
+	return 0;
+}
+
+static int top_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, top_show, PDE_DATA(inode));
+}
+
+static ssize_t read_id_write(struct file *file, const char __user *buf, size_t size, loff_t *pos)
+{
+
+	int ret;
+
+	ret = kstrtouint_from_user(buf, size, 10, &read_id);
+	if(ret) {
+		return ret;
+	}
+
+	return size;
+}
+
+static const struct file_operations top_read_file_ops = {
+	.owner   = THIS_MODULE,
+	.open    = top_open,
+	.read    = seq_read,
+	.write   = read_id_write,
+	.llseek  = seq_lseek,
+	.release = single_release,
+};
+
+static struct nf_conn_dict_pair_string * alloc_dict_pair_string(int string_size)
+{
+	struct nf_conn_dict_pair_string * new;
+
+	new = kzalloc(sizeof(*new), GFP_KERNEL);
+	if(!new) {
+		pr_err("%s: Could not allocate new pair string\n", __func__);
+		goto err;
+	}
+
+	new->str = kzalloc(string_size, GFP_KERNEL);
+	if(!new->str) {
+		pr_err("%s: Could not allocate new string\n", __func__);
+		goto err_free_new;
+	}
+
+	return new;
+
+err_free_new:
+	kfree(new);
+err:
+	return NULL;
+}
+
+static void free_dict_pair_string(struct nf_conn_dict_pair_string * dict_pair_string)
+{
+	kfree(dict_pair_string->str);
+	kfree(dict_pair_string);
+}
+
+static void free_pair(struct nf_conn_dict_pair *pair)
+{
+	free_dict_pair_string(pair->field);
+	free_dict_pair_string(pair->value);
+	kfree(pair);
+}
+
+void new_dict_pair(struct nf_conn_dict *dict, char * field, char * value)
+{
+	struct nf_conn_dict_pair * pair;
+	struct nf_conn_dict_pair_string * new_value, * old_value;
+	int ret;
+	u32 hash;
+
+	new_value = alloc_dict_pair_string(strlen(value) + 1);
+	if(!new_value) {
+		pr_err("%s: Could not allocate new_value\n", __func__);
+		return;
+	}
+
+	strcpy(new_value->str, value);
+	new_value->len = strlen(new_value->str);
+	new_value->hash = jhash(new_value->str, new_value->len, 0);
+
+	hash = jhash(field, strlen(field), 0);
+
+	rcu_read_lock();
+	pair = rhashtable_lookup_fast(&dict->pair_ht, &hash, pair_rhashtable_params);
+	rcu_read_unlock();
+	if(!pair) {
+		pair = kzalloc(sizeof(*pair), GFP_KERNEL);
+		if(!pair) {
+			pr_err("%s: Could not allocate pair structure\n", __func__);
+			free_dict_pair_string(new_value);
+			return;
+		}
+
+		pair->field = alloc_dict_pair_string(strlen(field) + 1);
+		if(!pair->field) {
+			pr_err("%s: Could not allocate pair->field\n", __func__);
+			free_dict_pair_string(new_value);
+			kfree(pair);
+			return;
+		}
+
+		strcpy(pair->field->str, field);
+		pair->field->len = strlen(pair->field->str);
+		pair->field->hash = hash;
+		pair->ct_id = (unsigned long)dict->key;
+		pair->value = new_value;
+
+		ret = rhashtable_lookup_insert_key(&dict->pair_ht, &pair->field->hash, &pair->node, pair_rhashtable_params);
+		if(ret < 0) {
+			pr_err("%s: Unable to insert pair into hashtable: %d\n", __func__, ret);
+			free_pair(pair);
+			return;
+		}
+
+	} else {
+		old_value = rcu_dereference(pair->value);
+		rcu_assign_pointer(pair->value, new_value);
+		free_dict_pair_string(old_value);
+	}
+
+	return;
+}
+EXPORT_SYMBOL_GPL(new_dict_pair);
+
+void new_dict(struct nf_conn *ct)
+{
+	struct nf_conn_dict * dict;
+	int ret;
+
+	dict = kzalloc(sizeof(*dict), GFP_KERNEL);
+	if(!dict) {
+		pr_err("%s: Could not allocate dict structure\n", __func__);
+		return;
+	}
+
+	dict->key = ct;
+
+	ret = rhashtable_lookup_insert_fast(&ht, &dict->node, dict_rhashtable_params);
+	if(ret < 0) {
+		pr_err("%s: Unable to insert dict into hashtable: %d\n", __func__, ret);
+		kfree(dict);
+		return;
+	}
+
+	ret = rhashtable_init(&dict->pair_ht, &pair_rhashtable_params);
+	if(ret < 0) {
+		pr_err("%s: Unable to initialize pair hashtable: %d\n", __func__, ret);
+		return;
+	}
+}
+
+static void free_dict_pair(void *ptr, void *arg)
+{
+	struct nf_conn_dict_pair * pair = (struct nf_conn_dict_pair *)ptr;
+
+	free_pair(pair);
+}
+
+static void __free_dict(struct nf_conn_dict * dict)
+{
+	if(!dict)
+		return;
+
+	rhashtable_free_and_destroy(&dict->pair_ht, free_dict_pair, NULL);
+
+	kfree(dict);
+}
+
+static void free_dict(void *ptr, void *arg)
+{
+	struct nf_conn_dict * dict = (struct nf_conn_dict *)ptr;
+
+	__free_dict(dict);
+}
+
+struct nf_conn_dict * find_conntrack_dict(struct nf_conn *ct)
+{
+	struct nf_conn_dict * dict;
+
+	rcu_read_lock();
+	dict = rhashtable_lookup_fast(&ht, &ct, dict_rhashtable_params);
+	rcu_read_unlock();
+
+	return dict;
+}
+EXPORT_SYMBOL_GPL(find_conntrack_dict);
+
+struct nf_conn_dict_pair * find_conntrack_dict_pair(struct nf_conn_dict * dict, u32 * hash)
+{
+	struct nf_conn_dict_pair * pair;
+
+	rcu_read_lock();
+	pair = rhashtable_lookup_fast(&dict->pair_ht, hash, pair_rhashtable_params);
+	rcu_read_unlock();
+
+	return pair;
+}
+EXPORT_SYMBOL_GPL(find_conntrack_dict_pair);
+
+void destroy_dict(struct nf_conn *ct)
+{
+	struct nf_conn_dict * dict;
+	int ret;
+
+	dict = find_conntrack_dict(ct);
+	if(!dict) {
+		return;
+	}
+
+	ret = rhashtable_remove_fast(&ht, &dict->node, dict_rhashtable_params);
+	if(ret < 0) {
+		pr_err("%s: Unable to remove seession from hashtable: %d\n", __func__, ret);
+		return;
+	}
+
+	__free_dict(dict);
+}
+
+static int __net_init dict_net_init(struct net *net)
+{
+	int ret = 0;
+	struct proc_dir_entry * temp;
+
+	dict_dir = proc_net_mkdir(net, "dict", net->proc_net);
+	if (!dict_dir) {
+		pr_err("cannot create dict proc entry");
+		return -ENOMEM;
+	}
+
+	temp = proc_create_data("all", 0440, dict_dir, &all_dict_file_ops, &ht);
+	if (!temp) {
+		pr_err("cannot create all proc");
+		remove_proc_entry("dict", net->proc_net);
+		return -ENOMEM;
+	}
+
+	temp = proc_create_data("write", 0440, dict_dir, &top_write_file_ops, NULL);
+	if (!temp) {
+		remove_proc_entry("all", dict_dir);
+		pr_err("cannot create write proc");
+		return -ENOMEM;
+	}
+
+	temp = proc_create_data("read", 0440, dict_dir, &top_read_file_ops, NULL);
+	if (!temp) {
+		remove_proc_entry("write", dict_dir);
+		remove_proc_entry("all", dict_dir);
+		pr_err("cannot create read proc");
+		return -ENOMEM;
+	}
+
+	return ret;
+}
+
+static void __net_exit dict_net_exit(struct net *net)
+{
+	remove_proc_entry("read", dict_dir);
+	remove_proc_entry("write", dict_dir);
+	remove_proc_entry("all", dict_dir);
+	remove_proc_entry("dict", net->proc_net);
+}
+
+static struct pernet_operations dict_net_ops = {
+	.init = dict_net_init,
+	.exit = dict_net_exit,
+};
+
+void nf_conntrack_dict_disable(void)
+{
+	unregister_pernet_subsys(&dict_net_ops);
+	rhashtable_free_and_destroy(&ht, free_dict, NULL);
+}
+
+int nf_conntrack_dict_enable(void)
+{
+	int err = 0;
+
+	err = rhashtable_init(&ht, &dict_rhashtable_params);
+	if(err < 0) {
+		pr_err("%s: Unable to initialize hashtable: %d\n", __func__, err);
+		goto err;
+	}
+
+	err = register_pernet_subsys(&dict_net_ops);
+	if (err) {
+		goto err_destroy_rhashtable;
+	}
+
+	return 0;
+
+err_destroy_rhashtable:
+	rhashtable_free_and_destroy(&ht, free_dict, NULL);
+err:
+	return err;
+}
+
diff --git a/net/netfilter/nf_conntrack_dict_ext.c b/net/netfilter/nf_conntrack_dict_ext.c
new file mode 100644
index 000000000000..713bd74290bd
--- /dev/null
+++ b/net/netfilter/nf_conntrack_dict_ext.c
@@ -0,0 +1,56 @@
+/*
+ *
+ * (C) 2013 Astaro GmbH & Co KG
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/export.h>
+#include <linux/types.h>
+
+#include <net/netfilter/nf_conntrack_dict.h>
+
+struct nf_conn_dict *nf_ct_dict_ext_add(struct nf_conn *ct)
+{
+	struct nf_conn_dict * dict;
+
+	dict = nf_ct_ext_add(ct, NF_CT_EXT_DICT, GFP_ATOMIC);
+	if(dict) {
+		new_dict(ct);
+	}
+
+	return dict;
+}
+
+static void nf_dict_destroy(struct nf_conn *ct)
+{
+	destroy_dict(ct);
+}
+
+static struct nf_ct_ext_type dict_extend __read_mostly = {
+	.len    = sizeof(struct nf_conn_dict *),
+	.align  = __alignof__(struct nf_conn_dict *),
+	.destroy	= nf_dict_destroy,
+	.id     = NF_CT_EXT_DICT,
+};
+
+int nf_conntrack_dict_init(void)
+{
+
+	int err = 0;
+
+	err = nf_conntrack_dict_enable();
+	if (err) {
+		return err;
+	}
+
+	return nf_ct_extend_register(&dict_extend);
+}
+
+void nf_conntrack_dict_fini(void)
+{
+	nf_ct_extend_unregister(&dict_extend);
+	nf_conntrack_dict_disable();
+}
diff --git a/net/netfilter/nf_conntrack_dict_livepatch.c b/net/netfilter/nf_conntrack_dict_livepatch.c
new file mode 100644
index 000000000000..8f1f7958b6fe
--- /dev/null
+++ b/net/netfilter/nf_conntrack_dict_livepatch.c
@@ -0,0 +1,269 @@
+#include <linux/module.h>
+#include <linux/livepatch.h>
+#include <net/netfilter/nf_conntrack.h>
+#include <net/netfilter/nf_conntrack_acct.h>
+#include <net/netfilter/nf_conntrack_dict.h>
+#include <net/netfilter/nf_conntrack_core.h>
+#include <net/netfilter/nf_conntrack_expect.h>
+#include <net/netfilter/nf_conntrack_helper.h>
+#include <net/netfilter/nf_conntrack_l4proto.h>
+#include <net/netfilter/nf_conntrack_labels.h>
+#include <net/netfilter/nf_conntrack_seqadj.h>
+#include <net/netfilter/nf_conntrack_synproxy.h>
+#include <net/netfilter/nf_conntrack_timeout.h>
+#include <net/netfilter/nf_conntrack_timestamp.h>
+
+MODULE_AUTHOR("Brett Mastbergen <bmastbergen@untangle.com>");
+MODULE_DESCRIPTION("Livepatched conntrack dict support");
+MODULE_LICENSE("GPL");
+MODULE_INFO(livepatch, "Y");
+
+static void livepatch_destroy_conntrack(struct nf_conntrack *nfct)
+{
+	struct nf_conn *ct = (struct nf_conn *)nfct;
+	struct nf_conntrack_l4proto *l4proto;
+	void (*my_nf_ct_del_from_dying_or_unconfirmed_list)(struct nf_conn *ct);
+
+	my_nf_ct_del_from_dying_or_unconfirmed_list = (void *)kallsyms_lookup_name("nf_ct_del_from_dying_or_unconfirmed_list");
+
+	pr_debug("destroy_conntrack(%p)\n", ct);
+	NF_CT_ASSERT(atomic_read(&nfct->use) == 0);
+
+	if (unlikely(nf_ct_is_template(ct))) {
+		nf_ct_tmpl_free(ct);
+		return;
+	}
+	rcu_read_lock();
+	l4proto = __nf_ct_l4proto_find(nf_ct_l3num(ct), nf_ct_protonum(ct));
+	if (l4proto->destroy)
+		l4proto->destroy(ct);
+
+	rcu_read_unlock();
+
+	local_bh_disable();
+	/* Expectations will have been removed in clean_from_lists,
+	 * except TFTP can create an expectation on the first packet,
+	 * before connection is in the list, so we need to clean here,
+	 * too.
+	 */
+	nf_ct_remove_expectations(ct);
+
+	my_nf_ct_del_from_dying_or_unconfirmed_list(ct);
+
+	local_bh_enable();
+
+	if (ct->master)
+		nf_ct_put(ct->master);
+
+	pr_debug("destroy_conntrack: returning ct=%p to slab\n", ct);
+	destroy_dict(ct);
+	nf_conntrack_free(ct);
+}
+
+static void my_nf_ct_add_to_unconfirmed_list(struct nf_conn *ct)
+{
+	struct ct_pcpu *pcpu;
+
+	/* add this conntrack to the (per cpu) unconfirmed list */
+	ct->cpu = smp_processor_id();
+	pcpu = per_cpu_ptr(nf_ct_net(ct)->ct.pcpu_lists, ct->cpu);
+
+	spin_lock(&pcpu->lock);
+	hlist_nulls_add_head(&ct->tuplehash[IP_CT_DIR_ORIGINAL].hnnode,
+			     &pcpu->unconfirmed);
+	spin_unlock(&pcpu->lock);
+}
+
+static struct nf_conntrack_tuple_hash *
+livepatch_init_conntrack(struct net *net, struct nf_conn *tmpl,
+	       const struct nf_conntrack_tuple *tuple,
+	       struct nf_conntrack_l3proto *l3proto,
+	       struct nf_conntrack_l4proto *l4proto,
+	       struct sk_buff *skb,
+	       unsigned int dataoff, u32 hash)
+{
+	struct nf_conn *ct;
+	struct nf_conn_help *help;
+	struct nf_conntrack_tuple repl_tuple;
+	struct nf_conntrack_ecache *ecache;
+	struct nf_conntrack_expect *exp = NULL;
+	const struct nf_conntrack_zone *zone;
+	struct nf_conn_timeout *timeout_ext;
+	struct nf_conntrack_zone tmp;
+	unsigned int *timeouts;
+	struct nf_conn * (*__my_nf_conntrack_alloc)(struct net *net,
+		     const struct nf_conntrack_zone *zone,
+		     const struct nf_conntrack_tuple *orig,
+		     const struct nf_conntrack_tuple *repl,
+		     gfp_t gfp, u32 hash);
+
+	struct nf_conntrack_expect *
+	(*my_nf_ct_find_expectation)(struct net *net,
+		       const struct nf_conntrack_zone *zone,
+		       const struct nf_conntrack_tuple *tuple);
+
+	__my_nf_conntrack_alloc = (void *)kallsyms_lookup_name("__nf_conntrack_alloc");
+	if(!__my_nf_conntrack_alloc) {
+		BUG();
+	}
+
+	my_nf_ct_find_expectation = (void *)kallsyms_lookup_name("nf_ct_find_expectation");
+	if(!my_nf_ct_find_expectation) {
+		BUG();
+	}
+
+	if (!nf_ct_invert_tuple(&repl_tuple, tuple, l3proto, l4proto)) {
+		pr_debug("Can't invert tuple.\n");
+		return NULL;
+	}
+
+	zone = nf_ct_zone_tmpl(tmpl, skb, &tmp);
+	ct = __my_nf_conntrack_alloc(net, zone, tuple, &repl_tuple, GFP_ATOMIC,
+				  hash);
+	if (IS_ERR(ct))
+		return (struct nf_conntrack_tuple_hash *)ct;
+
+	if (!nf_ct_add_synproxy(ct, tmpl)) {
+		nf_conntrack_free(ct);
+		return ERR_PTR(-ENOMEM);
+	}
+
+	timeout_ext = tmpl ? nf_ct_timeout_find(tmpl) : NULL;
+	if (timeout_ext) {
+		timeouts = nf_ct_timeout_data(timeout_ext);
+		if (unlikely(!timeouts))
+			timeouts = l4proto->get_timeouts(net);
+	} else {
+		timeouts = l4proto->get_timeouts(net);
+	}
+
+	if (!l4proto->new(ct, skb, dataoff, timeouts)) {
+		nf_conntrack_free(ct);
+		pr_debug("can't track with proto module\n");
+		return NULL;
+	}
+
+	if (timeout_ext)
+		nf_ct_timeout_ext_add(ct, rcu_dereference(timeout_ext->timeout),
+				      GFP_ATOMIC);
+
+	nf_ct_acct_ext_add(ct, GFP_ATOMIC);
+	nf_ct_tstamp_ext_add(ct, GFP_ATOMIC);
+	nf_ct_labels_ext_add(ct);
+	nf_ct_dict_ext_add(ct);
+
+	ecache = tmpl ? nf_ct_ecache_find(tmpl) : NULL;
+	nf_ct_ecache_ext_add(ct, ecache ? ecache->ctmask : 0,
+				 ecache ? ecache->expmask : 0,
+			     GFP_ATOMIC);
+
+	local_bh_disable();
+	if (net->ct.expect_count) {
+		spin_lock(&nf_conntrack_expect_lock);
+		exp = my_nf_ct_find_expectation(net, zone, tuple);
+		if (exp) {
+			pr_debug("expectation arrives ct=%p exp=%p\n",
+				 ct, exp);
+			/* Welcome, Mr. Bond.  We've been expecting you... */
+			__set_bit(IPS_EXPECTED_BIT, &ct->status);
+			/* exp->master safe, refcnt bumped in nf_ct_find_expectation */
+			ct->master = exp->master;
+			if (exp->helper) {
+				help = nf_ct_helper_ext_add(ct, exp->helper,
+							    GFP_ATOMIC);
+				if (help)
+					rcu_assign_pointer(help->helper, exp->helper);
+			}
+
+#ifdef CONFIG_NF_CONNTRACK_MARK
+			ct->mark = exp->master->mark;
+#endif
+#ifdef CONFIG_NF_CONNTRACK_SECMARK
+			ct->secmark = exp->master->secmark;
+#endif
+			NF_CT_STAT_INC(net, expect_new);
+		}
+		spin_unlock(&nf_conntrack_expect_lock);
+	}
+	if (!exp)
+		__nf_ct_try_assign_helper(ct, tmpl, GFP_ATOMIC);
+
+	/* Now it is inserted into the unconfirmed list, bump refcount */
+	nf_conntrack_get(&ct->ct_general);
+	my_nf_ct_add_to_unconfirmed_list(ct);
+
+	local_bh_enable();
+
+	if (exp) {
+		if (exp->expectfn)
+			exp->expectfn(ct, exp);
+		nf_ct_expect_put(exp);
+	}
+
+	new_dict(ct);
+
+	return &ct->tuplehash[IP_CT_DIR_ORIGINAL];
+}
+
+
+static struct klp_func funcs[] = {
+	{
+		.old_name = "init_conntrack",
+		.new_func = livepatch_init_conntrack,
+	},
+	{
+		.old_name = "destroy_conntrack",
+		.new_func = livepatch_destroy_conntrack,
+	}, { }
+};
+
+static struct klp_object objs[] = {
+	{
+		/* name being NULL means vmlinux */
+		.funcs = funcs,
+	}, { }
+};
+
+static struct klp_patch patch = {
+	.mod = THIS_MODULE,
+	.objs = objs,
+};
+
+static void nf_conntrack_dict_livepatch_exit(void)
+{
+	WARN_ON(klp_disable_patch(&patch));
+	WARN_ON(klp_unregister_patch(&patch));
+	nf_conntrack_dict_disable();
+}
+
+static int nf_conntrack_dict_livepatch_init(void)
+{
+	int err = 0;
+
+	err = nf_conntrack_dict_enable();
+	if (err) {
+		goto err;
+	}
+
+	err = klp_register_patch(&patch);
+	if (err) {
+		goto err_conntrack_dict_disable;
+	}
+
+	err = klp_enable_patch(&patch);
+	if (err) {
+		goto err_unregister_patch;
+	}
+
+	return 0;
+
+err_unregister_patch:
+	WARN_ON(klp_unregister_patch(&patch));
+err_conntrack_dict_disable:
+	nf_conntrack_dict_disable();
+err:
+	return err;
+}
+
+module_init(nf_conntrack_dict_livepatch_init);
+module_exit(nf_conntrack_dict_livepatch_exit);
diff --git a/net/netfilter/nft_dict.c b/net/netfilter/nft_dict.c
new file mode 100644
index 000000000000..25a419a23843
--- /dev/null
+++ b/net/netfilter/nft_dict.c
@@ -0,0 +1,165 @@
+#include <linux/glob.h>
+#include <linux/tcp.h>
+#include <net/netfilter/nf_tables.h>
+#include <net/netfilter/nf_conntrack.h>
+#include <net/netfilter/nf_conntrack_dict.h>
+
+#define DICT_FIELD_SIZE 128
+#define DICT_VALUE_SIZE 128
+struct nft_dict {
+	char field[DICT_FIELD_SIZE];
+	u8 field_len;
+	u32 field_hash;
+	char value[DICT_VALUE_SIZE];
+	u8 value_len;
+	u32 value_hash;
+	u32 set;
+};
+
+static const struct nla_policy nft_dict_policy[NFTA_DICT_MAX + 1] = {
+	[NFTA_DICT_FIELD]	= { .type = NLA_STRING, .len = DICT_FIELD_SIZE },
+	[NFTA_DICT_VALUE]	= { .type = NLA_STRING, .len = DICT_VALUE_SIZE },
+	[NFTA_DICT_SET]		= { .type = NLA_U32 },
+};
+
+static void nft_dict_get_eval(const struct nft_expr *expr, struct nft_regs *regs, const struct nft_pktinfo *pkt)
+{
+	struct nft_dict *priv = nft_expr_priv(expr);
+	enum ip_conntrack_info ctinfo;
+	struct nf_conn *ct;
+	struct nf_conn_dict * dict;
+	struct nf_conn_dict_pair * pair;
+
+	regs->verdict.code = NFT_BREAK;
+	
+	ct = nf_ct_get(pkt->skb, &ctinfo);
+	if (ct == NULL || nf_ct_is_untracked(ct)) {
+		return;
+	}
+
+	dict = find_conntrack_dict(ct);
+	if(!dict) {
+		return;
+	}
+
+	pair = find_conntrack_dict_pair(dict, &priv->field_hash);
+	if(!pair) {
+		return;
+	}
+
+	rcu_read_lock();
+	if(priv->value_hash != pair->value->hash) {
+		if(glob_match(priv->value, pair->value->str)) {
+			regs->verdict.code = NFT_CONTINUE;
+		}
+	} else {
+		regs->verdict.code = NFT_CONTINUE;
+	}
+
+	rcu_read_unlock();
+}
+
+static void nft_dict_set_eval(const struct nft_expr *expr, struct nft_regs *regs, const struct nft_pktinfo *pkt)
+{
+	struct nft_dict *priv = nft_expr_priv(expr);
+	enum ip_conntrack_info ctinfo;
+	struct nf_conn *ct;
+	struct nf_conn_dict * dict;
+
+	ct = nf_ct_get(pkt->skb, &ctinfo);
+	if (ct == NULL || nf_ct_is_untracked(ct)) {
+		return;
+	}
+
+	dict = find_conntrack_dict(ct);
+	if(!dict) {
+		return;
+	}
+
+	new_dict_pair(dict, priv->field, priv->value);
+}
+
+static int nft_dict_init(const struct nft_ctx *ctx, const struct nft_expr *expr, const struct nlattr * const tb[])
+{
+	struct nft_dict *priv = nft_expr_priv(expr);
+	if (tb[NFTA_DICT_FIELD] == NULL || tb[NFTA_DICT_VALUE] == NULL)
+		return -EINVAL;
+
+	nla_strlcpy(priv->field, tb[NFTA_DICT_FIELD], DICT_FIELD_SIZE);
+	priv->field_len = strlen(priv->field);
+	priv->field_hash = jhash(priv->field, priv->field_len, 0);
+	nla_strlcpy(priv->value, tb[NFTA_DICT_VALUE], DICT_VALUE_SIZE);
+	priv->value_len = strlen(priv->value);
+	priv->value_hash = jhash(priv->value, priv->value_len, 0);
+
+	return 0;
+}
+
+static int nft_dict_dump(struct sk_buff *skb, const struct nft_expr *expr)
+{
+	const struct nft_dict *priv = nft_expr_priv(expr);
+
+	if(nla_put_string(skb, NFTA_DICT_FIELD, priv->field))
+		return -1;
+
+	if(nla_put_string(skb, NFTA_DICT_VALUE, priv->value))
+		return -1;
+
+	if(nla_put_be32(skb, NFTA_DICT_SET, htonl(priv->set)))
+		return -1;
+
+	return 0;
+}
+
+static struct nft_expr_type nft_dict_type;
+static const struct nft_expr_ops nft_dict_get_ops = {
+	.eval = nft_dict_get_eval,
+	.size = NFT_EXPR_SIZE(sizeof(struct nft_dict)),
+	.init = nft_dict_init,
+	.dump = nft_dict_dump,
+	.type = &nft_dict_type,
+};
+
+static const struct nft_expr_ops nft_dict_set_ops = {
+	.eval = nft_dict_set_eval,
+	.size = NFT_EXPR_SIZE(sizeof(struct nft_dict)),
+	.init = nft_dict_init,
+	.dump = nft_dict_dump,
+	.type = &nft_dict_type,
+};
+
+static const struct nft_expr_ops *
+nft_dict_select_ops(const struct nft_ctx *ctx,
+		    const struct nlattr * const tb[])
+{
+	if (tb[NFTA_DICT_SET]) {
+		return &nft_dict_set_ops;
+	}
+
+	return &nft_dict_get_ops;
+}
+
+static struct nft_expr_type nft_dict_type __read_mostly = {
+	.name = "dict",
+	.select_ops = &nft_dict_select_ops,
+	.owner = THIS_MODULE,
+	.policy = nft_dict_policy,
+	.maxattr = NFTA_DICT_MAX,
+};
+
+static int __init nft_dict_module_init(void)
+{
+	return nft_register_expr(&nft_dict_type);
+};
+
+static void __exit nft_dict_module_exit(void)
+{
+	nft_unregister_expr(&nft_dict_type);
+}
+
+module_init(nft_dict_module_init);
+module_exit(nft_dict_module_exit);
+
+MODULE_AUTHOR("Brett Mastbergen");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Generic field/value pair matching for conntrack");
diff --git a/net/netfilter/xt_conndict.c b/net/netfilter/xt_conndict.c
new file mode 100644
index 000000000000..53ba7f44ea84
--- /dev/null
+++ b/net/netfilter/xt_conndict.c
@@ -0,0 +1,103 @@
+#include <linux/module.h>
+#include <linux/glob.h>
+#include <linux/netfilter/x_tables.h>
+#include <linux/netfilter/xt_conndict.h>
+#include <net/netfilter/nf_conntrack.h>
+#include <net/netfilter/nf_conntrack_dict.h>
+
+MODULE_AUTHOR("Brett Mastbergen <bmastbergen@untangle.com>");
+MODULE_DESCRIPTION("Just a skeleton");
+MODULE_LICENSE("GPL");
+
+static bool dict_mt(const struct sk_buff *skb, struct xt_action_param *par)
+{
+	struct xt_dict_info *info = (struct xt_dict_info *)par->matchinfo;
+	enum ip_conntrack_info ctinfo;
+	struct nf_conn *ct;
+	struct nf_conn_dict * dict;
+	bool invert = info->flags & XT_CONNDICT_FLAG_INVERT;
+
+	ct = nf_ct_get(skb, &ctinfo);
+	if (ct == NULL || nf_ct_is_untracked(ct)) {
+		return invert;
+	}
+
+	dict = find_conntrack_dict(ct);
+	if(!dict) {
+		return invert;
+	}
+
+	if(info->flags & XT_CONNDICT_FLAG_SET) {
+		new_dict_pair(dict, info->field, info->value);
+
+		return !invert;
+	} else {
+		struct nf_conn_dict_pair * pair;
+
+		pair = find_conntrack_dict_pair(dict, &info->field_hash);
+		if(!pair) {
+			return invert;
+		}
+
+		rcu_read_lock();
+		if(info->value_hash != pair->value->hash) {
+			if(glob_match(info->value, pair->value->str)) {
+				rcu_read_unlock();
+				return !invert;
+			}
+		} else {
+			return !invert;
+		}
+
+		rcu_read_unlock();
+	}
+
+	return invert;
+}
+
+static int dict_mt_check(const struct xt_mtchk_param *par)
+{
+	struct xt_dict_info *info = (struct xt_dict_info *)par->matchinfo;
+
+	if(!(info->flags & XT_CONNDICT_FLAG_SET)) {
+		info->field_hash = jhash(info->field, info->field_len, 0);
+		info->value_hash = jhash(info->value, info->value_len, 0);
+	}
+
+	return 0;
+}
+
+static void dict_mt_destroy(const struct xt_mtdtor_param *par)
+{
+}
+
+static struct xt_match xt_dict_mt_reg __read_mostly = {
+	.name       = "conndict",
+	.revision   = 0,
+	.family     = NFPROTO_UNSPEC,
+	.checkentry = dict_mt_check,
+	.match      = dict_mt,
+	.destroy    = dict_mt_destroy,
+	.matchsize  = sizeof(struct xt_dict_info),
+	.me         = THIS_MODULE,
+};
+
+static void __exit xt_dict_exit(void)
+{
+	xt_unregister_match(&xt_dict_mt_reg);
+}
+
+static int __init xt_dict_init(void)
+{
+	int err = 0;
+
+	err = xt_register_match(&xt_dict_mt_reg);
+	if(err < 0) {
+		pr_err("%s: Unable to register match: %d\n", __func__, err);
+	}
+
+	return err;
+}
+
+module_init(xt_dict_init);
+module_exit(xt_dict_exit);
-- 
2.11.0

