From 3913303f6dd80d5630c981f90d3e6fb133f3e631 Mon Sep 17 00:00:00 2001
From: Robby Cai <R63905@freescale.com>
Date: Mon, 13 Aug 2012 16:12:31 +0800
Subject: ENGR00220161: imx6sl: Add EVK board Support

- Copied the board file from ARM2, and consolidated the pinmux setting.
- Added a new pmic file for EVK.
- Added a new mach type.
- Added board_is_mx6sl_evk() API for late use if needed.
- Updated the defconfig

Signed-off-by: Robby Cai <R63905@freescale.com>
---
 arch/arm/configs/imx6s_defconfig            |    9 +-
 arch/arm/mach-mx6/Kconfig                   |   37 +
 arch/arm/mach-mx6/Makefile                  |    3 +-
 arch/arm/mach-mx6/board-mx6sl_arm2.c        |  472 +++++-----
 arch/arm/mach-mx6/board-mx6sl_arm2.h        |  358 --------
 arch/arm/mach-mx6/board-mx6sl_common.h      |  415 +++++++++
 arch/arm/mach-mx6/board-mx6sl_evk.c         | 1300 +++++++++++++++++++++++++++
 arch/arm/mach-mx6/mx6sl_evk_pmic_pfuze100.c |  440 +++++++++
 arch/arm/plat-mxc/include/mach/mxc.h        |    2 +
 arch/arm/tools/mach-types                   |    1 +
 10 files changed, 2406 insertions(+), 631 deletions(-)
 delete mode 100755 arch/arm/mach-mx6/board-mx6sl_arm2.h
 create mode 100644 arch/arm/mach-mx6/board-mx6sl_common.h
 create mode 100644 arch/arm/mach-mx6/board-mx6sl_evk.c
 create mode 100644 arch/arm/mach-mx6/mx6sl_evk_pmic_pfuze100.c

diff --git a/arch/arm/configs/imx6s_defconfig b/arch/arm/configs/imx6s_defconfig
index da09441..390770f 100644
--- a/arch/arm/configs/imx6s_defconfig
+++ b/arch/arm/configs/imx6s_defconfig
@@ -311,6 +311,7 @@ CONFIG_SOC_IMX6Q=y
 CONFIG_SOC_IMX6SL=y
 CONFIG_MACH_MX6Q_ARM2=y
 CONFIG_MACH_MX6SL_ARM2=y
+CONFIG_MACH_MX6SL_EVK=y
 # CONFIG_MACH_MX6Q_SABRELITE is not set
 CONFIG_MACH_MX6Q_SABRESD=y
 # CONFIG_MACH_MX6Q_SABREAUTO is not set
@@ -1595,14 +1596,6 @@ CONFIG_VIDEO_CAPTURE_DRIVERS=y
 # CONFIG_VIDEO_M52790 is not set
 # CONFIG_VIDEO_VIVI is not set
 # CONFIG_VIDEO_MXC_CAMERA is not set
-# CONFIG_MXC_CAMERA_MICRON111 is not set
-# CONFIG_MXC_CAMERA_OV2640 is not set
-# CONFIG_MXC_CAMERA_OV3640 is not set
-# CONFIG_MXC_CAMERA_OV5640 is not set
-# CONFIG_MXC_CAMERA_OV8820_MIPI is not set
-# CONFIG_MXC_CAMERA_OV5642 is not set
-# CONFIG_MXC_TVIN_ADV7180 is not set
-# CONFIG_MXC_IPU_DEVICE_QUEUE_SDC is not set
 CONFIG_VIDEO_MXC_OUTPUT=y
 CONFIG_VIDEO_MXC_IPU_OUTPUT=y
 # CONFIG_VIDEO_MXC_IPUV1_WVGA_OUTPUT is not set
diff --git a/arch/arm/mach-mx6/Kconfig b/arch/arm/mach-mx6/Kconfig
index 08875a6..45ae9ea 100644
--- a/arch/arm/mach-mx6/Kconfig
+++ b/arch/arm/mach-mx6/Kconfig
@@ -107,6 +107,43 @@ config MACH_MX6SL_ARM2
 	  Include support for i.MX 6Sololite Armadillo2 platform. This includes specific
 	  configurations for the board and its peripherals.
 
+config MACH_MX6SL_EVK
+	bool "Support i.MX 6SoloLite EVK platform"
+	select ARCH_MX6Q
+	select SOC_IMX6SL
+	select IMX_HAVE_PLATFORM_IMX_UART
+	select IMX_HAVE_PLATFORM_DMA
+	select IMX_HAVE_PLATFORM_FEC
+	select IMX_HAVE_PLATFORM_SDHCI_ESDHC_IMX
+	select IMX_HAVE_PLATFORM_SPI_IMX
+	select IMX_HAVE_PLATFORM_IMX_I2C
+	select IMX_HAVE_PLATFORM_VIV_GPU
+	select IMX_HAVE_PLATFORM_IMX_DVFS
+	select IMX_HAVE_PLATFORM_IMX_SSI
+	select IMX_HAVE_PLATFORM_IMX_ANATOP_THERMAL
+	select IMX_HAVE_PLATFORM_FSL_USB2_UDC
+	select IMX_HAVE_PLATFORM_MXC_EHCI
+	select IMX_HAVE_PLATFORM_FSL_OTG
+	select IMX_HAVE_PLATFORM_FSL_USB_WAKEUP
+	select IMX_HAVE_PLATFORM_AHCI
+	select IMX_HAVE_PLATFORM_IMX_OCOTP
+	select IMX_HAVE_PLATFORM_IMX_VIIM
+	select IMX_HAVE_PLATFORM_IMX2_WDT
+	select IMX_HAVE_PLATFORM_IMX_SNVS_RTC
+	select IMX_HAVE_PLATFORM_IMX_PM
+	select IMX_HAVE_PLATFORM_IMX_SPDIF
+	select IMX_HAVE_PLATFORM_PERFMON
+	select IMX_HAVE_PLATFORM_IMX_EPDC
+	select IMX_HAVE_PLATFORM_IMX_SPDC
+	select IMX_HAVE_PLATFORM_IMX_PXP
+	select IMX_HAVE_PLATFORM_IMX_KEYPAD
+	select IMX_HAVE_PLATFORM_IMX_DCP
+	select IMX_HAVE_PLATFORM_RANDOM_RNGC
+	select ARCH_HAS_RNGC
+	help
+	  Include support for i.MX 6Sololite EVK platform. This includes specific
+	  configurations for the board and its peripherals.
+
 config MACH_MX6Q_SABRELITE
 	bool "Support i.MX 6Quad SABRE Lite platform"
 	select ARCH_MX6Q
diff --git a/arch/arm/mach-mx6/Makefile b/arch/arm/mach-mx6/Makefile
index 24dae23..77d8091 100644
--- a/arch/arm/mach-mx6/Makefile
+++ b/arch/arm/mach-mx6/Makefile
@@ -10,10 +10,11 @@ mx6_mmdc.o mx6_ddr_freq.o
 obj-$(CONFIG_ARCH_MX6) += clock.o mx6_suspend.o clock_mx6sl.o
 obj-$(CONFIG_MACH_MX6Q_ARM2) += board-mx6q_arm2.o
 obj-$(CONFIG_MACH_MX6SL_ARM2) += board-mx6sl_arm2.o mx6sl_arm2_pmic_pfuze100.o
+obj-$(CONFIG_MACH_MX6SL_EVK) += board-mx6sl_evk.o mx6sl_evk_pmic_pfuze100.o
 obj-$(CONFIG_MACH_MX6Q_SABRELITE) += board-mx6q_sabrelite.o
 obj-$(CONFIG_MACH_MX6Q_SABRESD) += board-mx6q_sabresd.o mx6q_sabresd_pmic_pfuze100.o
 obj-$(CONFIG_MACH_MX6Q_SABREAUTO) += board-mx6q_sabreauto.o mx6q_sabreauto_pmic_pfuze100.o
 obj-$(CONFIG_SMP) += plat_hotplug.o platsmp.o headsmp.o
 obj-$(CONFIG_LOCAL_TIMERS) += localtimer.o
 obj-$(CONFIG_IMX_PCIE) += pcie.o
-obj-$(CONFIG_USB_EHCI_ARC_H1) += usb_h1.o
\ No newline at end of file
+obj-$(CONFIG_USB_EHCI_ARC_H1) += usb_h1.o
diff --git a/arch/arm/mach-mx6/board-mx6sl_arm2.c b/arch/arm/mach-mx6/board-mx6sl_arm2.c
index 0c51666..8f05702 100755
--- a/arch/arm/mach-mx6/board-mx6sl_arm2.c
+++ b/arch/arm/mach-mx6/board-mx6sl_arm2.c
@@ -33,7 +33,6 @@
 #include <linux/spi/flash.h>
 #include <linux/i2c.h>
 #include <linux/i2c/pca953x.h>
-#include <linux/ata.h>
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/map.h>
 #include <linux/mtd/partitions.h>
@@ -71,67 +70,11 @@
 #include "devices-imx6q.h"
 #include "crm_regs.h"
 #include "cpu_op-mx6.h"
-#include "board-mx6sl_arm2.h"
-
-#define MX6_ARM2_USBOTG1_PWR    IMX_GPIO_NR(4, 0)       /* KEY_COL4 */
-#define MX6_ARM2_USBOTG2_PWR    IMX_GPIO_NR(4, 2)       /* KEY_COL5 */
-#define MX6_ARM2_LCD_PWR_EN	IMX_GPIO_NR(4, 3)	/* KEY_ROW5 */
-#define MX6_ARM2_SD1_WP		IMX_GPIO_NR(4, 6)	/* KEY_COL7 */
-#define MX6_ARM2_SD1_CD		IMX_GPIO_NR(4, 7)	/* KEY_ROW7 */
-#define MX6_ARM2_ECSPI1_CS0	IMX_GPIO_NR(4, 11)	/* ECSPI1_SS0 */
-#define MX6_ARM2_HEADPHONE_DET	IMX_GPIO_NR(4, 19)	/* FEC_RX_ER */
-#define MX6_ARM2_SD2_WP		IMX_GPIO_NR(4, 29)	/* SD2_DAT6 */
-#define MX6_ARM2_SD2_CD		IMX_GPIO_NR(5, 0)	/* SD2_DAT7 */
-#define MX6_ARM2_SD3_CD		IMX_GPIO_NR(3, 22)	/* REF_CLK_32K */
-#define MX6_ARM2_FEC_PWR_EN	IMX_GPIO_NR(4, 21)	/* FEC_TX_CLK */
-
-/* EPDC GPIO pins */
-#define MX6SL_ARM2_EPDC_SDDO_0		IMX_GPIO_NR(1, 7)
-#define MX6SL_ARM2_EPDC_SDDO_1		IMX_GPIO_NR(1, 8)
-#define MX6SL_ARM2_EPDC_SDDO_2		IMX_GPIO_NR(1, 9)
-#define MX6SL_ARM2_EPDC_SDDO_3		IMX_GPIO_NR(1, 10)
-#define MX6SL_ARM2_EPDC_SDDO_4		IMX_GPIO_NR(1, 11)
-#define MX6SL_ARM2_EPDC_SDDO_5		IMX_GPIO_NR(1, 12)
-#define MX6SL_ARM2_EPDC_SDDO_6		IMX_GPIO_NR(1, 13)
-#define MX6SL_ARM2_EPDC_SDDO_7		IMX_GPIO_NR(1, 14)
-#define MX6SL_ARM2_EPDC_SDDO_8		IMX_GPIO_NR(1, 15)
-#define MX6SL_ARM2_EPDC_SDDO_9		IMX_GPIO_NR(1, 16)
-#define MX6SL_ARM2_EPDC_SDDO_10		IMX_GPIO_NR(1, 17)
-#define MX6SL_ARM2_EPDC_SDDO_11		IMX_GPIO_NR(1, 18)
-#define MX6SL_ARM2_EPDC_SDDO_12		IMX_GPIO_NR(1, 19)
-#define MX6SL_ARM2_EPDC_SDDO_13		IMX_GPIO_NR(1, 20)
-#define MX6SL_ARM2_EPDC_SDDO_14		IMX_GPIO_NR(1, 21)
-#define MX6SL_ARM2_EPDC_SDDO_15		IMX_GPIO_NR(1, 22)
-#define MX6SL_ARM2_EPDC_GDCLK		IMX_GPIO_NR(1, 31)
-#define MX6SL_ARM2_EPDC_GDSP		IMX_GPIO_NR(2, 2)
-#define MX6SL_ARM2_EPDC_GDOE		IMX_GPIO_NR(2, 0)
-#define MX6SL_ARM2_EPDC_GDRL		IMX_GPIO_NR(2, 1)
-#define MX6SL_ARM2_EPDC_SDCLK		IMX_GPIO_NR(1, 23)
-#define MX6SL_ARM2_EPDC_SDOE		IMX_GPIO_NR(1, 25)
-#define MX6SL_ARM2_EPDC_SDLE		IMX_GPIO_NR(1, 24)
-#define MX6SL_ARM2_EPDC_SDSHR		IMX_GPIO_NR(1, 26)
-#define MX6SL_ARM2_EPDC_PWRCOM		IMX_GPIO_NR(2, 11)
-#define MX6SL_ARM2_EPDC_PWRSTAT		IMX_GPIO_NR(2, 13)
-#define MX6SL_ARM2_EPDC_PWRCTRL0	IMX_GPIO_NR(2, 7)
-#define MX6SL_ARM2_EPDC_PWRCTRL1	IMX_GPIO_NR(2, 8)
-#define MX6SL_ARM2_EPDC_PWRCTRL2	IMX_GPIO_NR(2, 9)
-#define MX6SL_ARM2_EPDC_PWRCTRL3	IMX_GPIO_NR(2, 10)
-#define MX6SL_ARM2_EPDC_BDR0		IMX_GPIO_NR(2, 5)
-#define MX6SL_ARM2_EPDC_BDR1		IMX_GPIO_NR(2, 6)
-#define MX6SL_ARM2_EPDC_SDCE0		IMX_GPIO_NR(1, 27)
-#define MX6SL_ARM2_EPDC_SDCE1		IMX_GPIO_NR(1, 28)
-#define MX6SL_ARM2_EPDC_SDCE2		IMX_GPIO_NR(1, 29)
-#define MX6SL_ARM2_EPDC_SDCE3		IMX_GPIO_NR(1, 30)
-#define MX6SL_ARM2_EPDC_PMIC_WAKE	IMX_GPIO_NR(2, 14) /* EPDC_PWRWAKEUP */
-#define MX6SL_ARM2_EPDC_PMIC_INT	IMX_GPIO_NR(2, 12) /* EPDC_PWRINT */
-#define MX6SL_ARM2_EPDC_VCOM		IMX_GPIO_NR(2, 3)
-#define MX6SL_ARM2_ELAN_CE		IMX_GPIO_NR(2, 9)
-#define MX6SL_ARM2_ELAN_INT		IMX_GPIO_NR(2, 10)
-#define MX6SL_ARM2_ELAN_RST		IMX_GPIO_NR(4, 4)
+#include "board-mx6sl_common.h"
 
 static int spdc_sel;
 static int max17135_regulator_init(struct max17135 *max17135);
-struct clk *extern_audio_root;
+static struct clk *extern_audio_root;
 
 extern char *gp_reg_id;
 extern char *soc_reg_id;
@@ -215,8 +158,8 @@ static int plt_sd_pad_change(unsigned int index, int clock)
 }
 
 static const struct esdhc_platform_data mx6_arm2_sd1_data __initconst = {
-	.cd_gpio		= MX6_ARM2_SD1_CD,
-	.wp_gpio		= MX6_ARM2_SD1_WP,
+	.cd_gpio		= MX6_BRD_SD1_CD,
+	.wp_gpio		= MX6_BRD_SD1_WP,
 	.support_8bit		= 1,
 	.support_18v		= 1,
 	.keep_power_at_suspend	= 1,
@@ -225,8 +168,8 @@ static const struct esdhc_platform_data mx6_arm2_sd1_data __initconst = {
 };
 
 static const struct esdhc_platform_data mx6_arm2_sd2_data __initconst = {
-	.cd_gpio		= MX6_ARM2_SD2_CD,
-	.wp_gpio		= MX6_ARM2_SD2_WP,
+	.cd_gpio		= MX6_BRD_SD2_CD,
+	.wp_gpio		= MX6_BRD_SD2_WP,
 	.keep_power_at_suspend	= 1,
 	.delay_line		= 0,
 	.support_18v		= 1,
@@ -234,7 +177,7 @@ static const struct esdhc_platform_data mx6_arm2_sd2_data __initconst = {
 };
 
 static const struct esdhc_platform_data mx6_arm2_sd3_data __initconst = {
-	.cd_gpio		= MX6_ARM2_SD3_CD,
+	.cd_gpio		= MX6_BRD_SD3_CD,
 	.wp_gpio		= -1,
 	.keep_power_at_suspend	= 1,
 	.delay_line		= 0,
@@ -377,11 +320,11 @@ static struct max17135_platform_data max17135_pdata __initdata = {
 	.vpos_pwrdn = 2,
 	.gvee_pwrdn = 1,
 	.vneg_pwrdn = 1,
-	.gpio_pmic_pwrgood = MX6SL_ARM2_EPDC_PWRSTAT,
-	.gpio_pmic_vcom_ctrl = MX6SL_ARM2_EPDC_VCOM,
-	.gpio_pmic_wakeup = MX6SL_ARM2_EPDC_PMIC_WAKE,
-	.gpio_pmic_v3p3 = MX6SL_ARM2_EPDC_PWRCTRL0,
-	.gpio_pmic_intr = MX6SL_ARM2_EPDC_PMIC_INT,
+	.gpio_pmic_pwrgood = MX6SL_BRD_EPDC_PWRSTAT,
+	.gpio_pmic_vcom_ctrl = MX6SL_BRD_EPDC_VCOM,
+	.gpio_pmic_wakeup = MX6SL_BRD_EPDC_PMIC_WAKE,
+	.gpio_pmic_v3p3 = MX6SL_BRD_EPDC_PWRCTRL0,
+	.gpio_pmic_intr = MX6SL_BRD_EPDC_PMIC_INT,
 	.regulator_init = max17135_init_data,
 	.init = max17135_regulator_init,
 };
@@ -448,7 +391,7 @@ static int __init max17135_regulator_init(struct max17135 *max17135)
 }
 
 static int mx6_arm2_spi_cs[] = {
-	MX6_ARM2_ECSPI1_CS0,
+	MX6_BRD_ECSPI1_CS0,
 };
 
 static const struct spi_imx_master mx6_arm2_spi_data __initconst = {
@@ -551,7 +494,7 @@ static struct mxc_audio_platform_data wm8962_data = {
 	.ssi_num = 1,
 	.src_port = 2,
 	.ext_port = 3,
-	.hp_gpio = MX6_ARM2_HEADPHONE_DET,
+	.hp_gpio = MX6_BRD_HEADPHONE_DET,
 	.hp_active_low = 1,
 	.mic_gpio = -1,
 	.mic_active_low = 1,
@@ -618,7 +561,7 @@ static struct i2c_board_info mxc_i2c0_board_info[] __initdata = {
 		.platform_data = &max17135_pdata,
 	}, {
 		I2C_BOARD_INFO("elan-touch", 0x10),
-		.irq = gpio_to_irq(MX6SL_ARM2_ELAN_INT),
+		.irq = gpio_to_irq(MX6SL_BRD_ELAN_INT),
 	},
 };
 
@@ -679,11 +622,11 @@ static int mx6sl_arm2_fec_phy_init(struct phy_device *phydev)
 	int val;
 
 	/* power on FEC phy and reset phy */
-	gpio_request(MX6_ARM2_FEC_PWR_EN, "fec-pwr");
-	gpio_direction_output(MX6_ARM2_FEC_PWR_EN, 0);
+	gpio_request(MX6_BRD_FEC_PWR_EN, "fec-pwr");
+	gpio_direction_output(MX6_BRD_FEC_PWR_EN, 0);
 	/* wait RC ms for hw reset */
 	msleep(1);
-	gpio_direction_output(MX6_ARM2_FEC_PWR_EN, 1);
+	gpio_direction_output(MX6_BRD_FEC_PWR_EN, 1);
 
 	/* check phy power */
 	val = phy_read(phydev, 0x0);
@@ -704,109 +647,109 @@ static int epdc_get_pins(void)
 	int ret = 0;
 
 	/* Claim GPIOs for EPDC pins - used during power up/down */
-	ret |= gpio_request(MX6SL_ARM2_EPDC_SDDO_0, "epdc_d0");
-	ret |= gpio_request(MX6SL_ARM2_EPDC_SDDO_1, "epdc_d1");
-	ret |= gpio_request(MX6SL_ARM2_EPDC_SDDO_2, "epdc_d2");
-	ret |= gpio_request(MX6SL_ARM2_EPDC_SDDO_3, "epdc_d3");
-	ret |= gpio_request(MX6SL_ARM2_EPDC_SDDO_4, "epdc_d4");
-	ret |= gpio_request(MX6SL_ARM2_EPDC_SDDO_5, "epdc_d5");
-	ret |= gpio_request(MX6SL_ARM2_EPDC_SDDO_6, "epdc_d6");
-	ret |= gpio_request(MX6SL_ARM2_EPDC_SDDO_7, "epdc_d7");
-	ret |= gpio_request(MX6SL_ARM2_EPDC_GDCLK, "epdc_gdclk");
-	ret |= gpio_request(MX6SL_ARM2_EPDC_GDSP, "epdc_gdsp");
-	ret |= gpio_request(MX6SL_ARM2_EPDC_GDOE, "epdc_gdoe");
-	ret |= gpio_request(MX6SL_ARM2_EPDC_GDRL, "epdc_gdrl");
-	ret |= gpio_request(MX6SL_ARM2_EPDC_SDCLK, "epdc_sdclk");
-	ret |= gpio_request(MX6SL_ARM2_EPDC_SDOE, "epdc_sdoe");
-	ret |= gpio_request(MX6SL_ARM2_EPDC_SDLE, "epdc_sdle");
-	ret |= gpio_request(MX6SL_ARM2_EPDC_SDSHR, "epdc_sdshr");
-	ret |= gpio_request(MX6SL_ARM2_EPDC_BDR0, "epdc_bdr0");
-	ret |= gpio_request(MX6SL_ARM2_EPDC_SDCE0, "epdc_sdce0");
-	ret |= gpio_request(MX6SL_ARM2_EPDC_SDCE1, "epdc_sdce1");
-	ret |= gpio_request(MX6SL_ARM2_EPDC_SDCE2, "epdc_sdce2");
+	ret |= gpio_request(MX6SL_BRD_EPDC_SDDO_0, "epdc_d0");
+	ret |= gpio_request(MX6SL_BRD_EPDC_SDDO_1, "epdc_d1");
+	ret |= gpio_request(MX6SL_BRD_EPDC_SDDO_2, "epdc_d2");
+	ret |= gpio_request(MX6SL_BRD_EPDC_SDDO_3, "epdc_d3");
+	ret |= gpio_request(MX6SL_BRD_EPDC_SDDO_4, "epdc_d4");
+	ret |= gpio_request(MX6SL_BRD_EPDC_SDDO_5, "epdc_d5");
+	ret |= gpio_request(MX6SL_BRD_EPDC_SDDO_6, "epdc_d6");
+	ret |= gpio_request(MX6SL_BRD_EPDC_SDDO_7, "epdc_d7");
+	ret |= gpio_request(MX6SL_BRD_EPDC_GDCLK, "epdc_gdclk");
+	ret |= gpio_request(MX6SL_BRD_EPDC_GDSP, "epdc_gdsp");
+	ret |= gpio_request(MX6SL_BRD_EPDC_GDOE, "epdc_gdoe");
+	ret |= gpio_request(MX6SL_BRD_EPDC_GDRL, "epdc_gdrl");
+	ret |= gpio_request(MX6SL_BRD_EPDC_SDCLK, "epdc_sdclk");
+	ret |= gpio_request(MX6SL_BRD_EPDC_SDOE, "epdc_sdoe");
+	ret |= gpio_request(MX6SL_BRD_EPDC_SDLE, "epdc_sdle");
+	ret |= gpio_request(MX6SL_BRD_EPDC_SDSHR, "epdc_sdshr");
+	ret |= gpio_request(MX6SL_BRD_EPDC_BDR0, "epdc_bdr0");
+	ret |= gpio_request(MX6SL_BRD_EPDC_SDCE0, "epdc_sdce0");
+	ret |= gpio_request(MX6SL_BRD_EPDC_SDCE1, "epdc_sdce1");
+	ret |= gpio_request(MX6SL_BRD_EPDC_SDCE2, "epdc_sdce2");
 
 	return ret;
 }
 
 static void epdc_put_pins(void)
 {
-	gpio_free(MX6SL_ARM2_EPDC_SDDO_0);
-	gpio_free(MX6SL_ARM2_EPDC_SDDO_1);
-	gpio_free(MX6SL_ARM2_EPDC_SDDO_2);
-	gpio_free(MX6SL_ARM2_EPDC_SDDO_3);
-	gpio_free(MX6SL_ARM2_EPDC_SDDO_4);
-	gpio_free(MX6SL_ARM2_EPDC_SDDO_5);
-	gpio_free(MX6SL_ARM2_EPDC_SDDO_6);
-	gpio_free(MX6SL_ARM2_EPDC_SDDO_7);
-	gpio_free(MX6SL_ARM2_EPDC_GDCLK);
-	gpio_free(MX6SL_ARM2_EPDC_GDSP);
-	gpio_free(MX6SL_ARM2_EPDC_GDOE);
-	gpio_free(MX6SL_ARM2_EPDC_GDRL);
-	gpio_free(MX6SL_ARM2_EPDC_SDCLK);
-	gpio_free(MX6SL_ARM2_EPDC_SDOE);
-	gpio_free(MX6SL_ARM2_EPDC_SDLE);
-	gpio_free(MX6SL_ARM2_EPDC_SDSHR);
-	gpio_free(MX6SL_ARM2_EPDC_BDR0);
-	gpio_free(MX6SL_ARM2_EPDC_SDCE0);
-	gpio_free(MX6SL_ARM2_EPDC_SDCE1);
-	gpio_free(MX6SL_ARM2_EPDC_SDCE2);
+	gpio_free(MX6SL_BRD_EPDC_SDDO_0);
+	gpio_free(MX6SL_BRD_EPDC_SDDO_1);
+	gpio_free(MX6SL_BRD_EPDC_SDDO_2);
+	gpio_free(MX6SL_BRD_EPDC_SDDO_3);
+	gpio_free(MX6SL_BRD_EPDC_SDDO_4);
+	gpio_free(MX6SL_BRD_EPDC_SDDO_5);
+	gpio_free(MX6SL_BRD_EPDC_SDDO_6);
+	gpio_free(MX6SL_BRD_EPDC_SDDO_7);
+	gpio_free(MX6SL_BRD_EPDC_GDCLK);
+	gpio_free(MX6SL_BRD_EPDC_GDSP);
+	gpio_free(MX6SL_BRD_EPDC_GDOE);
+	gpio_free(MX6SL_BRD_EPDC_GDRL);
+	gpio_free(MX6SL_BRD_EPDC_SDCLK);
+	gpio_free(MX6SL_BRD_EPDC_SDOE);
+	gpio_free(MX6SL_BRD_EPDC_SDLE);
+	gpio_free(MX6SL_BRD_EPDC_SDSHR);
+	gpio_free(MX6SL_BRD_EPDC_BDR0);
+	gpio_free(MX6SL_BRD_EPDC_SDCE0);
+	gpio_free(MX6SL_BRD_EPDC_SDCE1);
+	gpio_free(MX6SL_BRD_EPDC_SDCE2);
 }
 
 static void epdc_enable_pins(void)
 {
 	/* Configure MUX settings to enable EPDC use */
-	mxc_iomux_v3_setup_multiple_pads(mx6sl_arm2_epdc_enable_pads, \
-				ARRAY_SIZE(mx6sl_arm2_epdc_enable_pads));
-
-	gpio_direction_input(MX6SL_ARM2_EPDC_SDDO_0);
-	gpio_direction_input(MX6SL_ARM2_EPDC_SDDO_1);
-	gpio_direction_input(MX6SL_ARM2_EPDC_SDDO_2);
-	gpio_direction_input(MX6SL_ARM2_EPDC_SDDO_3);
-	gpio_direction_input(MX6SL_ARM2_EPDC_SDDO_4);
-	gpio_direction_input(MX6SL_ARM2_EPDC_SDDO_5);
-	gpio_direction_input(MX6SL_ARM2_EPDC_SDDO_6);
-	gpio_direction_input(MX6SL_ARM2_EPDC_SDDO_7);
-	gpio_direction_input(MX6SL_ARM2_EPDC_GDCLK);
-	gpio_direction_input(MX6SL_ARM2_EPDC_GDSP);
-	gpio_direction_input(MX6SL_ARM2_EPDC_GDOE);
-	gpio_direction_input(MX6SL_ARM2_EPDC_GDRL);
-	gpio_direction_input(MX6SL_ARM2_EPDC_SDCLK);
-	gpio_direction_input(MX6SL_ARM2_EPDC_SDOE);
-	gpio_direction_input(MX6SL_ARM2_EPDC_SDLE);
-	gpio_direction_input(MX6SL_ARM2_EPDC_SDSHR);
-	gpio_direction_input(MX6SL_ARM2_EPDC_BDR0);
-	gpio_direction_input(MX6SL_ARM2_EPDC_SDCE0);
-	gpio_direction_input(MX6SL_ARM2_EPDC_SDCE1);
-	gpio_direction_input(MX6SL_ARM2_EPDC_SDCE2);
+	mxc_iomux_v3_setup_multiple_pads(mx6sl_brd_epdc_enable_pads, \
+				ARRAY_SIZE(mx6sl_brd_epdc_enable_pads));
+
+	gpio_direction_input(MX6SL_BRD_EPDC_SDDO_0);
+	gpio_direction_input(MX6SL_BRD_EPDC_SDDO_1);
+	gpio_direction_input(MX6SL_BRD_EPDC_SDDO_2);
+	gpio_direction_input(MX6SL_BRD_EPDC_SDDO_3);
+	gpio_direction_input(MX6SL_BRD_EPDC_SDDO_4);
+	gpio_direction_input(MX6SL_BRD_EPDC_SDDO_5);
+	gpio_direction_input(MX6SL_BRD_EPDC_SDDO_6);
+	gpio_direction_input(MX6SL_BRD_EPDC_SDDO_7);
+	gpio_direction_input(MX6SL_BRD_EPDC_GDCLK);
+	gpio_direction_input(MX6SL_BRD_EPDC_GDSP);
+	gpio_direction_input(MX6SL_BRD_EPDC_GDOE);
+	gpio_direction_input(MX6SL_BRD_EPDC_GDRL);
+	gpio_direction_input(MX6SL_BRD_EPDC_SDCLK);
+	gpio_direction_input(MX6SL_BRD_EPDC_SDOE);
+	gpio_direction_input(MX6SL_BRD_EPDC_SDLE);
+	gpio_direction_input(MX6SL_BRD_EPDC_SDSHR);
+	gpio_direction_input(MX6SL_BRD_EPDC_BDR0);
+	gpio_direction_input(MX6SL_BRD_EPDC_SDCE0);
+	gpio_direction_input(MX6SL_BRD_EPDC_SDCE1);
+	gpio_direction_input(MX6SL_BRD_EPDC_SDCE2);
 }
 
 static void epdc_disable_pins(void)
 {
 	/* Configure MUX settings for EPDC pins to
 	 * GPIO and drive to 0. */
-	mxc_iomux_v3_setup_multiple_pads(mx6sl_arm2_epdc_disable_pads, \
-				ARRAY_SIZE(mx6sl_arm2_epdc_disable_pads));
-
-	gpio_direction_output(MX6SL_ARM2_EPDC_SDDO_0, 0);
-	gpio_direction_output(MX6SL_ARM2_EPDC_SDDO_1, 0);
-	gpio_direction_output(MX6SL_ARM2_EPDC_SDDO_2, 0);
-	gpio_direction_output(MX6SL_ARM2_EPDC_SDDO_3, 0);
-	gpio_direction_output(MX6SL_ARM2_EPDC_SDDO_4, 0);
-	gpio_direction_output(MX6SL_ARM2_EPDC_SDDO_5, 0);
-	gpio_direction_output(MX6SL_ARM2_EPDC_SDDO_6, 0);
-	gpio_direction_output(MX6SL_ARM2_EPDC_SDDO_7, 0);
-	gpio_direction_output(MX6SL_ARM2_EPDC_GDCLK, 0);
-	gpio_direction_output(MX6SL_ARM2_EPDC_GDSP, 0);
-	gpio_direction_output(MX6SL_ARM2_EPDC_GDOE, 0);
-	gpio_direction_output(MX6SL_ARM2_EPDC_GDRL, 0);
-	gpio_direction_output(MX6SL_ARM2_EPDC_SDCLK, 0);
-	gpio_direction_output(MX6SL_ARM2_EPDC_SDOE, 0);
-	gpio_direction_output(MX6SL_ARM2_EPDC_SDLE, 0);
-	gpio_direction_output(MX6SL_ARM2_EPDC_SDSHR, 0);
-	gpio_direction_output(MX6SL_ARM2_EPDC_BDR0, 0);
-	gpio_direction_output(MX6SL_ARM2_EPDC_SDCE0, 0);
-	gpio_direction_output(MX6SL_ARM2_EPDC_SDCE1, 0);
-	gpio_direction_output(MX6SL_ARM2_EPDC_SDCE2, 0);
+	mxc_iomux_v3_setup_multiple_pads(mx6sl_brd_epdc_disable_pads, \
+				ARRAY_SIZE(mx6sl_brd_epdc_disable_pads));
+
+	gpio_direction_output(MX6SL_BRD_EPDC_SDDO_0, 0);
+	gpio_direction_output(MX6SL_BRD_EPDC_SDDO_1, 0);
+	gpio_direction_output(MX6SL_BRD_EPDC_SDDO_2, 0);
+	gpio_direction_output(MX6SL_BRD_EPDC_SDDO_3, 0);
+	gpio_direction_output(MX6SL_BRD_EPDC_SDDO_4, 0);
+	gpio_direction_output(MX6SL_BRD_EPDC_SDDO_5, 0);
+	gpio_direction_output(MX6SL_BRD_EPDC_SDDO_6, 0);
+	gpio_direction_output(MX6SL_BRD_EPDC_SDDO_7, 0);
+	gpio_direction_output(MX6SL_BRD_EPDC_GDCLK, 0);
+	gpio_direction_output(MX6SL_BRD_EPDC_GDSP, 0);
+	gpio_direction_output(MX6SL_BRD_EPDC_GDOE, 0);
+	gpio_direction_output(MX6SL_BRD_EPDC_GDRL, 0);
+	gpio_direction_output(MX6SL_BRD_EPDC_SDCLK, 0);
+	gpio_direction_output(MX6SL_BRD_EPDC_SDOE, 0);
+	gpio_direction_output(MX6SL_BRD_EPDC_SDLE, 0);
+	gpio_direction_output(MX6SL_BRD_EPDC_SDSHR, 0);
+	gpio_direction_output(MX6SL_BRD_EPDC_BDR0, 0);
+	gpio_direction_output(MX6SL_BRD_EPDC_SDCE0, 0);
+	gpio_direction_output(MX6SL_BRD_EPDC_SDCE1, 0);
+	gpio_direction_output(MX6SL_BRD_EPDC_SDCE2, 0);
 }
 
 static struct fb_videomode e60_v110_mode = {
@@ -946,108 +889,108 @@ static int spdc_get_pins(void)
 	int ret = 0;
 
 	/* Claim GPIOs for SPDC pins - used during power up/down */
-	ret |= gpio_request(MX6SL_ARM2_EPDC_SDDO_0, "SPDC_D0");
-	ret |= gpio_request(MX6SL_ARM2_EPDC_SDDO_1, "SPDC_D1");
-	ret |= gpio_request(MX6SL_ARM2_EPDC_SDDO_2, "SPDC_D2");
-	ret |= gpio_request(MX6SL_ARM2_EPDC_SDDO_3, "SPDC_D3");
-	ret |= gpio_request(MX6SL_ARM2_EPDC_SDDO_4, "SPDC_D4");
-	ret |= gpio_request(MX6SL_ARM2_EPDC_SDDO_5, "SPDC_D5");
-	ret |= gpio_request(MX6SL_ARM2_EPDC_SDDO_6, "SPDC_D6");
-	ret |= gpio_request(MX6SL_ARM2_EPDC_SDDO_7, "SPDC_D7");
+	ret |= gpio_request(MX6SL_BRD_EPDC_SDDO_0, "SPDC_D0");
+	ret |= gpio_request(MX6SL_BRD_EPDC_SDDO_1, "SPDC_D1");
+	ret |= gpio_request(MX6SL_BRD_EPDC_SDDO_2, "SPDC_D2");
+	ret |= gpio_request(MX6SL_BRD_EPDC_SDDO_3, "SPDC_D3");
+	ret |= gpio_request(MX6SL_BRD_EPDC_SDDO_4, "SPDC_D4");
+	ret |= gpio_request(MX6SL_BRD_EPDC_SDDO_5, "SPDC_D5");
+	ret |= gpio_request(MX6SL_BRD_EPDC_SDDO_6, "SPDC_D6");
+	ret |= gpio_request(MX6SL_BRD_EPDC_SDDO_7, "SPDC_D7");
 
-	ret |= gpio_request(MX6SL_ARM2_EPDC_GDOE, "SIPIX_YOE");
-	ret |= gpio_request(MX6SL_ARM2_EPDC_SDDO_9, "SIPIX_PWR_RDY");
+	ret |= gpio_request(MX6SL_BRD_EPDC_GDOE, "SIPIX_YOE");
+	ret |= gpio_request(MX6SL_BRD_EPDC_SDDO_9, "SIPIX_PWR_RDY");
 
-	ret |= gpio_request(MX6SL_ARM2_EPDC_GDSP, "SIPIX_YDIO");
+	ret |= gpio_request(MX6SL_BRD_EPDC_GDSP, "SIPIX_YDIO");
 
-	ret |= gpio_request(MX6SL_ARM2_EPDC_GDCLK, "SIPIX_YCLK");
-	ret |= gpio_request(MX6SL_ARM2_EPDC_SDSHR, "SIPIX_XDIO");
+	ret |= gpio_request(MX6SL_BRD_EPDC_GDCLK, "SIPIX_YCLK");
+	ret |= gpio_request(MX6SL_BRD_EPDC_SDSHR, "SIPIX_XDIO");
 
-	ret |= gpio_request(MX6SL_ARM2_EPDC_SDLE, "SIPIX_LD");
-	ret |= gpio_request(MX6SL_ARM2_EPDC_SDCE1, "SIPIX_SOE");
+	ret |= gpio_request(MX6SL_BRD_EPDC_SDLE, "SIPIX_LD");
+	ret |= gpio_request(MX6SL_BRD_EPDC_SDCE1, "SIPIX_SOE");
 
-	ret |= gpio_request(MX6SL_ARM2_EPDC_SDCLK, "SIPIX_XCLK");
-	ret |= gpio_request(MX6SL_ARM2_EPDC_SDDO_10, "SIPIX_SHD_N");
-	ret |= gpio_request(MX6SL_ARM2_EPDC_SDCE0, "SIPIX2_CE");
+	ret |= gpio_request(MX6SL_BRD_EPDC_SDCLK, "SIPIX_XCLK");
+	ret |= gpio_request(MX6SL_BRD_EPDC_SDDO_10, "SIPIX_SHD_N");
+	ret |= gpio_request(MX6SL_BRD_EPDC_SDCE0, "SIPIX2_CE");
 
 	return ret;
 }
 
 static void spdc_put_pins(void)
 {
-	gpio_free(MX6SL_ARM2_EPDC_SDDO_0);
-	gpio_free(MX6SL_ARM2_EPDC_SDDO_1);
-	gpio_free(MX6SL_ARM2_EPDC_SDDO_2);
-	gpio_free(MX6SL_ARM2_EPDC_SDDO_3);
-	gpio_free(MX6SL_ARM2_EPDC_SDDO_4);
-	gpio_free(MX6SL_ARM2_EPDC_SDDO_5);
-	gpio_free(MX6SL_ARM2_EPDC_SDDO_6);
-	gpio_free(MX6SL_ARM2_EPDC_SDDO_7);
-
-	gpio_free(MX6SL_ARM2_EPDC_GDOE);
-	gpio_free(MX6SL_ARM2_EPDC_SDDO_9);
-	gpio_free(MX6SL_ARM2_EPDC_GDSP);
-	gpio_free(MX6SL_ARM2_EPDC_GDCLK);
-	gpio_free(MX6SL_ARM2_EPDC_SDSHR);
-	gpio_free(MX6SL_ARM2_EPDC_SDLE);
-	gpio_free(MX6SL_ARM2_EPDC_SDCE1);
-	gpio_free(MX6SL_ARM2_EPDC_SDCLK);
-	gpio_free(MX6SL_ARM2_EPDC_SDDO_10);
-	gpio_free(MX6SL_ARM2_EPDC_SDCE0);
+	gpio_free(MX6SL_BRD_EPDC_SDDO_0);
+	gpio_free(MX6SL_BRD_EPDC_SDDO_1);
+	gpio_free(MX6SL_BRD_EPDC_SDDO_2);
+	gpio_free(MX6SL_BRD_EPDC_SDDO_3);
+	gpio_free(MX6SL_BRD_EPDC_SDDO_4);
+	gpio_free(MX6SL_BRD_EPDC_SDDO_5);
+	gpio_free(MX6SL_BRD_EPDC_SDDO_6);
+	gpio_free(MX6SL_BRD_EPDC_SDDO_7);
+
+	gpio_free(MX6SL_BRD_EPDC_GDOE);
+	gpio_free(MX6SL_BRD_EPDC_SDDO_9);
+	gpio_free(MX6SL_BRD_EPDC_GDSP);
+	gpio_free(MX6SL_BRD_EPDC_GDCLK);
+	gpio_free(MX6SL_BRD_EPDC_SDSHR);
+	gpio_free(MX6SL_BRD_EPDC_SDLE);
+	gpio_free(MX6SL_BRD_EPDC_SDCE1);
+	gpio_free(MX6SL_BRD_EPDC_SDCLK);
+	gpio_free(MX6SL_BRD_EPDC_SDDO_10);
+	gpio_free(MX6SL_BRD_EPDC_SDCE0);
 }
 
 static void spdc_enable_pins(void)
 {
 	/* Configure MUX settings to enable SPDC use */
-	mxc_iomux_v3_setup_multiple_pads(mx6sl_arm2_spdc_enable_pads, \
-				ARRAY_SIZE(mx6sl_arm2_spdc_enable_pads));
-
-	gpio_direction_input(MX6SL_ARM2_EPDC_SDDO_0);
-	gpio_direction_input(MX6SL_ARM2_EPDC_SDDO_1);
-	gpio_direction_input(MX6SL_ARM2_EPDC_SDDO_2);
-	gpio_direction_input(MX6SL_ARM2_EPDC_SDDO_3);
-	gpio_direction_input(MX6SL_ARM2_EPDC_SDDO_4);
-	gpio_direction_input(MX6SL_ARM2_EPDC_SDDO_5);
-	gpio_direction_input(MX6SL_ARM2_EPDC_SDDO_6);
-	gpio_direction_input(MX6SL_ARM2_EPDC_SDDO_7);
-	gpio_direction_input(MX6SL_ARM2_EPDC_GDOE);
-	gpio_direction_input(MX6SL_ARM2_EPDC_SDDO_9);
-	gpio_direction_input(MX6SL_ARM2_EPDC_GDSP);
-	gpio_direction_input(MX6SL_ARM2_EPDC_GDCLK);
-	gpio_direction_input(MX6SL_ARM2_EPDC_SDSHR);
-	gpio_direction_input(MX6SL_ARM2_EPDC_SDLE);
-	gpio_direction_input(MX6SL_ARM2_EPDC_SDCE1);
-	gpio_direction_input(MX6SL_ARM2_EPDC_SDCLK);
-	gpio_direction_input(MX6SL_ARM2_EPDC_SDDO_10);
-	gpio_direction_input(MX6SL_ARM2_EPDC_SDCE0);
+	mxc_iomux_v3_setup_multiple_pads(mx6sl_brd_spdc_enable_pads, \
+				ARRAY_SIZE(mx6sl_brd_spdc_enable_pads));
+
+	gpio_direction_input(MX6SL_BRD_EPDC_SDDO_0);
+	gpio_direction_input(MX6SL_BRD_EPDC_SDDO_1);
+	gpio_direction_input(MX6SL_BRD_EPDC_SDDO_2);
+	gpio_direction_input(MX6SL_BRD_EPDC_SDDO_3);
+	gpio_direction_input(MX6SL_BRD_EPDC_SDDO_4);
+	gpio_direction_input(MX6SL_BRD_EPDC_SDDO_5);
+	gpio_direction_input(MX6SL_BRD_EPDC_SDDO_6);
+	gpio_direction_input(MX6SL_BRD_EPDC_SDDO_7);
+	gpio_direction_input(MX6SL_BRD_EPDC_GDOE);
+	gpio_direction_input(MX6SL_BRD_EPDC_SDDO_9);
+	gpio_direction_input(MX6SL_BRD_EPDC_GDSP);
+	gpio_direction_input(MX6SL_BRD_EPDC_GDCLK);
+	gpio_direction_input(MX6SL_BRD_EPDC_SDSHR);
+	gpio_direction_input(MX6SL_BRD_EPDC_SDLE);
+	gpio_direction_input(MX6SL_BRD_EPDC_SDCE1);
+	gpio_direction_input(MX6SL_BRD_EPDC_SDCLK);
+	gpio_direction_input(MX6SL_BRD_EPDC_SDDO_10);
+	gpio_direction_input(MX6SL_BRD_EPDC_SDCE0);
 }
 
 static void spdc_disable_pins(void)
 {
 	/* Configure MUX settings for SPDC pins to
 	 * GPIO and drive to 0. */
-	mxc_iomux_v3_setup_multiple_pads(mx6sl_arm2_spdc_disable_pads, \
-				ARRAY_SIZE(mx6sl_arm2_spdc_disable_pads));
-
-	gpio_direction_output(MX6SL_ARM2_EPDC_SDDO_0, 0);
-	gpio_direction_output(MX6SL_ARM2_EPDC_SDDO_1, 0);
-	gpio_direction_output(MX6SL_ARM2_EPDC_SDDO_2, 0);
-	gpio_direction_output(MX6SL_ARM2_EPDC_SDDO_3, 0);
-	gpio_direction_output(MX6SL_ARM2_EPDC_SDDO_4, 0);
-	gpio_direction_output(MX6SL_ARM2_EPDC_SDDO_5, 0);
-	gpio_direction_output(MX6SL_ARM2_EPDC_SDDO_6, 0);
-	gpio_direction_output(MX6SL_ARM2_EPDC_SDDO_7, 0);
-
-	gpio_direction_output(MX6SL_ARM2_EPDC_GDOE, 0);
-	gpio_direction_output(MX6SL_ARM2_EPDC_SDDO_9, 0);
-	gpio_direction_output(MX6SL_ARM2_EPDC_GDSP, 0);
-	gpio_direction_output(MX6SL_ARM2_EPDC_GDCLK, 0);
-	gpio_direction_output(MX6SL_ARM2_EPDC_SDSHR, 0);
-	gpio_direction_output(MX6SL_ARM2_EPDC_SDLE, 0);
-	gpio_direction_output(MX6SL_ARM2_EPDC_SDCE1, 0);
-	gpio_direction_output(MX6SL_ARM2_EPDC_SDCLK, 0);
-	gpio_direction_output(MX6SL_ARM2_EPDC_SDDO_10, 0);
-	gpio_direction_output(MX6SL_ARM2_EPDC_SDCE0, 0);
+	mxc_iomux_v3_setup_multiple_pads(mx6sl_brd_spdc_disable_pads, \
+				ARRAY_SIZE(mx6sl_brd_spdc_disable_pads));
+
+	gpio_direction_output(MX6SL_BRD_EPDC_SDDO_0, 0);
+	gpio_direction_output(MX6SL_BRD_EPDC_SDDO_1, 0);
+	gpio_direction_output(MX6SL_BRD_EPDC_SDDO_2, 0);
+	gpio_direction_output(MX6SL_BRD_EPDC_SDDO_3, 0);
+	gpio_direction_output(MX6SL_BRD_EPDC_SDDO_4, 0);
+	gpio_direction_output(MX6SL_BRD_EPDC_SDDO_5, 0);
+	gpio_direction_output(MX6SL_BRD_EPDC_SDDO_6, 0);
+	gpio_direction_output(MX6SL_BRD_EPDC_SDDO_7, 0);
+
+	gpio_direction_output(MX6SL_BRD_EPDC_GDOE, 0);
+	gpio_direction_output(MX6SL_BRD_EPDC_SDDO_9, 0);
+	gpio_direction_output(MX6SL_BRD_EPDC_GDSP, 0);
+	gpio_direction_output(MX6SL_BRD_EPDC_GDCLK, 0);
+	gpio_direction_output(MX6SL_BRD_EPDC_SDSHR, 0);
+	gpio_direction_output(MX6SL_BRD_EPDC_SDLE, 0);
+	gpio_direction_output(MX6SL_BRD_EPDC_SDCE1, 0);
+	gpio_direction_output(MX6SL_BRD_EPDC_SDCLK, 0);
+	gpio_direction_output(MX6SL_BRD_EPDC_SDDO_10, 0);
+	gpio_direction_output(MX6SL_BRD_EPDC_SDCE0, 0);
 }
 
 static struct imx_spdc_panel_init_set spdc_init_set = {
@@ -1105,9 +1048,9 @@ static void setup_spdc(void)
 static void imx6_arm2_usbotg_vbus(bool on)
 {
 	if (on)
-		gpio_set_value(MX6_ARM2_USBOTG1_PWR, 1);
+		gpio_set_value(MX6_BRD_USBOTG1_PWR, 1);
 	else
-		gpio_set_value(MX6_ARM2_USBOTG1_PWR, 0);
+		gpio_set_value(MX6_BRD_USBOTG1_PWR, 0);
 }
 
 static void __init mx6_arm2_init_usb(void)
@@ -1120,19 +1063,19 @@ static void __init mx6_arm2_init_usb(void)
 	 * or it will affect signal quality at dp.
 	 */
 
-	ret = gpio_request(MX6_ARM2_USBOTG1_PWR, "usbotg-pwr");
+	ret = gpio_request(MX6_BRD_USBOTG1_PWR, "usbotg-pwr");
 	if (ret) {
-		pr_err("failed to get GPIO MX6_ARM2_USBOTG1_PWR:%d\n", ret);
+		pr_err("failed to get GPIO MX6_BRD_USBOTG1_PWR:%d\n", ret);
 		return;
 	}
-	gpio_direction_output(MX6_ARM2_USBOTG1_PWR, 0);
+	gpio_direction_output(MX6_BRD_USBOTG1_PWR, 0);
 
-	ret = gpio_request(MX6_ARM2_USBOTG2_PWR, "usbh1-pwr");
+	ret = gpio_request(MX6_BRD_USBOTG2_PWR, "usbh1-pwr");
 	if (ret) {
-		pr_err("failed to get GPIO MX6_ARM2_USBOTG2_PWR:%d\n", ret);
+		pr_err("failed to get GPIO MX6_BRD_USBOTG2_PWR:%d\n", ret);
 		return;
 	}
-	gpio_direction_output(MX6_ARM2_USBOTG2_PWR, 1);
+	gpio_direction_output(MX6_BRD_USBOTG2_PWR, 1);
 
 	mx6_set_otghost_vbus_func(imx6_arm2_usbotg_vbus);
 	mx6_usb_dr_init();
@@ -1197,23 +1140,23 @@ static const struct matrix_keymap_data mx6sl_arm2_map_data __initconst = {
 };
 static void __init elan_ts_init(void)
 {
-	mxc_iomux_v3_setup_multiple_pads(mx6sl_arm2_elan_pads,
-					ARRAY_SIZE(mx6sl_arm2_elan_pads));
+	mxc_iomux_v3_setup_multiple_pads(mx6sl_brd_elan_pads,
+					ARRAY_SIZE(mx6sl_brd_elan_pads));
 
 	/* ELAN Touchscreen */
-	gpio_request(MX6SL_ARM2_ELAN_INT, "elan-interrupt");
-	gpio_direction_input(MX6SL_ARM2_ELAN_INT);
+	gpio_request(MX6SL_BRD_ELAN_INT, "elan-interrupt");
+	gpio_direction_input(MX6SL_BRD_ELAN_INT);
 
-	gpio_request(MX6SL_ARM2_ELAN_CE, "elan-cs");
-	gpio_direction_output(MX6SL_ARM2_ELAN_CE, 1);
-	gpio_direction_output(MX6SL_ARM2_ELAN_CE, 0);
+	gpio_request(MX6SL_BRD_ELAN_CE, "elan-cs");
+	gpio_direction_output(MX6SL_BRD_ELAN_CE, 1);
+	gpio_direction_output(MX6SL_BRD_ELAN_CE, 0);
 
-	gpio_request(MX6SL_ARM2_ELAN_RST, "elan-rst");
-	gpio_direction_output(MX6SL_ARM2_ELAN_RST, 1);
-	gpio_direction_output(MX6SL_ARM2_ELAN_RST, 0);
+	gpio_request(MX6SL_BRD_ELAN_RST, "elan-rst");
+	gpio_direction_output(MX6SL_BRD_ELAN_RST, 1);
+	gpio_direction_output(MX6SL_BRD_ELAN_RST, 0);
 	mdelay(1);
-	gpio_direction_output(MX6SL_ARM2_ELAN_RST, 1);
-	gpio_direction_output(MX6SL_ARM2_ELAN_CE, 1);
+	gpio_direction_output(MX6SL_BRD_ELAN_RST, 1);
+	gpio_direction_output(MX6SL_BRD_ELAN_CE, 1);
 }
 
 #define SNVS_LPCR 0x38
@@ -1232,7 +1175,8 @@ static void mx6_snvs_poweroff(void)
  */
 static void __init mx6_arm2_init(void)
 {
-	mxc_iomux_v3_setup_multiple_pads(mx6sl_arm2_pads, ARRAY_SIZE(mx6sl_arm2_pads));
+	mxc_iomux_v3_setup_multiple_pads(mx6sl_brd_pads,
+					ARRAY_SIZE(mx6sl_brd_pads));
 
 	elan_ts_init();
 
@@ -1285,8 +1229,8 @@ static void __init mx6_arm2_init(void)
 	imx6q_add_mxc_pwm_backlight(0, &mx6_arm2_pwm_backlight_data);
 	imx6dl_add_imx_elcdif(&fb_data[0]);
 
-	gpio_request(MX6_ARM2_LCD_PWR_EN, "elcdif-power-on");
-	gpio_direction_output(MX6_ARM2_LCD_PWR_EN, 1);
+	gpio_request(MX6_BRD_LCD_PWR_EN, "elcdif-power-on");
+	gpio_direction_output(MX6_BRD_LCD_PWR_EN, 1);
 	mxc_register_device(&lcd_wvga_device, NULL);
 
 	imx6dl_add_imx_pxp();
diff --git a/arch/arm/mach-mx6/board-mx6sl_arm2.h b/arch/arm/mach-mx6/board-mx6sl_arm2.h
deleted file mode 100755
index 09a2116..0000000
--- a/arch/arm/mach-mx6/board-mx6sl_arm2.h
+++ /dev/null
@@ -1,358 +0,0 @@
-/*
- * Copyright (C) 2012 Freescale Semiconductor, Inc. All Rights Reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
-
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
-
- * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- */
-
-#ifndef _BOARD_MX6SL_ARM2_H
-#define _BOARD_MX6SL_ARM2_H
-#include <mach/iomux-mx6sl.h>
-
-static iomux_v3_cfg_t mx6sl_arm2_pads[] = {
-
-	/* AUDMUX */
-	MX6SL_PAD_AUD_TXC__AUDMUX_AUD3_TXC,
-	MX6SL_PAD_AUD_TXD__AUDMUX_AUD3_TXD,
-	MX6SL_PAD_AUD_TXFS__AUDMUX_AUD3_TXFS,
-	MX6SL_PAD_AUD_RXD__AUDMUX_AUD3_RXD,
-	MX6SL_PAD_AUD_MCLK__AUDMUX_AUDIO_CLK_OUT,
-
-	/* Audio Codec */
-	MX6SL_PAD_FEC_RX_ER__GPIO_4_19,	/* HEADPHONE_DET */
-
-	/* UART1 */
-	MX6SL_PAD_UART1_RXD__UART1_RXD,
-	MX6SL_PAD_UART1_TXD__UART1_TXD,
-
-	/* USBOTG ID pin */
-	MX6SL_PAD_EPDC_PWRCOM__ANATOP_USBOTG1_ID,
-
-	/* USBOTG POWER GPIO */
-	MX6SL_PAD_KEY_COL4__GPIO_4_0,
-	MX6SL_PAD_KEY_COL5__GPIO_4_2,
-	/* USB OC pin */
-	MX6SL_PAD_KEY_ROW4__USB_USBOTG1_OC,
-	MX6SL_PAD_ECSPI2_SCLK__USB_USBOTG2_OC,
-	/* USB HSIC pin */
-	MX6SL_PAD_HSIC_STROBE__USB_H_STROBE,
-	MX6SL_PAD_HSIC_DAT__USB_H_DATA,
-
-	/* SD1 */
-	MX6SL_PAD_SD1_CLK__USDHC1_CLK_50MHZ,
-	MX6SL_PAD_SD1_CMD__USDHC1_CMD_50MHZ,
-	MX6SL_PAD_SD1_DAT0__USDHC1_DAT0_50MHZ,
-	MX6SL_PAD_SD1_DAT1__USDHC1_DAT1_50MHZ,
-	MX6SL_PAD_SD1_DAT2__USDHC1_DAT2_50MHZ,
-	MX6SL_PAD_SD1_DAT3__USDHC1_DAT3_50MHZ,
-	MX6SL_PAD_SD1_DAT4__USDHC1_DAT4_50MHZ,
-	MX6SL_PAD_SD1_DAT5__USDHC1_DAT5_50MHZ,
-	MX6SL_PAD_SD1_DAT6__USDHC1_DAT6_50MHZ,
-	MX6SL_PAD_SD1_DAT7__USDHC1_DAT7_50MHZ,
-	/* SD1 CD & WP */
-	MX6SL_PAD_KEY_ROW7__GPIO_4_7,
-	MX6SL_PAD_KEY_COL7__GPIO_4_6,
-	/* SD2 */
-	MX6SL_PAD_SD2_CLK__USDHC2_CLK_50MHZ,
-	MX6SL_PAD_SD2_CMD__USDHC2_CMD_50MHZ,
-	MX6SL_PAD_SD2_DAT0__USDHC2_DAT0_50MHZ,
-	MX6SL_PAD_SD2_DAT1__USDHC2_DAT1_50MHZ,
-	MX6SL_PAD_SD2_DAT2__USDHC2_DAT2_50MHZ,
-	MX6SL_PAD_SD2_DAT3__USDHC2_DAT3_50MHZ,
-	/* SD2 CD & WP */
-	MX6SL_PAD_SD2_DAT7__GPIO_5_0,
-	MX6SL_PAD_SD2_DAT6__GPIO_4_29,
-	/* SD3 */
-	MX6SL_PAD_SD3_CLK__USDHC3_CLK_50MHZ,
-	MX6SL_PAD_SD3_CMD__USDHC3_CMD_50MHZ,
-	MX6SL_PAD_SD3_DAT0__USDHC3_DAT0_50MHZ,
-	MX6SL_PAD_SD3_DAT1__USDHC3_DAT1_50MHZ,
-	MX6SL_PAD_SD3_DAT2__USDHC3_DAT2_50MHZ,
-	MX6SL_PAD_SD3_DAT3__USDHC3_DAT3_50MHZ,
-	/* SD3 CD */
-	MX6SL_PAD_REF_CLK_32K__GPIO_3_22,
-
-	/* FEC */
-	MX6SL_PAD_FEC_MDC__FEC_MDC,
-	MX6SL_PAD_FEC_MDIO__FEC_MDIO,
-	MX6SL_PAD_FEC_REF_CLK__FEC_REF_OUT, /* clock from anatop */
-	MX6SL_PAD_FEC_RX_ER__GPIO_4_19,
-	MX6SL_PAD_FEC_CRS_DV__FEC_RX_DV,
-	MX6SL_PAD_FEC_RXD0__FEC_RDATA_0,
-	MX6SL_PAD_FEC_RXD1__FEC_RDATA_1,
-	MX6SL_PAD_FEC_TX_EN__FEC_TX_EN,
-	MX6SL_PAD_FEC_TXD0__FEC_TDATA_0,
-	MX6SL_PAD_FEC_TXD1__FEC_TDATA_1,
-	MX6SL_PAD_FEC_TX_CLK__GPIO_4_21, /* Phy power enable */
-
-	/* I2C */
-	MX6SL_PAD_I2C1_SCL__I2C1_SCL,
-	MX6SL_PAD_I2C1_SDA__I2C1_SDA,
-	MX6SL_PAD_I2C2_SCL__I2C2_SCL,
-	MX6SL_PAD_I2C2_SDA__I2C2_SDA,
-
-	/* ECSPI1 */
-	MX6SL_PAD_ECSPI1_MISO__ECSPI1_MISO,
-	MX6SL_PAD_ECSPI1_MOSI__ECSPI1_MOSI,
-	MX6SL_PAD_ECSPI1_SCLK__ECSPI1_SCLK,
-	MX6SL_PAD_ECSPI1_SS0__ECSPI1_SS0,
-	MX6SL_PAD_ECSPI1_SS0__GPIO_4_11,	/* SS0 */
-
-	/* LCD */
-	MX6SL_PAD_LCD_CLK__LCDIF_CLK,
-	MX6SL_PAD_LCD_ENABLE__LCDIF_ENABLE,
-	MX6SL_PAD_LCD_HSYNC__LCDIF_HSYNC,
-	MX6SL_PAD_LCD_VSYNC__LCDIF_VSYNC,
-	MX6SL_PAD_LCD_RESET__LCDIF_RESET,
-	MX6SL_PAD_LCD_DAT0__LCDIF_DAT_0,
-	MX6SL_PAD_LCD_DAT1__LCDIF_DAT_1,
-	MX6SL_PAD_LCD_DAT2__LCDIF_DAT_2,
-	MX6SL_PAD_LCD_DAT3__LCDIF_DAT_3,
-	MX6SL_PAD_LCD_DAT4__LCDIF_DAT_4,
-	MX6SL_PAD_LCD_DAT5__LCDIF_DAT_5,
-	MX6SL_PAD_LCD_DAT6__LCDIF_DAT_6,
-	MX6SL_PAD_LCD_DAT7__LCDIF_DAT_7,
-	MX6SL_PAD_LCD_DAT8__LCDIF_DAT_8,
-	MX6SL_PAD_LCD_DAT9__LCDIF_DAT_9,
-	MX6SL_PAD_LCD_DAT10__LCDIF_DAT_10,
-	MX6SL_PAD_LCD_DAT11__LCDIF_DAT_11,
-	MX6SL_PAD_LCD_DAT12__LCDIF_DAT_12,
-	MX6SL_PAD_LCD_DAT13__LCDIF_DAT_13,
-	MX6SL_PAD_LCD_DAT14__LCDIF_DAT_14,
-	MX6SL_PAD_LCD_DAT15__LCDIF_DAT_15,
-	MX6SL_PAD_LCD_DAT16__LCDIF_DAT_16,
-	MX6SL_PAD_LCD_DAT17__LCDIF_DAT_17,
-	MX6SL_PAD_LCD_DAT18__LCDIF_DAT_18,
-	MX6SL_PAD_LCD_DAT19__LCDIF_DAT_19,
-	MX6SL_PAD_LCD_DAT20__LCDIF_DAT_20,
-	MX6SL_PAD_LCD_DAT21__LCDIF_DAT_21,
-	MX6SL_PAD_LCD_DAT22__LCDIF_DAT_22,
-	MX6SL_PAD_LCD_DAT23__LCDIF_DAT_23,
-	/* LCD brightness */
-	MX6SL_PAD_PWM1__PWM1_PWMO,
-	/* LCD power on */
-	MX6SL_PAD_KEY_ROW5__GPIO_4_3,
-
-	/* keypad on E-Ink add-on board */
-	MX6SL_PAD_KEY_COL0__KPP_COL_0,
-	MX6SL_PAD_KEY_COL1__KPP_COL_1,
-	MX6SL_PAD_KEY_COL2__KPP_COL_2,
-	MX6SL_PAD_KEY_COL3__KPP_COL_3,
-	MX6SL_PAD_KEY_ROW0__KPP_ROW_0,
-	MX6SL_PAD_KEY_ROW1__KPP_ROW_1,
-	MX6SL_PAD_KEY_ROW2__KPP_ROW_2,
-	MX6SL_PAD_KEY_ROW3__KPP_ROW_3,
-
-	/* WDOG */
-	MX6SL_PAD_WDOG_B__WDOG1_WDOG_B,
-};
-
-static iomux_v3_cfg_t mx6sl_arm2_epdc_enable_pads[] = {
-	/* EPDC */
-	MX6SL_PAD_EPDC_D0__EPDC_SDDO_0,
-	MX6SL_PAD_EPDC_D1__EPDC_SDDO_1,
-	MX6SL_PAD_EPDC_D2__EPDC_SDDO_2,
-	MX6SL_PAD_EPDC_D3__EPDC_SDDO_3,
-	MX6SL_PAD_EPDC_D4__EPDC_SDDO_4,
-	MX6SL_PAD_EPDC_D5__EPDC_SDDO_5,
-	MX6SL_PAD_EPDC_D6__EPDC_SDDO_6,
-	MX6SL_PAD_EPDC_D7__EPDC_SDDO_7,
-	MX6SL_PAD_EPDC_D8__EPDC_SDDO_8,
-	MX6SL_PAD_EPDC_D9__EPDC_SDDO_9,
-	MX6SL_PAD_EPDC_D10__EPDC_SDDO_10,
-	MX6SL_PAD_EPDC_D11__EPDC_SDDO_11,
-	MX6SL_PAD_EPDC_D12__EPDC_SDDO_12,
-	MX6SL_PAD_EPDC_D13__EPDC_SDDO_13,
-	MX6SL_PAD_EPDC_D14__EPDC_SDDO_14,
-	MX6SL_PAD_EPDC_D15__EPDC_SDDO_15,
-
-	MX6SL_PAD_EPDC_GDCLK__EPDC_GDCLK,
-	MX6SL_PAD_EPDC_GDSP__EPDC_GDSP,
-	MX6SL_PAD_EPDC_GDOE__EPDC_GDOE,
-	MX6SL_PAD_EPDC_GDRL__EPDC_GDRL,
-	MX6SL_PAD_EPDC_SDCLK__EPDC_SDCLK,
-	MX6SL_PAD_EPDC_SDOE__EPDC_SDOE,
-	MX6SL_PAD_EPDC_SDLE__EPDC_SDLE,
-	MX6SL_PAD_EPDC_SDSHR__EPDC_SDSHR,
-	MX6SL_PAD_EPDC_BDR0__EPDC_BDR_0,
-	MX6SL_PAD_EPDC_SDCE0__EPDC_SDCE_0,
-	MX6SL_PAD_EPDC_SDCE1__EPDC_SDCE_1,
-	MX6SL_PAD_EPDC_SDCE2__EPDC_SDCE_2,
-
-	/* EPD PMIC (Maxim 17135) pins */
-	MX6SL_PAD_EPDC_VCOM0__GPIO_2_3,
-	MX6SL_PAD_EPDC_PWRSTAT__GPIO_2_13,
-	MX6SL_PAD_EPDC_PWRCTRL0__GPIO_2_7,
-	MX6SL_PAD_EPDC_PWRWAKEUP__GPIO_2_14,
-};
-
-static iomux_v3_cfg_t mx6sl_arm2_epdc_disable_pads[] = {
-	/* EPDC */
-	MX6SL_PAD_EPDC_D0__GPIO_1_7,
-	MX6SL_PAD_EPDC_D1__GPIO_1_8,
-	MX6SL_PAD_EPDC_D2__GPIO_1_9,
-	MX6SL_PAD_EPDC_D3__GPIO_1_10,
-	MX6SL_PAD_EPDC_D4__GPIO_1_11,
-	MX6SL_PAD_EPDC_D5__GPIO_1_12,
-	MX6SL_PAD_EPDC_D6__GPIO_1_13,
-	MX6SL_PAD_EPDC_D7__GPIO_1_14,
-	MX6SL_PAD_EPDC_D8__GPIO_1_15,
-	MX6SL_PAD_EPDC_D9__GPIO_1_16,
-	MX6SL_PAD_EPDC_D10__GPIO_1_17,
-	MX6SL_PAD_EPDC_D11__GPIO_1_18,
-	MX6SL_PAD_EPDC_D12__GPIO_1_19,
-	MX6SL_PAD_EPDC_D13__GPIO_1_20,
-	MX6SL_PAD_EPDC_D14__GPIO_1_21,
-	MX6SL_PAD_EPDC_D15__GPIO_1_22,
-
-	MX6SL_PAD_EPDC_GDCLK__GPIO_1_31,
-	MX6SL_PAD_EPDC_GDSP__GPIO_2_2,
-	MX6SL_PAD_EPDC_GDOE__GPIO_2_0,
-	MX6SL_PAD_EPDC_GDRL__GPIO_2_1,
-	MX6SL_PAD_EPDC_SDCLK__GPIO_1_23,
-	MX6SL_PAD_EPDC_SDOE__GPIO_1_25,
-	MX6SL_PAD_EPDC_SDLE__GPIO_1_24,
-	MX6SL_PAD_EPDC_SDSHR__GPIO_1_26,
-	MX6SL_PAD_EPDC_BDR0__GPIO_2_5,
-	MX6SL_PAD_EPDC_SDCE0__GPIO_1_27,
-	MX6SL_PAD_EPDC_SDCE1__GPIO_1_28,
-	MX6SL_PAD_EPDC_SDCE2__GPIO_1_29,
-
-	/* EPD PMIC (Maxim 17135) pins */
-	MX6SL_PAD_EPDC_VCOM0__GPIO_2_3,
-	MX6SL_PAD_EPDC_PWRSTAT__GPIO_2_13,
-	MX6SL_PAD_EPDC_PWRCTRL0__GPIO_2_7,
-	MX6SL_PAD_EPDC_PWRWAKEUP__GPIO_2_14,
-};
-
-static iomux_v3_cfg_t mx6sl_arm2_spdc_enable_pads[] = {
-	/* SPDC data*/
-	MX6SL_PAD_EPDC_D0__TCON_E_DATA_0,
-	MX6SL_PAD_EPDC_D1__TCON_E_DATA_1,
-	MX6SL_PAD_EPDC_D2__TCON_E_DATA_2,
-	MX6SL_PAD_EPDC_D3__TCON_E_DATA_3,
-	MX6SL_PAD_EPDC_D4__TCON_E_DATA_4,
-	MX6SL_PAD_EPDC_D5__TCON_E_DATA_5,
-	MX6SL_PAD_EPDC_D6__TCON_E_DATA_6,
-	MX6SL_PAD_EPDC_D7__TCON_E_DATA_7,
-
-	MX6SL_PAD_EPDC_GDOE__TCON_YOEL,   /* AUO panel SIPIX_YOE */
-
-	MX6SL_PAD_EPDC_D9__TCON_E_DATA_9, /* AUO panel SIPIX_PWR_RDY*/
-
-	MX6SL_PAD_EPDC_SDCE2__TCON_YDIOUR, /* AUO panel SIPIX_YDIO */
-	MX6SL_PAD_EPDC_SDCE3__TCON_YDIODR, /* AUO panel SIPIX_YDIO */
-	MX6SL_PAD_EPDC_GDRL__TCON_YDIOUL,  /* AUO panel SIPIX_YDIO */
-	MX6SL_PAD_EPDC_GDSP__TCON_YDIODL,  /* SIPIX_YDIO/SIPIX2_SPV */
-
-	MX6SL_PAD_EPDC_GDCLK__TCON_YCKL,  /* SIPIX_YCLK/SIPIX2_CKV */
-
-	MX6SL_PAD_EPDC_SDSHR__TCON_XDIOR, /* AUO panel SIPIX_XDIO */
-	MX6SL_PAD_EPDC_SDOE__TCON_XDIOL,  /* SIPIX_XDIO/SIPIX2_OE */
-
-	MX6SL_PAD_EPDC_SDLE__TCON_LD,     /* SIPIX_LD/SIPIX2_LE */
-
-	MX6SL_PAD_EPDC_SDCE1__TCON_YOER,  /* AUO panel SIPIX_SOE */
-	MX6SL_PAD_EPDC_BDR0__TCON_RL,     /* AUO panel SIPIX_SOE */
-	MX6SL_PAD_EPDC_BDR1__TCON_UD,     /* AUO panel SIPIX_SOE */
-
-	MX6SL_PAD_EPDC_SDCLK__TCON_CL,    /* SIPIX_XCLK/SIPIX2_CL */
-
-	MX6SL_PAD_EPDC_D10__TCON_E_DATA_10, /* AUO panel SIPIX_SHD_N */
-
-	MX6SL_PAD_EPDC_SDCE0__TCON_YCKR,  /* LG panel SIPIX2_CE */
-
-	/* EPD PMIC (Maxim 17135) pins */
-	MX6SL_PAD_EPDC_VCOM0__GPIO_2_3, /* PMICA_CEN */
-	MX6SL_PAD_EPDC_PWRSTAT__GPIO_2_13,
-	MX6SL_PAD_EPDC_PWRCTRL0__GPIO_2_7,
-	MX6SL_PAD_EPDC_PWRWAKEUP__GPIO_2_14,
-};
-
-static iomux_v3_cfg_t mx6sl_arm2_spdc_disable_pads[] = {
-	MX6SL_PAD_EPDC_D0__GPIO_1_7,
-	MX6SL_PAD_EPDC_D1__GPIO_1_8,
-	MX6SL_PAD_EPDC_D2__GPIO_1_9,
-	MX6SL_PAD_EPDC_D3__GPIO_1_10,
-	MX6SL_PAD_EPDC_D4__GPIO_1_11,
-	MX6SL_PAD_EPDC_D5__GPIO_1_12,
-	MX6SL_PAD_EPDC_D6__GPIO_1_13,
-	MX6SL_PAD_EPDC_D7__GPIO_1_14,
-
-	MX6SL_PAD_EPDC_SDCE1__GPIO_1_28,
-	MX6SL_PAD_EPDC_GDOE__GPIO_2_0,
-	MX6SL_PAD_EPDC_D9__GPIO_1_16,
-	MX6SL_PAD_EPDC_SDCE2__GPIO_1_29,
-	MX6SL_PAD_EPDC_SDCE3__GPIO_1_30,
-	MX6SL_PAD_EPDC_GDRL__GPIO_2_1,
-	MX6SL_PAD_EPDC_GDSP__GPIO_2_2,
-	MX6SL_PAD_EPDC_GDCLK__GPIO_1_31,
-	MX6SL_PAD_EPDC_SDSHR__GPIO_1_26,
-	MX6SL_PAD_EPDC_SDOE__GPIO_1_25,
-	MX6SL_PAD_EPDC_SDLE__GPIO_1_24,
-	MX6SL_PAD_EPDC_SDCE1__GPIO_1_28,
-	MX6SL_PAD_EPDC_BDR0__GPIO_2_5,
-	MX6SL_PAD_EPDC_BDR1__GPIO_2_6,
-	MX6SL_PAD_EPDC_SDCLK__GPIO_1_23,
-	MX6SL_PAD_EPDC_D10__GPIO_1_17,
-	MX6SL_PAD_EPDC_SDCE0__GPIO_1_27,
-
-	/* EPD PMIC (Maxim 17135) pins */
-	MX6SL_PAD_EPDC_VCOM0__GPIO_2_3,
-	MX6SL_PAD_EPDC_PWRSTAT__GPIO_2_13,
-	MX6SL_PAD_EPDC_PWRCTRL0__GPIO_2_7,
-	MX6SL_PAD_EPDC_PWRWAKEUP__GPIO_2_14,
-};
-
-static iomux_v3_cfg_t mx6sl_arm2_elan_pads[] = {
-	MX6SL_PAD_EPDC_PWRCTRL3__GPIO_2_10,	/* INT */
-	MX6SL_PAD_EPDC_PWRCTRL2__GPIO_2_9,	/* CE */
-	MX6SL_PAD_KEY_COL6__GPIO_4_4,		/* RST */
-};
-
-#define MX6SL_USDHC_8BIT_PAD_SETTING(id, speed)	\
-mx6sl_sd##id##_##speed##mhz[] = {		\
-	MX6SL_PAD_SD##id##_CLK__USDHC##id##_CLK_##speed##MHZ,	\
-	MX6SL_PAD_SD##id##_CMD__USDHC##id##_CMD_##speed##MHZ,	\
-	MX6SL_PAD_SD##id##_DAT0__USDHC##id##_DAT0_##speed##MHZ,	\
-	MX6SL_PAD_SD##id##_DAT1__USDHC##id##_DAT1_##speed##MHZ,	\
-	MX6SL_PAD_SD##id##_DAT2__USDHC##id##_DAT2_##speed##MHZ,	\
-	MX6SL_PAD_SD##id##_DAT3__USDHC##id##_DAT3_##speed##MHZ,	\
-	MX6SL_PAD_SD##id##_DAT4__USDHC##id##_DAT4_##speed##MHZ,	\
-	MX6SL_PAD_SD##id##_DAT5__USDHC##id##_DAT5_##speed##MHZ,	\
-	MX6SL_PAD_SD##id##_DAT6__USDHC##id##_DAT6_##speed##MHZ,	\
-	MX6SL_PAD_SD##id##_DAT7__USDHC##id##_DAT7_##speed##MHZ,	\
-}
-#define MX6SL_USDHC_4BIT_PAD_SETTING(id, speed)	\
-mx6sl_sd##id##_##speed##mhz[] = {		\
-	MX6SL_PAD_SD##id##_CLK__USDHC##id##_CLK_##speed##MHZ,	\
-	MX6SL_PAD_SD##id##_CMD__USDHC##id##_CMD_##speed##MHZ,	\
-	MX6SL_PAD_SD##id##_DAT0__USDHC##id##_DAT0_##speed##MHZ,	\
-	MX6SL_PAD_SD##id##_DAT1__USDHC##id##_DAT1_##speed##MHZ,	\
-	MX6SL_PAD_SD##id##_DAT2__USDHC##id##_DAT2_##speed##MHZ,	\
-	MX6SL_PAD_SD##id##_DAT3__USDHC##id##_DAT3_##speed##MHZ,	\
-}
-
-
-static iomux_v3_cfg_t MX6SL_USDHC_8BIT_PAD_SETTING(1, 50);
-static iomux_v3_cfg_t MX6SL_USDHC_8BIT_PAD_SETTING(1, 100);
-static iomux_v3_cfg_t MX6SL_USDHC_8BIT_PAD_SETTING(1, 200);
-static iomux_v3_cfg_t MX6SL_USDHC_4BIT_PAD_SETTING(2, 50);
-static iomux_v3_cfg_t MX6SL_USDHC_4BIT_PAD_SETTING(2, 100);
-static iomux_v3_cfg_t MX6SL_USDHC_4BIT_PAD_SETTING(2, 200);
-static iomux_v3_cfg_t MX6SL_USDHC_4BIT_PAD_SETTING(3, 50);
-static iomux_v3_cfg_t MX6SL_USDHC_4BIT_PAD_SETTING(3, 100);
-static iomux_v3_cfg_t MX6SL_USDHC_4BIT_PAD_SETTING(3, 200);
-
-#endif
diff --git a/arch/arm/mach-mx6/board-mx6sl_common.h b/arch/arm/mach-mx6/board-mx6sl_common.h
new file mode 100644
index 0000000..d005e02
--- /dev/null
+++ b/arch/arm/mach-mx6/board-mx6sl_common.h
@@ -0,0 +1,415 @@
+/*
+ * Copyright (C) 2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef _BOARD_MX6SL_COMMON_H
+#define _BOARD_MX6SL_COMMON_H
+#include <mach/iomux-mx6sl.h>
+
+#define MX6_BRD_USBOTG1_PWR	IMX_GPIO_NR(4, 0)       /* KEY_COL4 */
+#define MX6_BRD_USBOTG2_PWR	IMX_GPIO_NR(4, 2)       /* KEY_COL5 */
+#define MX6_BRD_LCD_PWR_EN	IMX_GPIO_NR(4, 3)	/* KEY_ROW5 */
+#define MX6_BRD_SD1_WP		IMX_GPIO_NR(4, 6)	/* KEY_COL7 */
+#define MX6_BRD_SD1_CD		IMX_GPIO_NR(4, 7)	/* KEY_ROW7 */
+#define MX6_BRD_ECSPI1_CS0	IMX_GPIO_NR(4, 11)	/* ECSPI1_SS0 */
+#define MX6_BRD_HEADPHONE_DET	IMX_GPIO_NR(4, 19)	/* FEC_RX_ER */
+#define MX6_BRD_SD2_WP		IMX_GPIO_NR(4, 29)	/* SD2_DAT6 */
+#define MX6_BRD_SD2_CD		IMX_GPIO_NR(5, 0)	/* SD2_DAT7 */
+#define MX6_BRD_SD3_CD		IMX_GPIO_NR(3, 22)	/* REF_CLK_32K */
+#define MX6_BRD_FEC_PWR_EN	IMX_GPIO_NR(4, 21)	/* FEC_TX_CLK */
+
+/* EPDC GPIO pins */
+#define MX6SL_BRD_EPDC_SDDO_0		IMX_GPIO_NR(1, 7)
+#define MX6SL_BRD_EPDC_SDDO_1		IMX_GPIO_NR(1, 8)
+#define MX6SL_BRD_EPDC_SDDO_2		IMX_GPIO_NR(1, 9)
+#define MX6SL_BRD_EPDC_SDDO_3		IMX_GPIO_NR(1, 10)
+#define MX6SL_BRD_EPDC_SDDO_4		IMX_GPIO_NR(1, 11)
+#define MX6SL_BRD_EPDC_SDDO_5		IMX_GPIO_NR(1, 12)
+#define MX6SL_BRD_EPDC_SDDO_6		IMX_GPIO_NR(1, 13)
+#define MX6SL_BRD_EPDC_SDDO_7		IMX_GPIO_NR(1, 14)
+#define MX6SL_BRD_EPDC_SDDO_8		IMX_GPIO_NR(1, 15)
+#define MX6SL_BRD_EPDC_SDDO_9		IMX_GPIO_NR(1, 16)
+#define MX6SL_BRD_EPDC_SDDO_10		IMX_GPIO_NR(1, 17)
+#define MX6SL_BRD_EPDC_SDDO_11		IMX_GPIO_NR(1, 18)
+#define MX6SL_BRD_EPDC_SDDO_12		IMX_GPIO_NR(1, 19)
+#define MX6SL_BRD_EPDC_SDDO_13		IMX_GPIO_NR(1, 20)
+#define MX6SL_BRD_EPDC_SDDO_14		IMX_GPIO_NR(1, 21)
+#define MX6SL_BRD_EPDC_SDDO_15		IMX_GPIO_NR(1, 22)
+#define MX6SL_BRD_EPDC_GDCLK		IMX_GPIO_NR(1, 31)
+#define MX6SL_BRD_EPDC_GDSP		IMX_GPIO_NR(2, 2)
+#define MX6SL_BRD_EPDC_GDOE		IMX_GPIO_NR(2, 0)
+#define MX6SL_BRD_EPDC_GDRL		IMX_GPIO_NR(2, 1)
+#define MX6SL_BRD_EPDC_SDCLK		IMX_GPIO_NR(1, 23)
+#define MX6SL_BRD_EPDC_SDOE		IMX_GPIO_NR(1, 25)
+#define MX6SL_BRD_EPDC_SDLE		IMX_GPIO_NR(1, 24)
+#define MX6SL_BRD_EPDC_SDSHR		IMX_GPIO_NR(1, 26)
+#define MX6SL_BRD_EPDC_PWRCOM		IMX_GPIO_NR(2, 11)
+#define MX6SL_BRD_EPDC_PWRSTAT		IMX_GPIO_NR(2, 13)
+#define MX6SL_BRD_EPDC_PWRCTRL0		IMX_GPIO_NR(2, 7)
+#define MX6SL_BRD_EPDC_PWRCTRL1		IMX_GPIO_NR(2, 8)
+#define MX6SL_BRD_EPDC_PWRCTRL2		IMX_GPIO_NR(2, 9)
+#define MX6SL_BRD_EPDC_PWRCTRL3		IMX_GPIO_NR(2, 10)
+#define MX6SL_BRD_EPDC_BDR0		IMX_GPIO_NR(2, 5)
+#define MX6SL_BRD_EPDC_BDR1		IMX_GPIO_NR(2, 6)
+#define MX6SL_BRD_EPDC_SDCE0		IMX_GPIO_NR(1, 27)
+#define MX6SL_BRD_EPDC_SDCE1		IMX_GPIO_NR(1, 28)
+#define MX6SL_BRD_EPDC_SDCE2		IMX_GPIO_NR(1, 29)
+#define MX6SL_BRD_EPDC_SDCE3		IMX_GPIO_NR(1, 30)
+#define MX6SL_BRD_EPDC_PMIC_WAKE	IMX_GPIO_NR(2, 14) /* EPDC_PWRWAKEUP */
+#define MX6SL_BRD_EPDC_PMIC_INT		IMX_GPIO_NR(2, 12) /* EPDC_PWRINT */
+#define MX6SL_BRD_EPDC_VCOM		IMX_GPIO_NR(2, 3)
+/* ELAN TS */
+#define MX6SL_BRD_ELAN_CE		IMX_GPIO_NR(2, 9)
+#define MX6SL_BRD_ELAN_INT		IMX_GPIO_NR(2, 10)
+#define MX6SL_BRD_ELAN_RST		IMX_GPIO_NR(4, 4)
+
+static iomux_v3_cfg_t mx6sl_brd_pads[] = {
+
+	/* AUDMUX */
+	MX6SL_PAD_AUD_TXC__AUDMUX_AUD3_TXC,
+	MX6SL_PAD_AUD_TXD__AUDMUX_AUD3_TXD,
+	MX6SL_PAD_AUD_TXFS__AUDMUX_AUD3_TXFS,
+	MX6SL_PAD_AUD_RXD__AUDMUX_AUD3_RXD,
+	MX6SL_PAD_AUD_MCLK__AUDMUX_AUDIO_CLK_OUT,
+
+	/* Audio Codec */
+	MX6SL_PAD_FEC_RX_ER__GPIO_4_19,	/* HEADPHONE_DET */
+
+	/* UART1 */
+	MX6SL_PAD_UART1_RXD__UART1_RXD,
+	MX6SL_PAD_UART1_TXD__UART1_TXD,
+
+	/* USBOTG ID pin */
+	MX6SL_PAD_EPDC_PWRCOM__ANATOP_USBOTG1_ID,
+
+	/* USBOTG POWER GPIO */
+	MX6SL_PAD_KEY_COL4__GPIO_4_0,
+	MX6SL_PAD_KEY_COL5__GPIO_4_2,
+	/* USB OC pin */
+	MX6SL_PAD_KEY_ROW4__USB_USBOTG1_OC,
+	MX6SL_PAD_ECSPI2_SCLK__USB_USBOTG2_OC,
+	/* USB HSIC pin */
+	MX6SL_PAD_HSIC_STROBE__USB_H_STROBE,
+	MX6SL_PAD_HSIC_DAT__USB_H_DATA,
+
+	/* SD1 */
+	MX6SL_PAD_SD1_CLK__USDHC1_CLK_50MHZ,
+	MX6SL_PAD_SD1_CMD__USDHC1_CMD_50MHZ,
+	MX6SL_PAD_SD1_DAT0__USDHC1_DAT0_50MHZ,
+	MX6SL_PAD_SD1_DAT1__USDHC1_DAT1_50MHZ,
+	MX6SL_PAD_SD1_DAT2__USDHC1_DAT2_50MHZ,
+	MX6SL_PAD_SD1_DAT3__USDHC1_DAT3_50MHZ,
+	MX6SL_PAD_SD1_DAT4__USDHC1_DAT4_50MHZ,
+	MX6SL_PAD_SD1_DAT5__USDHC1_DAT5_50MHZ,
+	MX6SL_PAD_SD1_DAT6__USDHC1_DAT6_50MHZ,
+	MX6SL_PAD_SD1_DAT7__USDHC1_DAT7_50MHZ,
+	/* SD1 CD & WP */
+	MX6SL_PAD_KEY_ROW7__GPIO_4_7,
+	MX6SL_PAD_KEY_COL7__GPIO_4_6,
+	/* SD2 */
+	MX6SL_PAD_SD2_CLK__USDHC2_CLK_50MHZ,
+	MX6SL_PAD_SD2_CMD__USDHC2_CMD_50MHZ,
+	MX6SL_PAD_SD2_DAT0__USDHC2_DAT0_50MHZ,
+	MX6SL_PAD_SD2_DAT1__USDHC2_DAT1_50MHZ,
+	MX6SL_PAD_SD2_DAT2__USDHC2_DAT2_50MHZ,
+	MX6SL_PAD_SD2_DAT3__USDHC2_DAT3_50MHZ,
+	/* SD2 CD & WP */
+	MX6SL_PAD_SD2_DAT7__GPIO_5_0,
+	MX6SL_PAD_SD2_DAT6__GPIO_4_29,
+	/* SD3 */
+	MX6SL_PAD_SD3_CLK__USDHC3_CLK_50MHZ,
+	MX6SL_PAD_SD3_CMD__USDHC3_CMD_50MHZ,
+	MX6SL_PAD_SD3_DAT0__USDHC3_DAT0_50MHZ,
+	MX6SL_PAD_SD3_DAT1__USDHC3_DAT1_50MHZ,
+	MX6SL_PAD_SD3_DAT2__USDHC3_DAT2_50MHZ,
+	MX6SL_PAD_SD3_DAT3__USDHC3_DAT3_50MHZ,
+	/* SD3 CD */
+	MX6SL_PAD_REF_CLK_32K__GPIO_3_22,
+
+	/* FEC */
+	MX6SL_PAD_FEC_MDC__FEC_MDC,
+	MX6SL_PAD_FEC_MDIO__FEC_MDIO,
+	MX6SL_PAD_FEC_REF_CLK__FEC_REF_OUT, /* clock from anatop */
+	MX6SL_PAD_FEC_RX_ER__GPIO_4_19,
+	MX6SL_PAD_FEC_CRS_DV__FEC_RX_DV,
+	MX6SL_PAD_FEC_RXD0__FEC_RDATA_0,
+	MX6SL_PAD_FEC_RXD1__FEC_RDATA_1,
+	MX6SL_PAD_FEC_TX_EN__FEC_TX_EN,
+	MX6SL_PAD_FEC_TXD0__FEC_TDATA_0,
+	MX6SL_PAD_FEC_TXD1__FEC_TDATA_1,
+	MX6SL_PAD_FEC_TX_CLK__GPIO_4_21, /* Phy power enable */
+
+	/* I2C */
+	MX6SL_PAD_I2C1_SCL__I2C1_SCL,
+	MX6SL_PAD_I2C1_SDA__I2C1_SDA,
+	MX6SL_PAD_I2C2_SCL__I2C2_SCL,
+	MX6SL_PAD_I2C2_SDA__I2C2_SDA,
+
+	/* ECSPI1 */
+	MX6SL_PAD_ECSPI1_MISO__ECSPI1_MISO,
+	MX6SL_PAD_ECSPI1_MOSI__ECSPI1_MOSI,
+	MX6SL_PAD_ECSPI1_SCLK__ECSPI1_SCLK,
+	MX6SL_PAD_ECSPI1_SS0__ECSPI1_SS0,
+	MX6SL_PAD_ECSPI1_SS0__GPIO_4_11,	/* SS0 */
+
+	/* LCD */
+	MX6SL_PAD_LCD_CLK__LCDIF_CLK,
+	MX6SL_PAD_LCD_ENABLE__LCDIF_ENABLE,
+	MX6SL_PAD_LCD_HSYNC__LCDIF_HSYNC,
+	MX6SL_PAD_LCD_VSYNC__LCDIF_VSYNC,
+	MX6SL_PAD_LCD_RESET__LCDIF_RESET,
+	MX6SL_PAD_LCD_DAT0__LCDIF_DAT_0,
+	MX6SL_PAD_LCD_DAT1__LCDIF_DAT_1,
+	MX6SL_PAD_LCD_DAT2__LCDIF_DAT_2,
+	MX6SL_PAD_LCD_DAT3__LCDIF_DAT_3,
+	MX6SL_PAD_LCD_DAT4__LCDIF_DAT_4,
+	MX6SL_PAD_LCD_DAT5__LCDIF_DAT_5,
+	MX6SL_PAD_LCD_DAT6__LCDIF_DAT_6,
+	MX6SL_PAD_LCD_DAT7__LCDIF_DAT_7,
+	MX6SL_PAD_LCD_DAT8__LCDIF_DAT_8,
+	MX6SL_PAD_LCD_DAT9__LCDIF_DAT_9,
+	MX6SL_PAD_LCD_DAT10__LCDIF_DAT_10,
+	MX6SL_PAD_LCD_DAT11__LCDIF_DAT_11,
+	MX6SL_PAD_LCD_DAT12__LCDIF_DAT_12,
+	MX6SL_PAD_LCD_DAT13__LCDIF_DAT_13,
+	MX6SL_PAD_LCD_DAT14__LCDIF_DAT_14,
+	MX6SL_PAD_LCD_DAT15__LCDIF_DAT_15,
+	MX6SL_PAD_LCD_DAT16__LCDIF_DAT_16,
+	MX6SL_PAD_LCD_DAT17__LCDIF_DAT_17,
+	MX6SL_PAD_LCD_DAT18__LCDIF_DAT_18,
+	MX6SL_PAD_LCD_DAT19__LCDIF_DAT_19,
+	MX6SL_PAD_LCD_DAT20__LCDIF_DAT_20,
+	MX6SL_PAD_LCD_DAT21__LCDIF_DAT_21,
+	MX6SL_PAD_LCD_DAT22__LCDIF_DAT_22,
+	MX6SL_PAD_LCD_DAT23__LCDIF_DAT_23,
+	/* LCD brightness */
+	MX6SL_PAD_PWM1__PWM1_PWMO,
+	/* LCD power on */
+	MX6SL_PAD_KEY_ROW5__GPIO_4_3,
+
+	/* keypad on E-Ink add-on board */
+	MX6SL_PAD_KEY_COL0__KPP_COL_0,
+	MX6SL_PAD_KEY_COL1__KPP_COL_1,
+	MX6SL_PAD_KEY_COL2__KPP_COL_2,
+	MX6SL_PAD_KEY_COL3__KPP_COL_3,
+	MX6SL_PAD_KEY_ROW0__KPP_ROW_0,
+	MX6SL_PAD_KEY_ROW1__KPP_ROW_1,
+	MX6SL_PAD_KEY_ROW2__KPP_ROW_2,
+	MX6SL_PAD_KEY_ROW3__KPP_ROW_3,
+
+	/* WDOG */
+	MX6SL_PAD_WDOG_B__WDOG1_WDOG_B,
+};
+
+static iomux_v3_cfg_t mx6sl_brd_epdc_enable_pads[] = {
+	/* EPDC */
+	MX6SL_PAD_EPDC_D0__EPDC_SDDO_0,
+	MX6SL_PAD_EPDC_D1__EPDC_SDDO_1,
+	MX6SL_PAD_EPDC_D2__EPDC_SDDO_2,
+	MX6SL_PAD_EPDC_D3__EPDC_SDDO_3,
+	MX6SL_PAD_EPDC_D4__EPDC_SDDO_4,
+	MX6SL_PAD_EPDC_D5__EPDC_SDDO_5,
+	MX6SL_PAD_EPDC_D6__EPDC_SDDO_6,
+	MX6SL_PAD_EPDC_D7__EPDC_SDDO_7,
+	MX6SL_PAD_EPDC_D8__EPDC_SDDO_8,
+	MX6SL_PAD_EPDC_D9__EPDC_SDDO_9,
+	MX6SL_PAD_EPDC_D10__EPDC_SDDO_10,
+	MX6SL_PAD_EPDC_D11__EPDC_SDDO_11,
+	MX6SL_PAD_EPDC_D12__EPDC_SDDO_12,
+	MX6SL_PAD_EPDC_D13__EPDC_SDDO_13,
+	MX6SL_PAD_EPDC_D14__EPDC_SDDO_14,
+	MX6SL_PAD_EPDC_D15__EPDC_SDDO_15,
+
+	MX6SL_PAD_EPDC_GDCLK__EPDC_GDCLK,
+	MX6SL_PAD_EPDC_GDSP__EPDC_GDSP,
+	MX6SL_PAD_EPDC_GDOE__EPDC_GDOE,
+	MX6SL_PAD_EPDC_GDRL__EPDC_GDRL,
+	MX6SL_PAD_EPDC_SDCLK__EPDC_SDCLK,
+	MX6SL_PAD_EPDC_SDOE__EPDC_SDOE,
+	MX6SL_PAD_EPDC_SDLE__EPDC_SDLE,
+	MX6SL_PAD_EPDC_SDSHR__EPDC_SDSHR,
+	MX6SL_PAD_EPDC_BDR0__EPDC_BDR_0,
+	MX6SL_PAD_EPDC_SDCE0__EPDC_SDCE_0,
+	MX6SL_PAD_EPDC_SDCE1__EPDC_SDCE_1,
+	MX6SL_PAD_EPDC_SDCE2__EPDC_SDCE_2,
+
+	/* EPD PMIC (Maxim 17135) pins */
+	MX6SL_PAD_EPDC_VCOM0__GPIO_2_3,
+	MX6SL_PAD_EPDC_PWRSTAT__GPIO_2_13,
+	MX6SL_PAD_EPDC_PWRCTRL0__GPIO_2_7,
+	MX6SL_PAD_EPDC_PWRWAKEUP__GPIO_2_14,
+};
+
+static iomux_v3_cfg_t mx6sl_brd_epdc_disable_pads[] = {
+	/* EPDC */
+	MX6SL_PAD_EPDC_D0__GPIO_1_7,
+	MX6SL_PAD_EPDC_D1__GPIO_1_8,
+	MX6SL_PAD_EPDC_D2__GPIO_1_9,
+	MX6SL_PAD_EPDC_D3__GPIO_1_10,
+	MX6SL_PAD_EPDC_D4__GPIO_1_11,
+	MX6SL_PAD_EPDC_D5__GPIO_1_12,
+	MX6SL_PAD_EPDC_D6__GPIO_1_13,
+	MX6SL_PAD_EPDC_D7__GPIO_1_14,
+	MX6SL_PAD_EPDC_D8__GPIO_1_15,
+	MX6SL_PAD_EPDC_D9__GPIO_1_16,
+	MX6SL_PAD_EPDC_D10__GPIO_1_17,
+	MX6SL_PAD_EPDC_D11__GPIO_1_18,
+	MX6SL_PAD_EPDC_D12__GPIO_1_19,
+	MX6SL_PAD_EPDC_D13__GPIO_1_20,
+	MX6SL_PAD_EPDC_D14__GPIO_1_21,
+	MX6SL_PAD_EPDC_D15__GPIO_1_22,
+
+	MX6SL_PAD_EPDC_GDCLK__GPIO_1_31,
+	MX6SL_PAD_EPDC_GDSP__GPIO_2_2,
+	MX6SL_PAD_EPDC_GDOE__GPIO_2_0,
+	MX6SL_PAD_EPDC_GDRL__GPIO_2_1,
+	MX6SL_PAD_EPDC_SDCLK__GPIO_1_23,
+	MX6SL_PAD_EPDC_SDOE__GPIO_1_25,
+	MX6SL_PAD_EPDC_SDLE__GPIO_1_24,
+	MX6SL_PAD_EPDC_SDSHR__GPIO_1_26,
+	MX6SL_PAD_EPDC_BDR0__GPIO_2_5,
+	MX6SL_PAD_EPDC_SDCE0__GPIO_1_27,
+	MX6SL_PAD_EPDC_SDCE1__GPIO_1_28,
+	MX6SL_PAD_EPDC_SDCE2__GPIO_1_29,
+
+	/* EPD PMIC (Maxim 17135) pins */
+	MX6SL_PAD_EPDC_VCOM0__GPIO_2_3,
+	MX6SL_PAD_EPDC_PWRSTAT__GPIO_2_13,
+	MX6SL_PAD_EPDC_PWRCTRL0__GPIO_2_7,
+	MX6SL_PAD_EPDC_PWRWAKEUP__GPIO_2_14,
+};
+
+static iomux_v3_cfg_t mx6sl_brd_spdc_enable_pads[] = {
+	/* SPDC data*/
+	MX6SL_PAD_EPDC_D0__TCON_E_DATA_0,
+	MX6SL_PAD_EPDC_D1__TCON_E_DATA_1,
+	MX6SL_PAD_EPDC_D2__TCON_E_DATA_2,
+	MX6SL_PAD_EPDC_D3__TCON_E_DATA_3,
+	MX6SL_PAD_EPDC_D4__TCON_E_DATA_4,
+	MX6SL_PAD_EPDC_D5__TCON_E_DATA_5,
+	MX6SL_PAD_EPDC_D6__TCON_E_DATA_6,
+	MX6SL_PAD_EPDC_D7__TCON_E_DATA_7,
+
+	MX6SL_PAD_EPDC_GDOE__TCON_YOEL,   /* AUO panel SIPIX_YOE */
+
+	MX6SL_PAD_EPDC_D9__TCON_E_DATA_9, /* AUO panel SIPIX_PWR_RDY*/
+
+	MX6SL_PAD_EPDC_SDCE2__TCON_YDIOUR, /* AUO panel SIPIX_YDIO */
+	MX6SL_PAD_EPDC_SDCE3__TCON_YDIODR, /* AUO panel SIPIX_YDIO */
+	MX6SL_PAD_EPDC_GDRL__TCON_YDIOUL,  /* AUO panel SIPIX_YDIO */
+	MX6SL_PAD_EPDC_GDSP__TCON_YDIODL,  /* SIPIX_YDIO/SIPIX2_SPV */
+
+	MX6SL_PAD_EPDC_GDCLK__TCON_YCKL,  /* SIPIX_YCLK/SIPIX2_CKV */
+
+	MX6SL_PAD_EPDC_SDSHR__TCON_XDIOR, /* AUO panel SIPIX_XDIO */
+	MX6SL_PAD_EPDC_SDOE__TCON_XDIOL,  /* SIPIX_XDIO/SIPIX2_OE */
+
+	MX6SL_PAD_EPDC_SDLE__TCON_LD,     /* SIPIX_LD/SIPIX2_LE */
+
+	MX6SL_PAD_EPDC_SDCE1__TCON_YOER,  /* AUO panel SIPIX_SOE */
+	MX6SL_PAD_EPDC_BDR0__TCON_RL,     /* AUO panel SIPIX_SOE */
+	MX6SL_PAD_EPDC_BDR1__TCON_UD,     /* AUO panel SIPIX_SOE */
+
+	MX6SL_PAD_EPDC_SDCLK__TCON_CL,    /* SIPIX_XCLK/SIPIX2_CL */
+
+	MX6SL_PAD_EPDC_D10__TCON_E_DATA_10, /* AUO panel SIPIX_SHD_N */
+
+	MX6SL_PAD_EPDC_SDCE0__TCON_YCKR,  /* LG panel SIPIX2_CE */
+
+	/* EPD PMIC (Maxim 17135) pins */
+	MX6SL_PAD_EPDC_VCOM0__GPIO_2_3, /* PMICA_CEN */
+	MX6SL_PAD_EPDC_PWRSTAT__GPIO_2_13,
+	MX6SL_PAD_EPDC_PWRCTRL0__GPIO_2_7,
+	MX6SL_PAD_EPDC_PWRWAKEUP__GPIO_2_14,
+};
+
+static iomux_v3_cfg_t mx6sl_brd_spdc_disable_pads[] = {
+	MX6SL_PAD_EPDC_D0__GPIO_1_7,
+	MX6SL_PAD_EPDC_D1__GPIO_1_8,
+	MX6SL_PAD_EPDC_D2__GPIO_1_9,
+	MX6SL_PAD_EPDC_D3__GPIO_1_10,
+	MX6SL_PAD_EPDC_D4__GPIO_1_11,
+	MX6SL_PAD_EPDC_D5__GPIO_1_12,
+	MX6SL_PAD_EPDC_D6__GPIO_1_13,
+	MX6SL_PAD_EPDC_D7__GPIO_1_14,
+
+	MX6SL_PAD_EPDC_SDCE1__GPIO_1_28,
+	MX6SL_PAD_EPDC_GDOE__GPIO_2_0,
+	MX6SL_PAD_EPDC_D9__GPIO_1_16,
+	MX6SL_PAD_EPDC_SDCE2__GPIO_1_29,
+	MX6SL_PAD_EPDC_SDCE3__GPIO_1_30,
+	MX6SL_PAD_EPDC_GDRL__GPIO_2_1,
+	MX6SL_PAD_EPDC_GDSP__GPIO_2_2,
+	MX6SL_PAD_EPDC_GDCLK__GPIO_1_31,
+	MX6SL_PAD_EPDC_SDSHR__GPIO_1_26,
+	MX6SL_PAD_EPDC_SDOE__GPIO_1_25,
+	MX6SL_PAD_EPDC_SDLE__GPIO_1_24,
+	MX6SL_PAD_EPDC_SDCE1__GPIO_1_28,
+	MX6SL_PAD_EPDC_BDR0__GPIO_2_5,
+	MX6SL_PAD_EPDC_BDR1__GPIO_2_6,
+	MX6SL_PAD_EPDC_SDCLK__GPIO_1_23,
+	MX6SL_PAD_EPDC_D10__GPIO_1_17,
+	MX6SL_PAD_EPDC_SDCE0__GPIO_1_27,
+
+	/* EPD PMIC (Maxim 17135) pins */
+	MX6SL_PAD_EPDC_VCOM0__GPIO_2_3,
+	MX6SL_PAD_EPDC_PWRSTAT__GPIO_2_13,
+	MX6SL_PAD_EPDC_PWRCTRL0__GPIO_2_7,
+	MX6SL_PAD_EPDC_PWRWAKEUP__GPIO_2_14,
+};
+
+static iomux_v3_cfg_t mx6sl_brd_elan_pads[] = {
+	MX6SL_PAD_EPDC_PWRCTRL3__GPIO_2_10,	/* INT */
+	MX6SL_PAD_EPDC_PWRCTRL2__GPIO_2_9,	/* CE */
+	MX6SL_PAD_KEY_COL6__GPIO_4_4,		/* RST */
+};
+
+#define MX6SL_USDHC_8BIT_PAD_SETTING(id, speed)	\
+mx6sl_sd##id##_##speed##mhz[] = {		\
+	MX6SL_PAD_SD##id##_CLK__USDHC##id##_CLK_##speed##MHZ,	\
+	MX6SL_PAD_SD##id##_CMD__USDHC##id##_CMD_##speed##MHZ,	\
+	MX6SL_PAD_SD##id##_DAT0__USDHC##id##_DAT0_##speed##MHZ,	\
+	MX6SL_PAD_SD##id##_DAT1__USDHC##id##_DAT1_##speed##MHZ,	\
+	MX6SL_PAD_SD##id##_DAT2__USDHC##id##_DAT2_##speed##MHZ,	\
+	MX6SL_PAD_SD##id##_DAT3__USDHC##id##_DAT3_##speed##MHZ,	\
+	MX6SL_PAD_SD##id##_DAT4__USDHC##id##_DAT4_##speed##MHZ,	\
+	MX6SL_PAD_SD##id##_DAT5__USDHC##id##_DAT5_##speed##MHZ,	\
+	MX6SL_PAD_SD##id##_DAT6__USDHC##id##_DAT6_##speed##MHZ,	\
+	MX6SL_PAD_SD##id##_DAT7__USDHC##id##_DAT7_##speed##MHZ,	\
+}
+#define MX6SL_USDHC_4BIT_PAD_SETTING(id, speed)	\
+mx6sl_sd##id##_##speed##mhz[] = {		\
+	MX6SL_PAD_SD##id##_CLK__USDHC##id##_CLK_##speed##MHZ,	\
+	MX6SL_PAD_SD##id##_CMD__USDHC##id##_CMD_##speed##MHZ,	\
+	MX6SL_PAD_SD##id##_DAT0__USDHC##id##_DAT0_##speed##MHZ,	\
+	MX6SL_PAD_SD##id##_DAT1__USDHC##id##_DAT1_##speed##MHZ,	\
+	MX6SL_PAD_SD##id##_DAT2__USDHC##id##_DAT2_##speed##MHZ,	\
+	MX6SL_PAD_SD##id##_DAT3__USDHC##id##_DAT3_##speed##MHZ,	\
+}
+
+
+static iomux_v3_cfg_t MX6SL_USDHC_8BIT_PAD_SETTING(1, 50);
+static iomux_v3_cfg_t MX6SL_USDHC_8BIT_PAD_SETTING(1, 100);
+static iomux_v3_cfg_t MX6SL_USDHC_8BIT_PAD_SETTING(1, 200);
+static iomux_v3_cfg_t MX6SL_USDHC_4BIT_PAD_SETTING(2, 50);
+static iomux_v3_cfg_t MX6SL_USDHC_4BIT_PAD_SETTING(2, 100);
+static iomux_v3_cfg_t MX6SL_USDHC_4BIT_PAD_SETTING(2, 200);
+static iomux_v3_cfg_t MX6SL_USDHC_4BIT_PAD_SETTING(3, 50);
+static iomux_v3_cfg_t MX6SL_USDHC_4BIT_PAD_SETTING(3, 100);
+static iomux_v3_cfg_t MX6SL_USDHC_4BIT_PAD_SETTING(3, 200);
+
+#endif
diff --git a/arch/arm/mach-mx6/board-mx6sl_evk.c b/arch/arm/mach-mx6/board-mx6sl_evk.c
new file mode 100644
index 0000000..3f42a0e
--- /dev/null
+++ b/arch/arm/mach-mx6/board-mx6sl_evk.c
@@ -0,0 +1,1300 @@
+/*
+ * Copyright (C) 2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/init.h>
+#include <linux/input.h>
+#include <linux/nodemask.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <linux/fsl_devices.h>
+#include <linux/smsc911x.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/flash.h>
+#include <linux/i2c.h>
+#include <linux/i2c/pca953x.h>
+#include <linux/ata.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+#include <linux/pmic_external.h>
+#include <linux/pmic_status.h>
+#include <linux/mxcfb.h>
+#include <linux/pwm_backlight.h>
+#include <linux/fec.h>
+#include <linux/memblock.h>
+#include <linux/gpio.h>
+#include <linux/etherdevice.h>
+#include <linux/regulator/anatop-regulator.h>
+#include <linux/regulator/consumer.h>
+#include <linux/regulator/machine.h>
+#include <linux/regulator/fixed.h>
+#include <linux/mfd/max17135.h>
+#include <sound/wm8962.h>
+#include <sound/pcm.h>
+
+#include <mach/common.h>
+#include <mach/hardware.h>
+#include <mach/mxc_dvfs.h>
+#include <mach/memory.h>
+#include <mach/iomux-mx6sl.h>
+#include <mach/imx-uart.h>
+#include <mach/viv_gpu.h>
+
+#include <asm/irq.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/time.h>
+
+#include "usb.h"
+#include "devices-imx6q.h"
+#include "crm_regs.h"
+#include "cpu_op-mx6.h"
+#include "board-mx6sl_common.h"
+
+
+static int spdc_sel;
+static int max17135_regulator_init(struct max17135 *max17135);
+struct clk *extern_audio_root;
+
+extern char *gp_reg_id;
+extern char *soc_reg_id;
+extern char *pu_reg_id;
+extern int __init mx6sl_evk_init_pfuze100(u32 int_gpio);
+
+enum sd_pad_mode {
+	SD_PAD_MODE_LOW_SPEED,
+	SD_PAD_MODE_MED_SPEED,
+	SD_PAD_MODE_HIGH_SPEED,
+};
+
+static int plt_sd_pad_change(unsigned int index, int clock)
+{
+	/* LOW speed is the default state of SD pads */
+	static enum sd_pad_mode pad_mode = SD_PAD_MODE_LOW_SPEED;
+
+	iomux_v3_cfg_t *sd_pads_200mhz = NULL;
+	iomux_v3_cfg_t *sd_pads_100mhz = NULL;
+	iomux_v3_cfg_t *sd_pads_50mhz = NULL;
+
+	u32 sd_pads_200mhz_cnt;
+	u32 sd_pads_100mhz_cnt;
+	u32 sd_pads_50mhz_cnt;
+
+	switch (index) {
+	case 0:
+		sd_pads_200mhz = mx6sl_sd1_200mhz;
+		sd_pads_100mhz = mx6sl_sd1_100mhz;
+		sd_pads_50mhz = mx6sl_sd1_50mhz;
+
+		sd_pads_200mhz_cnt = ARRAY_SIZE(mx6sl_sd1_200mhz);
+		sd_pads_100mhz_cnt = ARRAY_SIZE(mx6sl_sd1_100mhz);
+		sd_pads_50mhz_cnt = ARRAY_SIZE(mx6sl_sd1_50mhz);
+		break;
+	case 1:
+		sd_pads_200mhz = mx6sl_sd2_200mhz;
+		sd_pads_100mhz = mx6sl_sd2_100mhz;
+		sd_pads_50mhz = mx6sl_sd2_50mhz;
+
+		sd_pads_200mhz_cnt = ARRAY_SIZE(mx6sl_sd2_200mhz);
+		sd_pads_100mhz_cnt = ARRAY_SIZE(mx6sl_sd2_100mhz);
+		sd_pads_50mhz_cnt = ARRAY_SIZE(mx6sl_sd2_50mhz);
+		break;
+	case 2:
+		sd_pads_200mhz = mx6sl_sd3_200mhz;
+		sd_pads_100mhz = mx6sl_sd3_100mhz;
+		sd_pads_50mhz = mx6sl_sd3_50mhz;
+
+		sd_pads_200mhz_cnt = ARRAY_SIZE(mx6sl_sd3_200mhz);
+		sd_pads_100mhz_cnt = ARRAY_SIZE(mx6sl_sd3_100mhz);
+		sd_pads_50mhz_cnt = ARRAY_SIZE(mx6sl_sd3_50mhz);
+		break;
+	default:
+		printk(KERN_ERR "no such SD host controller index %d\n", index);
+		return -EINVAL;
+	}
+
+	if (clock > 100000000) {
+		if (pad_mode == SD_PAD_MODE_HIGH_SPEED)
+			return 0;
+		BUG_ON(!sd_pads_200mhz);
+		pad_mode = SD_PAD_MODE_HIGH_SPEED;
+		return mxc_iomux_v3_setup_multiple_pads(sd_pads_200mhz,
+							sd_pads_200mhz_cnt);
+	} else if (clock > 52000000) {
+		if (pad_mode == SD_PAD_MODE_MED_SPEED)
+			return 0;
+		BUG_ON(!sd_pads_100mhz);
+		pad_mode = SD_PAD_MODE_MED_SPEED;
+		return mxc_iomux_v3_setup_multiple_pads(sd_pads_100mhz,
+							sd_pads_100mhz_cnt);
+	} else {
+		if (pad_mode == SD_PAD_MODE_LOW_SPEED)
+			return 0;
+		BUG_ON(!sd_pads_50mhz);
+		pad_mode = SD_PAD_MODE_LOW_SPEED;
+		return mxc_iomux_v3_setup_multiple_pads(sd_pads_50mhz,
+							sd_pads_50mhz_cnt);
+	}
+}
+
+static const struct esdhc_platform_data mx6_evk_sd1_data __initconst = {
+	.cd_gpio		= MX6_BRD_SD1_CD,
+	.wp_gpio		= MX6_BRD_SD1_WP,
+	.support_8bit		= 1,
+	.support_18v		= 1,
+	.keep_power_at_suspend	= 1,
+	.delay_line		= 0,
+	.platform_pad_change = plt_sd_pad_change,
+};
+
+static const struct esdhc_platform_data mx6_evk_sd2_data __initconst = {
+	.cd_gpio		= MX6_BRD_SD2_CD,
+	.wp_gpio		= MX6_BRD_SD2_WP,
+	.keep_power_at_suspend	= 1,
+	.delay_line		= 0,
+	.support_18v		= 1,
+	.platform_pad_change = plt_sd_pad_change,
+};
+
+static const struct esdhc_platform_data mx6_evk_sd3_data __initconst = {
+	.cd_gpio		= MX6_BRD_SD3_CD,
+	.wp_gpio		= -1,
+	.keep_power_at_suspend	= 1,
+	.delay_line		= 0,
+	.support_18v		= 1,
+	.platform_pad_change = plt_sd_pad_change,
+};
+
+#define mV_to_uV(mV) (mV * 1000)
+#define uV_to_mV(uV) (uV / 1000)
+#define V_to_uV(V) (mV_to_uV(V * 1000))
+#define uV_to_V(uV) (uV_to_mV(uV) / 1000)
+
+static struct regulator_consumer_supply evk_vmmc_consumers[] = {
+	REGULATOR_SUPPLY("vmmc", "sdhci-esdhc-imx.0"),
+	REGULATOR_SUPPLY("vmmc", "sdhci-esdhc-imx.1"),
+	REGULATOR_SUPPLY("vmmc", "sdhci-esdhc-imx.2"),
+};
+
+static struct regulator_init_data evk_vmmc_init = {
+	.num_consumer_supplies = ARRAY_SIZE(evk_vmmc_consumers),
+	.consumer_supplies = evk_vmmc_consumers,
+};
+
+static struct fixed_voltage_config evk_vmmc_reg_config = {
+	.supply_name	= "vmmc",
+	.microvolts	= 3300000,
+	.gpio		= -1,
+	.init_data	= &evk_vmmc_init,
+};
+
+static struct platform_device evk_vmmc_reg_devices = {
+	.name		= "reg-fixed-voltage",
+	.id		= 0,
+	.dev		= {
+		.platform_data = &evk_vmmc_reg_config,
+	},
+};
+
+static struct regulator_consumer_supply display_consumers[] = {
+	{
+		/* MAX17135 */
+		.supply = "DISPLAY",
+	},
+};
+
+static struct regulator_consumer_supply vcom_consumers[] = {
+	{
+		/* MAX17135 */
+		.supply = "VCOM",
+	},
+};
+
+static struct regulator_consumer_supply v3p3_consumers[] = {
+	{
+		/* MAX17135 */
+		.supply = "V3P3",
+	},
+};
+
+static struct regulator_init_data max17135_init_data[] = {
+	{
+		.constraints = {
+			.name = "DISPLAY",
+			.valid_ops_mask =  REGULATOR_CHANGE_STATUS,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(display_consumers),
+		.consumer_supplies = display_consumers,
+	}, {
+		.constraints = {
+			.name = "GVDD",
+			.min_uV = V_to_uV(20),
+			.max_uV = V_to_uV(20),
+		},
+	}, {
+		.constraints = {
+			.name = "GVEE",
+			.min_uV = V_to_uV(-22),
+			.max_uV = V_to_uV(-22),
+		},
+	}, {
+		.constraints = {
+			.name = "HVINN",
+			.min_uV = V_to_uV(-22),
+			.max_uV = V_to_uV(-22),
+		},
+	}, {
+		.constraints = {
+			.name = "HVINP",
+			.min_uV = V_to_uV(20),
+			.max_uV = V_to_uV(20),
+		},
+	}, {
+		.constraints = {
+			.name = "VCOM",
+			.min_uV = mV_to_uV(-4325),
+			.max_uV = mV_to_uV(-500),
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE |
+			REGULATOR_CHANGE_STATUS,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(vcom_consumers),
+		.consumer_supplies = vcom_consumers,
+	}, {
+		.constraints = {
+			.name = "VNEG",
+			.min_uV = V_to_uV(-15),
+			.max_uV = V_to_uV(-15),
+		},
+	}, {
+		.constraints = {
+			.name = "VPOS",
+			.min_uV = V_to_uV(15),
+			.max_uV = V_to_uV(15),
+		},
+	}, {
+		.constraints = {
+			.name = "V3P3",
+			.valid_ops_mask =  REGULATOR_CHANGE_STATUS,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(v3p3_consumers),
+		.consumer_supplies = v3p3_consumers,
+	},
+};
+
+static const struct anatop_thermal_platform_data
+	mx6sl_anatop_thermal_data __initconst = {
+			.name = "anatop_thermal",
+	};
+
+static struct platform_device max17135_sensor_device = {
+	.name = "max17135_sensor",
+	.id = 0,
+};
+
+static struct max17135_platform_data max17135_pdata __initdata = {
+	.vneg_pwrup = 1,
+	.gvee_pwrup = 1,
+	.vpos_pwrup = 2,
+	.gvdd_pwrup = 1,
+	.gvdd_pwrdn = 1,
+	.vpos_pwrdn = 2,
+	.gvee_pwrdn = 1,
+	.vneg_pwrdn = 1,
+	.gpio_pmic_pwrgood = MX6SL_BRD_EPDC_PWRSTAT,
+	.gpio_pmic_vcom_ctrl = MX6SL_BRD_EPDC_VCOM,
+	.gpio_pmic_wakeup = MX6SL_BRD_EPDC_PMIC_WAKE,
+	.gpio_pmic_v3p3 = MX6SL_BRD_EPDC_PWRCTRL0,
+	.gpio_pmic_intr = MX6SL_BRD_EPDC_PMIC_INT,
+	.regulator_init = max17135_init_data,
+	.init = max17135_regulator_init,
+};
+
+static int __init max17135_regulator_init(struct max17135 *max17135)
+{
+	struct max17135_platform_data *pdata = &max17135_pdata;
+	int i, ret;
+
+	max17135->gvee_pwrup = pdata->gvee_pwrup;
+	max17135->vneg_pwrup = pdata->vneg_pwrup;
+	max17135->vpos_pwrup = pdata->vpos_pwrup;
+	max17135->gvdd_pwrup = pdata->gvdd_pwrup;
+	max17135->gvdd_pwrdn = pdata->gvdd_pwrdn;
+	max17135->vpos_pwrdn = pdata->vpos_pwrdn;
+	max17135->vneg_pwrdn = pdata->vneg_pwrdn;
+	max17135->gvee_pwrdn = pdata->gvee_pwrdn;
+
+	max17135->max_wait = pdata->vpos_pwrup + pdata->vneg_pwrup +
+		pdata->gvdd_pwrup + pdata->gvee_pwrup;
+
+	max17135->gpio_pmic_pwrgood = pdata->gpio_pmic_pwrgood;
+	max17135->gpio_pmic_vcom_ctrl = pdata->gpio_pmic_vcom_ctrl;
+	max17135->gpio_pmic_wakeup = pdata->gpio_pmic_wakeup;
+	max17135->gpio_pmic_v3p3 = pdata->gpio_pmic_v3p3;
+	max17135->gpio_pmic_intr = pdata->gpio_pmic_intr;
+
+	gpio_request(max17135->gpio_pmic_wakeup, "epdc-pmic-wake");
+	gpio_direction_output(max17135->gpio_pmic_wakeup, 0);
+
+	gpio_request(max17135->gpio_pmic_vcom_ctrl, "epdc-vcom");
+	gpio_direction_output(max17135->gpio_pmic_vcom_ctrl, 0);
+
+	gpio_request(max17135->gpio_pmic_v3p3, "epdc-v3p3");
+	gpio_direction_output(max17135->gpio_pmic_v3p3, 0);
+
+	gpio_request(max17135->gpio_pmic_intr, "epdc-pmic-int");
+	gpio_direction_input(max17135->gpio_pmic_intr);
+
+	gpio_request(max17135->gpio_pmic_pwrgood, "epdc-pwrstat");
+	gpio_direction_input(max17135->gpio_pmic_pwrgood);
+
+	max17135->vcom_setup = false;
+	max17135->init_done = false;
+
+	for (i = 0; i < MAX17135_NUM_REGULATORS; i++) {
+		ret = max17135_register_regulator(max17135, i,
+			&pdata->regulator_init[i]);
+		if (ret != 0) {
+			printk(KERN_ERR"max17135 regulator init failed: %d\n",
+				ret);
+			return ret;
+		}
+	}
+
+	/*
+	 * TODO: We cannot enable full constraints for now, since
+	 * it results in the PFUZE regulators being disabled
+	 * at the end of boot, which disables critical regulators.
+	 */
+	/*regulator_has_full_constraints();*/
+
+	return 0;
+}
+
+static int mx6_evk_spi_cs[] = {
+	MX6_BRD_ECSPI1_CS0,
+};
+
+static const struct spi_imx_master mx6_evk_spi_data __initconst = {
+	.chipselect     = mx6_evk_spi_cs,
+	.num_chipselect = ARRAY_SIZE(mx6_evk_spi_cs),
+};
+
+#if defined(CONFIG_MTD_M25P80) || defined(CONFIG_MTD_M25P80_MODULE)
+static struct mtd_partition m25p32_partitions[] = {
+	{
+		.name	= "bootloader",
+		.offset	= 0,
+		.size	= 0x00100000,
+	}, {
+		.name	= "kernel",
+		.offset	= MTDPART_OFS_APPEND,
+		.size	= MTDPART_SIZ_FULL,
+	},
+};
+
+static struct flash_platform_data m25p32_spi_flash_data = {
+	.name		= "m25p32",
+	.parts		= m25p32_partitions,
+	.nr_parts	= ARRAY_SIZE(m25p32_partitions),
+	.type		= "m25p32",
+};
+
+static struct spi_board_info m25p32_spi0_board_info[] __initdata = {
+	{
+	/* The modalias must be the same as spi device driver name */
+	.modalias	= "m25p80",
+	.max_speed_hz	= 20000000,
+	.bus_num	= 0,
+	.chip_select	= 0,
+	.platform_data	= &m25p32_spi_flash_data,
+	},
+};
+#endif
+
+static void spi_device_init(void)
+{
+#if defined(CONFIG_MTD_M25P80) || defined(CONFIG_MTD_M25P80_MODULE)
+	spi_register_board_info(m25p32_spi0_board_info,
+				ARRAY_SIZE(m25p32_spi0_board_info));
+#endif
+}
+
+static struct imx_ssi_platform_data mx6_sabresd_ssi_pdata = {
+	.flags = IMX_SSI_DMA | IMX_SSI_SYN,
+};
+
+static struct mxc_audio_platform_data wm8962_data;
+
+static struct platform_device mx6_sabresd_audio_wm8962_device = {
+	.name = "imx-wm8962",
+};
+
+static struct wm8962_pdata wm8962_config_data = {
+
+};
+
+static int wm8962_clk_enable(int enable)
+{
+	if (enable)
+		clk_enable(extern_audio_root);
+	else
+		clk_disable(extern_audio_root);
+
+	return 0;
+}
+
+static int mxc_wm8962_init(void)
+{
+	struct clk *pll4;
+	int rate;
+
+	extern_audio_root = clk_get(NULL, "extern_audio_clk");
+	if (IS_ERR(extern_audio_root)) {
+		pr_err("can't get extern_audio_root clock.\n");
+		return PTR_ERR(extern_audio_root);
+	}
+
+	pll4 = clk_get(NULL, "pll4");
+	if (IS_ERR(pll4)) {
+		pr_err("can't get pll4 clock.\n");
+		return PTR_ERR(pll4);
+	}
+
+	clk_set_parent(extern_audio_root, pll4);
+
+	rate = clk_round_rate(extern_audio_root, 26000000);
+	clk_set_rate(extern_audio_root, rate);
+
+	wm8962_data.sysclk = rate;
+
+	return 0;
+}
+
+static struct mxc_audio_platform_data wm8962_data = {
+	.ssi_num = 1,
+	.src_port = 2,
+	.ext_port = 3,
+	.hp_gpio = MX6_BRD_HEADPHONE_DET,
+	.hp_active_low = 1,
+	.mic_gpio = -1,
+	.mic_active_low = 1,
+	.init = mxc_wm8962_init,
+	.clock_enable = wm8962_clk_enable,
+};
+
+static struct regulator_consumer_supply sabresd_vwm8962_consumers[] = {
+	REGULATOR_SUPPLY("SPKVDD1", "1-001a"),
+	REGULATOR_SUPPLY("SPKVDD2", "1-001a"),
+};
+
+static struct regulator_init_data sabresd_vwm8962_init = {
+	.constraints = {
+		.name = "SPKVDD",
+		.valid_ops_mask =  REGULATOR_CHANGE_STATUS,
+		.boot_on = 1,
+	},
+	.num_consumer_supplies = ARRAY_SIZE(sabresd_vwm8962_consumers),
+	.consumer_supplies = sabresd_vwm8962_consumers,
+};
+
+static struct fixed_voltage_config sabresd_vwm8962_reg_config = {
+	.supply_name	= "SPKVDD",
+	.microvolts		= 4325000,
+	.gpio			= -1,
+	.enabled_at_boot = 1,
+	.init_data		= &sabresd_vwm8962_init,
+};
+
+static struct platform_device sabresd_vwm8962_reg_devices = {
+	.name	= "reg-fixed-voltage",
+	.id		= 4,
+	.dev	= {
+		.platform_data = &sabresd_vwm8962_reg_config,
+	},
+};
+
+static int __init imx6q_init_audio(void)
+{
+	platform_device_register(&sabresd_vwm8962_reg_devices);
+	mxc_register_device(&mx6_sabresd_audio_wm8962_device,
+			    &wm8962_data);
+	imx6q_add_imx_ssi(1, &mx6_sabresd_ssi_pdata);
+
+	return 0;
+}
+
+static struct imxi2c_platform_data mx6_evk_i2c0_data = {
+	.bitrate = 100000,
+};
+
+static struct imxi2c_platform_data mx6_evk_i2c1_data = {
+	.bitrate = 100000,
+};
+
+static struct imxi2c_platform_data mx6_evk_i2c2_data = {
+	.bitrate = 400000,
+};
+
+static struct i2c_board_info mxc_i2c0_board_info[] __initdata = {
+	{
+		I2C_BOARD_INFO("max17135", 0x48),
+		.platform_data = &max17135_pdata,
+	}, {
+		I2C_BOARD_INFO("elan-touch", 0x10),
+		.irq = gpio_to_irq(MX6SL_BRD_ELAN_INT),
+	},
+};
+
+static struct i2c_board_info mxc_i2c1_board_info[] __initdata = {
+	{
+		I2C_BOARD_INFO("wm8962", 0x1a),
+		.platform_data = &wm8962_config_data,
+	},
+};
+
+static struct i2c_board_info mxc_i2c2_board_info[] __initdata = {
+	{
+	},
+};
+
+static struct mxc_dvfs_platform_data mx6sl_evk_dvfscore_data = {
+	#ifdef CONFIG_MX6_INTER_LDO_BYPASS
+	.reg_id			= "VDDCORE",
+	#else
+	.reg_id			= "cpu_vddgp",
+	.soc_id			= "cpu_vddsoc",
+	.pu_id			= "cpu_vddvpu",
+	#endif
+	.clk1_id		= "cpu_clk",
+	.clk2_id		= "gpc_dvfs_clk",
+	.gpc_cntr_offset	= MXC_GPC_CNTR_OFFSET,
+	.ccm_cdcr_offset	= MXC_CCM_CDCR_OFFSET,
+	.ccm_cacrr_offset	= MXC_CCM_CACRR_OFFSET,
+	.ccm_cdhipr_offset	= MXC_CCM_CDHIPR_OFFSET,
+	.prediv_mask		= 0x1F800,
+	.prediv_offset		= 11,
+	.prediv_val		= 3,
+	.div3ck_mask		= 0xE0000000,
+	.div3ck_offset		= 29,
+	.div3ck_val		= 2,
+	.emac_val		= 0x08,
+	.upthr_val		= 25,
+	.dnthr_val		= 9,
+	.pncthr_val		= 33,
+	.upcnt_val		= 10,
+	.dncnt_val		= 10,
+	.delay_time		= 80,
+};
+
+static struct viv_gpu_platform_data imx6q_gpu_pdata __initdata = {
+	.reserved_mem_size = SZ_128M,
+};
+
+void __init early_console_setup(unsigned long base, struct clk *clk);
+
+static inline void mx6_evk_init_uart(void)
+{
+	imx6q_add_imx_uart(0, NULL); /* DEBUG UART1 */
+}
+
+static int mx6sl_evk_fec_phy_init(struct phy_device *phydev)
+{
+	int val;
+
+	/* power on FEC phy and reset phy */
+	gpio_request(MX6_BRD_FEC_PWR_EN, "fec-pwr");
+	gpio_direction_output(MX6_BRD_FEC_PWR_EN, 0);
+	/* wait RC ms for hw reset */
+	msleep(1);
+	gpio_direction_output(MX6_BRD_FEC_PWR_EN, 1);
+
+	/* check phy power */
+	val = phy_read(phydev, 0x0);
+	if (val & BMCR_PDOWN)
+		phy_write(phydev, 0x0, (val & ~BMCR_PDOWN));
+
+	return 0;
+}
+
+static struct fec_platform_data fec_data __initdata = {
+	.init = mx6sl_evk_fec_phy_init,
+	.phy = PHY_INTERFACE_MODE_RMII,
+};
+
+static int epdc_get_pins(void)
+{
+	int ret = 0;
+
+	/* Claim GPIOs for EPDC pins - used during power up/down */
+	ret |= gpio_request(MX6SL_BRD_EPDC_SDDO_0, "epdc_d0");
+	ret |= gpio_request(MX6SL_BRD_EPDC_SDDO_1, "epdc_d1");
+	ret |= gpio_request(MX6SL_BRD_EPDC_SDDO_2, "epdc_d2");
+	ret |= gpio_request(MX6SL_BRD_EPDC_SDDO_3, "epdc_d3");
+	ret |= gpio_request(MX6SL_BRD_EPDC_SDDO_4, "epdc_d4");
+	ret |= gpio_request(MX6SL_BRD_EPDC_SDDO_5, "epdc_d5");
+	ret |= gpio_request(MX6SL_BRD_EPDC_SDDO_6, "epdc_d6");
+	ret |= gpio_request(MX6SL_BRD_EPDC_SDDO_7, "epdc_d7");
+	ret |= gpio_request(MX6SL_BRD_EPDC_GDCLK, "epdc_gdclk");
+	ret |= gpio_request(MX6SL_BRD_EPDC_GDSP, "epdc_gdsp");
+	ret |= gpio_request(MX6SL_BRD_EPDC_GDOE, "epdc_gdoe");
+	ret |= gpio_request(MX6SL_BRD_EPDC_GDRL, "epdc_gdrl");
+	ret |= gpio_request(MX6SL_BRD_EPDC_SDCLK, "epdc_sdclk");
+	ret |= gpio_request(MX6SL_BRD_EPDC_SDOE, "epdc_sdoe");
+	ret |= gpio_request(MX6SL_BRD_EPDC_SDLE, "epdc_sdle");
+	ret |= gpio_request(MX6SL_BRD_EPDC_SDSHR, "epdc_sdshr");
+	ret |= gpio_request(MX6SL_BRD_EPDC_BDR0, "epdc_bdr0");
+	ret |= gpio_request(MX6SL_BRD_EPDC_SDCE0, "epdc_sdce0");
+	ret |= gpio_request(MX6SL_BRD_EPDC_SDCE1, "epdc_sdce1");
+	ret |= gpio_request(MX6SL_BRD_EPDC_SDCE2, "epdc_sdce2");
+
+	return ret;
+}
+
+static void epdc_put_pins(void)
+{
+	gpio_free(MX6SL_BRD_EPDC_SDDO_0);
+	gpio_free(MX6SL_BRD_EPDC_SDDO_1);
+	gpio_free(MX6SL_BRD_EPDC_SDDO_2);
+	gpio_free(MX6SL_BRD_EPDC_SDDO_3);
+	gpio_free(MX6SL_BRD_EPDC_SDDO_4);
+	gpio_free(MX6SL_BRD_EPDC_SDDO_5);
+	gpio_free(MX6SL_BRD_EPDC_SDDO_6);
+	gpio_free(MX6SL_BRD_EPDC_SDDO_7);
+	gpio_free(MX6SL_BRD_EPDC_GDCLK);
+	gpio_free(MX6SL_BRD_EPDC_GDSP);
+	gpio_free(MX6SL_BRD_EPDC_GDOE);
+	gpio_free(MX6SL_BRD_EPDC_GDRL);
+	gpio_free(MX6SL_BRD_EPDC_SDCLK);
+	gpio_free(MX6SL_BRD_EPDC_SDOE);
+	gpio_free(MX6SL_BRD_EPDC_SDLE);
+	gpio_free(MX6SL_BRD_EPDC_SDSHR);
+	gpio_free(MX6SL_BRD_EPDC_BDR0);
+	gpio_free(MX6SL_BRD_EPDC_SDCE0);
+	gpio_free(MX6SL_BRD_EPDC_SDCE1);
+	gpio_free(MX6SL_BRD_EPDC_SDCE2);
+}
+
+static void epdc_enable_pins(void)
+{
+	/* Configure MUX settings to enable EPDC use */
+	mxc_iomux_v3_setup_multiple_pads(mx6sl_brd_epdc_enable_pads, \
+				ARRAY_SIZE(mx6sl_brd_epdc_enable_pads));
+
+	gpio_direction_input(MX6SL_BRD_EPDC_SDDO_0);
+	gpio_direction_input(MX6SL_BRD_EPDC_SDDO_1);
+	gpio_direction_input(MX6SL_BRD_EPDC_SDDO_2);
+	gpio_direction_input(MX6SL_BRD_EPDC_SDDO_3);
+	gpio_direction_input(MX6SL_BRD_EPDC_SDDO_4);
+	gpio_direction_input(MX6SL_BRD_EPDC_SDDO_5);
+	gpio_direction_input(MX6SL_BRD_EPDC_SDDO_6);
+	gpio_direction_input(MX6SL_BRD_EPDC_SDDO_7);
+	gpio_direction_input(MX6SL_BRD_EPDC_GDCLK);
+	gpio_direction_input(MX6SL_BRD_EPDC_GDSP);
+	gpio_direction_input(MX6SL_BRD_EPDC_GDOE);
+	gpio_direction_input(MX6SL_BRD_EPDC_GDRL);
+	gpio_direction_input(MX6SL_BRD_EPDC_SDCLK);
+	gpio_direction_input(MX6SL_BRD_EPDC_SDOE);
+	gpio_direction_input(MX6SL_BRD_EPDC_SDLE);
+	gpio_direction_input(MX6SL_BRD_EPDC_SDSHR);
+	gpio_direction_input(MX6SL_BRD_EPDC_BDR0);
+	gpio_direction_input(MX6SL_BRD_EPDC_SDCE0);
+	gpio_direction_input(MX6SL_BRD_EPDC_SDCE1);
+	gpio_direction_input(MX6SL_BRD_EPDC_SDCE2);
+}
+
+static void epdc_disable_pins(void)
+{
+	/* Configure MUX settings for EPDC pins to
+	 * GPIO and drive to 0. */
+	mxc_iomux_v3_setup_multiple_pads(mx6sl_brd_epdc_disable_pads, \
+				ARRAY_SIZE(mx6sl_brd_epdc_disable_pads));
+
+	gpio_direction_output(MX6SL_BRD_EPDC_SDDO_0, 0);
+	gpio_direction_output(MX6SL_BRD_EPDC_SDDO_1, 0);
+	gpio_direction_output(MX6SL_BRD_EPDC_SDDO_2, 0);
+	gpio_direction_output(MX6SL_BRD_EPDC_SDDO_3, 0);
+	gpio_direction_output(MX6SL_BRD_EPDC_SDDO_4, 0);
+	gpio_direction_output(MX6SL_BRD_EPDC_SDDO_5, 0);
+	gpio_direction_output(MX6SL_BRD_EPDC_SDDO_6, 0);
+	gpio_direction_output(MX6SL_BRD_EPDC_SDDO_7, 0);
+	gpio_direction_output(MX6SL_BRD_EPDC_GDCLK, 0);
+	gpio_direction_output(MX6SL_BRD_EPDC_GDSP, 0);
+	gpio_direction_output(MX6SL_BRD_EPDC_GDOE, 0);
+	gpio_direction_output(MX6SL_BRD_EPDC_GDRL, 0);
+	gpio_direction_output(MX6SL_BRD_EPDC_SDCLK, 0);
+	gpio_direction_output(MX6SL_BRD_EPDC_SDOE, 0);
+	gpio_direction_output(MX6SL_BRD_EPDC_SDLE, 0);
+	gpio_direction_output(MX6SL_BRD_EPDC_SDSHR, 0);
+	gpio_direction_output(MX6SL_BRD_EPDC_BDR0, 0);
+	gpio_direction_output(MX6SL_BRD_EPDC_SDCE0, 0);
+	gpio_direction_output(MX6SL_BRD_EPDC_SDCE1, 0);
+	gpio_direction_output(MX6SL_BRD_EPDC_SDCE2, 0);
+}
+
+static struct fb_videomode e60_v110_mode = {
+	.name = "E60_V110",
+	.refresh = 50,
+	.xres = 800,
+	.yres = 600,
+	.pixclock = 18604700,
+	.left_margin = 8,
+	.right_margin = 178,
+	.upper_margin = 4,
+	.lower_margin = 10,
+	.hsync_len = 20,
+	.vsync_len = 4,
+	.sync = 0,
+	.vmode = FB_VMODE_NONINTERLACED,
+	.flag = 0,
+};
+static struct fb_videomode e60_v220_mode = {
+	.name = "E60_V220",
+	.refresh = 85,
+	.xres = 800,
+	.yres = 600,
+	.pixclock = 30000000,
+	.left_margin = 8,
+	.right_margin = 164,
+	.upper_margin = 4,
+	.lower_margin = 8,
+	.hsync_len = 4,
+	.vsync_len = 1,
+	.sync = 0,
+	.vmode = FB_VMODE_NONINTERLACED,
+	.flag = 0,
+	.refresh = 85,
+	.xres = 800,
+	.yres = 600,
+};
+static struct fb_videomode e060scm_mode = {
+	.name = "E060SCM",
+	.refresh = 85,
+	.xres = 800,
+	.yres = 600,
+	.pixclock = 26666667,
+	.left_margin = 8,
+	.right_margin = 100,
+	.upper_margin = 4,
+	.lower_margin = 8,
+	.hsync_len = 4,
+	.vsync_len = 1,
+	.sync = 0,
+	.vmode = FB_VMODE_NONINTERLACED,
+	.flag = 0,
+};
+static struct fb_videomode e97_v110_mode = {
+	.name = "E97_V110",
+	.refresh = 50,
+	.xres = 1200,
+	.yres = 825,
+	.pixclock = 32000000,
+	.left_margin = 12,
+	.right_margin = 128,
+	.upper_margin = 4,
+	.lower_margin = 10,
+	.hsync_len = 20,
+	.vsync_len = 4,
+	.sync = 0,
+	.vmode = FB_VMODE_NONINTERLACED,
+	.flag = 0,
+};
+
+static struct imx_epdc_fb_mode panel_modes[] = {
+	{
+		&e60_v110_mode,
+		4,      /* vscan_holdoff */
+		10,     /* sdoed_width */
+		20,     /* sdoed_delay */
+		10,     /* sdoez_width */
+		20,     /* sdoez_delay */
+		428,    /* gdclk_hp_offs */
+		20,     /* gdsp_offs */
+		0,      /* gdoe_offs */
+		1,      /* gdclk_offs */
+		1,      /* num_ce */
+	},
+	{
+		&e60_v220_mode,
+		4,      /* vscan_holdoff */
+		10,     /* sdoed_width */
+		20,     /* sdoed_delay */
+		10,     /* sdoez_width */
+		20,     /* sdoez_delay */
+		465,    /* gdclk_hp_offs */
+		20,     /* gdsp_offs */
+		0,      /* gdoe_offs */
+		9,      /* gdclk_offs */
+		1,      /* num_ce */
+	},
+	{
+		&e060scm_mode,
+		4,      /* vscan_holdoff */
+		10,     /* sdoed_width */
+		20,     /* sdoed_delay */
+		10,     /* sdoez_width */
+		20,     /* sdoez_delay */
+		419,    /* gdclk_hp_offs */
+		20,     /* gdsp_offs */
+		0,      /* gdoe_offs */
+		5,      /* gdclk_offs */
+		1,      /* num_ce */
+	},
+	{
+		&e97_v110_mode,
+		8,      /* vscan_holdoff */
+		10,     /* sdoed_width */
+		20,     /* sdoed_delay */
+		10,     /* sdoez_width */
+		20,     /* sdoez_delay */
+		632,    /* gdclk_hp_offs */
+		20,     /* gdsp_offs */
+		0,      /* gdoe_offs */
+		1,      /* gdclk_offs */
+		3,      /* num_ce */
+	}
+};
+
+static struct imx_epdc_fb_platform_data epdc_data = {
+	.epdc_mode = panel_modes,
+	.num_modes = ARRAY_SIZE(panel_modes),
+	.get_pins = epdc_get_pins,
+	.put_pins = epdc_put_pins,
+	.enable_pins = epdc_enable_pins,
+	.disable_pins = epdc_disable_pins,
+};
+
+static int spdc_get_pins(void)
+{
+	int ret = 0;
+
+	/* Claim GPIOs for SPDC pins - used during power up/down */
+	ret |= gpio_request(MX6SL_BRD_EPDC_SDDO_0, "SPDC_D0");
+	ret |= gpio_request(MX6SL_BRD_EPDC_SDDO_1, "SPDC_D1");
+	ret |= gpio_request(MX6SL_BRD_EPDC_SDDO_2, "SPDC_D2");
+	ret |= gpio_request(MX6SL_BRD_EPDC_SDDO_3, "SPDC_D3");
+	ret |= gpio_request(MX6SL_BRD_EPDC_SDDO_4, "SPDC_D4");
+	ret |= gpio_request(MX6SL_BRD_EPDC_SDDO_5, "SPDC_D5");
+	ret |= gpio_request(MX6SL_BRD_EPDC_SDDO_6, "SPDC_D6");
+	ret |= gpio_request(MX6SL_BRD_EPDC_SDDO_7, "SPDC_D7");
+
+	ret |= gpio_request(MX6SL_BRD_EPDC_GDOE, "SIPIX_YOE");
+	ret |= gpio_request(MX6SL_BRD_EPDC_SDDO_9, "SIPIX_PWR_RDY");
+
+	ret |= gpio_request(MX6SL_BRD_EPDC_GDSP, "SIPIX_YDIO");
+
+	ret |= gpio_request(MX6SL_BRD_EPDC_GDCLK, "SIPIX_YCLK");
+	ret |= gpio_request(MX6SL_BRD_EPDC_SDSHR, "SIPIX_XDIO");
+
+	ret |= gpio_request(MX6SL_BRD_EPDC_SDLE, "SIPIX_LD");
+	ret |= gpio_request(MX6SL_BRD_EPDC_SDCE1, "SIPIX_SOE");
+
+	ret |= gpio_request(MX6SL_BRD_EPDC_SDCLK, "SIPIX_XCLK");
+	ret |= gpio_request(MX6SL_BRD_EPDC_SDDO_10, "SIPIX_SHD_N");
+	ret |= gpio_request(MX6SL_BRD_EPDC_SDCE0, "SIPIX2_CE");
+
+	return ret;
+}
+
+static void spdc_put_pins(void)
+{
+	gpio_free(MX6SL_BRD_EPDC_SDDO_0);
+	gpio_free(MX6SL_BRD_EPDC_SDDO_1);
+	gpio_free(MX6SL_BRD_EPDC_SDDO_2);
+	gpio_free(MX6SL_BRD_EPDC_SDDO_3);
+	gpio_free(MX6SL_BRD_EPDC_SDDO_4);
+	gpio_free(MX6SL_BRD_EPDC_SDDO_5);
+	gpio_free(MX6SL_BRD_EPDC_SDDO_6);
+	gpio_free(MX6SL_BRD_EPDC_SDDO_7);
+
+	gpio_free(MX6SL_BRD_EPDC_GDOE);
+	gpio_free(MX6SL_BRD_EPDC_SDDO_9);
+	gpio_free(MX6SL_BRD_EPDC_GDSP);
+	gpio_free(MX6SL_BRD_EPDC_GDCLK);
+	gpio_free(MX6SL_BRD_EPDC_SDSHR);
+	gpio_free(MX6SL_BRD_EPDC_SDLE);
+	gpio_free(MX6SL_BRD_EPDC_SDCE1);
+	gpio_free(MX6SL_BRD_EPDC_SDCLK);
+	gpio_free(MX6SL_BRD_EPDC_SDDO_10);
+	gpio_free(MX6SL_BRD_EPDC_SDCE0);
+}
+
+static void spdc_enable_pins(void)
+{
+	/* Configure MUX settings to enable SPDC use */
+	mxc_iomux_v3_setup_multiple_pads(mx6sl_brd_spdc_enable_pads, \
+				ARRAY_SIZE(mx6sl_brd_spdc_enable_pads));
+
+	gpio_direction_input(MX6SL_BRD_EPDC_SDDO_0);
+	gpio_direction_input(MX6SL_BRD_EPDC_SDDO_1);
+	gpio_direction_input(MX6SL_BRD_EPDC_SDDO_2);
+	gpio_direction_input(MX6SL_BRD_EPDC_SDDO_3);
+	gpio_direction_input(MX6SL_BRD_EPDC_SDDO_4);
+	gpio_direction_input(MX6SL_BRD_EPDC_SDDO_5);
+	gpio_direction_input(MX6SL_BRD_EPDC_SDDO_6);
+	gpio_direction_input(MX6SL_BRD_EPDC_SDDO_7);
+	gpio_direction_input(MX6SL_BRD_EPDC_GDOE);
+	gpio_direction_input(MX6SL_BRD_EPDC_SDDO_9);
+	gpio_direction_input(MX6SL_BRD_EPDC_GDSP);
+	gpio_direction_input(MX6SL_BRD_EPDC_GDCLK);
+	gpio_direction_input(MX6SL_BRD_EPDC_SDSHR);
+	gpio_direction_input(MX6SL_BRD_EPDC_SDLE);
+	gpio_direction_input(MX6SL_BRD_EPDC_SDCE1);
+	gpio_direction_input(MX6SL_BRD_EPDC_SDCLK);
+	gpio_direction_input(MX6SL_BRD_EPDC_SDDO_10);
+	gpio_direction_input(MX6SL_BRD_EPDC_SDCE0);
+}
+
+static void spdc_disable_pins(void)
+{
+	/* Configure MUX settings for SPDC pins to
+	 * GPIO and drive to 0. */
+	mxc_iomux_v3_setup_multiple_pads(mx6sl_brd_spdc_disable_pads, \
+				ARRAY_SIZE(mx6sl_brd_spdc_disable_pads));
+
+	gpio_direction_output(MX6SL_BRD_EPDC_SDDO_0, 0);
+	gpio_direction_output(MX6SL_BRD_EPDC_SDDO_1, 0);
+	gpio_direction_output(MX6SL_BRD_EPDC_SDDO_2, 0);
+	gpio_direction_output(MX6SL_BRD_EPDC_SDDO_3, 0);
+	gpio_direction_output(MX6SL_BRD_EPDC_SDDO_4, 0);
+	gpio_direction_output(MX6SL_BRD_EPDC_SDDO_5, 0);
+	gpio_direction_output(MX6SL_BRD_EPDC_SDDO_6, 0);
+	gpio_direction_output(MX6SL_BRD_EPDC_SDDO_7, 0);
+
+	gpio_direction_output(MX6SL_BRD_EPDC_GDOE, 0);
+	gpio_direction_output(MX6SL_BRD_EPDC_SDDO_9, 0);
+	gpio_direction_output(MX6SL_BRD_EPDC_GDSP, 0);
+	gpio_direction_output(MX6SL_BRD_EPDC_GDCLK, 0);
+	gpio_direction_output(MX6SL_BRD_EPDC_SDSHR, 0);
+	gpio_direction_output(MX6SL_BRD_EPDC_SDLE, 0);
+	gpio_direction_output(MX6SL_BRD_EPDC_SDCE1, 0);
+	gpio_direction_output(MX6SL_BRD_EPDC_SDCLK, 0);
+	gpio_direction_output(MX6SL_BRD_EPDC_SDDO_10, 0);
+	gpio_direction_output(MX6SL_BRD_EPDC_SDCE0, 0);
+}
+
+static struct imx_spdc_panel_init_set spdc_init_set = {
+	.yoe_pol = false,
+	.dual_gate = false,
+	.resolution = 0,
+	.ud = false,
+	.rl = false,
+	.data_filter_n = true,
+	.power_ready = true,
+	.rgbw_mode_enable = false,
+	.hburst_len_en = true,
+};
+
+static struct fb_videomode erk_1_4_a01 = {
+	.name = "ERK_1_4_A01",
+	.refresh = 50,
+	.xres = 800,
+	.yres = 600,
+	.pixclock = 40000000,
+	.vmode = FB_VMODE_NONINTERLACED,
+};
+
+static struct imx_spdc_fb_mode spdc_panel_modes[] = {
+	{
+		&erk_1_4_a01,
+		&spdc_init_set,
+		.wave_timing = "pvi"
+	},
+};
+
+static struct imx_spdc_fb_platform_data spdc_data = {
+	.spdc_mode = spdc_panel_modes,
+	.num_modes = ARRAY_SIZE(spdc_panel_modes),
+	.get_pins = spdc_get_pins,
+	.put_pins = spdc_put_pins,
+	.enable_pins = spdc_enable_pins,
+	.disable_pins = spdc_disable_pins,
+};
+
+static int __init early_use_spdc_sel(char *p)
+{
+	spdc_sel = 1;
+	return 0;
+}
+early_param("spdc", early_use_spdc_sel);
+
+static void setup_spdc(void)
+{
+	/* GPR0[8]: 0:EPDC, 1:SPDC */
+	if (spdc_sel)
+		mxc_iomux_set_gpr_register(0, 8, 1, 1);
+}
+
+static void imx6_evk_usbotg_vbus(bool on)
+{
+	if (on)
+		gpio_set_value(MX6_BRD_USBOTG1_PWR, 1);
+	else
+		gpio_set_value(MX6_BRD_USBOTG1_PWR, 0);
+}
+
+static void __init mx6_evk_init_usb(void)
+{
+	int ret = 0;
+
+	imx_otg_base = MX6_IO_ADDRESS(MX6Q_USB_OTG_BASE_ADDR);
+
+	/* disable external charger detect,
+	 * or it will affect signal quality at dp.
+	 */
+
+	ret = gpio_request(MX6_BRD_USBOTG1_PWR, "usbotg-pwr");
+	if (ret) {
+		pr_err("failed to get GPIO MX6_BRD_USBOTG1_PWR:%d\n", ret);
+		return;
+	}
+	gpio_direction_output(MX6_BRD_USBOTG1_PWR, 0);
+
+	ret = gpio_request(MX6_BRD_USBOTG2_PWR, "usbh1-pwr");
+	if (ret) {
+		pr_err("failed to get GPIO MX6_BRD_USBOTG2_PWR:%d\n", ret);
+		return;
+	}
+	gpio_direction_output(MX6_BRD_USBOTG2_PWR, 1);
+
+	mx6_set_otghost_vbus_func(imx6_evk_usbotg_vbus);
+	mx6_usb_dr_init();
+#ifdef CONFIG_USB_EHCI_ARC_HSIC
+	mx6_usb_h2_init();
+#endif
+}
+
+static struct platform_pwm_backlight_data mx6_evk_pwm_backlight_data = {
+	.pwm_id		= 0,
+	.max_brightness	= 255,
+	.dft_brightness	= 128,
+	.pwm_period_ns	= 50000,
+};
+static struct fb_videomode video_modes[] = {
+	{
+	 /* 800x480 @ 57 Hz , pixel clk @ 32MHz */
+	 "SEIKO-WVGA", 60, 800, 480, 29850, 99, 164, 33, 10, 10, 10,
+	 FB_SYNC_CLK_LAT_FALL,
+	 FB_VMODE_NONINTERLACED,
+	 0,},
+};
+
+static struct mxc_fb_platform_data fb_data[] = {
+	{
+	 .interface_pix_fmt = V4L2_PIX_FMT_RGB24,
+	 .mode_str = "SEIKO-WVGA",
+	 .mode = video_modes,
+	 .num_modes = ARRAY_SIZE(video_modes),
+	 },
+};
+
+static struct platform_device lcd_wvga_device = {
+	.name = "lcd_seiko",
+};
+
+static int mx6sl_evk_keymap[] = {
+	KEY(0, 0, KEY_SELECT),
+	KEY(0, 1, KEY_BACK),
+	KEY(0, 2, KEY_F1),
+	KEY(0, 3, KEY_F2),
+
+	KEY(1, 0, KEY_F3),
+	KEY(1, 1, KEY_F4),
+	KEY(1, 2, KEY_F5),
+	KEY(1, 3, KEY_MENU),
+
+	KEY(2, 0, KEY_PREVIOUS),
+	KEY(2, 1, KEY_NEXT),
+	KEY(2, 2, KEY_HOME),
+	KEY(2, 3, KEY_NEXT),
+
+	KEY(3, 0, KEY_UP),
+	KEY(3, 1, KEY_LEFT),
+	KEY(3, 2, KEY_RIGHT),
+	KEY(3, 3, KEY_DOWN),
+};
+
+static const struct matrix_keymap_data mx6sl_evk_map_data __initconst = {
+	.keymap		= mx6sl_evk_keymap,
+	.keymap_size	= ARRAY_SIZE(mx6sl_evk_keymap),
+};
+static void __init elan_ts_init(void)
+{
+	mxc_iomux_v3_setup_multiple_pads(mx6sl_brd_elan_pads,
+					ARRAY_SIZE(mx6sl_brd_elan_pads));
+
+	/* ELAN Touchscreen */
+	gpio_request(MX6SL_BRD_ELAN_INT, "elan-interrupt");
+	gpio_direction_input(MX6SL_BRD_ELAN_INT);
+
+	gpio_request(MX6SL_BRD_ELAN_CE, "elan-cs");
+	gpio_direction_output(MX6SL_BRD_ELAN_CE, 1);
+	gpio_direction_output(MX6SL_BRD_ELAN_CE, 0);
+
+	gpio_request(MX6SL_BRD_ELAN_RST, "elan-rst");
+	gpio_direction_output(MX6SL_BRD_ELAN_RST, 1);
+	gpio_direction_output(MX6SL_BRD_ELAN_RST, 0);
+	mdelay(1);
+	gpio_direction_output(MX6SL_BRD_ELAN_RST, 1);
+	gpio_direction_output(MX6SL_BRD_ELAN_CE, 1);
+}
+
+#define SNVS_LPCR 0x38
+static void mx6_snvs_poweroff(void)
+{
+	u32 value;
+	void __iomem *mx6_snvs_base = MX6_IO_ADDRESS(MX6Q_SNVS_BASE_ADDR);
+
+	value = readl(mx6_snvs_base + SNVS_LPCR);
+	/* set TOP and DP_EN bit */
+	writel(value | 0x60, mx6_snvs_base + SNVS_LPCR);
+}
+
+/*!
+ * Board specific initialization.
+ */
+static void __init mx6_evk_init(void)
+{
+	mxc_iomux_v3_setup_multiple_pads(mx6sl_brd_pads,
+					ARRAY_SIZE(mx6sl_brd_pads));
+
+	elan_ts_init();
+
+	#ifdef CONFIG_MX6_INTER_LDO_BYPASS
+	gp_reg_id = mx6sl_evk_dvfscore_data.reg_id;
+	#else
+	gp_reg_id = mx6sl_evk_dvfscore_data.reg_id;
+	soc_reg_id = mx6sl_evk_dvfscore_data.soc_id;
+	pu_reg_id = mx6sl_evk_dvfscore_data.pu_id;
+	mx6_cpu_regulator_init();
+	#endif
+
+	imx6q_add_imx_snvs_rtc();
+
+	imx6q_add_imx_i2c(0, &mx6_evk_i2c0_data);
+	imx6q_add_imx_i2c(1, &mx6_evk_i2c1_data);
+	i2c_register_board_info(0, mxc_i2c0_board_info,
+			ARRAY_SIZE(mxc_i2c0_board_info));
+	i2c_register_board_info(1, mxc_i2c1_board_info,
+			ARRAY_SIZE(mxc_i2c1_board_info));
+	imx6q_add_imx_i2c(2, &mx6_evk_i2c2_data);
+	i2c_register_board_info(2, mxc_i2c2_board_info,
+			ARRAY_SIZE(mxc_i2c2_board_info));
+
+	/* SPI */
+	imx6q_add_ecspi(0, &mx6_evk_spi_data);
+	spi_device_init();
+
+	mx6sl_evk_init_pfuze100(0);
+
+	imx6q_add_anatop_thermal_imx(1, &mx6sl_anatop_thermal_data);
+
+	mx6_evk_init_uart();
+	/* get enet tx reference clk from FEC_REF_CLK pad.
+	 * GPR1[14] = 0, GPR1[18:17] = 00
+	 */
+	mxc_iomux_set_gpr_register(1, 14, 1, 0);
+	mxc_iomux_set_gpr_register(1, 17, 2, 0);
+
+	imx6_init_fec(fec_data);
+
+	platform_device_register(&evk_vmmc_reg_devices);
+	imx6q_add_sdhci_usdhc_imx(0, &mx6_evk_sd1_data);
+	imx6q_add_sdhci_usdhc_imx(1, &mx6_evk_sd2_data);
+	imx6q_add_sdhci_usdhc_imx(2, &mx6_evk_sd3_data);
+
+	mx6_evk_init_usb();
+	imx6q_add_otp();
+	imx6q_add_mxc_pwm(0);
+	imx6q_add_mxc_pwm_backlight(0, &mx6_evk_pwm_backlight_data);
+	imx6dl_add_imx_elcdif(&fb_data[0]);
+
+	gpio_request(MX6_BRD_LCD_PWR_EN, "elcdif-power-on");
+	gpio_direction_output(MX6_BRD_LCD_PWR_EN, 1);
+	mxc_register_device(&lcd_wvga_device, NULL);
+
+	imx6dl_add_imx_pxp();
+	imx6dl_add_imx_pxp_client();
+	mxc_register_device(&max17135_sensor_device, NULL);
+	setup_spdc();
+	if (!spdc_sel)
+		imx6dl_add_imx_epdc(&epdc_data);
+	else
+		imx6sl_add_imx_spdc(&spdc_data);
+	imx6q_add_dvfs_core(&mx6sl_evk_dvfscore_data);
+
+	imx6q_init_audio();
+
+	imx6q_add_viim();
+	imx6q_add_imx2_wdt(0, NULL);
+
+	imx_add_viv_gpu(&imx6_gpu_data, &imx6q_gpu_pdata);
+	imx6sl_add_imx_keypad(&mx6sl_evk_map_data);
+	imx6q_add_busfreq();
+	imx6sl_add_dcp();
+	imx6sl_add_rngb();
+
+	pm_power_off = mx6_snvs_poweroff;
+}
+
+extern void __iomem *twd_base;
+static void __init mx6_timer_init(void)
+{
+	struct clk *uart_clk;
+#ifdef CONFIG_LOCAL_TIMERS
+	twd_base = ioremap(LOCAL_TWD_ADDR, SZ_256);
+	BUG_ON(!twd_base);
+#endif
+	mx6sl_clocks_init(32768, 24000000, 0, 0);
+
+	uart_clk = clk_get_sys("imx-uart.0", NULL);
+	early_console_setup(UART1_BASE_ADDR, uart_clk);
+}
+
+static struct sys_timer mxc_timer = {
+	.init   = mx6_timer_init,
+};
+
+static void __init mx6_evk_reserve(void)
+{
+#if defined(CONFIG_MXC_GPU_VIV) || defined(CONFIG_MXC_GPU_VIV_MODULE)
+	phys_addr_t phys;
+
+	if (imx6q_gpu_pdata.reserved_mem_size) {
+		phys = memblock_alloc_base(imx6q_gpu_pdata.reserved_mem_size,
+					   SZ_4K, MEMBLOCK_ALLOC_ACCESSIBLE);
+		memblock_remove(phys, imx6q_gpu_pdata.reserved_mem_size);
+		imx6q_gpu_pdata.reserved_mem_base = phys;
+	}
+#endif
+}
+
+MACHINE_START(MX6SL_EVK, "Freescale i.MX 6SoloLite EVK Board")
+	.boot_params	= MX6SL_PHYS_OFFSET + 0x100,
+	.map_io		= mx6_map_io,
+	.init_irq	= mx6_init_irq,
+	.init_machine	= mx6_evk_init,
+	.timer		= &mxc_timer,
+	.reserve	= mx6_evk_reserve,
+MACHINE_END
diff --git a/arch/arm/mach-mx6/mx6sl_evk_pmic_pfuze100.c b/arch/arm/mach-mx6/mx6sl_evk_pmic_pfuze100.c
new file mode 100644
index 0000000..7a74b1f
--- /dev/null
+++ b/arch/arm/mach-mx6/mx6sl_evk_pmic_pfuze100.c
@@ -0,0 +1,440 @@
+/*
+ * Copyright (C) 2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/err.h>
+#include <linux/i2c.h>
+#include <linux/gpio.h>
+#include <linux/regulator/machine.h>
+#include <linux/mfd/pfuze.h>
+#include <mach/irqs.h>
+
+/*
+ * Convenience conversion.
+ * Here atm, maybe there is somewhere better for this.
+ */
+#define mV_to_uV(mV) (mV * 1000)
+#define uV_to_mV(uV) (uV / 1000)
+#define V_to_uV(V) (mV_to_uV(V * 1000))
+#define uV_to_V(uV) (uV_to_mV(uV) / 1000)
+
+#define PFUZE100_I2C_DEVICE_NAME  "pfuze100"
+/* 7-bit I2C bus slave address */
+#define PFUZE100_I2C_ADDR         (0x08)
+ /*SWBST*/
+#define PFUZE100_SW1ASTANDBY	33
+#define PFUZE100_SW1ASTANDBY_STBY_VAL	(0x16)
+#define PFUZE100_SW1ASTANDBY_STBY_M	(0x3f<<0)
+#define PFUZE100_SW1BSTANDBY   40
+#define PFUZE100_SW1BSTANDBY_STBY_VAL  (0x16)
+#define PFUZE100_SW1BSTANDBY_STBY_M    (0x3f<<0)
+#define PFUZE100_SW1CSTANDBY	47
+#define PFUZE100_SW1CSTANDBY_STBY_VAL	(0x16)
+#define PFUZE100_SW1CSTANDBY_STBY_M	(0x3f<<0)
+#define PFUZE100_SW2STANDBY     54
+#define PFUZE100_SW2STANDBY_STBY_VAL    0x0
+#define PFUZE100_SW2STANDBY_STBY_M      (0x3f<<0)
+#define PFUZE100_SW3ASTANDBY    61
+#define PFUZE100_SW3ASTANDBY_STBY_VAL   0x0
+#define PFUZE100_SW3ASTANDBY_STBY_M     (0x3f<<0)
+#define PFUZE100_SW3BSTANDBY    68
+#define PFUZE100_SW3BSTANDBY_STBY_VAL   0x0
+#define PFUZE100_SW3BSTANDBY_STBY_M     (0x3f<<0)
+#define PFUZE100_SW4STANDBY     75
+#define PFUZE100_SW4STANDBY_STBY_VAL    0
+#define PFUZE100_SW4STANDBY_STBY_M      (0x3f<<0)
+#define PFUZE100_SWBSTCON1	102
+#define PFUZE100_SWBSTCON1_SWBSTMOD_VAL	(0x1<<2)
+#define PFUZE100_SWBSTCON1_SWBSTMOD_M	(0x3<<2)
+#define PFUZE100_SW1ACON		36
+#define PFUZE100_SW1ACON_SPEED_VAL	(0x1<<6)	/*default */
+#define PFUZE100_SW1ACON_SPEED_M	(0x3<<6)
+
+
+#ifdef CONFIG_MX6_INTER_LDO_BYPASS
+static struct regulator_consumer_supply sw1_consumers[] = {
+	{
+		.supply	   = "VDDCORE",
+	}
+};
+#endif
+
+static struct regulator_consumer_supply sw2_consumers[] = {
+	{
+		.supply		= "MICVDD",
+		.dev_name	= "1-001a",
+	},
+	{
+		.supply 	= "DBVDD",
+		.dev_name	= "1-001a",
+	}
+
+};
+static struct regulator_consumer_supply sw4_consumers[] = {
+       {
+	.supply = "AUD_1V8",
+	}
+};
+static struct regulator_consumer_supply swbst_consumers[] = {
+       {
+	.supply = "SWBST_5V",
+	}
+};
+static struct regulator_consumer_supply vgen1_consumers[] = {
+       {
+	.supply = "VGEN1_1V5",
+	}
+};
+static struct regulator_consumer_supply vgen2_consumers[] = {
+       {
+	.supply = "VGEN2_1V5",
+	}
+};
+static struct regulator_consumer_supply vgen4_consumers[] = {
+	{
+		.supply    = "AVDD",
+		.dev_name	= "1-001a",
+	},
+	{
+		.supply    = "DCVDD",
+		.dev_name	= "1-001a",
+	},
+	{
+		.supply    = "CPVDD",
+		.dev_name	= "1-001a",
+	},
+	{
+		.supply    = "PLLVDD",
+		.dev_name	= "1-001a",
+	}
+};
+static struct regulator_consumer_supply vgen5_consumers[] = {
+       {
+	.supply = "VGEN5_2V8",
+	}
+};
+static struct regulator_consumer_supply vgen6_consumers[] = {
+       {
+	.supply = "VGEN6_3V3",
+	}
+};
+
+static struct regulator_init_data sw1a_init = {
+	.constraints = {
+			.name = "PFUZE100_SW1A",
+#ifdef PFUZE100_FIRST_VERSION
+			.min_uV = 650000,
+			.max_uV = 1437500,
+#else
+			.min_uV = 300000,
+			.max_uV = 1875000,
+#endif
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+			.valid_modes_mask = 0,
+			.boot_on = 1,
+			.always_on = 1,
+			},
+	#ifdef CONFIG_MX6_INTER_LDO_BYPASS
+	.num_consumer_supplies = ARRAY_SIZE(sw1_consumers),
+	.consumer_supplies = sw1_consumers,
+	#endif
+};
+
+static struct regulator_init_data sw1b_init = {
+	.constraints = {
+			.name = "PFUZE100_SW1B",
+			.min_uV = 300000,
+			.max_uV = 1875000,
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+			.valid_modes_mask = 0,
+			.always_on = 1,
+			.boot_on = 1,
+			},
+};
+
+static struct regulator_init_data sw1c_init = {
+	.constraints = {
+			.name = "PFUZE100_SW1C",
+			.min_uV = 300000,
+			.max_uV = 1875000,
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+			.valid_modes_mask = 0,
+			.always_on = 1,
+			.boot_on = 1,
+			},
+};
+
+static struct regulator_init_data sw2_init = {
+	.constraints = {
+			.name = "PFUZE100_SW2",
+#if PFUZE100_SW2_VOL6
+			.min_uV = 800000,
+			.max_uV = 3950000,
+#else
+			.min_uV = 400000,
+			.max_uV = 1975000,
+#endif
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+			.valid_modes_mask = 0,
+			.always_on = 1,
+			.boot_on = 1,
+			},
+	.num_consumer_supplies = ARRAY_SIZE(sw2_consumers),
+	.consumer_supplies = sw2_consumers,
+};
+
+static struct regulator_init_data sw3a_init = {
+	.constraints = {
+			.name = "PFUZE100_SW3A",
+#if PFUZE100_SW3_VOL6
+			.min_uV = 800000,
+			.max_uV = 3950000,
+#else
+			.min_uV = 400000,
+			.max_uV = 1975000,
+#endif
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+			.valid_modes_mask = 0,
+			.always_on = 1,
+			.boot_on = 1,
+			},
+};
+
+static struct regulator_init_data sw3b_init = {
+	.constraints = {
+			.name = "PFUZE100_SW3B",
+#if PFUZE100_SW3_VOL6
+			.min_uV = 800000,
+			.max_uV = 3950000,
+#else
+			.min_uV = 400000,
+			.max_uV = 1975000,
+#endif
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+			.valid_modes_mask = 0,
+			.always_on = 1,
+			.boot_on = 1,
+			},
+};
+
+static struct regulator_init_data sw4_init = {
+	.constraints = {
+			.name = "PFUZE100_SW4",
+#if PFUZE100_SW4_VOL6
+			.min_uV = 800000,
+			.max_uV = 3950000,
+#else
+			.min_uV = 400000,
+			.max_uV = 1975000,
+#endif
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+			.valid_modes_mask = 0,
+			},
+	.num_consumer_supplies = ARRAY_SIZE(sw4_consumers),
+	.consumer_supplies = sw4_consumers,
+};
+
+static struct regulator_init_data swbst_init = {
+	.constraints = {
+			.name = "PFUZE100_SWBST",
+			.min_uV = 5000000,
+			.max_uV = 5150000,
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+			.valid_modes_mask = 0,
+			.always_on = 1,
+			.boot_on = 1,
+			},
+	.num_consumer_supplies = ARRAY_SIZE(swbst_consumers),
+	.consumer_supplies = swbst_consumers,
+};
+
+static struct regulator_init_data vsnvs_init = {
+	.constraints = {
+			.name = "PFUZE100_VSNVS",
+			.min_uV = 1200000,
+			.max_uV = 3000000,
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+			.valid_modes_mask = 0,
+			.always_on = 1,
+			.boot_on = 1,
+			},
+};
+
+static struct regulator_init_data vrefddr_init = {
+	.constraints = {
+			.name = "PFUZE100_VREFDDR",
+			.always_on = 1,
+			.boot_on = 1,
+			},
+};
+
+static struct regulator_init_data vgen1_init = {
+	.constraints = {
+			.name = "PFUZE100_VGEN1",
+#ifdef PFUZE100_FIRST_VERSION
+			.min_uV = 1200000,
+			.max_uV = 1550000,
+#else
+			.min_uV = 800000,
+			.max_uV = 1550000,
+#endif
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE |
+			REGULATOR_CHANGE_STATUS,
+			.valid_modes_mask = 0,
+			.always_on = 0,
+			.boot_on = 0,
+			},
+	.num_consumer_supplies = ARRAY_SIZE(vgen1_consumers),
+	.consumer_supplies = vgen1_consumers,
+};
+
+static struct regulator_init_data vgen2_init = {
+	.constraints = {
+			.name = "PFUZE100_VGEN2",
+#ifdef PFUZE100_FIRST_VERSION
+			.min_uV = 1200000,
+			.max_uV = 1550000,
+#else
+			.min_uV = 800000,
+			.max_uV = 1550000,
+#endif
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE |
+			REGULATOR_CHANGE_STATUS,
+			.valid_modes_mask = 0,
+			},
+	.num_consumer_supplies = ARRAY_SIZE(vgen2_consumers),
+	.consumer_supplies = vgen2_consumers,
+
+};
+
+static struct regulator_init_data vgen3_init = {
+	.constraints = {
+			.name = "PFUZE100_VGEN3",
+			.min_uV = 1800000,
+			.max_uV = 3300000,
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE |
+			REGULATOR_CHANGE_STATUS,
+			.valid_modes_mask = 0,
+			.always_on = 0,
+			.boot_on = 0,
+			},
+};
+
+static struct regulator_init_data vgen4_init = {
+	.constraints = {
+			.name = "PFUZE100_VGEN4",
+			.min_uV = 1800000,
+			.max_uV = 3300000,
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE |
+			REGULATOR_CHANGE_STATUS,
+			.valid_modes_mask = 0,
+			},
+	.num_consumer_supplies = ARRAY_SIZE(vgen4_consumers),
+	.consumer_supplies = vgen4_consumers,
+};
+
+static struct regulator_init_data vgen5_init = {
+	.constraints = {
+			.name = "PFUZE100_VGEN5",
+			.min_uV = 1800000,
+			.max_uV = 3300000,
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE |
+			REGULATOR_CHANGE_STATUS,
+			.valid_modes_mask = 0,
+			},
+	.num_consumer_supplies = ARRAY_SIZE(vgen5_consumers),
+	.consumer_supplies = vgen5_consumers,
+};
+
+static struct regulator_init_data vgen6_init = {
+	.constraints = {
+			.name = "PFUZE100_VGEN6",
+			.min_uV = 1800000,
+			.max_uV = 3300000,
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE |
+			REGULATOR_CHANGE_STATUS,
+			.valid_modes_mask = 0,
+			},
+	.num_consumer_supplies = ARRAY_SIZE(vgen6_consumers),
+	.consumer_supplies = vgen6_consumers,
+};
+
+static int pfuze100_init(struct mc_pfuze *pfuze)
+{
+	int ret;
+	ret = pfuze_reg_rmw(pfuze, PFUZE100_SW1ASTANDBY,
+			    PFUZE100_SW1ASTANDBY_STBY_M,
+			    PFUZE100_SW1ASTANDBY_STBY_VAL);
+	if (ret)
+		goto err;
+	ret = pfuze_reg_rmw(pfuze, PFUZE100_SW1CSTANDBY,
+			    PFUZE100_SW1CSTANDBY_STBY_M,
+			    PFUZE100_SW1CSTANDBY_STBY_VAL);
+	if (ret)
+		goto err;
+	/*set SW1ABDVSPEED as 25mV step each 4us,quick than 16us before.*/
+	ret = pfuze_reg_rmw(pfuze, PFUZE100_SW1ACON,
+			    PFUZE100_SW1ACON_SPEED_M,
+			    PFUZE100_SW1ACON_SPEED_VAL);
+	if (ret)
+		goto err;
+	return 0;
+err:
+	printk(KERN_ERR "pfuze100 init error!\n");
+	return -1;
+}
+
+static struct pfuze_regulator_init_data mx6q_sabreauto_pfuze100_regulators[] = {
+	{.id = PFUZE100_SW1A,	.init_data = &sw1a_init},
+	{.id = PFUZE100_SW1B,	.init_data = &sw1b_init},
+	{.id = PFUZE100_SW1C,	.init_data = &sw1c_init},
+	{.id = PFUZE100_SW2,	.init_data = &sw2_init},
+	{.id = PFUZE100_SW3A,	.init_data = &sw3a_init},
+	{.id = PFUZE100_SW3B,	.init_data = &sw3b_init},
+	{.id = PFUZE100_SW4,	.init_data = &sw4_init},
+	{.id = PFUZE100_SWBST,	.init_data = &swbst_init},
+	{.id = PFUZE100_VSNVS,	.init_data = &vsnvs_init},
+	{.id = PFUZE100_VREFDDR,	.init_data = &vrefddr_init},
+	{.id = PFUZE100_VGEN1,	.init_data = &vgen1_init},
+	{.id = PFUZE100_VGEN2,	.init_data = &vgen2_init},
+	{.id = PFUZE100_VGEN3,	.init_data = &vgen3_init},
+	{.id = PFUZE100_VGEN4,	.init_data = &vgen4_init},
+	{.id = PFUZE100_VGEN5,	.init_data = &vgen5_init},
+	{.id = PFUZE100_VGEN6,	.init_data = &vgen6_init},
+};
+
+static struct pfuze_platform_data pfuze100_plat = {
+	.flags = PFUZE_USE_REGULATOR,
+	.num_regulators = ARRAY_SIZE(mx6q_sabreauto_pfuze100_regulators),
+	.regulators = mx6q_sabreauto_pfuze100_regulators,
+	.pfuze_init = pfuze100_init,
+};
+
+static struct i2c_board_info __initdata pfuze100_i2c_device = {
+	I2C_BOARD_INFO(PFUZE100_I2C_DEVICE_NAME, PFUZE100_I2C_ADDR),
+	.platform_data = &pfuze100_plat,
+};
+
+int __init mx6sl_evk_init_pfuze100(u32 int_gpio)
+{
+	if (int_gpio)
+		pfuze100_i2c_device.irq = gpio_to_irq(int_gpio); /*update INT gpio */
+	return i2c_register_board_info(0, &pfuze100_i2c_device, 1);
+}
diff --git a/arch/arm/plat-mxc/include/mach/mxc.h b/arch/arm/plat-mxc/include/mach/mxc.h
index 8245767..3f58604 100755
--- a/arch/arm/plat-mxc/include/mach/mxc.h
+++ b/arch/arm/plat-mxc/include/mach/mxc.h
@@ -94,6 +94,8 @@ extern unsigned int system_rev;
 	board_is_rev(IMX_BOARD_REV_2))
 #define board_is_mx6q_sabre_auto() (cpu_is_mx6q() && \
 	board_is_rev(IMX_BOARD_REV_3))
+#define board_is_mx6sl_evk() (cpu_is_mx6sl() && \
+	board_is_rev(IMX_BOARD_REV_3))
 
 #define board_is_mx6_unknown() \
 	board_is_rev(IMX_BOARD_REV_1)
diff --git a/arch/arm/tools/mach-types b/arch/arm/tools/mach-types
index 5b48a6b..88210d9 100644
--- a/arch/arm/tools/mach-types
+++ b/arch/arm/tools/mach-types
@@ -1118,4 +1118,5 @@ mx6q_sabrelite		MACH_MX6Q_SABRELITE	MX6Q_SABRELITE		3769
 mx6q_sabresd		MACH_MX6Q_SABRESD	MX6Q_SABRESD		3980
 mx6q_arm2		MACH_MX6Q_ARM2		MX6Q_ARM2		3837
 mx6sl_arm2		MACH_MX6SL_ARM2		MX6SL_ARM2		4091
+mx6sl_evk		MACH_MX6SL_EVK		MX6SL_EVK		4307
 
-- 
1.7.9.5

