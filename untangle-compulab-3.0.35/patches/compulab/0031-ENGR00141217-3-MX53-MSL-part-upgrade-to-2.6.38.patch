From 249d47dc9e9301bb408056cd8232731c75a82834 Mon Sep 17 00:00:00 2001
From: Frank Li <Frank.Li@freescale.com>
Date: Tue, 22 Feb 2011 17:34:58 +0800
Subject: ENGR00141217-3 MX53 MSL part upgrade to 2.6.38

imx51_babbage:
imx53_smd: add i2c device
imx53_smd: add i2c board device info
imx53_smd: add esdhc device support
imx53_smd: Add SRTC devices
imx53_smd: enable the AHCI SATA
imx53_smd: Add GPIO Keypad support
imx53_ard: enable ARD board bootup
imx53_ard: add ethernet pin mux
imx53_ard: add smsc911x device
imx53_loco: add i2c device
imx53_loco: change sii902x i2c device
imx53_loco: register v4l2 output device
imx53_loco: add srtc device
imx53_loco: enable the AHCI SATA
imx53_loco: Add GPIO Keypad support
imx53_evk: add evk and arm2 boards io setting and set up display
imx5: add ipu\vpu
imx5: clock.c: remove RATE_PROPAGATES
imx5: Add clock, dvfs, busfreq, sdram_autogating support.
imx5: fix warnings on boot
imx5: add v4l2 device
imx5: add board_is_rev support
imx5: Add sdma support for i.Mx53 and i.Mx51
imx5: add p1003
imx5: add ipuv3
imx5: add sata
imx5: add pmic board files
imx5: add pm function
imx5: add iram config
imx5: add gpu
imx5: fix clock debug enable_count error
imx53: add gpio irq support for mx53
imx53: change PWM backlight device register method to dynamic
imx53: change v4l2 device register method to dynamic
imx53: add vpu devices support
imx53: add dvfs-core and busfreq devices register method
imx53: Add usb devices
imx53: add i2c pad settings
imx53: add ssi support

Signed-off-by: Richard Zhao <richard.zhao@freescale.com>
Signed-off-by: Frank Li <Frank.Li@freescale.com>
Signed-off-by: Jason Chen <b02280@freescale.com>
Signed-off-by: Zeng Zhaoming <b32542@freescale.com>
Signed-off-by: Richard Zhu <r65037@freescale.com>
Signed-off-by: Zhou Jingyu <Jingyu.Zhou@freescale.com>
Signed-off-by: Zhang Yan <b34916@freescale.com>
---
 arch/arm/Kconfig                                  |    1 +
 arch/arm/mach-imx/Kconfig                         |    6 +
 arch/arm/mach-mx5/Kconfig                         |   35 +
 arch/arm/mach-mx5/Makefile                        |   11 +-
 arch/arm/mach-mx5/board-mx50_rdp.c                |    5 +-
 arch/arm/mach-mx5/board-mx51_babbage.c            |   29 +-
 arch/arm/mach-mx5/board-mx53_ard.c                |  224 +
 arch/arm/mach-mx5/bus_freq.c                      | 1113 +++++
 arch/arm/mach-mx5/clock-mx51-mx53.c               |   12 +-
 arch/arm/mach-mx5/clock.c                         | 5095 +++++++++++++++++++++
 arch/arm/mach-mx5/cpu.c                           |   53 +-
 arch/arm/mach-mx5/cpu_op-mx51.c                   |   48 +-
 arch/arm/mach-mx5/cpu_op-mx51.h                   |    4 +-
 arch/arm/mach-mx5/cpu_op-mx53.c                   |  159 +
 arch/arm/mach-mx5/cpu_op-mx53.h                   |   43 +
 arch/arm/mach-mx5/crm_regs.h                      |  491 +-
 arch/arm/mach-mx5/devices-imx50.h                 |    5 +-
 arch/arm/mach-mx5/devices-imx51.h                 |    3 +
 arch/arm/mach-mx5/devices-imx53.h                 |   52 +
 arch/arm/mach-mx5/devices.c                       |  112 +-
 arch/arm/mach-mx5/devices.h                       |    9 +
 arch/arm/mach-mx5/mx53_loco_pmic_da9053.c         |  289 ++
 arch/arm/mach-mx5/mx53_smd_pmic_da9053.c          |  314 ++
 arch/arm/mach-mx5/pm.c                            |  281 ++
 arch/arm/mach-mx5/sdram_autogating.c              |  201 +
 arch/arm/mach-mx5/suspend.S                       |  162 +
 arch/arm/mach-mx5/system.c                        |  202 +-
 arch/arm/mach-mx5/usb.h                           |   47 +
 arch/arm/mach-mx5/usb_dr.c                        |  334 ++
 arch/arm/mach-mx5/usb_h1.c                        |  272 ++
 arch/arm/mach-mx5/usb_h2.c                        |  215 +
 arch/arm/plat-mxc/Kconfig                         |   19 +
 arch/arm/plat-mxc/Makefile                        |   12 +-
 arch/arm/plat-mxc/clock.c                         |   21 +-
 arch/arm/plat-mxc/cpu.c                           |   22 +
 arch/arm/plat-mxc/cpufreq.c                       |    4 +-
 arch/arm/plat-mxc/devices/Kconfig                 |   27 +-
 arch/arm/plat-mxc/devices/Makefile                |    8 +
 arch/arm/plat-mxc/devices/platform-ahci-imx.c     |   55 +
 arch/arm/plat-mxc/devices/platform-imx-dma.c      |   36 +-
 arch/arm/plat-mxc/devices/platform-imx-i2c.c      |    1 +
 arch/arm/plat-mxc/devices/platform-imx-iim.c      |   59 +
 arch/arm/plat-mxc/devices/platform-imx-ssi.c      |   10 +
 arch/arm/plat-mxc/devices/platform-imx_dvfs.c     |   53 +
 arch/arm/plat-mxc/devices/platform-imx_ipuv3.c    |  164 +
 arch/arm/plat-mxc/devices/platform-imx_srtc.c     |   53 +
 arch/arm/plat-mxc/devices/platform-imx_tve.c      |   47 +
 arch/arm/plat-mxc/devices/platform-imx_vpu.c      |  121 +
 arch/arm/plat-mxc/devices/platform-mxc_gpu.c      |  107 +
 arch/arm/plat-mxc/devices/platform-mxc_pwm.c      |    9 +
 arch/arm/plat-mxc/dvfs_core.c                     |  994 ++++
 arch/arm/plat-mxc/dvfs_per.c                      |  936 ++++
 arch/arm/plat-mxc/gpio.c                          |    5 +-
 arch/arm/plat-mxc/include/mach/ahci_sata.h        |   51 +
 arch/arm/plat-mxc/include/mach/arc_otg.h          |  377 ++
 arch/arm/plat-mxc/include/mach/clock.h            |   13 +-
 arch/arm/plat-mxc/include/mach/common.h           |   10 +-
 arch/arm/plat-mxc/include/mach/devices-common.h   |   81 +
 arch/arm/plat-mxc/include/mach/dvfs_dptc_struct.h |  169 +
 arch/arm/plat-mxc/include/mach/fsl_usb.h          |  100 +
 arch/arm/plat-mxc/include/mach/fsl_usb_gadget.h   |   40 +
 arch/arm/plat-mxc/include/mach/iomux-mx53.h       |   31 +-
 arch/arm/plat-mxc/include/mach/ipu-v3.h           |   38 +
 arch/arm/plat-mxc/include/mach/memory.h           |   36 +-
 arch/arm/plat-mxc/include/mach/mx51.h             |   32 +-
 arch/arm/plat-mxc/include/mach/mx53.h             |   67 +-
 arch/arm/plat-mxc/include/mach/mxc.h              |   58 +-
 arch/arm/plat-mxc/include/mach/mxc91231.h         |  256 ++
 arch/arm/plat-mxc/include/mach/mxc_dvfs.h         |  276 ++
 arch/arm/plat-mxc/include/mach/mxc_edid.h         |   40 +
 arch/arm/plat-mxc/include/mach/mxc_vpu.h          |   99 +
 arch/arm/plat-mxc/include/mach/sdram_autogating.h |   56 +
 arch/arm/plat-mxc/include/mach/system.h           |   36 +-
 arch/arm/plat-mxc/isp1504xc.c                     |  275 ++
 arch/arm/plat-mxc/pwm.c                           |    3 +-
 arch/arm/plat-mxc/serialxc.c                      |   64 +
 arch/arm/plat-mxc/usb_common.c                    |  908 ++++
 arch/arm/plat-mxc/usb_wakeup.c                    |  224 +
 arch/arm/plat-mxc/utmixc.c                        |  108 +
 79 files changed, 15803 insertions(+), 235 deletions(-)
 mode change 100644 => 100755 arch/arm/Kconfig
 mode change 100644 => 100755 arch/arm/mach-imx/Kconfig
 mode change 100644 => 100755 arch/arm/mach-mx5/Kconfig
 mode change 100644 => 100755 arch/arm/mach-mx5/Makefile
 mode change 100644 => 100755 arch/arm/mach-mx5/board-mx50_rdp.c
 mode change 100644 => 100755 arch/arm/mach-mx5/board-mx51_babbage.c
 create mode 100755 arch/arm/mach-mx5/board-mx53_ard.c
 create mode 100755 arch/arm/mach-mx5/bus_freq.c
 mode change 100644 => 100755 arch/arm/mach-mx5/clock-mx51-mx53.c
 create mode 100755 arch/arm/mach-mx5/clock.c
 mode change 100644 => 100755 arch/arm/mach-mx5/cpu.c
 mode change 100644 => 100755 arch/arm/mach-mx5/cpu_op-mx51.c
 mode change 100644 => 100755 arch/arm/mach-mx5/cpu_op-mx51.h
 create mode 100755 arch/arm/mach-mx5/cpu_op-mx53.c
 create mode 100755 arch/arm/mach-mx5/cpu_op-mx53.h
 mode change 100644 => 100755 arch/arm/mach-mx5/crm_regs.h
 mode change 100644 => 100755 arch/arm/mach-mx5/devices-imx50.h
 mode change 100644 => 100755 arch/arm/mach-mx5/devices-imx51.h
 mode change 100644 => 100755 arch/arm/mach-mx5/devices-imx53.h
 mode change 100644 => 100755 arch/arm/mach-mx5/devices.c
 mode change 100644 => 100755 arch/arm/mach-mx5/devices.h
 create mode 100755 arch/arm/mach-mx5/mx53_loco_pmic_da9053.c
 create mode 100755 arch/arm/mach-mx5/mx53_smd_pmic_da9053.c
 create mode 100755 arch/arm/mach-mx5/pm.c
 create mode 100755 arch/arm/mach-mx5/sdram_autogating.c
 create mode 100755 arch/arm/mach-mx5/suspend.S
 mode change 100644 => 100755 arch/arm/mach-mx5/system.c
 create mode 100755 arch/arm/mach-mx5/usb.h
 create mode 100755 arch/arm/mach-mx5/usb_dr.c
 create mode 100755 arch/arm/mach-mx5/usb_h1.c
 create mode 100755 arch/arm/mach-mx5/usb_h2.c
 mode change 100644 => 100755 arch/arm/plat-mxc/Kconfig
 mode change 100644 => 100755 arch/arm/plat-mxc/Makefile
 mode change 100644 => 100755 arch/arm/plat-mxc/clock.c
 mode change 100644 => 100755 arch/arm/plat-mxc/cpu.c
 mode change 100644 => 100755 arch/arm/plat-mxc/cpufreq.c
 mode change 100644 => 100755 arch/arm/plat-mxc/devices/Kconfig
 mode change 100644 => 100755 arch/arm/plat-mxc/devices/Makefile
 create mode 100755 arch/arm/plat-mxc/devices/platform-ahci-imx.c
 mode change 100644 => 100755 arch/arm/plat-mxc/devices/platform-imx-dma.c
 mode change 100644 => 100755 arch/arm/plat-mxc/devices/platform-imx-i2c.c
 create mode 100755 arch/arm/plat-mxc/devices/platform-imx-iim.c
 mode change 100644 => 100755 arch/arm/plat-mxc/devices/platform-imx-ssi.c
 create mode 100755 arch/arm/plat-mxc/devices/platform-imx_dvfs.c
 create mode 100755 arch/arm/plat-mxc/devices/platform-imx_ipuv3.c
 create mode 100755 arch/arm/plat-mxc/devices/platform-imx_srtc.c
 create mode 100755 arch/arm/plat-mxc/devices/platform-imx_tve.c
 create mode 100755 arch/arm/plat-mxc/devices/platform-imx_vpu.c
 create mode 100755 arch/arm/plat-mxc/devices/platform-mxc_gpu.c
 mode change 100644 => 100755 arch/arm/plat-mxc/devices/platform-mxc_pwm.c
 create mode 100755 arch/arm/plat-mxc/dvfs_core.c
 create mode 100755 arch/arm/plat-mxc/dvfs_per.c
 mode change 100644 => 100755 arch/arm/plat-mxc/gpio.c
 create mode 100755 arch/arm/plat-mxc/include/mach/ahci_sata.h
 create mode 100755 arch/arm/plat-mxc/include/mach/arc_otg.h
 mode change 100644 => 100755 arch/arm/plat-mxc/include/mach/clock.h
 mode change 100644 => 100755 arch/arm/plat-mxc/include/mach/common.h
 mode change 100644 => 100755 arch/arm/plat-mxc/include/mach/devices-common.h
 create mode 100755 arch/arm/plat-mxc/include/mach/dvfs_dptc_struct.h
 create mode 100755 arch/arm/plat-mxc/include/mach/fsl_usb.h
 create mode 100755 arch/arm/plat-mxc/include/mach/fsl_usb_gadget.h
 mode change 100644 => 100755 arch/arm/plat-mxc/include/mach/iomux-mx53.h
 create mode 100755 arch/arm/plat-mxc/include/mach/ipu-v3.h
 mode change 100644 => 100755 arch/arm/plat-mxc/include/mach/memory.h
 mode change 100644 => 100755 arch/arm/plat-mxc/include/mach/mx51.h
 mode change 100644 => 100755 arch/arm/plat-mxc/include/mach/mx53.h
 mode change 100644 => 100755 arch/arm/plat-mxc/include/mach/mxc.h
 create mode 100755 arch/arm/plat-mxc/include/mach/mxc91231.h
 create mode 100755 arch/arm/plat-mxc/include/mach/mxc_dvfs.h
 create mode 100755 arch/arm/plat-mxc/include/mach/mxc_edid.h
 create mode 100755 arch/arm/plat-mxc/include/mach/mxc_vpu.h
 create mode 100755 arch/arm/plat-mxc/include/mach/sdram_autogating.h
 mode change 100644 => 100755 arch/arm/plat-mxc/include/mach/system.h
 create mode 100755 arch/arm/plat-mxc/isp1504xc.c
 mode change 100644 => 100755 arch/arm/plat-mxc/pwm.c
 create mode 100755 arch/arm/plat-mxc/serialxc.c
 create mode 100755 arch/arm/plat-mxc/usb_common.c
 create mode 100755 arch/arm/plat-mxc/usb_wakeup.c
 create mode 100755 arch/arm/plat-mxc/utmixc.c

diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
old mode 100644
new mode 100755
index 6ecc1c4..0f643b9
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -377,6 +377,7 @@ config ARCH_MXC
 	select CLKDEV_LOOKUP
 	select CLKSRC_MMIO
 	select HAVE_SCHED_CLOCK
+	select ZONE_DMA
 	help
 	  Support for Freescale MXC/iMX-based family of processors
 
diff --git a/arch/arm/mach-imx/Kconfig b/arch/arm/mach-imx/Kconfig
old mode 100644
new mode 100755
index 59c97a3..edc9a61
--- a/arch/arm/mach-imx/Kconfig
+++ b/arch/arm/mach-imx/Kconfig
@@ -32,6 +32,8 @@ config SOC_IMX25
 	select ARCH_MXC_AUDMUX_V2
 	select ARCH_MXC_IOMUX_V3
 	select MXC_AVIC
+	select IMX_HAVE_PLATFORM_FEC
+	select IMX_HAVE_PLATFORM_MXC_PWM
 
 config SOC_IMX27
 	bool
@@ -40,6 +42,8 @@ config SOC_IMX27
 	select IMX_HAVE_DMA_V1
 	select IMX_HAVE_IOMUX_V1
 	select MXC_AVIC
+	select IMX_HAVE_PLATFORM_FEC
+	select IMX_HAVE_PLATFORM_MXC_PWM
 
 config SOC_IMX31
 	bool
@@ -57,6 +61,8 @@ config SOC_IMX35
 	select HAVE_EPIT
 	select ARCH_MX35
 	select MXC_AVIC
+	select IMX_HAVE_PLATFORM_FEC
+	select IMX_HAVE_PLATFORM_MXC_PWM
 
 
 if ARCH_MX1
diff --git a/arch/arm/mach-mx5/Kconfig b/arch/arm/mach-mx5/Kconfig
old mode 100644
new mode 100755
index 799fbc4..b292de9
--- a/arch/arm/mach-mx5/Kconfig
+++ b/arch/arm/mach-mx5/Kconfig
@@ -31,6 +31,14 @@ config	SOC_IMX51
 	select ARCH_MXC_AUDMUX_V2
 	select ARCH_HAS_CPUFREQ
 	select ARCH_MX5
+	select IMX_HAVE_PLATFORM_FEC
+	select IMX_HAVE_PLATFORM_MXC_PWM
+	select IMX_HAVE_PLATFORM_IMX_IPUV3
+	select IMX_HAVE_PLATFORM_IMX_TVE
+	select IMX_HAVE_PLATFORM_IMX_VPU
+	select IMX_HAVE_PLATFORM_IMX_DVFS
+	select IMX_HAVE_PLATFORM_IMX_SSI
+	select IMX_HAVE_PLATFORM_IMX_IIM
 
 config	SOC_IMX53
 	bool
@@ -40,6 +48,15 @@ config	SOC_IMX53
 	select ARCH_MXC_IOMUX_V3
 	select ARCH_MX5
 	select ARCH_MX53
+	select ARCH_HAS_CPUFREQ
+	select IMX_HAVE_PLATFORM_FEC
+	select IMX_HAVE_PLATFORM_MXC_PWM
+	select IMX_HAVE_PLATFORM_IMX_IPUV3
+	select IMX_HAVE_PLATFORM_IMX_TVE
+	select IMX_HAVE_PLATFORM_IMX_VPU
+	select IMX_HAVE_PLATFORM_IMX_DVFS
+	select IMX_HAVE_PLATFORM_IMX_SSI
+	select IMX_HAVE_PLATFORM_IMX_IIM
 
 if ARCH_MX50_SUPPORTED
 #comment "i.MX50 machines:"
@@ -174,6 +191,7 @@ config MACH_MX53_EVK
 	select IMX_HAVE_PLATFORM_IMX2_WDT
 	select IMX_HAVE_PLATFORM_IMX_UART
 	select IMX_HAVE_PLATFORM_IMX_I2C
+	select IMX_HAVE_PLATFORM_MXC_GPU
 	select IMX_HAVE_PLATFORM_SDHCI_ESDHC_IMX
 	select IMX_HAVE_PLATFORM_SPI_IMX
 	help
@@ -186,7 +204,11 @@ config MACH_MX53_SMD
 	select IMX_HAVE_PLATFORM_IMX2_WDT
 	select IMX_HAVE_PLATFORM_IMX_I2C
 	select IMX_HAVE_PLATFORM_IMX_UART
+	select IMX_HAVE_PLATFORM_IMX_I2C
+	select IMX_HAVE_PLATFORM_MXC_GPU
 	select IMX_HAVE_PLATFORM_SDHCI_ESDHC_IMX
+	select IMX_HAVE_PLATFORM_IMX_SRTC
+	select IMX_HAVE_PLATFORM_SATA_AHCI
 	help
 	  Include support for MX53 SMD platform. This includes specific
 	  configurations for the board and its peripherals.
@@ -197,12 +219,25 @@ config MACH_MX53_LOCO
 	select IMX_HAVE_PLATFORM_IMX2_WDT
 	select IMX_HAVE_PLATFORM_IMX_I2C
 	select IMX_HAVE_PLATFORM_IMX_UART
+	select IMX_HAVE_PLATFORM_IMX_SRTC
+	select IMX_HAVE_PLATFORM_MXC_GPU
 	select IMX_HAVE_PLATFORM_SDHCI_ESDHC_IMX
+	select IMX_HAVE_PLATFORM_SATA_AHCI
 	select IMX_HAVE_PLATFORM_GPIO_KEYS
 	help
 	  Include support for MX53 LOCO platform. This includes specific
 	  configurations for the board and its peripherals.
 
+config MACH_MX53_ARD
+	bool "Support MX53 ARD platform"
+	select SOC_IMX53
+	select IMX_HAVE_PLATFORM_IMX2_WDT
+	select IMX_HAVE_PLATFORM_IMX_UART
+	select IMX_HAVE_PLATFORM_MXC_GPU
+	select IMX_HAVE_PLATFORM_SDHCI_ESDHC_IMX
+	help
+	  Include support for MX53 ARD platform. This includes specific
+	  configurations for the board and its peripherals.
 endif # ARCH_MX53_SUPPORTED
 
 endif
diff --git a/arch/arm/mach-mx5/Makefile b/arch/arm/mach-mx5/Makefile
old mode 100644
new mode 100755
index 0b9338c..8eb96286
--- a/arch/arm/mach-mx5/Makefile
+++ b/arch/arm/mach-mx5/Makefile
@@ -3,15 +3,18 @@
 #
 
 # Object file lists.
-obj-y   := cpu.o mm.o clock-mx51-mx53.o devices.o ehci.o system.o
+obj-y   := cpu.o mm.o clock.o devices.o ehci.o bus_freq.o sdram_autogating.o  \
+pm.o system.o suspend.o usb_dr.o usb_h1.o usb_h2.o
+
 obj-$(CONFIG_SOC_IMX50) += mm-mx50.o
 
-obj-$(CONFIG_CPU_FREQ_IMX)    += cpu_op-mx51.o
+obj-$(CONFIG_CPU_FREQ_IMX)    += cpu_op-mx51.o cpu_op-mx53.o
 obj-$(CONFIG_MACH_MX51_BABBAGE) += board-mx51_babbage.o
 obj-$(CONFIG_MACH_MX51_3DS) += board-mx51_3ds.o
 obj-$(CONFIG_MACH_MX53_EVK) += board-mx53_evk.o
-obj-$(CONFIG_MACH_MX53_SMD) += board-mx53_smd.o
-obj-$(CONFIG_MACH_MX53_LOCO) += board-mx53_loco.o
+obj-$(CONFIG_MACH_MX53_SMD) += board-mx53_smd.o mx53_smd_pmic_da9053.o
+obj-$(CONFIG_MACH_MX53_LOCO) += board-mx53_loco.o mx53_loco_pmic_da9053.o
+obj-$(CONFIG_MACH_MX53_ARD) += board-mx53_ard.o
 obj-$(CONFIG_MACH_EUKREA_CPUIMX51) += board-cpuimx51.o
 obj-$(CONFIG_MACH_EUKREA_MBIMX51_BASEBOARD) += eukrea_mbimx51-baseboard.o
 obj-$(CONFIG_MACH_EUKREA_CPUIMX51SD) += board-cpuimx51sd.o
diff --git a/arch/arm/mach-mx5/board-mx50_rdp.c b/arch/arm/mach-mx5/board-mx50_rdp.c
old mode 100644
new mode 100755
index 11210e1..c64403c
--- a/arch/arm/mach-mx5/board-mx50_rdp.c
+++ b/arch/arm/mach-mx5/board-mx50_rdp.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2010-2011 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -187,6 +187,8 @@ static const struct imxi2c_platform_data i2c_data __initconst = {
 	.bitrate = 100000,
 };
 
+static int z160_revision __initdata = 1;
+
 /*
  * Board specific initialization.
  */
@@ -202,6 +204,7 @@ static void __init mx50_rdp_board_init(void)
 	imx50_add_imx_i2c(0, &i2c_data);
 	imx50_add_imx_i2c(1, &i2c_data);
 	imx50_add_imx_i2c(2, &i2c_data);
+	imx50_add_mxc_gpu(&z160_revision);
 }
 
 static void __init mx50_rdp_timer_init(void)
diff --git a/arch/arm/mach-mx5/board-mx51_babbage.c b/arch/arm/mach-mx5/board-mx51_babbage.c
old mode 100644
new mode 100755
index c7b3fab..a555871
--- a/arch/arm/mach-mx5/board-mx51_babbage.c
+++ b/arch/arm/mach-mx5/board-mx51_babbage.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
  * Copyright (C) 2009-2010 Amit Kucheria <amit.kucheria@canonical.com>
  *
  * The code contained herein is licensed under the GNU General Public
@@ -32,6 +32,7 @@
 
 #include "devices-imx51.h"
 #include "devices.h"
+#include "crm_regs.h"
 #include "cpu_op-mx51.h"
 
 #define BABBAGE_USB_HUB_RESET	IMX_GPIO_NR(1, 7)
@@ -169,6 +170,21 @@ static struct imxi2c_platform_data babbage_hsi2c_data = {
 	.bitrate = 400000,
 };
 
+static void babbage_suspend_enter()
+{
+}
+
+static void babbage_suspend_exit()
+{
+	/*clear the EMPGC0/1 bits */
+	__raw_writel(0, MXC_SRPG_EMPGC0_SRPGCR);
+	__raw_writel(0, MXC_SRPG_EMPGC1_SRPGCR);
+}
+
+static struct mxc_pm_platform_data babbage_pm_data = {
+	.suspend_enter = babbage_suspend_enter,
+	.suspend_exit = babbage_suspend_exit,
+};
 static int gpio_usbh1_active(void)
 {
 	iomux_v3_cfg_t usbh1stp_gpio = MX51_PAD_USBH1_STP__GPIO1_27;
@@ -331,6 +347,8 @@ static const struct spi_imx_master mx51_babbage_spi_pdata __initconst = {
 	.num_chipselect = ARRAY_SIZE(mx51_babbage_spi_cs),
 };
 
+static int z160_revision __initdata;
+
 /*
  * Board specific initialization.
  */
@@ -340,9 +358,6 @@ static void __init mx51_babbage_init(void)
 	iomux_v3_cfg_t power_key = _MX51_PAD_EIM_A27__GPIO2_21 |
 		MUX_PAD_CTRL(PAD_CTL_SRE_FAST | PAD_CTL_DSE_HIGH | PAD_CTL_PUS_100K_UP);
 
-#if defined(CONFIG_CPU_FREQ_IMX)
-	get_cpu_op = mx51_get_cpu_op;
-#endif
 	mxc_iomux_v3_setup_multiple_pads(mx51babbage_pads,
 					ARRAY_SIZE(mx51babbage_pads));
 
@@ -360,8 +375,9 @@ static void __init mx51_babbage_init(void)
 	imx51_add_imx_i2c(0, &babbage_i2c_data);
 	imx51_add_imx_i2c(1, &babbage_i2c_data);
 	mxc_register_device(&mxc_hsi2c_device, &babbage_hsi2c_data);
+	mxc_register_device(&mxc_pm_device, &babbage_pm_data);
 
-	if (otg_mode_host)
+	/*if (otg_mode_host)
 		mxc_register_device(&mxc_usbdr_host_device, &dr_utmi_config);
 	else {
 		initialize_otg_port(NULL);
@@ -369,7 +385,7 @@ static void __init mx51_babbage_init(void)
 	}
 
 	gpio_usbh1_active();
-	mxc_register_device(&mxc_usbh1_device, &usbh1_config);
+	mxc_register_device(&mxc_usbh1_device, &usbh1_config);*/
 	/* setback USBH1_STP to be function */
 	mxc_iomux_v3_setup_pad(usbh1stp);
 	babbage_usbhub_reset();
@@ -381,6 +397,7 @@ static void __init mx51_babbage_init(void)
 		ARRAY_SIZE(mx51_babbage_spi_board_info));
 	imx51_add_ecspi(0, &mx51_babbage_spi_pdata);
 	imx51_add_imx2_wdt(0, NULL);
+	imx51_add_mxc_gpu(&z160_revision);
 }
 
 static void __init mx51_babbage_timer_init(void)
diff --git a/arch/arm/mach-mx5/board-mx53_ard.c b/arch/arm/mach-mx5/board-mx53_ard.c
new file mode 100755
index 0000000..521bffd
--- /dev/null
+++ b/arch/arm/mach-mx5/board-mx53_ard.c
@@ -0,0 +1,224 @@
+/*
+ * Copyright (C) 2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <linux/init.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/gpio.h>
+#include <linux/smsc911x.h>
+
+#include <mach/common.h>
+#include <mach/hardware.h>
+#include <mach/imx-uart.h>
+#include <mach/iomux-mx53.h>
+
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/time.h>
+
+#include "crm_regs.h"
+#include "devices-imx53.h"
+
+#define ARD_SD1_WP IMX_GPIO_NR(1, 9)
+#define ARD_SD2_WP IMX_GPIO_NR(1, 2)
+#define ARD_ETHERNET_INT_B IMX_GPIO_NR(2, 31)
+
+static iomux_v3_cfg_t mx53_ard_pads[] = {
+	/* UART */
+	MX53_PAD_PATA_DIOW__UART1_TXD_MUX,
+	MX53_PAD_PATA_DMACK__UART1_RXD_MUX,
+	MX53_PAD_PATA_BUFFER_EN__UART2_RXD_MUX,
+	MX53_PAD_PATA_DMARQ__UART2_TXD_MUX,
+	MX53_PAD_PATA_DIOR__UART2_RTS,
+	MX53_PAD_PATA_INTRQ__UART2_CTS,
+	MX53_PAD_PATA_CS_0__UART3_TXD_MUX,
+	MX53_PAD_PATA_CS_1__UART3_RXD_MUX,
+	MX53_PAD_PATA_DA_1__UART3_CTS,
+	MX53_PAD_PATA_DA_2__UART3_RTS,
+
+	/* SDHC1 */
+	MX53_PAD_SD1_CMD__ESDHC1_CMD,
+	MX53_PAD_SD1_CLK__ESDHC1_CLK,
+	MX53_PAD_SD1_DATA0__ESDHC1_DAT0,
+	MX53_PAD_SD1_DATA1__ESDHC1_DAT1,
+	MX53_PAD_SD1_DATA2__ESDHC1_DAT2,
+	MX53_PAD_SD1_DATA3__ESDHC1_DAT3,
+	MX53_PAD_PATA_DATA8__ESDHC1_DAT4,
+	MX53_PAD_PATA_DATA9__ESDHC1_DAT5,
+	MX53_PAD_PATA_DATA10__ESDHC1_DAT6,
+	MX53_PAD_PATA_DATA11__ESDHC1_DAT7,
+	MX53_PAD_GPIO_1__GPIO1_1,
+	MX53_PAD_GPIO_9__GPIO1_9,
+
+	/* SDHC2 */
+	MX53_PAD_SD2_CLK__ESDHC2_CLK,
+	MX53_PAD_SD2_CMD__ESDHC2_CMD,
+	MX53_PAD_SD2_DATA0__ESDHC2_DAT0,
+	MX53_PAD_SD2_DATA1__ESDHC2_DAT1,
+	MX53_PAD_SD2_DATA2__ESDHC2_DAT2,
+	MX53_PAD_SD2_DATA3__ESDHC2_DAT3,
+	MX53_PAD_PATA_DATA12__ESDHC2_DAT4,
+	MX53_PAD_PATA_DATA13__ESDHC2_DAT5,
+	MX53_PAD_PATA_DATA14__ESDHC2_DAT6,
+	MX53_PAD_PATA_DATA15__ESDHC2_DAT7,
+	MX53_PAD_GPIO_4__GPIO1_4,
+	MX53_PAD_GPIO_2__GPIO1_2,
+
+	/* WEIM for CS1 */
+	/* ETHERNET_INT_B */
+	MX53_PAD_EIM_EB3__GPIO2_31,
+	MX53_PAD_EIM_D16__EMI_WEIM_D_16,
+	MX53_PAD_EIM_D17__EMI_WEIM_D_17,
+	MX53_PAD_EIM_D18__EMI_WEIM_D_18,
+	MX53_PAD_EIM_D19__EMI_WEIM_D_19,
+	MX53_PAD_EIM_D20__EMI_WEIM_D_20,
+	MX53_PAD_EIM_D21__EMI_WEIM_D_21,
+	MX53_PAD_EIM_D22__EMI_WEIM_D_22,
+	MX53_PAD_EIM_D23__EMI_WEIM_D_23,
+	MX53_PAD_EIM_D24__EMI_WEIM_D_24,
+	MX53_PAD_EIM_D25__EMI_WEIM_D_25,
+	MX53_PAD_EIM_D26__EMI_WEIM_D_26,
+	MX53_PAD_EIM_D27__EMI_WEIM_D_27,
+	MX53_PAD_EIM_D28__EMI_WEIM_D_28,
+	MX53_PAD_EIM_D29__EMI_WEIM_D_29,
+	MX53_PAD_EIM_D30__EMI_WEIM_D_30,
+	MX53_PAD_EIM_D31__EMI_WEIM_D_31,
+	MX53_PAD_EIM_DA0__EMI_NAND_WEIM_DA_0,
+	MX53_PAD_EIM_DA1__EMI_NAND_WEIM_DA_1,
+	MX53_PAD_EIM_DA2__EMI_NAND_WEIM_DA_2,
+	MX53_PAD_EIM_DA3__EMI_NAND_WEIM_DA_3,
+	MX53_PAD_EIM_DA4__EMI_NAND_WEIM_DA_4,
+	MX53_PAD_EIM_DA5__EMI_NAND_WEIM_DA_5,
+	MX53_PAD_EIM_DA6__EMI_NAND_WEIM_DA_6,
+	MX53_PAD_EIM_OE__EMI_WEIM_OE,
+	MX53_PAD_EIM_RW__EMI_WEIM_RW,
+	MX53_PAD_EIM_CS1__EMI_WEIM_CS_1,
+};
+
+/* Config CS1 settings for ethernet controller */
+static void weim_cs_config(void)
+{
+	u32 reg;
+	void __iomem *weim_base, *iomuxc_base;
+	weim_base = ioremap(MX53_WEIM_BASE_ADDR, SZ_4K);
+	iomuxc_base = ioremap(MX53_IOMUXC_BASE_ADDR, SZ_4K);
+
+	/* CS1 timings for LAN9220 */
+	writel(0x20001, (weim_base + 0x18));
+	writel(0x0, (weim_base + 0x1C));
+	writel(0x16000202, (weim_base + 0x20));
+	writel(0x00000002, (weim_base + 0x24));
+	writel(0x16002082, (weim_base + 0x28));
+	writel(0x00000000, (weim_base + 0x2C));
+	writel(0x00000000, (weim_base + 0x90));
+
+	/* specify 64 MB on CS1 and CS0 on GPR1 */
+	reg = readl(iomuxc_base + 0x4);
+	reg &= ~0x3F;
+	reg |= 0x1B;
+	writel(reg, (iomuxc_base + 0x4));
+	iounmap(iomuxc_base);
+	iounmap(weim_base);
+}
+
+static struct resource ard_smsc911x_resources[] = {
+	{
+	 .start = MX53_CS1_BASE_ADDR,
+	 .end = MX53_CS1_BASE_ADDR + SZ_4K - 1,
+	 .flags = IORESOURCE_MEM,
+	},
+	{
+	 .start =  gpio_to_irq(ARD_ETHERNET_INT_B),
+	 .end =  gpio_to_irq(ARD_ETHERNET_INT_B),
+	 .flags = IORESOURCE_IRQ,
+	},
+};
+
+
+struct smsc911x_platform_config ard_smsc911x_config = {
+	.irq_polarity = SMSC911X_IRQ_POLARITY_ACTIVE_LOW,
+	.irq_type = SMSC911X_IRQ_TYPE_PUSH_PULL,
+	.flags = SMSC911X_USE_32BIT,
+};
+
+static struct platform_device ard_smsc_lan9220_device = {
+	.name = "smsc911x",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(ard_smsc911x_resources),
+	.resource = ard_smsc911x_resources,
+};
+
+
+static const struct imxuart_platform_data mx53_ard_uart_data __initconst = {
+	.flags = IMXUART_HAVE_RTSCTS,
+};
+
+static const struct esdhc_platform_data mx53_ard_sd0_data __initconst = {
+	.wp_gpio = ARD_SD1_WP,
+};
+
+static const struct esdhc_platform_data mx53_ard_sd1_data __initconst = {
+	.wp_gpio = ARD_SD2_WP,
+};
+
+static inline void mx53_ard_init_uart(void)
+{
+	imx53_add_imx_uart(0, NULL);
+	imx53_add_imx_uart(1, &mx53_ard_uart_data);
+	imx53_add_imx_uart(2, &mx53_ard_uart_data);
+}
+
+static void __init mx53_ard_io_init(void)
+{
+	/* MX53 ARD board */
+	pr_info("MX53 ARD board \n");
+	gpio_request(ARD_ETHERNET_INT_B, "eth-int-b");
+	gpio_direction_input(ARD_ETHERNET_INT_B);
+}
+static void __init mx53_ard_board_init(void)
+{
+	mxc_iomux_v3_setup_multiple_pads(mx53_ard_pads,
+					ARRAY_SIZE(mx53_ard_pads));
+	mx53_ard_init_uart();
+	imx53_add_imx2_wdt(0, NULL);
+	imx53_add_sdhci_esdhc_imx(0, &mx53_ard_sd0_data);
+	imx53_add_sdhci_esdhc_imx(1, &mx53_ard_sd1_data);
+
+	weim_cs_config();
+	mx53_ard_io_init();
+	mxc_register_device(&ard_smsc_lan9220_device, &ard_smsc911x_config);
+}
+
+static void __init mx53_ard_timer_init(void)
+{
+	mx53_clocks_init(32768, 24000000, 22579200, 0);
+}
+
+static struct sys_timer mx53_ard_timer = {
+	.init	= mx53_ard_timer_init,
+};
+
+MACHINE_START(MX53_ARD, "Freescale MX53 ARD Board")
+	.map_io = mx53_map_io,
+	.init_early = imx53_init_early,
+	.init_irq = mx53_init_irq,
+	.timer = &mx53_ard_timer,
+	.init_machine = mx53_ard_board_init,
+MACHINE_END
diff --git a/arch/arm/mach-mx5/bus_freq.c b/arch/arm/mach-mx5/bus_freq.c
new file mode 100755
index 0000000..4cf5a33
--- /dev/null
+++ b/arch/arm/mach-mx5/bus_freq.c
@@ -0,0 +1,1113 @@
+/*
+ * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file bus_freq.c
+ *
+ * @brief A common API for the Freescale Semiconductor i.MXC CPUfreq module
+ * and DVFS CORE module.
+ *
+ * The APIs are for setting bus frequency to low or high.
+ *
+ * @ingroup PM
+ */
+#include <asm/io.h>
+#include <linux/sched.h>
+#include <linux/proc_fs.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
+#include <linux/mutex.h>
+#include <mach/iram.h>
+#include <mach/hardware.h>
+#include <mach/clock.h>
+#include <mach/mxc_dvfs.h>
+#include <mach/sdram_autogating.h>
+#include <asm/mach/map.h>
+#include <asm/mach-types.h>
+#include <asm/cacheflush.h>
+#include <asm/tlb.h>
+#include "crm_regs.h"
+
+#define LP_LOW_VOLTAGE		1050000
+#define LP_NORMAL_VOLTAGE		1250000
+#define LP_APM_CLK   			24000000
+#define NAND_LP_APM_CLK			12000000
+#define AXI_A_NORMAL_CLK		166250000
+#define AXI_A_CLK_NORMAL_DIV		4
+#define AXI_B_CLK_NORMAL_DIV		5
+#define AHB_CLK_NORMAL_DIV		AXI_B_CLK_NORMAL_DIV
+#define EMI_SLOW_CLK_NORMAL_DIV		AXI_B_CLK_NORMAL_DIV
+#define NFC_CLK_NORMAL_DIV      	4
+#define SPIN_DELAY	1000000 /* in nanoseconds */
+#define HW_QOS_DISABLE		0x70
+#define HW_QOS_DISABLE_SET		0x74
+#define HW_QOS_DISABLE_CLR		0x78
+#define DDR_TYPE_DDR3		0x0
+#define DDR_TYPE_DDR2		0x1
+
+DEFINE_SPINLOCK(ddr_freq_lock);
+
+static unsigned long lp_normal_rate;
+static unsigned long lp_med_rate;
+static unsigned long ddr_normal_rate;
+static unsigned long ddr_med_rate;
+static unsigned long ddr_low_rate;
+static int cur_ddr_rate;
+static unsigned char mx53_ddr_type;
+
+static struct clk *ddr_clk;
+static struct clk *pll1_sw_clk;
+static struct clk *pll1;
+static struct clk *pll2;
+static struct clk *pll3;
+static struct clk *pll4;
+static struct clk *main_bus_clk;
+static struct clk *axi_a_clk;
+static struct clk *axi_b_clk;
+static struct clk *cpu_clk;
+static struct clk *ddr_hf_clk;
+static struct clk *ahb_clk;
+static struct clk *ddr_clk;
+static struct clk *periph_apm_clk;
+static struct clk *lp_apm;
+static struct clk *gpc_dvfs_clk;
+static struct clk *emi_garb_clk;
+static struct clk *epdc_clk;
+
+static void __iomem *pll1_base;
+static void __iomem *pll4_base;
+
+static void __iomem *qosc_base;
+
+struct regulator *pll_regulator;
+
+struct regulator *lp_regulator;
+int low_bus_freq_mode;
+int high_bus_freq_mode;
+int med_bus_freq_mode;
+
+int bus_freq_scaling_initialized;
+char *gp_reg_id;
+char *lp_reg_id;
+
+static struct cpu_op *cpu_op_tbl;
+static struct device *busfreq_dev;
+static int busfreq_suspended;
+static int cpu_podf;
+/* True if bus_frequency is scaled not using DVFS-PER */
+int bus_freq_scaling_is_active;
+
+int cpu_op_nr;
+int lp_high_freq;
+int lp_med_freq;
+
+static int lp_voltage;
+struct workqueue_struct *voltage_wq;
+static struct work_struct voltage_change_handler;
+struct completion voltage_change_cmpl;
+
+void enter_lpapm_mode_mx50(void);
+void enter_lpapm_mode_mx51(void);
+void enter_lpapm_mode_mx53(void);
+void exit_lpapm_mode_mx50(int high_bus_freq);
+void exit_lpapm_mode_mx51(void);
+void exit_lpapm_mode_mx53(void);
+int low_freq_bus_used(void);
+void set_ddr_freq(int ddr_freq);
+void *ddr_freq_change_iram_base;
+void (*change_ddr_freq)(void *ccm_addr, void *databahn_addr, u32 freq) = NULL;
+
+extern void mx50_ddr_freq_change(u32 ccm_base,
+					u32 databahn_addr, u32 freq);
+extern int dvfs_core_is_active;
+extern struct cpu_op *(*get_cpu_op)(int *op);
+extern void __iomem *ccm_base;
+extern void __iomem *databahn_base;
+
+struct dvfs_wp dvfs_core_setpoint[] = {
+						{33, 8, 33, 10, 10, 0x08},
+						{26, 0, 33, 20, 10, 0x08},
+						{28, 8, 33, 20, 30, 0x08},
+						{29, 0, 33, 20, 10, 0x08},};
+
+static DEFINE_SPINLOCK(voltage_lock);
+struct mutex bus_freq_mutex;
+
+struct timeval start_time;
+struct timeval end_time;
+
+static void voltage_work_handler(struct work_struct *work)
+{
+	if (lp_regulator != NULL) {
+		u32 ret = 0;
+		ret = regulator_set_voltage(lp_regulator,
+					lp_voltage, lp_voltage);
+		udelay(400);
+		if (ret < 0) {
+			printk(KERN_ERR "COULD NOT SET LP VOLTAGE!!!!!!\n");
+			return;
+		}
+	}
+	complete_all(&voltage_change_cmpl);
+}
+
+int set_low_bus_freq(void)
+{
+	if (busfreq_suspended)
+		return 0;
+	if (bus_freq_scaling_initialized) {
+		/* can not enter low bus freq, when cpu is in higher freq
+		 * or only have one working point */
+		if ((clk_get_rate(cpu_clk) >
+				cpu_op_tbl[cpu_op_nr - 1].cpu_rate)
+			|| (cpu_op_nr == 1)) {
+			return 0;
+		}
+
+		mutex_lock(&bus_freq_mutex);
+
+		stop_dvfs_per();
+
+		stop_sdram_autogating();
+
+		if (cpu_is_mx50())
+			enter_lpapm_mode_mx50();
+		else if (cpu_is_mx51())
+			enter_lpapm_mode_mx51();
+		else
+			enter_lpapm_mode_mx53();
+		mutex_unlock(&bus_freq_mutex);
+	}
+	return 0;
+}
+
+void enter_lpapm_mode_mx50()
+{
+	u32 reg;
+	unsigned long flags;
+	spin_lock_irqsave(&ddr_freq_lock, flags);
+
+	set_ddr_freq(LP_APM_CLK);
+	/* Set the parent of main_bus_clk to be PLL3 */
+	clk_set_parent(main_bus_clk, pll3);
+
+	/* Set the AHB dividers to be 2.
+	 * Set the dividers so that clock rates
+	 * are not greater than current clock rate.
+	 */
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	reg &= ~(MXC_CCM_CBCDR_AXI_A_PODF_MASK
+			| MXC_CCM_CBCDR_AXI_B_PODF_MASK
+			| MXC_CCM_CBCDR_AHB_PODF_MASK
+			| MX50_CCM_CBCDR_WEIM_PODF_MASK);
+	reg |= (1 << MXC_CCM_CBCDR_AXI_A_PODF_OFFSET
+			| 1 << MXC_CCM_CBCDR_AXI_B_PODF_OFFSET
+			| 1 << MXC_CCM_CBCDR_AHB_PODF_OFFSET
+			| 0 << MX50_CCM_CBCDR_WEIM_PODF_OFFSET);
+	__raw_writel(reg, MXC_CCM_CBCDR);
+	while (__raw_readl(MXC_CCM_CDHIPR) & 0x0F)
+		udelay(10);
+
+	low_bus_freq_mode = 1;
+	high_bus_freq_mode = 0;
+	med_bus_freq_mode = 0;
+
+	/* Set the source of main_bus_clk to be lp-apm. */
+	clk_set_parent(main_bus_clk, lp_apm);
+
+	/* Set the AHB dividers to be 1. */
+	/* Set the dividers to be  1, so the clock rates
+	 * are at 24Mhz
+	 */
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	reg &= ~(MXC_CCM_CBCDR_AXI_A_PODF_MASK
+			| MXC_CCM_CBCDR_AXI_B_PODF_MASK
+			| MXC_CCM_CBCDR_AHB_PODF_MASK
+			| MX50_CCM_CBCDR_WEIM_PODF_MASK);
+	reg |= (0 << MXC_CCM_CBCDR_AXI_A_PODF_OFFSET
+			| 0 << MXC_CCM_CBCDR_AXI_B_PODF_OFFSET
+			| 0 << MXC_CCM_CBCDR_AHB_PODF_OFFSET
+			| 0 << MX50_CCM_CBCDR_WEIM_PODF_OFFSET);
+	__raw_writel(reg, MXC_CCM_CBCDR);
+	while (__raw_readl(MXC_CCM_CDHIPR) & 0x0F)
+		udelay(10);
+
+	spin_unlock_irqrestore(&ddr_freq_lock, flags);
+
+	spin_lock_irqsave(&voltage_lock, flags);
+	lp_voltage = LP_LOW_VOLTAGE;
+	INIT_COMPLETION(voltage_change_cmpl);
+	queue_work(voltage_wq, &voltage_change_handler);
+	spin_unlock_irqrestore(&voltage_lock, flags);
+
+	if (clk_get_usecount(pll1_sw_clk) == 1) {
+		/* Relock PLL1 to 160MHz. */
+		clk_set_parent(pll1_sw_clk, pll2);
+		/* Set the divider to ARM_PODF to 3. */
+		__raw_writel(0x02, MXC_CCM_CACRR);
+
+		clk_set_rate(pll1, 160000000);
+		clk_set_parent(pll1_sw_clk, pll1);
+		/* Set the divider to ARM_PODF to 1. */
+		__raw_writel(0x0, MXC_CCM_CACRR);
+	}
+
+	udelay(100);
+}
+
+void enter_lpapm_mode_mx51()
+{
+	u32 reg;
+	/* Set PLL3 to 133Mhz if no-one is using it. */
+	if (clk_get_usecount(pll3) == 0) {
+		u32 pll3_rate = clk_get_rate(pll3);
+
+		clk_enable(pll3);
+		clk_set_rate(pll3, clk_round_rate(pll3, 133000000));
+
+		/*Change the DDR freq to 133Mhz. */
+		clk_set_rate(ddr_hf_clk,
+		     clk_round_rate(ddr_hf_clk, ddr_low_rate));
+
+		/* Set the parent of Periph_apm_clk to be PLL3 */
+		clk_set_parent(periph_apm_clk, pll3);
+		clk_set_parent(main_bus_clk, periph_apm_clk);
+
+		/* Set the dividers to be  1, so the clock rates
+		  * are at 133MHz.
+		  */
+		reg = __raw_readl(MXC_CCM_CBCDR);
+		reg &= ~(MXC_CCM_CBCDR_AXI_A_PODF_MASK
+				| MXC_CCM_CBCDR_AXI_B_PODF_MASK
+				| MXC_CCM_CBCDR_AHB_PODF_MASK
+				| MXC_CCM_CBCDR_EMI_PODF_MASK
+				| MXC_CCM_CBCDR_NFC_PODF_OFFSET);
+		reg |= (0 << MXC_CCM_CBCDR_AXI_A_PODF_OFFSET
+				| 0 << MXC_CCM_CBCDR_AXI_B_PODF_OFFSET
+				| 0 << MXC_CCM_CBCDR_AHB_PODF_OFFSET
+				| 0 << MXC_CCM_CBCDR_EMI_PODF_OFFSET
+				| 3 << MXC_CCM_CBCDR_NFC_PODF_OFFSET);
+		__raw_writel(reg, MXC_CCM_CBCDR);
+
+		clk_enable(emi_garb_clk);
+		while (__raw_readl(MXC_CCM_CDHIPR) & 0x1F)
+			udelay(10);
+		clk_disable(emi_garb_clk);
+
+		low_bus_freq_mode = 1;
+		high_bus_freq_mode = 0;
+		med_bus_freq_mode = 0;
+
+		/* Set the source of Periph_APM_Clock to be lp-apm. */
+		clk_set_parent(periph_apm_clk, lp_apm);
+
+		/* Set PLL3 back to original rate. */
+		clk_set_rate(pll3, clk_round_rate(pll3, pll3_rate));
+		clk_disable(pll3);
+	}
+}
+
+void enter_lpapm_mode_mx53()
+{
+	u32 reg;
+	struct timespec nstimeofday;
+	struct timespec curtime;
+
+	/* TBD: Reduce DDR frequency for DDR2 */
+	/* if (mx53_ddr_type == DDR_TYPE_DDR2) {
+	} */
+
+	/* move cpu clk to pll2, 400 / 3 = 133Mhz for cpu  */
+    /* Change the source of pll1_sw_clk to be the step_clk */
+    reg = __raw_readl(MXC_CCM_CCSR);
+    reg |= MXC_CCM_CCSR_PLL1_SW_CLK_SEL;
+    __raw_writel(reg, MXC_CCM_CCSR);
+
+	cpu_podf = __raw_readl(MXC_CCM_CACRR);
+	reg = __raw_readl(MXC_CCM_CDHIPR);
+	if ((reg & MXC_CCM_CDHIPR_ARM_PODF_BUSY) == 0)
+		__raw_writel(0x2, MXC_CCM_CACRR);
+	else
+		printk(KERN_DEBUG "ARM_PODF still in busy!!!!\n");
+	clk_set_parent(pll1_sw_clk, pll2);
+
+	/* ahb = pll2/8, axi_b = pll2/8, axi_a = pll2/1*/
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	reg &= ~(MXC_CCM_CBCDR_AXI_A_PODF_MASK
+		| MXC_CCM_CBCDR_AXI_B_PODF_MASK
+		| MXC_CCM_CBCDR_AHB_PODF_MASK);
+	reg |= (0 << MXC_CCM_CBCDR_AXI_A_PODF_OFFSET
+		| 7 << MXC_CCM_CBCDR_AXI_B_PODF_OFFSET
+		| 7 << MXC_CCM_CBCDR_AHB_PODF_OFFSET);
+	__raw_writel(reg, MXC_CCM_CBCDR);
+
+	getnstimeofday(&nstimeofday);
+	while (__raw_readl(MXC_CCM_CDHIPR) &
+			(MXC_CCM_CDHIPR_AXI_A_PODF_BUSY |
+			 MXC_CCM_CDHIPR_AXI_B_PODF_BUSY |
+			 MXC_CCM_CDHIPR_AHB_PODF_BUSY)) {
+			getnstimeofday(&curtime);
+		if (curtime.tv_nsec - nstimeofday.tv_nsec
+			       > SPIN_DELAY)
+			panic("low bus freq set rate error\n");
+	}
+
+	/* keep this infront of propagating */
+	low_bus_freq_mode = 1;
+	high_bus_freq_mode = 0;
+	med_bus_freq_mode = 0;
+
+	if (clk_get_usecount(pll1) == 0) {
+		reg = __raw_readl(pll1_base + MXC_PLL_DP_CTL);
+		reg &= ~MXC_PLL_DP_CTL_UPEN;
+		__raw_writel(reg, pll1_base + MXC_PLL_DP_CTL);
+	}
+	if (clk_get_usecount(pll4) == 0) {
+		reg = __raw_readl(pll4_base + MXC_PLL_DP_CTL);
+		reg &= ~MXC_PLL_DP_CTL_UPEN;
+		__raw_writel(reg, pll4_base + MXC_PLL_DP_CTL);
+	}
+}
+
+int set_high_bus_freq(int high_bus_freq)
+{
+	u32 reg;
+	if (bus_freq_scaling_initialized) {
+		mutex_lock(&bus_freq_mutex);
+		/*
+		 * If the CPU freq is 800MHz, set the bus to the high
+		 * setpoint (133MHz) and DDR to 200MHz.
+		 */
+		if ((clk_get_rate(cpu_clk) >
+				cpu_op_tbl[cpu_op_nr - 1].cpu_rate)
+				|| lp_high_freq)
+			high_bus_freq = 1;
+
+		stop_sdram_autogating();
+
+		if (low_bus_freq_mode) {
+			/* Relock PLL3 to 133MHz */
+			if (cpu_is_mx50())
+				exit_lpapm_mode_mx50(high_bus_freq);
+			else if (cpu_is_mx51())
+				exit_lpapm_mode_mx51();
+			else
+				exit_lpapm_mode_mx53();
+			start_dvfs_per();
+		}
+		if (bus_freq_scaling_is_active) {
+			if (!high_bus_freq_mode && high_bus_freq) {
+				if (cpu_is_mx50()) {
+					if (med_bus_freq_mode) {
+						/* Increase SYS_CLK */
+						reg = __raw_readl(MXC_CCM_CLK_SYS);
+						reg &= ~MXC_CCM_CLK_SYS_DIV_PLL_MASK;
+						reg |= 4 << MXC_CCM_CLK_SYS_DIV_PLL_OFFSET;
+						__raw_writel(reg, MXC_CCM_CLK_SYS);
+
+						/* Set the dividers to the default dividers */
+						reg = __raw_readl(MXC_CCM_CBCDR);
+						reg &= ~(MXC_CCM_CBCDR_AXI_A_PODF_MASK
+							| MXC_CCM_CBCDR_AXI_B_PODF_MASK
+							| MXC_CCM_CBCDR_AHB_PODF_MASK
+							| MX50_CCM_CBCDR_WEIM_PODF_MASK);
+						reg |= (0 << MXC_CCM_CBCDR_AXI_A_PODF_OFFSET
+							|1 << MXC_CCM_CBCDR_AXI_B_PODF_OFFSET
+							|2 << MXC_CCM_CBCDR_AHB_PODF_OFFSET
+							|0 << MX50_CCM_CBCDR_WEIM_PODF_OFFSET);
+						__raw_writel(reg, MXC_CCM_CBCDR);
+
+						while (__raw_readl(MXC_CCM_CDHIPR) & 0xF)
+							udelay(10);
+					}
+				} else {
+					clk_set_rate(ahb_clk,
+						clk_round_rate(ahb_clk,
+							lp_normal_rate));
+					clk_set_rate(ddr_hf_clk,
+						clk_round_rate(ddr_hf_clk,
+							ddr_normal_rate));
+				}
+				/* Set to the high setpoint. */
+				high_bus_freq_mode = 1;
+				low_bus_freq_mode = 0;
+				med_bus_freq_mode = 0;
+			} else if (!med_bus_freq_mode && !high_bus_freq) {
+				if (cpu_is_mx50()) {
+					/* Set the dividers to the medium setpoint dividers */
+					reg = __raw_readl(MXC_CCM_CBCDR);
+					reg &= ~(MXC_CCM_CBCDR_AXI_A_PODF_MASK
+						| MXC_CCM_CBCDR_AXI_B_PODF_MASK
+						| MXC_CCM_CBCDR_AHB_PODF_MASK
+						| MX50_CCM_CBCDR_WEIM_PODF_MASK);
+					reg |= (1 << MXC_CCM_CBCDR_AXI_A_PODF_OFFSET
+						|3 << MXC_CCM_CBCDR_AXI_B_PODF_OFFSET
+						|5 << MXC_CCM_CBCDR_AHB_PODF_OFFSET
+						|0 << MX50_CCM_CBCDR_WEIM_PODF_OFFSET);
+					__raw_writel(reg, MXC_CCM_CBCDR);
+
+					while (__raw_readl(MXC_CCM_CDHIPR) & 0xF)
+						udelay(10);
+					/* Reduce SYS_CLK */
+					reg = __raw_readl(MXC_CCM_CLK_SYS);
+					reg &= ~MXC_CCM_CLK_SYS_DIV_PLL_MASK;
+					reg |= 8 << MXC_CCM_CLK_SYS_DIV_PLL_OFFSET;
+					__raw_writel(reg, MXC_CCM_CLK_SYS);
+				} else {
+					if (cpu_is_mx51())
+						clk_set_rate(ddr_hf_clk,
+							clk_round_rate(
+							ddr_hf_clk,
+							ddr_low_rate));
+					clk_set_rate(ahb_clk,
+					clk_round_rate(
+						ahb_clk, lp_med_rate));
+				}
+				/* Set to the medium setpoint. */
+				high_bus_freq_mode = 0;
+				low_bus_freq_mode = 0;
+				med_bus_freq_mode = 1;
+			}
+			if (cpu_is_mx50()) {
+				if (med_bus_freq_mode &&
+					(cur_ddr_rate != ddr_med_rate))
+					set_ddr_freq(ddr_med_rate);
+				if (high_bus_freq_mode &&
+					(cur_ddr_rate != ddr_normal_rate))
+					set_ddr_freq(ddr_normal_rate);
+			}
+		}
+		start_sdram_autogating();
+		mutex_unlock(&bus_freq_mutex);
+	}
+	return 0;
+}
+
+void exit_lpapm_mode_mx50(int high_bus_freq)
+{
+	u32 reg;
+	unsigned long flags;
+
+	if (clk_get_usecount(pll1_sw_clk) == 1) {
+		/* Relock PLL1 to 800MHz. */
+		clk_set_parent(pll1_sw_clk, pll2);
+		/* Set the divider to ARM_PODF to 3, cpu is at 160MHz. */
+		__raw_writel(0x02, MXC_CCM_CACRR);
+
+		clk_set_rate(pll1, 800000000);
+		clk_set_parent(pll1_sw_clk, pll1);
+		/* Set the divider to ARM_PODF to 5. */
+		__raw_writel(0x4, MXC_CCM_CACRR);
+	}
+
+	if (!completion_done(&voltage_change_cmpl))
+		wait_for_completion_interruptible(&voltage_change_cmpl);
+	spin_lock_irqsave(&voltage_lock, flags);
+	if (lp_voltage != LP_NORMAL_VOLTAGE) {
+		INIT_COMPLETION(voltage_change_cmpl);
+		lp_voltage = LP_NORMAL_VOLTAGE;
+		if (!queue_work(voltage_wq, &voltage_change_handler))
+			printk(KERN_ERR "WORK_NOT_ADDED\n");
+		spin_unlock_irqrestore(&voltage_lock, flags);
+		wait_for_completion_interruptible(&voltage_change_cmpl);
+	} else {
+		spin_unlock_irqrestore(&voltage_lock, flags);
+		if (!completion_done(&voltage_change_cmpl))
+			wait_for_completion_interruptible(&voltage_change_cmpl);
+	}
+
+	spin_lock_irqsave(&ddr_freq_lock, flags);
+	if (!low_bus_freq_mode) {
+		spin_unlock_irqrestore(&ddr_freq_lock, flags);
+		return;
+	}
+
+	/* Temporarily set the dividers when the source is PLL3.
+	 * No clock rate is above 133MHz.
+	 */
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	reg &= ~(MXC_CCM_CBCDR_AXI_A_PODF_MASK
+		| MXC_CCM_CBCDR_AXI_B_PODF_MASK
+		| MXC_CCM_CBCDR_AHB_PODF_MASK
+		| MX50_CCM_CBCDR_WEIM_PODF_MASK);
+	reg |= (1 << MXC_CCM_CBCDR_AXI_A_PODF_OFFSET
+		|1 << MXC_CCM_CBCDR_AXI_B_PODF_OFFSET
+		|1 << MXC_CCM_CBCDR_AHB_PODF_OFFSET
+		|0 << MX50_CCM_CBCDR_WEIM_PODF_OFFSET);
+	__raw_writel(reg, MXC_CCM_CBCDR);
+
+	while (__raw_readl(MXC_CCM_CDHIPR) & 0xF)
+		udelay(10);
+
+	clk_set_parent(main_bus_clk, pll3);
+
+	if (bus_freq_scaling_is_active && !high_bus_freq) {
+		/* Set the dividers to the medium setpoint dividers */
+		reg = __raw_readl(MXC_CCM_CBCDR);
+		reg &= ~(MXC_CCM_CBCDR_AXI_A_PODF_MASK
+			| MXC_CCM_CBCDR_AXI_B_PODF_MASK
+			| MXC_CCM_CBCDR_AHB_PODF_MASK
+			| MX50_CCM_CBCDR_WEIM_PODF_MASK);
+		reg |= (1 << MXC_CCM_CBCDR_AXI_A_PODF_OFFSET
+			|3 << MXC_CCM_CBCDR_AXI_B_PODF_OFFSET
+			|5 << MXC_CCM_CBCDR_AHB_PODF_OFFSET
+			|0 << MX50_CCM_CBCDR_WEIM_PODF_OFFSET);
+		__raw_writel(reg, MXC_CCM_CBCDR);
+
+		while (__raw_readl(MXC_CCM_CDHIPR) & 0xF)
+			udelay(10);
+
+		/*Set the main_bus_clk parent to be PLL2. */
+		clk_set_parent(main_bus_clk, pll2);
+
+		/* Set to the medium setpoint. */
+		high_bus_freq_mode = 0;
+		low_bus_freq_mode = 0;
+		med_bus_freq_mode = 1;
+		set_ddr_freq(ddr_med_rate);
+	} else {
+		/* Set the dividers to the default dividers */
+		reg = __raw_readl(MXC_CCM_CBCDR);
+		reg &= ~(MXC_CCM_CBCDR_AXI_A_PODF_MASK
+			| MXC_CCM_CBCDR_AXI_B_PODF_MASK
+			| MXC_CCM_CBCDR_AHB_PODF_MASK
+			| MX50_CCM_CBCDR_WEIM_PODF_MASK);
+		reg |= (0 << MXC_CCM_CBCDR_AXI_A_PODF_OFFSET
+			|1 << MXC_CCM_CBCDR_AXI_B_PODF_OFFSET
+			|2 << MXC_CCM_CBCDR_AHB_PODF_OFFSET
+			|0 << MX50_CCM_CBCDR_WEIM_PODF_OFFSET);
+		__raw_writel(reg, MXC_CCM_CBCDR);
+
+		while (__raw_readl(MXC_CCM_CDHIPR) & 0xF)
+			udelay(10);
+
+		/*Set the main_bus_clk parent to be PLL2. */
+		clk_set_parent(main_bus_clk, pll2);
+
+		/* Set to the high setpoint. */
+		high_bus_freq_mode = 1;
+		low_bus_freq_mode = 0;
+		med_bus_freq_mode = 0;
+		set_ddr_freq(ddr_normal_rate);
+	}
+
+	spin_unlock_irqrestore(&ddr_freq_lock, flags);
+
+	udelay(100);
+}
+
+void exit_lpapm_mode_mx51()
+{
+	u32 reg;
+
+	/* Temporarily Set the dividers  is PLL3.
+	 * No clock rate is above 133MHz.
+	 */
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	reg &= ~(MXC_CCM_CBCDR_AXI_A_PODF_MASK
+		| MXC_CCM_CBCDR_AXI_B_PODF_MASK
+		| MXC_CCM_CBCDR_AHB_PODF_MASK
+		| MXC_CCM_CBCDR_EMI_PODF_MASK
+		| MXC_CCM_CBCDR_NFC_PODF_OFFSET);
+	reg |= (1 << MXC_CCM_CBCDR_AXI_A_PODF_OFFSET
+		| 1 << MXC_CCM_CBCDR_AXI_B_PODF_OFFSET
+		| 1 << MXC_CCM_CBCDR_AHB_PODF_OFFSET
+		| 1 << MXC_CCM_CBCDR_EMI_PODF_OFFSET
+		| 3 << MXC_CCM_CBCDR_NFC_PODF_OFFSET);
+	__raw_writel(reg, MXC_CCM_CBCDR);
+
+	clk_enable(emi_garb_clk);
+	while (__raw_readl(MXC_CCM_CDHIPR) & 0x1F)
+		udelay(10);
+	clk_disable(emi_garb_clk);
+
+	clk_set_parent(periph_apm_clk, pll3);
+
+	/* Set the dividers to the default dividers */
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	reg &= ~(MXC_CCM_CBCDR_AXI_A_PODF_MASK
+		| MXC_CCM_CBCDR_AXI_B_PODF_MASK
+		| MXC_CCM_CBCDR_AHB_PODF_MASK
+		| MXC_CCM_CBCDR_EMI_PODF_MASK
+		| MXC_CCM_CBCDR_NFC_PODF_OFFSET);
+	reg |= (3 << MXC_CCM_CBCDR_AXI_A_PODF_OFFSET
+		| 4 << MXC_CCM_CBCDR_AXI_B_PODF_OFFSET
+		| 4 << MXC_CCM_CBCDR_AHB_PODF_OFFSET
+		| 4 << MXC_CCM_CBCDR_EMI_PODF_OFFSET
+		| 3 << MXC_CCM_CBCDR_NFC_PODF_OFFSET);
+	__raw_writel(reg, MXC_CCM_CBCDR);
+
+	clk_enable(emi_garb_clk);
+	while (__raw_readl(MXC_CCM_CDHIPR) & 0x1F)
+		udelay(10);
+
+	low_bus_freq_mode = 0;
+	high_bus_freq_mode = 1;
+	clk_disable(emi_garb_clk);
+
+	/*Set the main_bus_clk parent to be PLL2. */
+	clk_set_parent(main_bus_clk, pll2);
+
+	/*Change the DDR freq to 200MHz*/
+	clk_set_rate(ddr_hf_clk,
+	    clk_round_rate(ddr_hf_clk, ddr_normal_rate));
+}
+
+void exit_lpapm_mode_mx53()
+{
+	u32 reg;
+	struct timespec nstimeofday;
+	struct timespec curtime;
+
+
+	/* move cpu clk to pll1 */
+	reg = __raw_readl(MXC_CCM_CDHIPR);
+	if ((reg & MXC_CCM_CDHIPR_ARM_PODF_BUSY) != 0)
+		__raw_writel(cpu_podf & 0x7,
+				MXC_CCM_CACRR);
+	else
+		printk(KERN_DEBUG
+			"ARM_PODF still in busy!!!!\n");
+
+	clk_set_parent(pll1_sw_clk, pll1);
+
+
+	/* ahb = 400/3, axi_b = 400/2, axi_a = 400*/
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	reg &= ~(MXC_CCM_CBCDR_AXI_A_PODF_MASK
+		| MXC_CCM_CBCDR_AXI_B_PODF_MASK
+		| MXC_CCM_CBCDR_AHB_PODF_MASK);
+	reg |= (0 << MXC_CCM_CBCDR_AXI_A_PODF_OFFSET
+		| 1 << MXC_CCM_CBCDR_AXI_B_PODF_OFFSET
+		| 2 << MXC_CCM_CBCDR_AHB_PODF_OFFSET);
+	__raw_writel(reg, MXC_CCM_CBCDR);
+
+	getnstimeofday(&nstimeofday);
+	while (__raw_readl(MXC_CCM_CDHIPR) &
+		(MXC_CCM_CDHIPR_AXI_A_PODF_BUSY |
+		 MXC_CCM_CDHIPR_AXI_B_PODF_BUSY |
+		 MXC_CCM_CDHIPR_AHB_PODF_BUSY)) {
+			getnstimeofday(&curtime);
+		if (curtime.tv_nsec
+			- nstimeofday.tv_nsec
+			> SPIN_DELAY)
+			panic("bus freq error\n");
+	}
+
+	/* keep this infront of propagating */
+	low_bus_freq_mode = 0;
+	high_bus_freq_mode = 1;
+	med_bus_freq_mode = 0;
+
+	/* TBD: Restore DDR frequency for DDR2 */
+	/* if (mx53_ddr_type == DDR_TYPE_DDR2) {
+	} */
+}
+
+int can_change_ddr_freq(void)
+{
+	if (clk_get_usecount(epdc_clk) == 0)
+		return 1;
+	return 0;
+}
+
+void set_ddr_freq(int ddr_rate)
+{
+	u32 reg;
+	unsigned long flags;
+
+	if (!can_change_ddr_freq())
+		return;
+
+	spin_lock_irqsave(&ddr_freq_lock, flags);
+	local_flush_tlb_all();
+	flush_cache_all();
+
+	/* Disable all masters from accessing the DDR. */
+	reg = __raw_readl(qosc_base + HW_QOS_DISABLE);
+	reg |= 0xFFE;
+	__raw_writel(reg, qosc_base + HW_QOS_DISABLE_SET);
+	udelay(100);
+
+	/* Set the DDR to default freq.
+	 */
+	change_ddr_freq(ccm_base, databahn_base, ddr_rate);
+
+	/* Enable all masters to access the DDR. */
+	__raw_writel(reg, qosc_base + HW_QOS_DISABLE_CLR);
+
+	spin_unlock_irqrestore(&ddr_freq_lock, flags);
+	cur_ddr_rate = ddr_rate;
+	udelay(100);
+}
+
+int low_freq_bus_used(void)
+{
+	if ((lp_high_freq == 0)
+	    && (lp_med_freq == 0))
+		return 1;
+	else
+		return 0;
+}
+
+void setup_pll(void)
+{
+}
+
+static ssize_t bus_freq_scaling_enable_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	if (bus_freq_scaling_is_active)
+		return sprintf(buf, "Bus frequency scaling is enabled\n");
+	else
+		return sprintf(buf, "Bus frequency scaling is disabled\n");
+}
+
+static ssize_t bus_freq_scaling_enable_store(struct device *dev,
+				 struct device_attribute *attr,
+				 const char *buf, size_t size)
+{
+	u32 reg;
+
+	if (strncmp(buf, "1", 1) == 0) {
+		if (dvfs_per_active()) {
+			printk(KERN_INFO "bus frequency scaling cannot be\
+				 enabled when DVFS-PER is active\n");
+			return size;
+		}
+		if (!cpu_is_mx50()) {
+			/* Initialize DVFS-PODF to 0. */
+			reg = __raw_readl(MXC_CCM_CDCR);
+			reg &= ~MXC_CCM_CDCR_PERIPH_CLK_DVFS_PODF_MASK;
+			__raw_writel(reg, MXC_CCM_CDCR);
+			clk_set_parent(main_bus_clk, pll2);
+		}
+		bus_freq_scaling_is_active = 1;
+		set_high_bus_freq(0);
+	} else if (strncmp(buf, "0", 1) == 0) {
+		if (bus_freq_scaling_is_active)
+			set_high_bus_freq(1);
+		bus_freq_scaling_is_active = 0;
+	}
+
+	return size;
+}
+
+static int busfreq_suspend(struct platform_device *pdev, pm_message_t message)
+{
+	if (low_bus_freq_mode)
+		set_high_bus_freq(1);
+	busfreq_suspended = 1;
+	return 0;
+}
+
+static int busfreq_resume(struct platform_device *pdev)
+{
+	busfreq_suspended = 0;
+	return  0;
+}
+
+static DEVICE_ATTR(enable, 0644, bus_freq_scaling_enable_show,
+			bus_freq_scaling_enable_store);
+
+/*!
+ * This is the probe routine for the bus frequency driver.
+ *
+ * @param   pdev   The platform device structure
+ *
+ * @return         The function returns 0 on success
+ *
+ */
+static int __devinit busfreq_probe(struct platform_device *pdev)
+{
+	int err = 0;
+	unsigned long pll2_rate, pll1_rate;
+	unsigned long iram_paddr;
+	struct mxc_bus_freq_platform_data *p_bus_freq_data;
+
+	p_bus_freq_data = pdev->dev.platform_data;
+	gp_reg_id = p_bus_freq_data->gp_reg_id;
+	lp_reg_id = p_bus_freq_data->lp_reg_id;
+
+	if (cpu_is_mx51()) {
+		pll1_base = MX51_IO_ADDRESS(MX51_PLL1_BASE_ADDR);
+	} else if (cpu_is_mx53()) {
+		pll1_base = MX53_IO_ADDRESS(MX53_PLL1_BASE_ADDR);
+		pll4_base = MX53_IO_ADDRESS(MX53_PLL4_BASE_ADDR);
+	} else if (cpu_is_mx50()) {
+		pll1_base = MX50_IO_ADDRESS(MX50_PLL1_BASE_ADDR);
+	}
+
+	busfreq_dev = &pdev->dev;
+
+	main_bus_clk = clk_get(NULL, "main_bus_clk");
+	if (IS_ERR(main_bus_clk)) {
+		printk(KERN_DEBUG "%s: failed to get main_bus_clk\n",
+		       __func__);
+		return PTR_ERR(main_bus_clk);
+	}
+
+	pll1_sw_clk = clk_get(NULL, "pll1_sw_clk");
+	if (IS_ERR(pll1_sw_clk)) {
+		printk(KERN_DEBUG "%s: failed to get pll1_sw_clk\n", __func__);
+		return PTR_ERR(pll1_sw_clk);
+	}
+
+	pll1 = clk_get(NULL, "pll1_main_clk");
+	if (IS_ERR(pll1)) {
+		printk(KERN_DEBUG "%s: failed to get pll1\n", __func__);
+		return PTR_ERR(pll1);
+	}
+
+	pll2 = clk_get(NULL, "pll2");
+	if (IS_ERR(pll2)) {
+		printk(KERN_DEBUG "%s: failed to get pll2\n", __func__);
+		return PTR_ERR(pll2);
+	}
+
+	pll3 = clk_get(NULL, "pll3");
+	if (IS_ERR(pll3)) {
+		printk(KERN_DEBUG "%s: failed to get pll3\n", __func__);
+		return PTR_ERR(pll3);
+	}
+
+	if (cpu_is_mx53()) {
+		pll4 = clk_get(NULL, "pll4");
+		if (IS_ERR(pll4)) {
+			printk(KERN_DEBUG "%s: failed to get pll4\n", __func__);
+			return PTR_ERR(pll4);
+		}
+	}
+
+	axi_a_clk = clk_get(NULL, "axi_a_clk");
+	if (IS_ERR(axi_a_clk)) {
+		printk(KERN_DEBUG "%s: failed to get axi_a_clk\n",
+		       __func__);
+		return PTR_ERR(axi_a_clk);
+	}
+
+	axi_b_clk = clk_get(NULL, "axi_b_clk");
+	if (IS_ERR(axi_b_clk)) {
+		printk(KERN_DEBUG "%s: failed to get axi_b_clk\n",
+		       __func__);
+		return PTR_ERR(axi_b_clk);
+	}
+
+	ddr_clk = clk_get(NULL, "ddr_clk");
+	if (IS_ERR(ddr_clk)) {
+		printk(KERN_DEBUG "%s: failed to get ddr_clk\n",
+		       __func__);
+		return PTR_ERR(ddr_clk);
+	}
+
+	ddr_hf_clk = clk_get_parent(ddr_clk);
+
+	if (IS_ERR(ddr_hf_clk)) {
+		printk(KERN_DEBUG "%s: failed to get ddr_hf_clk\n",
+		       __func__);
+		return PTR_ERR(ddr_hf_clk);
+	}
+
+	ahb_clk = clk_get(NULL, "ahb_clk");
+	if (IS_ERR(ahb_clk)) {
+		printk(KERN_DEBUG "%s: failed to get ahb_clk\n",
+		       __func__);
+		return PTR_ERR(ahb_clk);
+	}
+
+	cpu_clk = clk_get(NULL, "cpu_clk");
+	if (IS_ERR(cpu_clk)) {
+		printk(KERN_DEBUG "%s: failed to get cpu_clk\n",
+		       __func__);
+		return PTR_ERR(cpu_clk);
+	}
+
+	if (cpu_is_mx51())
+		emi_garb_clk = clk_get(NULL, "emi_intr_clk.1");
+	else if (cpu_is_mx53())
+		emi_garb_clk = clk_get(NULL, "emi_intr_clk.1");
+	else
+		emi_garb_clk = clk_get(NULL, "ocram_clk");
+	if (IS_ERR(emi_garb_clk)) {
+		printk(KERN_DEBUG "%s: failed to get emi_garb_clk\n",
+		       __func__);
+		return PTR_ERR(emi_garb_clk);
+	}
+
+	if (cpu_is_mx51()  || cpu_is_mx53()) {
+		periph_apm_clk = clk_get(NULL, "periph_apm_clk");
+		if (IS_ERR(periph_apm_clk)) {
+			printk(KERN_DEBUG "%s: failed to get periph_apm_clk\n",
+			       __func__);
+			return PTR_ERR(periph_apm_clk);
+		}
+	}
+
+	lp_apm = clk_get(NULL, "lp_apm");
+	if (IS_ERR(lp_apm)) {
+		printk(KERN_DEBUG "%s: failed to get lp_apm\n",
+		       __func__);
+		return PTR_ERR(lp_apm);
+	}
+
+	gpc_dvfs_clk = clk_get(NULL, "gpc_dvfs_clk");
+	if (IS_ERR(gpc_dvfs_clk)) {
+		printk(KERN_DEBUG "%s: failed to get gpc_dvfs_clk\n", __func__);
+		return PTR_ERR(gpc_dvfs_clk);
+	}
+
+	err = sysfs_create_file(&busfreq_dev->kobj, &dev_attr_enable.attr);
+	if (err) {
+		printk(KERN_ERR
+		       "Unable to register sysdev entry for BUSFREQ");
+		return err;
+	}
+
+	pll1_rate = clk_get_rate(pll1_sw_clk);
+	pll2_rate = clk_get_rate(pll2);
+
+	if (pll2_rate == 665000000) {
+		/* for mx51 */
+		lp_normal_rate = pll2_rate / 5;
+		lp_med_rate = pll2_rate / 8;
+		ddr_normal_rate = pll1_rate / 4; /* 200M */
+		ddr_low_rate = pll1_rate / 6; /* 133M */
+	} else if (pll2_rate == 600000000) {
+		/* for mx53 evk rev.A */
+		lp_normal_rate = pll2_rate / 5;
+		lp_med_rate = pll2_rate / 8;
+		ddr_normal_rate = pll2_rate / 2;
+		ddr_low_rate = pll2_rate / 2;
+	} else if (pll2_rate == 400000000) {
+		if (cpu_is_mx50()) {
+			lp_normal_rate = pll2_rate / 3;
+			ddr_normal_rate = clk_get_rate(ddr_clk);
+			lp_med_rate = pll2_rate / 6;
+			ddr_low_rate = LP_APM_CLK;
+			ddr_med_rate = pll2_rate / 3;
+		}
+	}
+
+	/* for mx53 */
+	if (cpu_is_mx53()) {
+		/* set DDR type */
+		if (machine_is_mx53_evk() || machine_is_mx53_ard())
+			mx53_ddr_type = DDR_TYPE_DDR2;
+		else
+			mx53_ddr_type = DDR_TYPE_DDR3;
+		if (mx53_ddr_type == DDR_TYPE_DDR2) {
+			/* DDR2 */
+			lp_normal_rate = pll2_rate / 3;
+			lp_med_rate = pll2_rate / 5;
+			ddr_normal_rate = pll2_rate / 1;
+			ddr_low_rate = pll2_rate / 3;
+		} else {
+			/* DDR3: DDR3 frequency can not be lower than 300MHZ */
+			lp_normal_rate = pll2_rate / 3;
+			lp_med_rate = pll2_rate / 5;
+			ddr_normal_rate = pll2_rate / 1;
+			ddr_low_rate = pll2_rate / 1;
+		}
+	}
+
+	if (cpu_is_mx50()) {
+		u32 reg;
+
+		iram_alloc(SZ_8K, &iram_paddr);
+		/* Need to remap the area here since we want the memory region
+			 to be executable. */
+		ddr_freq_change_iram_base = __arm_ioremap(iram_paddr,
+							SZ_8K, MT_HIGH_VECTORS);
+		memcpy(ddr_freq_change_iram_base, mx50_ddr_freq_change, SZ_8K);
+		change_ddr_freq = (void *)ddr_freq_change_iram_base;
+		cur_ddr_rate = ddr_normal_rate;
+
+		lp_regulator = regulator_get(NULL, lp_reg_id);
+		if (IS_ERR(lp_regulator)) {
+			printk(KERN_DEBUG
+			"%s: failed to get lp regulator\n", __func__);
+			return PTR_ERR(lp_regulator);
+		}
+
+		qosc_base = ioremap(MX50_QOSC_BASE_ADDR, SZ_4K);
+		/* Enable the QoSC */
+		reg = __raw_readl(qosc_base);
+		reg &= ~0xC0000000;
+		__raw_writel(reg, qosc_base);
+
+		voltage_wq = create_workqueue("voltage_change");
+		INIT_WORK(&voltage_change_handler, voltage_work_handler);
+
+		init_completion(&voltage_change_cmpl);
+
+		epdc_clk = clk_get(NULL, "epdc_axi");
+		if (IS_ERR(epdc_clk)) {
+			printk(KERN_DEBUG "%s: failed to get epdc_axi_clk\n",
+				__func__);
+			return PTR_ERR(epdc_clk);
+		}
+	}
+	cpu_op_tbl = get_cpu_op(&cpu_op_nr);
+	low_bus_freq_mode = 0;
+	high_bus_freq_mode = 1;
+	med_bus_freq_mode = 0;
+	bus_freq_scaling_is_active = 0;
+	bus_freq_scaling_initialized = 1;
+
+	mutex_init(&bus_freq_mutex);
+	return 0;
+}
+
+static struct platform_driver busfreq_driver = {
+	.driver = {
+		   .name = "busfreq",
+		},
+	.probe = busfreq_probe,
+	.suspend = busfreq_suspend,
+	.resume = busfreq_resume,
+};
+
+/*!
+ * Initialise the busfreq_driver.
+ *
+ * @return  The function always returns 0.
+ */
+
+static int __init busfreq_init(void)
+{
+	if (platform_driver_register(&busfreq_driver) != 0) {
+		printk(KERN_ERR "busfreq_driver register failed\n");
+		return -ENODEV;
+	}
+
+	printk(KERN_INFO "Bus freq driver module loaded\n");
+	return 0;
+}
+
+static void __exit busfreq_cleanup(void)
+{
+	sysfs_remove_file(&busfreq_dev->kobj, &dev_attr_enable.attr);
+
+	/* Unregister the device structure */
+	platform_driver_unregister(&busfreq_driver);
+	bus_freq_scaling_initialized = 0;
+}
+
+module_init(busfreq_init);
+module_exit(busfreq_cleanup);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("BusFreq driver");
+MODULE_LICENSE("GPL");
diff --git a/arch/arm/mach-mx5/clock-mx51-mx53.c b/arch/arm/mach-mx5/clock-mx51-mx53.c
old mode 100644
new mode 100755
index 6b89c1b..a6a409b
--- a/arch/arm/mach-mx5/clock-mx51-mx53.c
+++ b/arch/arm/mach-mx5/clock-mx51-mx53.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008-2011 Freescale Semiconductor, Inc. All Rights Reserved.
  * Copyright (C) 2009-2010 Amit Kucheria <amit.kucheria@canonical.com>
  *
  * The code contained herein is licensed under the GNU General Public
@@ -1277,6 +1277,8 @@ DEFINE_CLOCK(i2c1_clk, 0, MXC_CCM_CCGR1, MXC_CCM_CCGRx_CG9_OFFSET,
 	NULL, NULL, &ipg_clk, NULL);
 DEFINE_CLOCK(i2c2_clk, 1, MXC_CCM_CCGR1, MXC_CCM_CCGRx_CG10_OFFSET,
 	NULL, NULL, &ipg_clk, NULL);
+DEFINE_CLOCK(i2c3_clk, 2, MXC_CCM_CCGR1, MXC_CCM_CCGRx_CG11_OFFSET,
+	NULL, NULL, &ipg_clk, NULL);
 DEFINE_CLOCK(hsi2c_clk, 0, MXC_CCM_CCGR1, MXC_CCM_CCGRx_CG11_OFFSET,
 	NULL, NULL, &ipg_clk, NULL);
 
@@ -1452,7 +1454,7 @@ static struct clk_lookup mx51_lookups[] = {
 	_REGISTER_CLOCK("imx2-wdt.0", NULL, dummy_clk)
 	_REGISTER_CLOCK("imx2-wdt.1", NULL, dummy_clk)
 	_REGISTER_CLOCK(NULL, "mipi_hsp", mipi_hsp_clk)
-	_REGISTER_CLOCK("imx-ipuv3", NULL, ipu_clk)
+	_REGISTER_CLOCK("imx-ipuv3", "ipu", ipu_clk)
 	_REGISTER_CLOCK("imx-ipuv3", "di0", ipu_di0_clk)
 	_REGISTER_CLOCK("imx-ipuv3", "di1", ipu_di1_clk)
 	_REGISTER_CLOCK(NULL, "gpc_dvfs", gpc_dvfs_clk)
@@ -1467,6 +1469,7 @@ static struct clk_lookup mx53_lookups[] = {
 	_REGISTER_CLOCK(NULL, "iim_clk", iim_clk)
 	_REGISTER_CLOCK("imx-i2c.0", NULL, i2c1_clk)
 	_REGISTER_CLOCK("imx-i2c.1", NULL, i2c2_clk)
+	_REGISTER_CLOCK("imx-i2c.2", NULL, i2c3_clk)
 	_REGISTER_CLOCK("sdhci-esdhc-imx.0", NULL, esdhc1_clk)
 	_REGISTER_CLOCK("sdhci-esdhc-imx.1", NULL, esdhc2_mx53_clk)
 	_REGISTER_CLOCK("sdhci-esdhc-imx.2", NULL, esdhc3_mx53_clk)
@@ -1476,6 +1479,11 @@ static struct clk_lookup mx53_lookups[] = {
 	_REGISTER_CLOCK("imx53-cspi.0", NULL, cspi_clk)
 	_REGISTER_CLOCK("imx2-wdt.0", NULL, dummy_clk)
 	_REGISTER_CLOCK("imx2-wdt.1", NULL, dummy_clk)
+	_REGISTER_CLOCK("imx-ipuv3", "ipu", ipu_clk)
+	_REGISTER_CLOCK("imx-ipuv3", "di0", ipu_di0_clk)
+	_REGISTER_CLOCK("imx-ipuv3", "di1", ipu_di1_clk)
+	_REGISTER_CLOCK("mxc_pwm.0", "pwm", pwm1_clk)
+	_REGISTER_CLOCK("mxc_pwm.1", "pwm", pwm2_clk)
 };
 
 static void clk_tree_init(void)
diff --git a/arch/arm/mach-mx5/clock.c b/arch/arm/mach-mx5/clock.c
new file mode 100755
index 0000000..3684bdd
--- /dev/null
+++ b/arch/arm/mach-mx5/clock.c
@@ -0,0 +1,5095 @@
+/*
+ * Copyright (C) 2008-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/time.h>
+#include <linux/hrtimer.h>
+#include <linux/mm.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/clkdev.h>
+#include <asm/div64.h>
+#include <mach/hardware.h>
+#include <mach/common.h>
+#include <mach/clock.h>
+#include <mach/mxc_dvfs.h>
+#include <mach/sdram_autogating.h>
+
+#include "crm_regs.h"
+#include "cpu_op-mx51.h"
+#include "cpu_op-mx53.h"
+
+/* External clock values passed-in by the board code */
+static unsigned long external_high_reference, external_low_reference;
+static unsigned long oscillator_reference, ckih2_reference;
+
+static struct clk pll1_main_clk;
+static struct clk pll1_sw_clk;
+static struct clk pll2_sw_clk;
+static struct clk pll3_sw_clk;
+static struct clk pll4_sw_clk;
+static struct clk lp_apm_clk;
+static struct clk tve_clk;
+static struct clk emi_fast_clk;
+static struct clk emi_slow_clk;
+static struct clk emi_intr_clk[];
+static struct clk ddr_clk;
+static struct clk ipu_clk[];
+static struct clk ldb_di_clk[];
+static struct clk axi_a_clk;
+static struct clk axi_b_clk;
+static struct clk ddr_hf_clk;
+static struct clk mipi_hsp_clk;
+static struct clk gpu3d_clk;
+static struct clk gpu2d_clk;
+static struct clk vpu_clk[];
+static int cpu_curr_op;
+static struct cpu_op *cpu_op_tbl;
+
+static void __iomem *pll1_base;
+static void __iomem *pll2_base;
+static void __iomem *pll3_base;
+static void __iomem *pll4_base;
+
+extern int cpu_op_nr;
+extern int lp_high_freq;
+extern int lp_med_freq;
+static int max_axi_a_clk;
+static int max_axi_b_clk;
+static int max_ahb_clk;
+static int max_emi_slow_clk;
+extern int dvfs_core_is_active;
+
+#define SPIN_DELAY	1000000 /* in nanoseconds */
+#define MAX_AXI_A_CLK_MX51 	166250000
+#define MAX_AXI_A_CLK_MX53 	400000000
+#define MAX_AXI_B_CLK_MX51 	133000000
+#define MAX_AXI_B_CLK_MX53 	200000000
+#define MAX_AHB_CLK_MX51	133000000
+#define MAX_EMI_SLOW_CLK_MX51	133000000
+#define MAX_AHB_CLK_MX53	133333333
+#define MAX_EMI_SLOW_CLK_MX53	133333333
+#define MAX_DDR_HF_RATE		200000000
+/* To keep compatible with some NAND flash, limit
+ * max NAND clk to 34MHZ. The user can modify it for
+ * dedicate NAND flash */
+#define MAX_NFC_CLK		34000000
+
+#define UART1_DMA_ENABLE	0
+#define UART2_DMA_ENABLE	0
+#define UART3_DMA_ENABLE	0
+#define UART4_DMA_ENABLE	0
+#define UART5_DMA_ENABLE	0
+
+extern int mxc_jtag_enabled;
+extern int uart_at_24;
+extern int cpufreq_trig_needed;
+extern int low_bus_freq_mode;
+
+static int cpu_clk_set_op(int op);
+extern struct cpu_op *(*get_cpu_op)(int *op);
+extern void (*set_num_cpu_op)(int num);
+
+static struct clk esdhc3_clk[];
+
+static void __calc_pre_post_dividers(u32 div, u32 *pre, u32 *post)
+{
+	u32 min_pre, temp_pre, old_err, err;
+
+	if (div >= 512) {
+		*pre = 8;
+		*post = 64;
+	} else if (div >= 8) {
+		min_pre = (div - 1) / 64 + 1;
+		old_err = 8;
+		for (temp_pre = 8; temp_pre >= min_pre; temp_pre--) {
+			err = div % temp_pre;
+			if (err == 0) {
+				*pre = temp_pre;
+				break;
+			}
+			err = temp_pre - err;
+			if (err < old_err) {
+				old_err = err;
+				*pre = temp_pre;
+			}
+		}
+		*post = (div + *pre - 1) / *pre;
+	} else if (div < 8) {
+		*pre = div;
+		*post = 1;
+	}
+}
+
+static int _clk_enable(struct clk *clk)
+{
+	u32 reg;
+	reg = __raw_readl(clk->enable_reg);
+	reg |= MXC_CCM_CCGRx_CG_MASK << clk->enable_shift;
+	__raw_writel(reg, clk->enable_reg);
+
+	if (clk->flags & AHB_HIGH_SET_POINT)
+		lp_high_freq++;
+	else if (clk->flags & AHB_MED_SET_POINT)
+		lp_med_freq++;
+
+	return 0;
+}
+
+static int _clk_enable_inrun(struct clk *clk)
+{
+	u32 reg;
+
+	reg = __raw_readl(clk->enable_reg);
+	reg &= ~(MXC_CCM_CCGRx_CG_MASK << clk->enable_shift);
+	reg |= 1 << clk->enable_shift;
+	__raw_writel(reg, clk->enable_reg);
+	return 0;
+}
+
+static void _clk_disable(struct clk *clk)
+{
+	u32 reg;
+	reg = __raw_readl(clk->enable_reg);
+	reg &= ~(MXC_CCM_CCGRx_CG_MASK << clk->enable_shift);
+	__raw_writel(reg, clk->enable_reg);
+
+	if (clk->flags & AHB_HIGH_SET_POINT)
+		lp_high_freq--;
+	else if (clk->flags & AHB_MED_SET_POINT)
+		lp_med_freq--;
+}
+
+static void _clk_disable_inwait(struct clk *clk)
+{
+	u32 reg;
+	reg = __raw_readl(clk->enable_reg);
+	reg &= ~(MXC_CCM_CCGRx_CG_MASK << clk->enable_shift);
+	reg |= 1 << clk->enable_shift;
+	__raw_writel(reg, clk->enable_reg);
+}
+
+/*
+ * For the 4-to-1 muxed input clock
+ */
+static inline u32 _get_mux(struct clk *parent, struct clk *m0,
+			   struct clk *m1, struct clk *m2, struct clk *m3)
+{
+	if (parent == m0)
+		return 0;
+	else if (parent == m1)
+		return 1;
+	else if (parent == m2)
+		return 2;
+	else if (parent == m3)
+		return 3;
+	else
+		BUG();
+
+	return 0;
+}
+
+/*
+ * For the ddr muxed input clock
+ */
+static inline u32 _get_mux_ddr(struct clk *parent, struct clk *m0,
+			   struct clk *m1, struct clk *m2, struct clk *m3, struct clk *m4)
+{
+	if (parent == m0)
+		return 0;
+	else if (parent == m1)
+		return 1;
+	else if (parent == m2)
+		return 2;
+	else if (parent == m3)
+		return 3;
+	else if (parent == m4)
+		return 4;
+	else
+		BUG();
+
+	return 0;
+}
+
+static inline void __iomem *_get_pll_base(struct clk *pll)
+{
+	if (pll == &pll1_main_clk)
+		return pll1_base;
+	else if (pll == &pll2_sw_clk)
+		return pll2_base;
+	else if (pll == &pll3_sw_clk)
+		return pll3_base;
+	else if (pll == &pll4_sw_clk)
+		return pll4_base;
+	else
+		BUG();
+
+	return NULL;
+}
+
+static unsigned long get_high_reference_clock_rate(struct clk *clk)
+{
+	return external_high_reference;
+}
+
+static unsigned long get_low_reference_clock_rate(struct clk *clk)
+{
+	return external_low_reference;
+}
+
+static unsigned long get_oscillator_reference_clock_rate(struct clk *clk)
+{
+	return oscillator_reference;
+}
+
+static unsigned long get_ckih2_reference_clock_rate(struct clk *clk)
+{
+	return ckih2_reference;
+}
+
+/* External high frequency clock */
+static struct clk ckih_clk = {
+	.get_rate = get_high_reference_clock_rate,
+};
+
+static struct clk ckih2_clk = {
+	.get_rate = get_ckih2_reference_clock_rate,
+};
+
+static struct clk osc_clk = {
+	.get_rate = get_oscillator_reference_clock_rate,
+};
+
+/* External low frequency (32kHz) clock */
+static struct clk ckil_clk = {
+	.get_rate = get_low_reference_clock_rate,
+};
+
+static unsigned long _fpm_get_rate(struct clk *clk)
+{
+	u32 rate = ckil_clk.get_rate(&ckil_clk) * 512;
+	if ((__raw_readl(MXC_CCM_CCR) & MXC_CCM_CCR_FPM_MULT_MASK) != 0)
+		rate *= 2;
+	return rate;
+}
+
+static int _fpm_enable(struct clk *clk)
+{
+	u32 reg = __raw_readl(MXC_CCM_CCR);
+	reg |= MXC_CCM_CCR_FPM_EN;
+	__raw_writel(reg, MXC_CCM_CCR);
+	return 0;
+}
+
+static void _fpm_disable(struct clk *clk)
+{
+	u32 reg = __raw_readl(MXC_CCM_CCR);
+	reg &= ~MXC_CCM_CCR_FPM_EN;
+	__raw_writel(reg, MXC_CCM_CCR);
+}
+
+static struct clk fpm_clk = {
+	.parent = &ckil_clk,
+	.get_rate = _fpm_get_rate,
+	.enable = _fpm_enable,
+	.disable = _fpm_disable,
+};
+
+static unsigned long _fpm_div2_get_rate(struct clk *clk)
+{
+	return  clk_get_rate(clk->parent) / 2;
+}
+
+static struct clk fpm_div2_clk = {
+	.parent = &fpm_clk,
+	.get_rate = _fpm_div2_get_rate,
+};
+
+static unsigned long _clk_pll_get_rate(struct clk *clk)
+{
+	long mfi, mfn, mfd, pdf, ref_clk, mfn_abs;
+	unsigned long dp_op, dp_mfd, dp_mfn, dp_ctl, pll_hfsm, dbl;
+	void __iomem *pllbase;
+	s64 temp;
+
+	pllbase = _get_pll_base(clk);
+
+	dp_ctl = __raw_readl(pllbase + MXC_PLL_DP_CTL);
+	pll_hfsm = dp_ctl & MXC_PLL_DP_CTL_HFSM;
+	dbl = dp_ctl & MXC_PLL_DP_CTL_DPDCK0_2_EN;
+
+	if (pll_hfsm == 0) {
+		dp_op = __raw_readl(pllbase + MXC_PLL_DP_OP);
+		dp_mfd = __raw_readl(pllbase + MXC_PLL_DP_MFD);
+		dp_mfn = __raw_readl(pllbase + MXC_PLL_DP_MFN);
+	} else {
+		dp_op = __raw_readl(pllbase + MXC_PLL_DP_HFS_OP);
+		dp_mfd = __raw_readl(pllbase + MXC_PLL_DP_HFS_MFD);
+		dp_mfn = __raw_readl(pllbase + MXC_PLL_DP_HFS_MFN);
+	}
+	pdf = dp_op & MXC_PLL_DP_OP_PDF_MASK;
+	mfi = (dp_op & MXC_PLL_DP_OP_MFI_MASK) >> MXC_PLL_DP_OP_MFI_OFFSET;
+	mfi = (mfi <= 5) ? 5 : mfi;
+	mfd = dp_mfd & MXC_PLL_DP_MFD_MASK;
+	mfn = mfn_abs = dp_mfn & MXC_PLL_DP_MFN_MASK;
+	/* Sign extend to 32-bits */
+	if (mfn >= 0x04000000) {
+		mfn |= 0xFC000000;
+		mfn_abs = -mfn;
+	}
+
+	ref_clk = 2 * clk_get_rate(clk->parent);
+	if (dbl != 0)
+		ref_clk *= 2;
+
+	ref_clk /= (pdf + 1);
+	temp = (u64) ref_clk * mfn_abs;
+	do_div(temp, mfd + 1);
+	if (mfn < 0)
+		temp = -temp;
+	temp = (ref_clk * mfi) + temp;
+
+	return temp;
+}
+
+static int _clk_pll_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg, reg1;
+	void __iomem *pllbase;
+	struct timespec nstimeofday;
+	struct timespec curtime;
+
+	long mfi, pdf, mfn, mfd = 999999;
+	s64 temp64;
+	unsigned long quad_parent_rate;
+	unsigned long pll_hfsm, dp_ctl;
+
+	pllbase = _get_pll_base(clk);
+
+	quad_parent_rate = 4 * clk_get_rate(clk->parent);
+	pdf = mfi = -1;
+	while (++pdf < 16 && mfi < 5)
+		mfi = rate * (pdf+1) / quad_parent_rate;
+	if (mfi > 15)
+		return -1;
+	pdf--;
+
+	temp64 = rate*(pdf+1) - quad_parent_rate*mfi;
+	do_div(temp64, quad_parent_rate/1000000);
+	mfn = (long)temp64;
+
+	dp_ctl = __raw_readl(pllbase + MXC_PLL_DP_CTL);
+	/* use dpdck0_2 */
+	__raw_writel(dp_ctl | 0x1000L, pllbase + MXC_PLL_DP_CTL);
+	pll_hfsm = dp_ctl & MXC_PLL_DP_CTL_HFSM;
+	if (pll_hfsm == 0) {
+		reg = mfi<<4 | pdf;
+		__raw_writel(reg, pllbase + MXC_PLL_DP_OP);
+		__raw_writel(mfd, pllbase + MXC_PLL_DP_MFD);
+		__raw_writel(mfn, pllbase + MXC_PLL_DP_MFN);
+	} else {
+		reg = mfi<<4 | pdf;
+		__raw_writel(reg, pllbase + MXC_PLL_DP_HFS_OP);
+		__raw_writel(mfd, pllbase + MXC_PLL_DP_HFS_MFD);
+		__raw_writel(mfn, pllbase + MXC_PLL_DP_HFS_MFN);
+	}
+	/* If auto restart is disabled, restart the PLL and
+	  * wait for it to lock.
+	  */
+	reg = __raw_readl(pllbase + MXC_PLL_DP_CTL);
+	if (reg & MXC_PLL_DP_CTL_UPEN) {
+		reg = __raw_readl(pllbase + MXC_PLL_DP_CONFIG);
+		if (!(reg & MXC_PLL_DP_CONFIG_AREN)) {
+			reg1 = __raw_readl(pllbase + MXC_PLL_DP_CTL);
+			reg1 |= MXC_PLL_DP_CTL_RST;
+			__raw_writel(reg1, pllbase + MXC_PLL_DP_CTL);
+		}
+		/* Wait for lock */
+		getnstimeofday(&nstimeofday);
+		while (!(__raw_readl(pllbase + MXC_PLL_DP_CTL)
+					& MXC_PLL_DP_CTL_LRF)) {
+			getnstimeofday(&curtime);
+			if (curtime.tv_nsec - nstimeofday.tv_nsec > SPIN_DELAY)
+				panic("pll_set_rate: pll relock failed\n");
+		}
+	}
+	return 0;
+}
+
+static int _clk_pll_enable(struct clk *clk)
+{
+	u32 reg;
+	void __iomem *pllbase;
+	struct timespec nstimeofday;
+	struct timespec curtime;
+
+	pllbase = _get_pll_base(clk);
+	reg = __raw_readl(pllbase + MXC_PLL_DP_CTL);
+
+	if (reg & MXC_PLL_DP_CTL_UPEN)
+		return 0;
+
+	reg |=  MXC_PLL_DP_CTL_UPEN;
+	__raw_writel(reg, pllbase + MXC_PLL_DP_CTL);
+
+	/* Wait for lock */
+	getnstimeofday(&nstimeofday);
+	while (!(__raw_readl(pllbase + MXC_PLL_DP_CTL) & MXC_PLL_DP_CTL_LRF)) {
+		getnstimeofday(&curtime);
+		if (curtime.tv_nsec - nstimeofday.tv_nsec > SPIN_DELAY)
+			panic("pll relock failed\n");
+	}
+	return 0;
+}
+
+static void _clk_pll_disable(struct clk *clk)
+{
+	u32 reg;
+	void __iomem *pllbase;
+
+	pllbase = _get_pll_base(clk);
+	reg = __raw_readl(pllbase + MXC_PLL_DP_CTL) & ~MXC_PLL_DP_CTL_UPEN;
+	__raw_writel(reg, pllbase + MXC_PLL_DP_CTL);
+}
+
+static struct clk pll1_main_clk = {
+	.parent = &osc_clk,
+	.get_rate = _clk_pll_get_rate,
+	.enable = _clk_pll_enable,
+	.disable = _clk_pll_disable,
+};
+
+static int _clk_pll1_sw_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	reg = __raw_readl(MXC_CCM_CCSR);
+
+	if (parent == &pll1_main_clk) {
+		reg &= ~MXC_CCM_CCSR_PLL1_SW_CLK_SEL;
+		__raw_writel(reg, MXC_CCM_CCSR);
+		/* Set the step_clk parent to be lp_apm, to save power. */
+		mux = _get_mux(&lp_apm_clk, &lp_apm_clk, NULL, &pll2_sw_clk,
+			       &pll3_sw_clk);
+		reg = __raw_readl(MXC_CCM_CCSR);
+		reg = (reg & ~MXC_CCM_CCSR_STEP_SEL_MASK) |
+		    (mux << MXC_CCM_CCSR_STEP_SEL_OFFSET);
+	} else {
+		if (parent == &lp_apm_clk) {
+			reg |= MXC_CCM_CCSR_PLL1_SW_CLK_SEL;
+			reg = __raw_readl(MXC_CCM_CCSR);
+			mux = _get_mux(parent, &lp_apm_clk, NULL, &pll2_sw_clk,
+				       &pll3_sw_clk);
+			reg = (reg & ~MXC_CCM_CCSR_STEP_SEL_MASK) |
+			    (mux << MXC_CCM_CCSR_STEP_SEL_OFFSET);
+		} else {
+			mux = _get_mux(parent, &lp_apm_clk, NULL, &pll2_sw_clk,
+				       &pll3_sw_clk);
+			reg = (reg & ~MXC_CCM_CCSR_STEP_SEL_MASK) |
+			    (mux << MXC_CCM_CCSR_STEP_SEL_OFFSET);
+			__raw_writel(reg, MXC_CCM_CCSR);
+			reg = __raw_readl(MXC_CCM_CCSR);
+			reg |= MXC_CCM_CCSR_PLL1_SW_CLK_SEL;
+
+		}
+	}
+	__raw_writel(reg, MXC_CCM_CCSR);
+
+	return 0;
+}
+
+static unsigned long _clk_pll1_sw_get_rate(struct clk *clk)
+{
+	u32 reg, div;
+	div = 1;
+	reg = __raw_readl(MXC_CCM_CCSR);
+
+	if (clk->parent == &pll2_sw_clk) {
+		div = ((reg & MXC_CCM_CCSR_PLL2_PODF_MASK) >>
+		       MXC_CCM_CCSR_PLL2_PODF_OFFSET) + 1;
+	} else if (clk->parent == &pll3_sw_clk) {
+		div = ((reg & MXC_CCM_CCSR_PLL3_PODF_MASK) >>
+		       MXC_CCM_CCSR_PLL3_PODF_OFFSET) + 1;
+	}
+	return clk_get_rate(clk->parent) / div;
+}
+
+/* pll1 switch clock */
+static struct clk pll1_sw_clk = {
+	.parent = &pll1_main_clk,
+	.set_parent = _clk_pll1_sw_set_parent,
+	.get_rate = _clk_pll1_sw_get_rate,
+};
+
+static int _clk_pll2_sw_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg;
+
+	reg = __raw_readl(MXC_CCM_CCSR);
+
+	if (parent == &pll2_sw_clk) {
+		reg &= ~MXC_CCM_CCSR_PLL2_SW_CLK_SEL;
+	} else {
+		reg = (reg & ~MXC_CCM_CCSR_PLL2_SW_CLK_SEL);
+		reg |= MXC_CCM_CCSR_PLL2_SW_CLK_SEL;
+	}
+	__raw_writel(reg, MXC_CCM_CCSR);
+	return 0;
+}
+
+/* same as pll2_main_clk. These two clocks should always be the same */
+static struct clk pll2_sw_clk = {
+	.parent = &osc_clk,
+	.get_rate = _clk_pll_get_rate,
+	.enable = _clk_pll_enable,
+	.disable = _clk_pll_disable,
+	.set_rate = _clk_pll_set_rate,
+	.set_parent = _clk_pll2_sw_set_parent,
+};
+
+/* same as pll3_main_clk. These two clocks should always be the same */
+static struct clk pll3_sw_clk = {
+	.parent = &osc_clk,
+	.set_rate = _clk_pll_set_rate,
+	.get_rate = _clk_pll_get_rate,
+	.enable = _clk_pll_enable,
+	.disable = _clk_pll_disable,
+};
+
+/* same as pll4_main_clk. These two clocks should always be the same */
+static struct clk pll4_sw_clk = {
+	.parent = &osc_clk,
+	.set_rate = _clk_pll_set_rate,
+	.get_rate = _clk_pll_get_rate,
+	.enable = _clk_pll_enable,
+	.disable = _clk_pll_disable,
+};
+
+static int _clk_lp_apm_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg;
+
+	if (parent == &osc_clk)
+		reg = __raw_readl(MXC_CCM_CCSR) & ~MXC_CCM_CCSR_LP_APM_SEL;
+	else if (parent == &fpm_clk)
+		reg = __raw_readl(MXC_CCM_CCSR) | MXC_CCM_CCSR_LP_APM_SEL;
+	else
+		return -EINVAL;
+
+	__raw_writel(reg, MXC_CCM_CCSR);
+
+	return 0;
+}
+
+static struct clk lp_apm_clk = {
+	.parent = &osc_clk,
+	.set_parent = _clk_lp_apm_set_parent,
+};
+
+static unsigned long _clk_arm_get_rate(struct clk *clk)
+{
+	u32 cacrr, div;
+
+	cacrr = __raw_readl(MXC_CCM_CACRR);
+	div = (cacrr & MXC_CCM_CACRR_ARM_PODF_MASK) + 1;
+	return clk_get_rate(clk->parent) / div;
+}
+
+static int _clk_cpu_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 i;
+	for (i = 0; i < cpu_op_nr; i++) {
+		if (rate == cpu_op_tbl[i].cpu_rate)
+			break;
+	}
+	if (i >= cpu_op_nr)
+		return -EINVAL;
+	cpu_clk_set_op(i);
+
+	return 0;
+}
+
+static unsigned long _clk_cpu_round_rate(struct clk *clk,
+						unsigned long rate)
+{
+	u32 i;
+	u32 op;
+
+	for (i = 0; i < cpu_op_nr; i++) {
+		if (rate == cpu_op_tbl[i].cpu_rate)
+			break;
+	}
+
+	if (i > cpu_op_nr)
+		op = 0;
+
+	return cpu_op_tbl[op].cpu_rate;
+}
+
+
+static struct clk cpu_clk = {
+	.parent = &pll1_sw_clk,
+	.get_rate = _clk_arm_get_rate,
+	.set_rate = _clk_cpu_set_rate,
+	.round_rate = _clk_cpu_round_rate,
+};
+
+static int _clk_periph_apm_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+	struct timespec nstimeofday;
+	struct timespec curtime;
+
+	mux = _get_mux(parent, &pll1_sw_clk, &pll3_sw_clk, &lp_apm_clk, NULL);
+
+	reg = __raw_readl(MXC_CCM_CBCMR) & ~MXC_CCM_CBCMR_PERIPH_CLK_SEL_MASK;
+	reg |= mux << MXC_CCM_CBCMR_PERIPH_CLK_SEL_OFFSET;
+	__raw_writel(reg, MXC_CCM_CBCMR);
+
+	getnstimeofday(&nstimeofday);
+	while (__raw_readl(MXC_CCM_CDHIPR) &
+			MXC_CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) {
+		getnstimeofday(&curtime);
+		if (curtime.tv_nsec - nstimeofday.tv_nsec > SPIN_DELAY)
+			panic("pll _clk_periph_apm_set_parent failed\n");
+	}
+	return 0;
+}
+
+static struct clk periph_apm_clk = {
+	.parent = &pll1_sw_clk,
+	.set_parent = _clk_periph_apm_set_parent,
+};
+
+/* TODO: Need to sync with GPC to determine if DVFS is in place so that
+ * the DVFS_PODF divider can be applied in CDCR register.
+ */
+static unsigned long _clk_main_bus_get_rate(struct clk *clk)
+{
+	u32 div = 0;
+
+	if (dvfs_per_divider_active() || low_bus_freq_mode)
+		div  = (__raw_readl(MXC_CCM_CDCR) & 0x3);
+	return clk_get_rate(clk->parent) / (div + 1);
+}
+
+static int _clk_main_bus_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg;
+	if (emi_fast_clk.usecount == 0)
+		emi_fast_clk.enable(&emi_fast_clk);
+	if (emi_slow_clk.usecount == 0)
+		emi_slow_clk.enable(&emi_slow_clk);
+
+	if (parent == &pll2_sw_clk) {
+		reg = __raw_readl(MXC_CCM_CBCDR) &
+		    ~MXC_CCM_CBCDR_PERIPH_CLK_SEL;
+	} else if (parent == &periph_apm_clk) {
+		reg = __raw_readl(MXC_CCM_CBCDR) | MXC_CCM_CBCDR_PERIPH_CLK_SEL;
+	} else {
+		return -EINVAL;
+	}
+	__raw_writel(reg, MXC_CCM_CBCDR);
+	if (emi_fast_clk.usecount == 0)
+		emi_fast_clk.disable(&emi_fast_clk);
+	if (emi_slow_clk.usecount == 0)
+		emi_slow_clk.disable(&emi_slow_clk);
+
+	return 0;
+}
+
+static struct clk main_bus_clk = {
+	.parent = &pll2_sw_clk,
+	.set_parent = _clk_main_bus_set_parent,
+	.get_rate = _clk_main_bus_get_rate,
+};
+
+static unsigned long _clk_axi_a_get_rate(struct clk *clk)
+{
+	u32 reg, div;
+
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	div = ((reg & MXC_CCM_CBCDR_AXI_A_PODF_MASK) >>
+	       MXC_CCM_CBCDR_AXI_A_PODF_OFFSET) + 1;
+	return clk_get_rate(clk->parent) / div;
+}
+
+static int _clk_axi_a_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg, div;
+	struct timespec nstimeofday;
+	struct timespec curtime;
+	u32 parent_rate = clk_get_rate(clk->parent);
+
+	div = parent_rate / rate;
+	if (div == 0)
+		div++;
+	if (((parent_rate / div) != rate) || (div > 8))
+		return -EINVAL;
+	if (emi_fast_clk.usecount == 0)
+		emi_fast_clk.enable(&emi_fast_clk);
+	if (emi_slow_clk.usecount == 0)
+		emi_slow_clk.enable(&emi_slow_clk);
+
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	reg &= ~MXC_CCM_CBCDR_AXI_A_PODF_MASK;
+	reg |= (div - 1) << MXC_CCM_CBCDR_AXI_A_PODF_OFFSET;
+	__raw_writel(reg, MXC_CCM_CBCDR);
+
+	getnstimeofday(&nstimeofday);
+	while (__raw_readl(MXC_CCM_CDHIPR) & MXC_CCM_CDHIPR_AXI_A_PODF_BUSY) {
+		getnstimeofday(&curtime);
+		if (curtime.tv_nsec - nstimeofday.tv_nsec > SPIN_DELAY)
+			panic("pll _clk_axi_a_set_rate failed\n");
+	}
+	if (emi_fast_clk.usecount == 0)
+		emi_fast_clk.disable(&emi_fast_clk);
+	if (emi_slow_clk.usecount == 0)
+		emi_slow_clk.disable(&emi_slow_clk);
+
+	return 0;
+}
+
+static unsigned long _clk_axi_a_round_rate(struct clk *clk,
+						unsigned long rate)
+{
+	u32 div;
+	u32 parent_rate = clk_get_rate(clk->parent);
+
+	div = parent_rate / rate;
+
+	/* Make sure rate is not greater than the maximum value for the clock.
+	 * Also prevent a div of 0.
+	 */
+	if (div == 0)
+		div++;
+	if (parent_rate / div > max_axi_a_clk)
+		div++;
+
+	if (div > 8)
+		div = 8;
+
+	return parent_rate / div;
+}
+
+
+static struct clk axi_a_clk = {
+	.parent = &main_bus_clk,
+	.get_rate = _clk_axi_a_get_rate,
+	.set_rate = _clk_axi_a_set_rate,
+	.round_rate = _clk_axi_a_round_rate,
+};
+
+static unsigned long _clk_ddr_hf_get_rate(struct clk *clk)
+{
+	u32 reg, div;
+
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	div = ((reg & MXC_CCM_CBCDR_DDR_PODF_MASK) >>
+	       MXC_CCM_CBCDR_DDR_PODF_OFFSET) + 1;
+	return clk_get_rate(clk->parent) / div;
+}
+
+static unsigned long _clk_ddr_hf_round_rate(struct clk *clk,
+						unsigned long rate)
+{
+	u32 div;
+	u32 parent_rate = clk_get_rate(clk->parent);
+
+	div = parent_rate / rate;
+
+	/* Make sure rate is not greater than the maximum value for the clock.
+	 * Also prevent a div of 0.
+	 */
+	if (div == 0)
+		div++;
+	if (parent_rate / div > MAX_DDR_HF_RATE)
+		div++;
+
+	if (div > 8)
+		div = 8;
+
+	return parent_rate / div;
+}
+
+static int _clk_ddr_hf_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg, div;
+	struct timespec nstimeofday;
+	struct timespec curtime;
+	u32 parent_rate = clk_get_rate(clk->parent);
+
+	div = parent_rate / rate;
+	if (div == 0)
+		div++;
+	if (((parent_rate / div) != rate) || (div > 8))
+		return -EINVAL;
+	if (emi_fast_clk.usecount == 0)
+		emi_fast_clk.enable(&emi_fast_clk);
+	if (emi_slow_clk.usecount == 0)
+		emi_slow_clk.enable(&emi_slow_clk);
+
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	reg &= ~MXC_CCM_CBCDR_DDR_PODF_MASK;
+	reg |= (div - 1) << MXC_CCM_CBCDR_DDR_PODF_OFFSET;
+	__raw_writel(reg, MXC_CCM_CBCDR);
+
+	getnstimeofday(&nstimeofday);
+	while (__raw_readl(MXC_CCM_CDHIPR) & MXC_CCM_CDHIPR_DDR_PODF_BUSY) {
+		getnstimeofday(&curtime);
+		if (curtime.tv_nsec - nstimeofday.tv_nsec > SPIN_DELAY)
+			panic("clk_ddr_hf_set_rate failed\n");
+	}
+	if (emi_fast_clk.usecount == 0)
+		emi_fast_clk.disable(&emi_fast_clk);
+	if (emi_slow_clk.usecount == 0)
+		emi_slow_clk.disable(&emi_slow_clk);
+
+	return 0;
+}
+
+static struct clk ddr_hf_clk = {
+	.parent = &pll1_sw_clk,
+	.get_rate = _clk_ddr_hf_get_rate,
+	.round_rate = _clk_ddr_hf_round_rate,
+	.set_rate = _clk_ddr_hf_set_rate,
+};
+
+static unsigned long _clk_axi_b_get_rate(struct clk *clk)
+{
+	u32 reg, div;
+
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	div = ((reg & MXC_CCM_CBCDR_AXI_B_PODF_MASK) >>
+	       MXC_CCM_CBCDR_AXI_B_PODF_OFFSET) + 1;
+	return clk_get_rate(clk->parent) / div;
+}
+
+static int _clk_axi_b_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg, div;
+	struct timespec nstimeofday;
+	struct timespec curtime;
+	u32 parent_rate = clk_get_rate(clk->parent);
+
+	div = parent_rate / rate;
+	if (div == 0)
+		div++;
+	if (((parent_rate / div) != rate) || (div > 8))
+		return -EINVAL;
+
+	emi_fast_clk.enable(&emi_fast_clk);
+	if (emi_slow_clk.usecount == 0)
+		emi_slow_clk.enable(&emi_slow_clk);
+
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	reg &= ~MXC_CCM_CBCDR_AXI_B_PODF_MASK;
+	reg |= (div - 1) << MXC_CCM_CBCDR_AXI_B_PODF_OFFSET;
+	__raw_writel(reg, MXC_CCM_CBCDR);
+
+	getnstimeofday(&nstimeofday);
+	while (__raw_readl(MXC_CCM_CDHIPR) & MXC_CCM_CDHIPR_AXI_B_PODF_BUSY) {
+		getnstimeofday(&curtime);
+		if (curtime.tv_nsec - nstimeofday.tv_nsec > SPIN_DELAY)
+			panic("_clk_axi_b_set_rate failed\n");
+	}
+
+	emi_fast_clk.disable(&emi_fast_clk);
+	if (emi_slow_clk.usecount == 0)
+		emi_slow_clk.disable(&emi_slow_clk);
+
+	return 0;
+}
+
+static unsigned long _clk_axi_b_round_rate(struct clk *clk,
+						unsigned long rate)
+{
+	u32 div;
+	u32 parent_rate = clk_get_rate(clk->parent);
+
+	div = parent_rate / rate;
+
+	/* Make sure rate is not greater than the maximum value for the clock.
+	 * Also prevent a div of 0.
+	 */
+	if (div == 0)
+		div++;
+	if (parent_rate / div > max_axi_b_clk)
+		div++;
+
+	if (div > 8)
+		div = 8;
+
+	return parent_rate / div;
+}
+
+
+static struct clk axi_b_clk = {
+	.parent = &main_bus_clk,
+	.get_rate = _clk_axi_b_get_rate,
+	.set_rate = _clk_axi_b_set_rate,
+	.round_rate = _clk_axi_b_round_rate,
+};
+
+static unsigned long _clk_ahb_get_rate(struct clk *clk)
+{
+	u32 reg, div;
+
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	div = ((reg & MXC_CCM_CBCDR_AHB_PODF_MASK) >>
+	       MXC_CCM_CBCDR_AHB_PODF_OFFSET) + 1;
+	return clk_get_rate(clk->parent) / div;
+}
+
+
+static int _clk_ahb_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg, div;
+	struct timespec nstimeofday;
+	struct timespec curtime;
+	u32 parent_rate = clk_get_rate(clk->parent);
+
+	div = parent_rate / rate;
+	if (div == 0)
+		div++;
+	if (((parent_rate / div) != rate) || (div > 8))
+		return -EINVAL;
+	if (emi_fast_clk.usecount == 0)
+		emi_fast_clk.enable(&emi_fast_clk);
+	if (emi_slow_clk.usecount == 0)
+		emi_slow_clk.enable(&emi_slow_clk);
+
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	reg &= ~MXC_CCM_CBCDR_AHB_PODF_MASK;
+	reg |= (div - 1) << MXC_CCM_CBCDR_AHB_PODF_OFFSET;
+	__raw_writel(reg, MXC_CCM_CBCDR);
+
+	getnstimeofday(&nstimeofday);
+	while (__raw_readl(MXC_CCM_CDHIPR) & MXC_CCM_CDHIPR_AHB_PODF_BUSY) {
+		getnstimeofday(&curtime);
+		if (curtime.tv_nsec - nstimeofday.tv_nsec > SPIN_DELAY)
+			panic("_clk_ahb_set_rate failed\n");
+	}
+	if (emi_fast_clk.usecount == 0)
+		emi_fast_clk.disable(&emi_fast_clk);
+	if (emi_slow_clk.usecount == 0)
+		emi_slow_clk.disable(&emi_slow_clk);
+
+	return 0;
+}
+
+static unsigned long _clk_ahb_round_rate(struct clk *clk,
+						unsigned long rate)
+{
+	u32 div;
+	u32 parent_rate = clk_get_rate(clk->parent);
+
+	div = parent_rate / rate;
+
+	/* Make sure rate is not greater than the maximum value for the clock.
+	 * Also prevent a div of 0.
+	 */
+	if (div == 0)
+		div++;
+	if (parent_rate / div > max_ahb_clk)
+		div++;
+
+	if (div > 8)
+		div = 8;
+
+	return parent_rate / div;
+}
+
+
+static struct clk ahb_clk = {
+	.parent = &main_bus_clk,
+	.get_rate = _clk_ahb_get_rate,
+	.set_rate = _clk_ahb_set_rate,
+	.round_rate = _clk_ahb_round_rate,
+};
+
+static int _clk_max_enable(struct clk *clk)
+{
+	u32 reg;
+
+	_clk_enable(clk);
+
+	/* Handshake with MAX when LPM is entered. */
+	reg = __raw_readl(MXC_CCM_CLPCR);
+	if (cpu_is_mx51())
+		reg &= ~MXC_CCM_CLPCR_BYPASS_MAX_LPM_HS_MX51;
+	else
+		reg &= ~MXC_CCM_CLPCR_BYPASS_MAX_LPM_HS;
+	__raw_writel(reg, MXC_CCM_CLPCR);
+
+	return 0;
+}
+
+
+static void _clk_max_disable(struct clk *clk)
+{
+	u32 reg;
+
+	_clk_disable_inwait(clk);
+
+	/* No Handshake with MAX when LPM is entered as its disabled. */
+	reg = __raw_readl(MXC_CCM_CLPCR);
+	if (cpu_is_mx51())
+		reg |= MXC_CCM_CLPCR_BYPASS_MAX_LPM_HS_MX51;
+	else
+		reg |= MXC_CCM_CLPCR_BYPASS_MAX_LPM_HS;
+	__raw_writel(reg, MXC_CCM_CLPCR);
+}
+
+
+static struct clk ahb_max_clk = {
+	.parent = &ahb_clk,
+	.enable_reg = MXC_CCM_CCGR0,
+	.enable_shift = MXC_CCM_CCGRx_CG14_OFFSET,
+	.enable = _clk_max_enable,
+	.disable = _clk_max_disable,
+};
+
+static int _clk_emi_slow_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg;
+
+	if (emi_fast_clk.usecount == 0)
+		emi_fast_clk.enable(&emi_fast_clk);
+	if (emi_slow_clk.usecount == 0)
+		emi_slow_clk.enable(&emi_slow_clk);
+
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	if (parent == &ahb_clk) {
+		reg |= MXC_CCM_CBCDR_EMI_CLK_SEL;
+	} else if (parent == &main_bus_clk) {
+		reg &= ~MXC_CCM_CBCDR_EMI_CLK_SEL;
+	} else {
+		BUG();
+	}
+	__raw_writel(reg, MXC_CCM_CBCDR);
+
+	if (emi_fast_clk.usecount == 0)
+		emi_fast_clk.disable(&emi_fast_clk);
+	if (emi_slow_clk.usecount == 0)
+		emi_slow_clk.disable(&emi_slow_clk);
+
+	return 0;
+}
+
+static unsigned long _clk_emi_slow_get_rate(struct clk *clk)
+{
+	u32 reg, div;
+
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	div = ((reg & MXC_CCM_CBCDR_EMI_PODF_MASK) >>
+	       MXC_CCM_CBCDR_EMI_PODF_OFFSET) + 1;
+	return clk_get_rate(clk->parent) / div;
+}
+
+static int _clk_emi_slow_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg, div;
+	struct timespec nstimeofday;
+	struct timespec curtime;
+	u32 parent_rate = clk_get_rate(clk->parent);
+
+	div = parent_rate / rate;
+	if (div == 0)
+		div++;
+	if (((parent_rate / div) != rate) || (div > 8))
+		return -EINVAL;
+	if (emi_fast_clk.usecount == 0)
+		emi_fast_clk.enable(&emi_fast_clk);
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	reg &= ~MXC_CCM_CBCDR_EMI_PODF_MASK;
+	reg |= (div - 1) << MXC_CCM_CBCDR_EMI_PODF_OFFSET;
+	__raw_writel(reg, MXC_CCM_CBCDR);
+	getnstimeofday(&nstimeofday);
+	while (__raw_readl(MXC_CCM_CDHIPR) & MXC_CCM_CDHIPR_EMI_PODF_BUSY) {
+		getnstimeofday(&curtime);
+		if ((curtime.tv_nsec - nstimeofday.tv_nsec) > SPIN_DELAY)
+			panic("_clk_emi_slow_set_rate failed\n");
+	}
+
+	if (emi_fast_clk.usecount == 0)
+		emi_fast_clk.disable(&emi_fast_clk);
+
+	return 0;
+}
+
+static unsigned long _clk_emi_slow_round_rate(struct clk *clk,
+					      unsigned long rate)
+{
+	u32 div;
+	u32 parent_rate = clk_get_rate(clk->parent);
+
+	div = parent_rate / rate;
+
+	/* Make sure rate is not greater than the maximum value for the clock.
+	 * Also prevent a div of 0.
+	 */
+	if (div == 0)
+		div++;
+	if (parent_rate / div > max_emi_slow_clk)
+		div++;
+
+	if (div > 8)
+		div = 8;
+
+	return parent_rate / div;
+}
+
+
+static struct clk emi_slow_clk = {
+	.parent = &main_bus_clk,
+	.set_parent = _clk_emi_slow_set_parent,
+	.get_rate = _clk_emi_slow_get_rate,
+	.set_rate = _clk_emi_slow_set_rate,
+	.round_rate = _clk_emi_slow_round_rate,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR5,
+	.enable_shift = MXC_CCM_CCGRx_CG8_OFFSET,
+	.disable = _clk_disable_inwait,
+};
+
+static struct clk ahbmux1_clk = {
+	.id = 0,
+	.parent = &ahb_clk,
+	.secondary = &ahb_max_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR0,
+	.enable_shift = MXC_CCM_CCGRx_CG8_OFFSET,
+	.disable = _clk_disable_inwait,
+};
+
+static struct clk ahbmux2_clk = {
+	.id = 0,
+	.parent = &ahb_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR0,
+	.enable_shift = MXC_CCM_CCGRx_CG9_OFFSET,
+	.disable = _clk_disable_inwait,
+};
+
+
+static struct clk emi_fast_clk = {
+	.parent = &ddr_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR5,
+	.enable_shift = MXC_CCM_CCGRx_CG7_OFFSET,
+	.disable = _clk_disable_inwait,
+};
+
+static struct clk emi_intr_clk[] = {
+	{
+	.id = 0,
+	.parent = &ahb_clk,
+	.secondary = &ahbmux2_clk,
+	.enable_reg = MXC_CCM_CCGR5,
+	.enable_shift = MXC_CCM_CCGRx_CG9_OFFSET,
+	.enable = _clk_enable,
+	.disable = _clk_disable_inwait,
+	},
+	{
+	/* On MX51 - this clock is name emi_garb_clk, and controls the
+	 * access of ARM to GARB.
+	 */
+	.id = 1,
+	.parent = &ahb_clk,
+	.secondary = &ahbmux2_clk,
+	.enable_reg = MXC_CCM_CCGR6,
+	.enable_shift = MXC_CCM_CCGRx_CG4_OFFSET,
+	.enable = _clk_enable,
+	.disable = _clk_disable_inwait,
+	}
+};
+
+static unsigned long _clk_ipg_get_rate(struct clk *clk)
+{
+	u32 reg, div;
+
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	div = ((reg & MXC_CCM_CBCDR_IPG_PODF_MASK) >>
+	       MXC_CCM_CBCDR_IPG_PODF_OFFSET) + 1;
+	return clk_get_rate(clk->parent) / div;
+}
+
+static struct clk ipg_clk = {
+	.parent = &ahb_clk,
+	.get_rate = _clk_ipg_get_rate,
+};
+
+static unsigned long _clk_ipg_per_get_rate(struct clk *clk)
+{
+	u32 reg, prediv1, prediv2, podf;
+
+	if (clk->parent == &main_bus_clk || clk->parent == &lp_apm_clk) {
+		/* the main_bus_clk is the one before the DVFS engine */
+		reg = __raw_readl(MXC_CCM_CBCDR);
+		prediv1 = ((reg & MXC_CCM_CBCDR_PERCLK_PRED1_MASK) >>
+			   MXC_CCM_CBCDR_PERCLK_PRED1_OFFSET) + 1;
+		prediv2 = ((reg & MXC_CCM_CBCDR_PERCLK_PRED2_MASK) >>
+			   MXC_CCM_CBCDR_PERCLK_PRED2_OFFSET) + 1;
+		podf = ((reg & MXC_CCM_CBCDR_PERCLK_PODF_MASK) >>
+			MXC_CCM_CBCDR_PERCLK_PODF_OFFSET) + 1;
+		return clk_get_rate(clk->parent) / (prediv1 * prediv2 * podf);
+	} else if (clk->parent == &ipg_clk) {
+		return clk_get_rate(&ipg_clk);
+	}
+	BUG();
+	return 0;
+}
+
+static int _clk_ipg_per_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	reg = __raw_readl(MXC_CCM_CBCMR);
+	mux = _get_mux(parent, &main_bus_clk, &lp_apm_clk, &ipg_clk, NULL);
+	if (mux == 2) {
+		reg |= MXC_CCM_CBCMR_PERCLK_IPG_CLK_SEL;
+	} else {
+		reg &= ~MXC_CCM_CBCMR_PERCLK_IPG_CLK_SEL;
+		if (mux == 0)
+			reg &= ~MXC_CCM_CBCMR_PERCLK_LP_APM_CLK_SEL;
+		else
+			reg |= MXC_CCM_CBCMR_PERCLK_LP_APM_CLK_SEL;
+	}
+	__raw_writel(reg, MXC_CCM_CBCMR);
+
+	return 0;
+}
+
+static struct clk ipg_perclk = {
+	.parent = &lp_apm_clk,
+	.get_rate = _clk_ipg_per_get_rate,
+	.set_parent = _clk_ipg_per_set_parent,
+};
+
+static int _clk_ipmux_enable(struct clk *clk)
+{
+	u32 reg;
+	reg = __raw_readl(clk->enable_reg);
+	reg |= 1  << clk->enable_shift;
+	__raw_writel(reg, clk->enable_reg);
+
+	return 0;
+}
+
+static void _clk_ipmux_disable(struct clk *clk)
+{
+	u32 reg;
+	reg = __raw_readl(clk->enable_reg);
+	reg &= ~(0x1 << clk->enable_shift);
+	__raw_writel(reg, clk->enable_reg);
+}
+
+static struct clk ipumux1_clk = {
+	.enable_reg = MXC_CCM_CCGR5,
+	.enable_shift = MXC_CCM_CCGR5_CG6_1_OFFSET,
+	.enable = _clk_ipmux_enable,
+	.disable = _clk_ipmux_disable,
+};
+
+static struct clk ipumux2_clk = {
+	.enable_reg = MXC_CCM_CCGR5,
+	.enable_shift = MXC_CCM_CCGR5_CG6_2_OFFSET,
+	.enable = _clk_ipmux_enable,
+	.disable = _clk_ipmux_disable,
+};
+
+static int _clk_ocram_enable(struct clk *clk)
+{
+	return 0;
+}
+
+static void _clk_ocram_disable(struct clk *clk)
+{
+}
+
+static struct clk ocram_clk = {
+	.enable_reg = MXC_CCM_CCGR6,
+	.enable_shift = MXC_CCM_CCGRx_CG1_OFFSET,
+	.enable = _clk_ocram_enable,
+	.disable = _clk_ocram_disable,
+};
+
+
+static struct clk aips_tz1_clk = {
+	.parent = &ahb_clk,
+	.secondary = &ahb_max_clk,
+	.enable_reg = MXC_CCM_CCGR0,
+	.enable_shift = MXC_CCM_CCGRx_CG12_OFFSET,
+	.enable = _clk_enable,
+	.disable = _clk_disable_inwait,
+};
+
+static struct clk aips_tz2_clk = {
+	.parent = &ahb_clk,
+	.secondary = &ahb_max_clk,
+	.enable_reg = MXC_CCM_CCGR0,
+	.enable_shift = MXC_CCM_CCGRx_CG13_OFFSET,
+	.enable = _clk_enable,
+	.disable = _clk_disable_inwait,
+};
+
+static struct clk gpc_dvfs_clk = {
+	.enable_reg = MXC_CCM_CCGR5,
+	.enable_shift = MXC_CCM_CCGRx_CG12_OFFSET,
+	.enable = _clk_enable,
+	.disable = _clk_disable,
+};
+
+static int _clk_sdma_enable(struct clk *clk)
+{
+	u32 reg;
+
+	_clk_enable(clk);
+
+	/* Handshake with SDMA when LPM is entered. */
+	reg = __raw_readl(MXC_CCM_CLPCR);
+	if (cpu_is_mx51())
+		reg &= ~MXC_CCM_CLPCR_BYPASS_SDMA_LPM_HS_MX51;
+	else
+		reg &= ~MXC_CCM_CLPCR_BYPASS_SDMA_LPM_HS;
+	__raw_writel(reg, MXC_CCM_CLPCR);
+
+	return 0;
+}
+
+static void _clk_sdma_disable(struct clk *clk)
+{
+	u32 reg;
+
+	_clk_disable(clk);
+	/* No handshake with SDMA as its not enabled. */
+	reg = __raw_readl(MXC_CCM_CLPCR);
+	if (cpu_is_mx51())
+		reg |= MXC_CCM_CLPCR_BYPASS_SDMA_LPM_HS_MX51;
+	else
+		reg |= MXC_CCM_CLPCR_BYPASS_SDMA_LPM_HS;
+	__raw_writel(reg, MXC_CCM_CLPCR);
+}
+
+
+static struct clk sdma_clk[] = {
+	{
+	 .parent = &ahb_clk,
+	 .enable_reg = MXC_CCM_CCGR4,
+	 .enable_shift = MXC_CCM_CCGRx_CG15_OFFSET,
+	 .enable = _clk_sdma_enable,
+	 .disable = _clk_sdma_disable,
+	 },
+	{
+	 .parent = &ipg_clk,
+#ifdef CONFIG_SDMA_IRAM
+	 .secondary = &emi_intr_clk[0],
+#endif
+	 },
+};
+
+static int _clk_ipu_enable(struct clk *clk)
+{
+	u32 reg;
+
+	_clk_enable(clk);
+	/* Handshake with IPU when certain clock rates are changed. */
+	reg = __raw_readl(MXC_CCM_CCDR);
+	if (cpu_is_mx51())
+		reg &= ~MXC_CCM_CCDR_IPU_HS_MASK;
+	else
+		reg &= ~MXC_CCM_CCDR_IPU_HS_MX53_MASK;
+	__raw_writel(reg, MXC_CCM_CCDR);
+
+	/* Handshake with IPU when LPM is entered as its enabled. */
+	reg = __raw_readl(MXC_CCM_CLPCR);
+	reg &= ~MXC_CCM_CLPCR_BYPASS_IPU_LPM_HS;
+	__raw_writel(reg, MXC_CCM_CLPCR);
+
+	start_sdram_autogating();
+
+	return 0;
+}
+
+static void _clk_ipu_disable(struct clk *clk)
+{
+	u32 reg;
+
+	if (sdram_autogating_active())
+		stop_sdram_autogating();
+
+	_clk_disable(clk);
+
+	/* No handshake with IPU whe dividers are changed
+	 * as its not enabled. */
+	reg = __raw_readl(MXC_CCM_CCDR);
+	if (cpu_is_mx51())
+		reg |= MXC_CCM_CCDR_IPU_HS_MASK;
+	else
+		reg |= MXC_CCM_CCDR_IPU_HS_MX53_MASK;
+	__raw_writel(reg, MXC_CCM_CCDR);
+
+	/* No handshake with IPU when LPM is entered as its not enabled. */
+	reg = __raw_readl(MXC_CCM_CLPCR);
+	reg |= MXC_CCM_CLPCR_BYPASS_IPU_LPM_HS;
+	__raw_writel(reg, MXC_CCM_CLPCR);
+}
+
+static int _clk_ipu_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+	reg = __raw_readl(MXC_CCM_CBCMR);
+	mux = _get_mux(parent, &axi_a_clk, &axi_b_clk, &ahb_clk,
+		       &emi_slow_clk);
+	reg = (reg & ~MXC_CCM_CBCMR_IPU_HSP_CLK_SEL_MASK) |
+	    (mux << MXC_CCM_CBCMR_IPU_HSP_CLK_SEL_OFFSET);
+	__raw_writel(reg, MXC_CCM_CBCMR);
+
+	return 0;
+}
+
+
+static struct clk ipu_clk[] = {
+	{
+	.parent = &ahb_clk,
+	.secondary = &ipu_clk[1],
+	.enable_reg = MXC_CCM_CCGR5,
+	.enable_shift = MXC_CCM_CCGRx_CG5_OFFSET,
+	.enable = _clk_ipu_enable,
+	.disable = _clk_ipu_disable,
+	.set_parent = _clk_ipu_set_parent,
+	 .flags = CPU_FREQ_TRIG_UPDATE | AHB_MED_SET_POINT,
+	},
+	{
+	 .parent = &emi_fast_clk,
+	 .secondary = &ahbmux1_clk,
+	}
+};
+
+static int _clk_ipu_di_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg;
+
+	reg = __raw_readl(MXC_CCM_CSCMR2);
+	reg &= ~MXC_CCM_CSCMR2_DI_CLK_SEL_MASK(clk->id);
+	if (parent == &pll3_sw_clk)
+		;
+	else if (parent == &osc_clk)
+		reg |= 1 << MXC_CCM_CSCMR2_DI_CLK_SEL_OFFSET(clk->id);
+	else if (parent == &ckih_clk)
+		reg |= 2 << MXC_CCM_CSCMR2_DI_CLK_SEL_OFFSET(clk->id);
+	else if ((parent == &pll4_sw_clk) && (clk->id == 0)) {
+		if (cpu_is_mx51())
+			return -EINVAL;
+		reg |= 3 << MXC_CCM_CSCMR2_DI_CLK_SEL_OFFSET(clk->id);
+	} else if ((parent == &tve_clk) && (clk->id == 1))
+		reg |= 3 << MXC_CCM_CSCMR2_DI_CLK_SEL_OFFSET(clk->id);
+	else if ((parent == &ldb_di_clk[clk->id]) && cpu_is_mx53())
+		reg |= 5 << MXC_CCM_CSCMR2_DI_CLK_SEL_OFFSET(clk->id);
+	else		/* Assume any other clock is external clock pin */
+		reg |= 4 << MXC_CCM_CSCMR2_DI_CLK_SEL_OFFSET(clk->id);
+	__raw_writel(reg, MXC_CCM_CSCMR2);
+
+	return 0;
+}
+
+static int priv_div;
+static unsigned long _clk_ipu_di_get_rate(struct clk *clk)
+{
+	u32 reg, mux;
+	u32 div = 1;
+
+	reg = __raw_readl(MXC_CCM_CSCMR2);
+	mux = (reg & MXC_CCM_CSCMR2_DI_CLK_SEL_MASK(clk->id)) >>
+		MXC_CCM_CSCMR2_DI_CLK_SEL_OFFSET(clk->id);
+	if (mux == 0) {
+		reg = __raw_readl(MXC_CCM_CDCDR) &
+		    MXC_CCM_CDCDR_DI1_CLK_PRED_MASK;
+		div = (reg >> MXC_CCM_CDCDR_DI1_CLK_PRED_OFFSET) + 1;
+	} else if ((mux == 3) && (clk->id == 1)) {
+		if (priv_div)
+			div = priv_div;
+	} else if ((mux == 3) && (clk->id == 0)) {
+		reg = __raw_readl(MXC_CCM_CDCDR) &
+			MXC_CCM_CDCDR_DI_PLL4_PODF_MASK;
+		div = (reg >> MXC_CCM_CDCDR_DI_PLL4_PODF_OFFSET) + 1;
+	}
+	return clk_get_rate(clk->parent) / div;
+}
+
+static int _clk_ipu_di_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg, div;
+	u32 parent_rate = clk_get_rate(clk->parent);
+
+	div = parent_rate / rate;
+	if (div == 0)
+		div++;
+	if (((parent_rate / div) != rate) || (div > 8))
+		return -EINVAL;
+
+	if ((clk->parent == &pll4_sw_clk) && (clk->id == 0)) {
+		reg = __raw_readl(MXC_CCM_CDCDR);
+		reg &= ~MXC_CCM_CDCDR_DI_PLL4_PODF_MASK;
+		reg |= (div - 1) << MXC_CCM_CDCDR_DI_PLL4_PODF_OFFSET;
+		__raw_writel(reg, MXC_CCM_CDCDR);
+	} else if (clk->parent == &pll3_sw_clk) {
+		reg = __raw_readl(MXC_CCM_CDCDR);
+		reg &= ~MXC_CCM_CDCDR_DI1_CLK_PRED_MASK;
+		reg |= (div - 1) << MXC_CCM_CDCDR_DI1_CLK_PRED_OFFSET;
+		__raw_writel(reg, MXC_CCM_CDCDR);
+	} else if (((clk->parent == &tve_clk) && (clk->id == 1)) ||
+		((clk->parent == &ldb_di_clk[clk->id]) && cpu_is_mx53())) {
+		priv_div = div;
+		return 0;
+	} else
+		return -EINVAL;
+
+	return 0;
+}
+
+static unsigned long _clk_ipu_di_round_rate(struct clk *clk,
+					    unsigned long rate)
+{
+	u32 div;
+	u32 parent_rate = clk_get_rate(clk->parent);
+
+	if ((clk->parent == &ldb_di_clk[clk->id]) && cpu_is_mx53())
+		return parent_rate;
+	else {
+		div = (parent_rate + rate/2) / rate;
+		if (div > 8)
+			div = 8;
+		else if (div == 0)
+			div++;
+		return parent_rate / div;
+	}
+}
+
+static struct clk ipu_di_clk[] = {
+	{
+	.id = 0,
+	.parent = &pll3_sw_clk,
+	.enable_reg = MXC_CCM_CCGR6,
+	.enable_shift = MXC_CCM_CCGRx_CG5_OFFSET,
+	.get_rate = _clk_ipu_di_get_rate,
+	.set_parent = _clk_ipu_di_set_parent,
+	.round_rate = _clk_ipu_di_round_rate,
+	.set_rate = _clk_ipu_di_set_rate,
+	.enable = _clk_enable,
+	.disable = _clk_disable,
+	},
+	{
+	.id = 1,
+	.parent = &pll3_sw_clk,
+	.enable_reg = MXC_CCM_CCGR6,
+	.enable_shift = MXC_CCM_CCGRx_CG6_OFFSET,
+	.get_rate = _clk_ipu_di_get_rate,
+	.set_parent = _clk_ipu_di_set_parent,
+	.round_rate = _clk_ipu_di_round_rate,
+	.set_rate = _clk_ipu_di_set_rate,
+	.enable = _clk_enable,
+	.disable = _clk_disable,
+	},
+};
+
+static int _clk_ldb_di_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg;
+
+	reg = __raw_readl(MXC_CCM_CSCMR2);
+
+	if ((parent == &pll3_sw_clk)) {
+		if (clk->id == 0)
+			reg &= ~(MXC_CCM_CSCMR2_LDB_DI0_CLK_SEL);
+		else
+			reg &= ~(MXC_CCM_CSCMR2_LDB_DI1_CLK_SEL);
+	} else if ((parent == &pll4_sw_clk)) {
+		if (clk->id == 0)
+			reg |= MXC_CCM_CSCMR2_LDB_DI0_CLK_SEL;
+		else
+			reg |= MXC_CCM_CSCMR2_LDB_DI1_CLK_SEL;
+	} else {
+		BUG();
+	}
+
+	__raw_writel(reg, MXC_CCM_CSCMR2);
+	return 0;
+}
+
+static unsigned long _clk_ldb_di_get_rate(struct clk *clk)
+{
+	u32 div;
+
+	if (clk->id == 0)
+		div = __raw_readl(MXC_CCM_CSCMR2) &
+			MXC_CCM_CSCMR2_LDB_DI0_IPU_DIV;
+	else
+		div = __raw_readl(MXC_CCM_CSCMR2) &
+			MXC_CCM_CSCMR2_LDB_DI1_IPU_DIV;
+
+	if (div)
+		return clk_get_rate(clk->parent) / 7;
+
+	return (2 * clk_get_rate(clk->parent)) / 7;
+}
+
+static unsigned long _clk_ldb_di_round_rate(struct clk *clk,
+						unsigned long rate)
+{
+	u32 parent_rate = clk_get_rate(clk->parent);
+
+	if (rate * 7 <= parent_rate + parent_rate/20)
+		return parent_rate / 7;
+	else
+		return 2 * parent_rate / 7;
+}
+
+static int _clk_ldb_di_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg, div = 0;
+	u32 parent_rate = clk_get_rate(clk->parent);
+
+	if (rate * 7 <= parent_rate + parent_rate/20) {
+		div = 7;
+		rate = parent_rate / 7;
+	} else
+		rate = 2 * parent_rate / 7;
+
+	reg = __raw_readl(MXC_CCM_CSCMR2);
+	if (div == 7)
+		reg |= (clk->id ? MXC_CCM_CSCMR2_LDB_DI1_IPU_DIV :
+			MXC_CCM_CSCMR2_LDB_DI0_IPU_DIV);
+	else
+		reg &= ~(clk->id ? MXC_CCM_CSCMR2_LDB_DI1_IPU_DIV :
+			MXC_CCM_CSCMR2_LDB_DI0_IPU_DIV);
+	__raw_writel(reg, MXC_CCM_CSCMR2);
+
+	return 0;
+}
+
+static int _clk_ldb_di_enable(struct clk *clk)
+{
+	_clk_enable(clk);
+	ipu_di_clk[clk->id].set_parent(&ipu_di_clk[clk->id], clk);
+	ipu_di_clk[clk->id].parent = clk;
+	ipu_di_clk[clk->id].enable(&ipu_di_clk[clk->id]);
+	ipu_di_clk[clk->id].usecount++;
+	return 0;
+}
+
+static void _clk_ldb_di_disable(struct clk *clk)
+{
+	_clk_disable(clk);
+	ipu_di_clk[clk->id].disable(&ipu_di_clk[clk->id]);
+	ipu_di_clk[clk->id].usecount--;
+}
+
+static struct clk ldb_di_clk[] = {
+	{
+	.id = 0,
+	.parent = &pll4_sw_clk,
+	.enable_reg = MXC_CCM_CCGR6,
+	.enable_shift = MXC_CCM_CCGRx_CG14_OFFSET,
+	.get_rate = _clk_ldb_di_get_rate,
+	.set_parent = _clk_ldb_di_set_parent,
+	.round_rate = _clk_ldb_di_round_rate,
+	.set_rate = _clk_ldb_di_set_rate,
+	.enable = _clk_ldb_di_enable,
+	.disable = _clk_ldb_di_disable,
+	.flags = AHB_MED_SET_POINT,
+	},
+	{
+	.id = 1,
+	.parent = &pll4_sw_clk,
+	.enable_reg = MXC_CCM_CCGR6,
+	.enable_shift = MXC_CCM_CCGRx_CG15_OFFSET,
+	.get_rate = _clk_ldb_di_get_rate,
+	.set_parent = _clk_ldb_di_set_parent,
+	.round_rate = _clk_ldb_di_round_rate,
+	.set_rate = _clk_ldb_di_set_rate,
+	.enable = _clk_ldb_di_enable,
+	.disable = _clk_ldb_di_disable,
+	.flags = AHB_MED_SET_POINT,
+	},
+};
+
+static int _clk_csi0_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	reg = __raw_readl(MXC_CCM_CSCMR2);
+	mux = _get_mux(parent, &pll1_sw_clk, &pll2_sw_clk, &pll3_sw_clk, NULL);
+	reg = (reg & ~MXC_CCM_CSCMR2_CSI_MCLK1_CLK_SEL_MASK) |
+		    (mux << MXC_CCM_CSCMR2_CSI_MCLK1_CLK_SEL_OFFSET);
+	__raw_writel(reg, MXC_CCM_CSCMR2);
+
+	return 0;
+}
+
+static unsigned long _clk_csi0_get_rate(struct clk *clk)
+{
+	u32 reg, pred, podf;
+
+	reg = __raw_readl(MXC_CCM_CSCDR4);
+	pred = ((reg & MXC_CCM_CSCDR4_CSI_MCLK1_CLK_PRED_MASK) >>
+			MXC_CCM_CSCDR4_CSI_MCLK1_CLK_PRED_OFFSET) + 1;
+	podf = ((reg & MXC_CCM_CSCDR4_CSI_MCLK1_CLK_PODF_MASK) >>
+			MXC_CCM_CSCDR4_CSI_MCLK1_CLK_PODF_OFFSET) + 1;
+	return clk_get_rate(clk->parent)/(pred * podf);
+}
+
+static unsigned long _clk_csi0_round_rate(struct clk *clk, unsigned long rate)
+{
+	u32 pre, post;
+	u32 parent_rate = clk_get_rate(clk->parent);
+	u32 div = parent_rate / rate;
+	if (parent_rate % rate)
+		div++;
+
+	__calc_pre_post_dividers(div, &pre, &post);
+
+	return parent_rate / (pre * post);
+}
+
+static int _clk_csi0_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg;
+	u32 div;
+	u32 pre, post;
+	u32 parent_rate = clk_get_rate(clk->parent);
+
+	div = parent_rate / rate;
+
+	if ((parent_rate / div) != rate)
+		return -EINVAL;
+
+	__calc_pre_post_dividers(div, &pre, &post);
+
+	/* Set CSI clock divider */
+	reg = __raw_readl(MXC_CCM_CSCDR4) &
+	    ~(MXC_CCM_CSCDR4_CSI_MCLK1_CLK_PRED_MASK |
+		MXC_CCM_CSCDR4_CSI_MCLK1_CLK_PODF_MASK);
+	reg |= (post - 1) << MXC_CCM_CSCDR4_CSI_MCLK1_CLK_PODF_OFFSET;
+	reg |= (pre - 1) << MXC_CCM_CSCDR4_CSI_MCLK1_CLK_PRED_OFFSET;
+	__raw_writel(reg, MXC_CCM_CSCDR4);
+
+	return 0;
+}
+
+static struct clk csi0_clk = {
+	.parent = &pll3_sw_clk,
+	.set_parent = _clk_csi0_set_parent,
+	.get_rate = _clk_csi0_get_rate,
+	.round_rate = _clk_csi0_round_rate,
+	.set_rate = _clk_csi0_set_rate,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR6,
+	.enable_shift = MXC_CCM_CCGRx_CG2_OFFSET,
+	.disable = _clk_disable,
+};
+
+static int _clk_csi1_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	reg = __raw_readl(MXC_CCM_CSCMR2);
+	mux = _get_mux(parent, &pll1_sw_clk, &pll2_sw_clk, &pll3_sw_clk, NULL);
+	reg = (reg & ~MXC_CCM_CSCMR2_CSI_MCLK2_CLK_SEL_MASK) |
+		    (mux << MXC_CCM_CSCMR2_CSI_MCLK2_CLK_SEL_OFFSET);
+	__raw_writel(reg, MXC_CCM_CSCMR2);
+
+	return 0;
+}
+
+static unsigned long _clk_csi1_get_rate(struct clk *clk)
+{
+	u32 reg, pred, podf;
+
+	reg = __raw_readl(MXC_CCM_CSCDR4);
+	pred = ((reg & MXC_CCM_CSCDR4_CSI_MCLK2_CLK_PRED_MASK) >>
+			MXC_CCM_CSCDR4_CSI_MCLK2_CLK_PRED_OFFSET) + 1;
+	podf = ((reg & MXC_CCM_CSCDR4_CSI_MCLK2_CLK_PODF_MASK) >>
+			MXC_CCM_CSCDR4_CSI_MCLK2_CLK_PODF_OFFSET) + 1;
+	return clk_get_rate(clk->parent)/(pred * podf) ;
+}
+
+static unsigned long _clk_csi1_round_rate(struct clk *clk, unsigned long rate)
+{
+	u32 pre, post;
+	u32 parent_rate = clk_get_rate(clk->parent);
+	u32 div = parent_rate / rate;
+	if (parent_rate % rate)
+		div++;
+
+	__calc_pre_post_dividers(div, &pre, &post);
+
+	return parent_rate / (pre * post);
+}
+
+static int _clk_csi1_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg;
+	u32 div;
+	u32 pre, post;
+	u32 parent_rate = clk_get_rate(clk->parent);
+
+	div = parent_rate / rate;
+
+	if ((parent_rate / div) != rate)
+		return -EINVAL;
+
+	__calc_pre_post_dividers(div, &pre, &post);
+
+	/* Set CSI clock divider */
+	reg = __raw_readl(MXC_CCM_CSCDR4) &
+	    ~(MXC_CCM_CSCDR4_CSI_MCLK2_CLK_PRED_MASK |
+		MXC_CCM_CSCDR4_CSI_MCLK2_CLK_PODF_MASK);
+	reg |= (post - 1) << MXC_CCM_CSCDR4_CSI_MCLK2_CLK_PODF_OFFSET;
+	reg |= (pre - 1) << MXC_CCM_CSCDR4_CSI_MCLK2_CLK_PRED_OFFSET;
+	__raw_writel(reg, MXC_CCM_CSCDR4);
+
+	return 0;
+}
+
+static struct clk csi1_clk = {
+	.parent = &pll3_sw_clk,
+	.set_parent = _clk_csi1_set_parent,
+	.get_rate = _clk_csi1_get_rate,
+	.round_rate = _clk_csi1_round_rate,
+	.set_rate = _clk_csi1_set_rate,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR6,
+	.enable_shift = MXC_CCM_CCGRx_CG3_OFFSET,
+	.disable = _clk_disable,
+};
+
+
+static int _clk_hsc_enable(struct clk *clk)
+{
+	u32 reg;
+
+	_clk_enable(clk);
+	/* Handshake with IPU when certain clock rates are changed. */
+	reg = __raw_readl(MXC_CCM_CCDR);
+	reg &= ~MXC_CCM_CCDR_HSC_HS_MASK;
+	__raw_writel(reg, MXC_CCM_CCDR);
+
+	reg = __raw_readl(MXC_CCM_CLPCR);
+	reg &= ~MXC_CCM_CLPCR_BYPASS_HSC_LPM_HS;
+	__raw_writel(reg, MXC_CCM_CLPCR);
+
+	return 0;
+}
+
+static void _clk_hsc_disable(struct clk *clk)
+{
+	u32 reg;
+
+	_clk_disable(clk);
+	/* No handshake with HSC as its not enabled. */
+	reg = __raw_readl(MXC_CCM_CCDR);
+	reg |= MXC_CCM_CCDR_HSC_HS_MASK;
+	__raw_writel(reg, MXC_CCM_CCDR);
+
+	reg = __raw_readl(MXC_CCM_CLPCR);
+	reg |= MXC_CCM_CLPCR_BYPASS_HSC_LPM_HS;
+	__raw_writel(reg, MXC_CCM_CLPCR);
+}
+
+static struct clk mipi_esc_clk = {
+	.parent = &pll2_sw_clk,
+	.enable_reg = MXC_CCM_CCGR4,
+	.enable_shift = MXC_CCM_CCGRx_CG5_OFFSET,
+};
+
+static struct clk mipi_hsc2_clk = {
+	.parent = &pll2_sw_clk,
+	.enable_reg = MXC_CCM_CCGR4,
+	.enable_shift = MXC_CCM_CCGRx_CG4_OFFSET,
+	.secondary = &mipi_esc_clk,
+};
+
+static struct clk mipi_hsc1_clk = {
+	.parent = &pll2_sw_clk,
+	.enable_reg = MXC_CCM_CCGR4,
+	.enable_shift = MXC_CCM_CCGRx_CG3_OFFSET,
+	.secondary = &mipi_hsc2_clk,
+};
+
+static struct clk mipi_hsp_clk = {
+	.parent = &ipu_clk[0],
+	.enable_reg = MXC_CCM_CCGR4,
+	.enable_shift = MXC_CCM_CCGRx_CG6_OFFSET,
+	.enable = _clk_hsc_enable,
+	.disable = _clk_hsc_disable,
+	.secondary = &mipi_hsc1_clk,
+};
+
+static int _clk_tve_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg;
+
+	reg = __raw_readl(MXC_CCM_CSCMR1);
+
+	if ((parent == &pll3_sw_clk) && cpu_is_mx51()) {
+		reg &= ~(MXC_CCM_CSCMR1_TVE_CLK_SEL);
+	} else if ((parent == &pll4_sw_clk) && cpu_is_mx53()) {
+		reg &= ~(MXC_CCM_CSCMR1_TVE_EXT_CLK_SEL);
+	} else if ((parent == &osc_clk) && cpu_is_mx51()) {
+		reg |= MXC_CCM_CSCMR1_TVE_CLK_SEL;
+		reg &= ~MXC_CCM_CSCMR1_TVE_EXT_CLK_SEL;
+	} else if (parent == &ckih_clk) {
+		reg |= MXC_CCM_CSCMR1_TVE_EXT_CLK_SEL;
+		reg |= MXC_CCM_CSCMR1_TVE_CLK_SEL; /* Reserved on MX53 */
+	} else {
+		BUG();
+	}
+
+	__raw_writel(reg, MXC_CCM_CSCMR1);
+	return 0;
+}
+
+static unsigned long _clk_tve_get_rate(struct clk *clk)
+{
+	u32 reg, div = 1;
+
+	reg = __raw_readl(MXC_CCM_CSCMR1);
+	if ((reg & (MXC_CCM_CSCMR1_TVE_CLK_SEL | MXC_CCM_CSCMR1_TVE_EXT_CLK_SEL)) == 0) {
+		reg = __raw_readl(MXC_CCM_CDCDR) &
+		    MXC_CCM_CDCDR_TVE_CLK_PRED_MASK;
+		div = (reg >> MXC_CCM_CDCDR_TVE_CLK_PRED_OFFSET) + 1;
+	}
+	return clk_get_rate(clk->parent) / div;
+}
+
+static unsigned long _clk_tve_round_rate(struct clk *clk,
+						unsigned long rate)
+{
+	u32 reg, div;
+	u32 parent_rate = clk_get_rate(clk->parent);
+
+	reg = __raw_readl(MXC_CCM_CSCMR1);
+	if (cpu_is_mx51() && (reg & MXC_CCM_CSCMR1_TVE_CLK_SEL))
+		return -EINVAL;
+	if (cpu_is_mx53() && (reg & MXC_CCM_CSCMR1_TVE_EXT_CLK_SEL))
+		return -EINVAL;
+
+	div = (parent_rate + rate/2) / rate;
+	if (div > 8)
+		div = 8;
+	else if (div == 0)
+		div++;
+	return parent_rate / div;
+}
+
+static int _clk_tve_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg, div;
+	u32 parent_rate = clk_get_rate(clk->parent);
+
+	reg = __raw_readl(MXC_CCM_CSCMR1);
+	if (cpu_is_mx51() && (reg & MXC_CCM_CSCMR1_TVE_CLK_SEL))
+		return -EINVAL;
+	if (cpu_is_mx53() && (reg & MXC_CCM_CSCMR1_TVE_EXT_CLK_SEL))
+		return -EINVAL;
+
+	div = parent_rate / rate;
+	if (div == 0)
+		div++;
+	if (((parent_rate / div) != rate) || (div > 8))
+		return -EINVAL;
+
+	div--;
+	reg = __raw_readl(MXC_CCM_CDCDR) & ~MXC_CCM_CDCDR_TVE_CLK_PRED_MASK;
+	reg |= div << MXC_CCM_CDCDR_TVE_CLK_PRED_OFFSET;
+	__raw_writel(reg, MXC_CCM_CDCDR);
+	return 0;
+}
+
+static struct clk tve_clk = {
+	.parent = &pll3_sw_clk,
+	.set_parent = _clk_tve_set_parent,
+	.enable_reg = MXC_CCM_CCGR2,
+	.enable_shift = MXC_CCM_CCGRx_CG15_OFFSET,
+	.get_rate = _clk_tve_get_rate,
+	.round_rate = _clk_tve_round_rate,
+	.set_rate = _clk_tve_set_rate,
+	.enable = _clk_enable,
+	.disable = _clk_disable,
+	.flags = AHB_HIGH_SET_POINT | CPU_FREQ_TRIG_UPDATE,
+};
+
+static struct clk spba_clk = {
+	.parent = &ipg_clk,
+	.enable_reg = MXC_CCM_CCGR5,
+	.enable_shift = MXC_CCM_CCGRx_CG0_OFFSET,
+	.enable = _clk_enable,
+	.disable = _clk_disable,
+};
+
+static unsigned long _clk_uart_get_rate(struct clk *clk)
+{
+	u32 reg, prediv, podf;
+
+	reg = __raw_readl(MXC_CCM_CSCDR1);
+	prediv = ((reg & MXC_CCM_CSCDR1_UART_CLK_PRED_MASK) >>
+		  MXC_CCM_CSCDR1_UART_CLK_PRED_OFFSET) + 1;
+	podf = ((reg & MXC_CCM_CSCDR1_UART_CLK_PODF_MASK) >>
+		MXC_CCM_CSCDR1_UART_CLK_PODF_OFFSET) + 1;
+
+	return clk_get_rate(clk->parent)/(prediv * podf) ;
+}
+
+static int _clk_uart_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	mux = _get_mux(parent, &pll1_sw_clk, &pll2_sw_clk, &pll3_sw_clk,
+		       &lp_apm_clk);
+	reg = __raw_readl(MXC_CCM_CSCMR1) & ~MXC_CCM_CSCMR1_UART_CLK_SEL_MASK;
+	reg |= mux << MXC_CCM_CSCMR1_UART_CLK_SEL_OFFSET;
+	__raw_writel(reg, MXC_CCM_CSCMR1);
+
+	return 0;
+}
+
+static struct clk uart_main_clk = {
+	.parent = &pll2_sw_clk,
+	.get_rate = _clk_uart_get_rate,
+	.set_parent = _clk_uart_set_parent,
+};
+
+static struct clk uart1_clk[] = {
+	{
+	 .id = 0,
+	 .parent = &uart_main_clk,
+	 .secondary = &uart1_clk[1],
+	 .enable_reg = MXC_CCM_CCGR1,
+	 .enable_shift = MXC_CCM_CCGRx_CG4_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+#if UART1_DMA_ENABLE
+	.flags = AHB_HIGH_SET_POINT | CPU_FREQ_TRIG_UPDATE,
+#endif
+	 },
+	{
+	 .id = 0,
+	 .parent = &ipg_clk,
+#if UART1_DMA_ENABLE
+	 .secondary = &aips_tz1_clk,
+#endif
+	 .enable_reg = MXC_CCM_CCGR1,
+	 .enable_shift = MXC_CCM_CCGRx_CG3_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+};
+
+static struct clk uart2_clk[] = {
+	{
+	 .id = 1,
+	 .parent = &uart_main_clk,
+	 .secondary = &uart2_clk[1],
+	 .enable_reg = MXC_CCM_CCGR1,
+	 .enable_shift = MXC_CCM_CCGRx_CG6_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+#if UART2_DMA_ENABLE
+	.flags = AHB_HIGH_SET_POINT | CPU_FREQ_TRIG_UPDATE,
+#endif
+	 },
+	{
+	 .id = 1,
+	 .parent = &ipg_clk,
+#if UART2_DMA_ENABLE
+	 .secondary = &aips_tz1_clk,
+#endif
+	 .enable_reg = MXC_CCM_CCGR1,
+	 .enable_shift = MXC_CCM_CCGRx_CG5_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+};
+
+static struct clk uart3_clk[] = {
+	{
+	 .id = 2,
+	 .parent = &uart_main_clk,
+	 .secondary = &uart3_clk[1],
+	 .enable_reg = MXC_CCM_CCGR1,
+	 .enable_shift = MXC_CCM_CCGRx_CG8_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+#if UART3_DMA_ENABLE
+	.flags = AHB_HIGH_SET_POINT | CPU_FREQ_TRIG_UPDATE,
+#endif
+	 },
+	{
+	 .id = 2,
+	 .parent = &ipg_clk,
+	 .secondary = &spba_clk,
+	 .enable_reg = MXC_CCM_CCGR1,
+	 .enable_shift = MXC_CCM_CCGRx_CG7_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+};
+
+static struct clk uart4_clk[] = {
+	{
+	 .id = 3,
+	 .parent = &uart_main_clk,
+	 .secondary = &uart4_clk[1],
+	 .enable_reg = MXC_CCM_CCGR7,
+	 .enable_shift = MXC_CCM_CCGRx_CG5_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+#if UART4_DMA_ENABLE
+	.flags = AHB_HIGH_SET_POINT | CPU_FREQ_TRIG_UPDATE,
+#endif
+	 },
+	{
+	 .id = 3,
+	 .parent = &ipg_clk,
+	 .secondary = &spba_clk,
+	 .enable_reg = MXC_CCM_CCGR7,
+	 .enable_shift = MXC_CCM_CCGRx_CG4_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+};
+
+static struct clk uart5_clk[] = {
+	{
+	 .id = 4,
+	 .parent = &uart_main_clk,
+	 .secondary = &uart5_clk[1],
+	 .enable_reg = MXC_CCM_CCGR7,
+	 .enable_shift = MXC_CCM_CCGRx_CG7_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+#if UART5_DMA_ENABLE
+	.flags = AHB_HIGH_SET_POINT | CPU_FREQ_TRIG_UPDATE,
+#endif
+	 },
+	{
+	 .id = 4,
+	 .parent = &ipg_clk,
+	 .secondary = &spba_clk,
+	 .enable_reg = MXC_CCM_CCGR7,
+	 .enable_shift = MXC_CCM_CCGRx_CG6_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+};
+
+static struct clk gpt_clk[] = {
+	{
+	 .parent = &ipg_perclk,
+	 .id = 0,
+	 .enable_reg = MXC_CCM_CCGR2,
+	 .enable_shift = MXC_CCM_CCGRx_CG9_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 .secondary = &gpt_clk[1],
+	 },
+	{
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .enable_reg = MXC_CCM_CCGR2,
+	 .enable_shift = MXC_CCM_CCGRx_CG10_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+	{
+	 .id = 0,
+	 .parent = &ckil_clk,
+	 },
+};
+
+static struct clk pwm1_clk[] = {
+	{
+	 .parent = &ipg_perclk,
+	 .id = 0,
+	 .enable_reg = MXC_CCM_CCGR2,
+	 .enable_shift = MXC_CCM_CCGRx_CG6_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 .secondary = &pwm1_clk[1],
+	 },
+	{
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .enable_reg = MXC_CCM_CCGR2,
+	 .enable_shift = MXC_CCM_CCGRx_CG5_OFFSET,
+	 .enable = _clk_enable_inrun, /*Active only when ARM is running. */
+	 .disable = _clk_disable,
+	 },
+	{
+	 .id = 0,
+	 .parent = &ckil_clk,
+	 },
+};
+
+static struct clk pwm2_clk[] = {
+	{
+	 .parent = &ipg_perclk,
+	 .id = 1,
+	 .enable_reg = MXC_CCM_CCGR2,
+	 .enable_shift = MXC_CCM_CCGRx_CG8_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 .secondary = &pwm2_clk[1],
+	 },
+	{
+	 .id = 1,
+	 .parent = &ipg_clk,
+	 .enable_reg = MXC_CCM_CCGR2,
+	 .enable_shift = MXC_CCM_CCGRx_CG7_OFFSET,
+	 .enable = _clk_enable_inrun, /*Active only when ARM is running. */
+	 .disable = _clk_disable,
+	 },
+	{
+	 .id = 1,
+	 .parent = &ckil_clk,
+	 },
+};
+
+static struct clk i2c_clk[] = {
+	{
+	 .id = 0,
+	 .parent = &ipg_perclk,
+	 .enable_reg = MXC_CCM_CCGR1,
+	 .enable_shift = MXC_CCM_CCGRx_CG9_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+	{
+	 .id = 1,
+	 .parent = &ipg_perclk,
+	 .enable_reg = MXC_CCM_CCGR1,
+	 .enable_shift = MXC_CCM_CCGRx_CG10_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+	{
+	 .id = 2,
+	 .parent = &ipg_perclk,
+	 .enable_reg = MXC_CCM_CCGR1,
+	 .enable_shift = MXC_CCM_CCGRx_CG11_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+};
+
+static unsigned long _clk_hsi2c_serial_get_rate(struct clk *clk)
+{
+	u32 reg, prediv, podf;
+
+	reg = __raw_readl(MXC_CCM_CSCDR3);
+	prediv = ((reg & MXC_CCM_CSCDR3_HSI2C_CLK_PRED_MASK) >>
+		  MXC_CCM_CSCDR3_HSI2C_CLK_PRED_OFFSET) + 1;
+	podf = ((reg & MXC_CCM_CSCDR3_HSI2C_CLK_PODF_MASK) >>
+		MXC_CCM_CSCDR3_HSI2C_CLK_PODF_OFFSET) + 1;
+
+	return clk_get_rate(clk->parent) / (prediv * podf);
+}
+
+static struct clk hsi2c_serial_clk = {
+	.id = 0,
+	.parent = &pll3_sw_clk,
+	.secondary = &spba_clk,
+	.enable_reg = MXC_CCM_CCGR1,
+	.enable_shift = MXC_CCM_CCGRx_CG11_OFFSET,
+	.get_rate = _clk_hsi2c_serial_get_rate,
+	.enable = _clk_enable,
+	.disable = _clk_disable,
+};
+
+static struct clk hsi2c_clk = {
+	.id = 0,
+	.parent = &ipg_clk,
+	.enable_reg = MXC_CCM_CCGR1,
+	.enable_shift = MXC_CCM_CCGRx_CG12_OFFSET,
+	.enable = _clk_enable,
+	.disable = _clk_disable,
+	.flags = AHB_HIGH_SET_POINT | CPU_FREQ_TRIG_UPDATE,
+};
+
+static unsigned long _clk_cspi_get_rate(struct clk *clk)
+{
+	u32 reg, prediv, podf;
+
+	reg = __raw_readl(MXC_CCM_CSCDR2);
+	prediv = ((reg & MXC_CCM_CSCDR2_CSPI_CLK_PRED_MASK) >>
+		  MXC_CCM_CSCDR2_CSPI_CLK_PRED_OFFSET) + 1;
+	if (prediv == 1)
+		BUG();
+	podf = ((reg & MXC_CCM_CSCDR2_CSPI_CLK_PODF_MASK) >>
+		MXC_CCM_CSCDR2_CSPI_CLK_PODF_OFFSET) + 1;
+
+	return clk_get_rate(clk->parent) / (prediv * podf);
+}
+
+static int _clk_cspi_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	mux = _get_mux(parent, &pll1_sw_clk, &pll2_sw_clk, &pll3_sw_clk,
+		       &lp_apm_clk);
+	reg = __raw_readl(MXC_CCM_CSCMR1) & ~MXC_CCM_CSCMR1_CSPI_CLK_SEL_MASK;
+	reg |= mux << MXC_CCM_CSCMR1_CSPI_CLK_SEL_OFFSET;
+	__raw_writel(reg, MXC_CCM_CSCMR1);
+
+	return 0;
+}
+
+static struct clk cspi_main_clk = {
+	.parent = &pll3_sw_clk,
+	.get_rate = _clk_cspi_get_rate,
+	.set_parent = _clk_cspi_set_parent,
+};
+
+static struct clk cspi1_clk[] = {
+	{
+	 .id = 0,
+	 .parent = &cspi_main_clk,
+	 .secondary = &cspi1_clk[1],
+	 .enable_reg = MXC_CCM_CCGR4,
+	 .enable_shift = MXC_CCM_CCGRx_CG10_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+	{
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .secondary = &spba_clk,
+	 .enable_reg = MXC_CCM_CCGR4,
+	 .enable_shift = MXC_CCM_CCGRx_CG9_OFFSET,
+	 .enable = _clk_enable_inrun, /*Active only when ARM is running. */
+	 .disable = _clk_disable,
+	 },
+};
+
+static struct clk cspi2_clk[] = {
+	{
+	 .id = 1,
+	 .parent = &cspi_main_clk,
+	 .secondary = &cspi2_clk[1],
+	 .enable_reg = MXC_CCM_CCGR4,
+	 .enable_shift = MXC_CCM_CCGRx_CG12_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+	{
+	 .id = 1,
+	 .parent = &ipg_clk,
+	 .secondary = &aips_tz2_clk,
+	 .enable_reg = MXC_CCM_CCGR4,
+	 .enable_shift = MXC_CCM_CCGRx_CG11_OFFSET,
+	 .enable = _clk_enable_inrun, /*Active only when ARM is running. */
+	 .disable = _clk_disable,
+	 },
+};
+
+static struct clk cspi3_clk = {
+	.id = 2,
+	.parent = &ipg_clk,
+	.enable_reg = MXC_CCM_CCGR4,
+	.enable_shift = MXC_CCM_CCGRx_CG13_OFFSET,
+	.enable = _clk_enable,
+	.disable = _clk_disable,
+	.secondary = &aips_tz2_clk,
+};
+
+static unsigned long _clk_ieee_rtc_get_rate(struct clk *clk)
+{
+	u32 reg, prediv, podf;
+
+	reg = __raw_readl(MXC_CCM_CSCDR2);
+	prediv = ((reg & MXC_CCM_CSCDR2_IEEE_CLK_PRED_MASK) >>
+		  MXC_CCM_CSCDR2_IEEE_CLK_PRED_OFFSET) + 1;
+	if (prediv == 1)
+		BUG();
+	podf = ((reg & MXC_CCM_CSCDR2_IEEE_CLK_PODF_MASK) >>
+		MXC_CCM_CSCDR2_IEEE_CLK_PODF_OFFSET) + 1;
+
+	return clk_get_rate(clk->parent) / (prediv * podf);
+}
+
+static int _clk_ieee_rtc_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg, div, pre, post;
+	u32 parent_rate = clk_get_rate(clk->parent);
+
+	div = parent_rate / rate;
+	if (div == 0)
+		div++;
+	if (((parent_rate / div) != rate) || div > 512)
+		return -EINVAL;
+
+	__calc_pre_post_dividers(div, &pre, &post);
+
+	reg = __raw_readl(MXC_CCM_CSCDR2);
+	reg &= ~(MXC_CCM_CSCDR2_IEEE_CLK_PRED_MASK |
+		 MXC_CCM_CSCDR2_IEEE_CLK_PODF_MASK);
+	reg |= (post - 1) << MXC_CCM_CSCDR2_IEEE_CLK_PODF_OFFSET;
+	reg |= (pre - 1) << MXC_CCM_CSCDR2_IEEE_CLK_PRED_OFFSET;
+	__raw_writel(reg, MXC_CCM_CSCDR2);
+
+	return 0;
+}
+
+static unsigned long _clk_ieee_rtc_round_rate(struct clk *clk,
+						unsigned long rate)
+{
+	u32 pre, post;
+	u32 parent_rate = clk_get_rate(clk->parent);
+	u32 div = parent_rate / rate;
+
+	if (parent_rate % rate)
+		div++;
+
+	__calc_pre_post_dividers(div, &pre, &post);
+
+	return parent_rate / (pre * post);
+}
+
+static int _clk_ieee_rtc_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	mux = _get_mux(parent, &pll3_sw_clk, &pll4_sw_clk,
+		       NULL, NULL);
+	reg = __raw_readl(MXC_CCM_CSCMR2) & ~MXC_CCM_CSCMR2_IEEE_CLK_SEL_MASK;
+	reg |= mux << MXC_CCM_CSCMR2_IEEE_CLK_SEL_OFFSET;
+	__raw_writel(reg, MXC_CCM_CSCMR2);
+
+	return 0;
+}
+
+static struct clk ieee_rtc_clk = {
+	.id = 0,
+	.parent = &pll3_sw_clk,
+	.set_parent = _clk_ieee_rtc_set_parent,
+	.set_rate = _clk_ieee_rtc_set_rate,
+	.round_rate = _clk_ieee_rtc_round_rate,
+	.get_rate = _clk_ieee_rtc_get_rate,
+};
+
+static int _clk_ssi_lp_apm_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	mux = _get_mux(parent, &ckih_clk, &lp_apm_clk, &ckih2_clk, NULL);
+	reg = __raw_readl(MXC_CCM_CSCMR1) &
+	    ~MXC_CCM_CSCMR1_SSI_APM_CLK_SEL_MASK;
+	reg |= mux << MXC_CCM_CSCMR1_SSI_APM_CLK_SEL_OFFSET;
+	__raw_writel(reg, MXC_CCM_CSCMR1);
+
+	return 0;
+}
+
+static struct clk ssi_lp_apm_clk = {
+	.parent = &ckih_clk,
+	.set_parent = _clk_ssi_lp_apm_set_parent,
+};
+
+static unsigned long _clk_ssi1_get_rate(struct clk *clk)
+{
+	u32 reg, prediv, podf;
+
+	reg = __raw_readl(MXC_CCM_CS1CDR);
+	prediv = ((reg & MXC_CCM_CS1CDR_SSI1_CLK_PRED_MASK) >>
+		  MXC_CCM_CS1CDR_SSI1_CLK_PRED_OFFSET) + 1;
+	if (prediv == 1)
+		BUG();
+	podf = ((reg & MXC_CCM_CS1CDR_SSI1_CLK_PODF_MASK) >>
+		MXC_CCM_CS1CDR_SSI1_CLK_PODF_OFFSET) + 1;
+
+	return clk_get_rate(clk->parent) / (prediv * podf);
+}
+static int _clk_ssi1_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	mux = _get_mux(parent, &pll1_sw_clk, &pll2_sw_clk,
+		       &pll3_sw_clk, &ssi_lp_apm_clk);
+	reg = __raw_readl(MXC_CCM_CSCMR1) & ~MXC_CCM_CSCMR1_SSI1_CLK_SEL_MASK;
+	reg |= mux << MXC_CCM_CSCMR1_SSI1_CLK_SEL_OFFSET;
+	__raw_writel(reg, MXC_CCM_CSCMR1);
+
+	return 0;
+}
+
+static struct clk ssi1_clk[] = {
+	{
+	 .id = 0,
+	 .parent = &pll3_sw_clk,
+	 .set_parent = _clk_ssi1_set_parent,
+	 .secondary = &ssi1_clk[1],
+	 .get_rate = _clk_ssi1_get_rate,
+	 .enable_reg = MXC_CCM_CCGR3,
+	 .enable_shift = MXC_CCM_CCGRx_CG9_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+	{
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .secondary = &ssi1_clk[2],
+	 .enable_reg = MXC_CCM_CCGR3,
+	 .enable_shift = MXC_CCM_CCGRx_CG8_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+	{
+	 .id = 0,
+	 .parent = &aips_tz2_clk,
+#ifdef CONFIG_SND_MXC_SOC_IRAM
+	 .secondary = &emi_intr_clk[0],
+#else
+	 .secondary = &emi_fast_clk,
+#endif
+	 },
+};
+
+static unsigned long _clk_ssi2_get_rate(struct clk *clk)
+{
+	u32 reg, prediv, podf;
+
+	reg = __raw_readl(MXC_CCM_CS2CDR);
+	prediv = ((reg & MXC_CCM_CS2CDR_SSI2_CLK_PRED_MASK) >>
+		  MXC_CCM_CS2CDR_SSI2_CLK_PRED_OFFSET) + 1;
+	if (prediv == 1)
+		BUG();
+	podf = ((reg & MXC_CCM_CS2CDR_SSI2_CLK_PODF_MASK) >>
+		MXC_CCM_CS2CDR_SSI2_CLK_PODF_OFFSET) + 1;
+
+	return clk_get_rate(clk->parent) / (prediv * podf);
+}
+
+static int _clk_ssi2_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	mux = _get_mux(parent, &pll1_sw_clk, &pll2_sw_clk,
+		       &pll3_sw_clk, &ssi_lp_apm_clk);
+	reg = __raw_readl(MXC_CCM_CSCMR1) & ~MXC_CCM_CSCMR1_SSI2_CLK_SEL_MASK;
+	reg |= mux << MXC_CCM_CSCMR1_SSI2_CLK_SEL_OFFSET;
+	__raw_writel(reg, MXC_CCM_CSCMR1);
+
+	return 0;
+}
+
+static struct clk ssi2_clk[] = {
+	{
+	 .id = 1,
+	 .parent = &pll3_sw_clk,
+	 .set_parent = _clk_ssi2_set_parent,
+	 .secondary = &ssi2_clk[1],
+	 .get_rate = _clk_ssi2_get_rate,
+	 .enable_reg = MXC_CCM_CCGR3,
+	 .enable_shift = MXC_CCM_CCGRx_CG11_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+	{
+	 .id = 1,
+	 .parent = &ipg_clk,
+	 .secondary = &ssi2_clk[2],
+	 .enable_reg = MXC_CCM_CCGR3,
+	 .enable_shift = MXC_CCM_CCGRx_CG10_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+	{
+	 .id = 1,
+	 .parent = &spba_clk,
+#ifdef CONFIG_SND_MXC_SOC_IRAM
+	 .secondary = &emi_intr_clk[0],
+#else
+	 .secondary = &emi_fast_clk,
+#endif
+	 },
+};
+
+static int _clk_ssi3_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg;
+	reg = __raw_readl(MXC_CCM_CSCMR1) & ~MXC_CCM_CSCMR1_SSI3_CLK_SEL;
+
+	if (parent == &ssi1_clk[0])
+		reg &= ~MXC_CCM_CSCMR1_SSI3_CLK_SEL;
+	else if (parent == &ssi2_clk[0])
+		reg |= MXC_CCM_CSCMR1_SSI3_CLK_SEL;
+	else {
+		printk(KERN_ERR"Set ssi3 clock parent failed!\n");
+		printk(KERN_ERR"ssi3 only support");
+		printk(KERN_ERR"ssi1 and ssi2 as parent clock\n");
+		return -1;
+	}
+
+	__raw_writel(reg, MXC_CCM_CSCMR1);
+	return 0;
+}
+
+static struct clk ssi3_clk[] = {
+	{
+	 .id = 2,
+	 .parent = &ssi1_clk[0],
+	 .set_parent = _clk_ssi3_set_parent,
+	 .secondary = &ssi3_clk[1],
+	 .enable_reg = MXC_CCM_CCGR3,
+	 .enable_shift = MXC_CCM_CCGRx_CG13_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+	{
+	 .id = 2,
+	 .parent = &ipg_clk,
+	 .secondary = &ssi3_clk[2],
+	 .enable_reg = MXC_CCM_CCGR3,
+	 .enable_shift = MXC_CCM_CCGRx_CG12_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+	{
+	 .id = 2,
+	 .parent = &aips_tz2_clk,
+#ifdef CONFIG_SND_MXC_SOC_IRAM
+	 .secondary = &emi_intr_clk,
+#else
+	 .secondary = &emi_fast_clk,
+#endif
+	 },
+};
+
+static unsigned long _clk_ssi_ext1_get_rate(struct clk *clk)
+{
+	u32 reg, prediv, podf;
+	u32 div = 1;
+
+	reg = __raw_readl(MXC_CCM_CSCMR1);
+	if ((reg & MXC_CCM_CSCMR1_SSI_EXT1_COM_CLK_SEL) == 0) {
+		reg = __raw_readl(MXC_CCM_CS1CDR);
+		prediv = ((reg & MXC_CCM_CS1CDR_SSI_EXT1_CLK_PRED_MASK) >>
+			  MXC_CCM_CS1CDR_SSI_EXT1_CLK_PRED_OFFSET) + 1;
+		podf = ((reg & MXC_CCM_CS1CDR_SSI_EXT1_CLK_PODF_MASK) >>
+			MXC_CCM_CS1CDR_SSI_EXT1_CLK_PODF_OFFSET) + 1;
+		div = prediv * podf;
+	}
+	return clk_get_rate(clk->parent) / div;
+}
+
+static int _clk_ssi_ext1_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg, div, pre, post;
+	u32 parent_rate = clk_get_rate(clk->parent);
+
+	div = parent_rate / rate;
+	if (div == 0)
+		div++;
+	if (((parent_rate / div) != rate) || div > 512)
+		return -EINVAL;
+
+	__calc_pre_post_dividers(div, &pre, &post);
+
+	reg = __raw_readl(MXC_CCM_CS1CDR);
+	reg &= ~(MXC_CCM_CS1CDR_SSI_EXT1_CLK_PRED_MASK |
+		 MXC_CCM_CS1CDR_SSI_EXT1_CLK_PODF_MASK);
+	reg |= (post - 1) << MXC_CCM_CS1CDR_SSI_EXT1_CLK_PODF_OFFSET;
+	reg |= (pre - 1) << MXC_CCM_CS1CDR_SSI_EXT1_CLK_PRED_OFFSET;
+	__raw_writel(reg, MXC_CCM_CS1CDR);
+
+	return 0;
+}
+
+static int _clk_ssi_ext1_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	reg = __raw_readl(MXC_CCM_CSCMR1);
+	if (parent == &ssi1_clk[0]) {
+		reg |= MXC_CCM_CSCMR1_SSI_EXT1_COM_CLK_SEL;
+	} else {
+		reg &= ~MXC_CCM_CSCMR1_SSI_EXT1_COM_CLK_SEL;
+		mux = _get_mux(parent, &pll1_sw_clk, &pll2_sw_clk, &pll3_sw_clk,
+			       &ssi_lp_apm_clk);
+		reg = (reg & ~MXC_CCM_CSCMR1_SSI_EXT1_CLK_SEL_MASK) |
+		    (mux << MXC_CCM_CSCMR1_SSI_EXT1_CLK_SEL_OFFSET);
+	}
+
+	__raw_writel(reg, MXC_CCM_CSCMR1);
+
+	return 0;
+}
+
+static unsigned long _clk_ssi_ext1_round_rate(struct clk *clk,
+						unsigned long rate)
+{
+	u32 pre, post;
+	u32 parent_rate = clk_get_rate(clk->parent);
+	u32 div = parent_rate / rate;
+
+	if (parent_rate % rate)
+		div++;
+
+	__calc_pre_post_dividers(div, &pre, &post);
+
+	return parent_rate / (pre * post);
+}
+
+static struct clk ssi_ext1_clk = {
+	.parent = &pll3_sw_clk,
+	.set_parent = _clk_ssi_ext1_set_parent,
+	.set_rate = _clk_ssi_ext1_set_rate,
+	.round_rate = _clk_ssi_ext1_round_rate,
+	.get_rate = _clk_ssi_ext1_get_rate,
+	.enable_reg = MXC_CCM_CCGR3,
+	.enable_shift = MXC_CCM_CCGRx_CG14_OFFSET,
+	.enable = _clk_enable,
+	.disable = _clk_disable,
+};
+
+static unsigned long _clk_ssi_ext2_get_rate(struct clk *clk)
+{
+	u32 reg, prediv, podf;
+	u32 div = 1;
+
+	reg = __raw_readl(MXC_CCM_CSCMR1);
+	if ((reg & MXC_CCM_CSCMR1_SSI_EXT2_COM_CLK_SEL) == 0) {
+		reg = __raw_readl(MXC_CCM_CS2CDR);
+		prediv = ((reg & MXC_CCM_CS2CDR_SSI_EXT2_CLK_PRED_MASK) >>
+			  MXC_CCM_CS2CDR_SSI_EXT2_CLK_PRED_OFFSET) + 1;
+		if (prediv == 1)
+			BUG();
+		podf = ((reg & MXC_CCM_CS2CDR_SSI_EXT2_CLK_PODF_MASK) >>
+			MXC_CCM_CS2CDR_SSI_EXT2_CLK_PODF_OFFSET) + 1;
+		div = prediv * podf;
+	}
+	return clk_get_rate(clk->parent) / div;
+}
+
+static int _clk_ssi_ext2_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	reg = __raw_readl(MXC_CCM_CSCMR1);
+	if (parent == &ssi2_clk[0]) {
+		reg |= MXC_CCM_CSCMR1_SSI_EXT2_COM_CLK_SEL;
+	} else {
+		reg &= ~MXC_CCM_CSCMR1_SSI_EXT2_COM_CLK_SEL;
+		mux = _get_mux(parent, &pll1_sw_clk, &pll2_sw_clk, &pll3_sw_clk,
+			       &ssi_lp_apm_clk);
+		reg = (reg & ~MXC_CCM_CSCMR1_SSI_EXT2_CLK_SEL_MASK) |
+		    (mux << MXC_CCM_CSCMR1_SSI_EXT2_CLK_SEL_OFFSET);
+	}
+
+	__raw_writel(reg, MXC_CCM_CSCMR1);
+
+	return 0;
+}
+
+static struct clk ssi_ext2_clk = {
+	.parent = &pll3_sw_clk,
+	.set_parent = _clk_ssi_ext2_set_parent,
+	.get_rate = _clk_ssi_ext2_get_rate,
+	.enable_reg = MXC_CCM_CCGR3,
+	.enable_shift = MXC_CCM_CCGRx_CG15_OFFSET,
+	.enable = _clk_enable,
+	.disable = _clk_disable,
+};
+
+static int _clk_esai_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	reg = __raw_readl(MXC_CCM_CSCMR2);
+	if (parent ==  &pll1_sw_clk || parent ==  &pll2_sw_clk ||
+		    parent ==  &pll3_sw_clk) {
+		mux = _get_mux(parent, &pll1_sw_clk, &pll2_sw_clk, &pll3_sw_clk,
+			NULL);
+		reg &= ~MXC_CCM_CSCMR2_ESAI_PRE_SEL_MASK;
+		reg |= mux << MXC_CCM_CSCMR2_ESAI_PRE_SEL_OFFSET;
+		reg &= ~MXC_CCM_CSCMR2_ESAI_POST_SEL_MASK;
+		reg |= 0 << MXC_CCM_CSCMR2_ESAI_POST_SEL_OFFSET;
+		/* divider setting */
+	} else {
+		mux = _get_mux(parent, &ssi1_clk[0], &ssi2_clk[0], &ckih_clk,
+			&ckih2_clk);
+		reg &= ~MXC_CCM_CSCMR2_ESAI_POST_SEL_MASK;
+		reg |= (mux + 1) << MXC_CCM_CSCMR2_ESAI_POST_SEL_OFFSET;
+		/* divider setting */
+	}
+
+	__raw_writel(reg, MXC_CCM_CSCMR2);
+
+	/* set podf = 0 */
+	reg = __raw_readl(MXC_CCM_CS1CDR);
+	reg &= ~MXC_CCM_CS1CDR_ESAI_CLK_PODF_MASK;
+	__raw_writel(reg, MXC_CCM_CS1CDR);
+
+	return 0;
+}
+
+static unsigned long _clk_esai_get_rate(struct clk *clk)
+{
+	u32 reg, pred, podf;
+
+	reg = __raw_readl(MXC_CCM_CS1CDR);
+	if (clk->parent ==  &pll1_sw_clk || clk->parent ==  &pll2_sw_clk ||
+		    clk->parent ==  &pll3_sw_clk) {
+		pred = ((reg & MXC_CCM_CS1CDR_ESAI_CLK_PRED_MASK) >>
+			MXC_CCM_CS1CDR_ESAI_CLK_PRED_OFFSET) + 1;
+		podf = ((reg & MXC_CCM_CS1CDR_ESAI_CLK_PODF_MASK) >>
+			MXC_CCM_CS1CDR_ESAI_CLK_PODF_OFFSET) + 1;
+
+		return clk_get_rate(clk->parent) / (pred * podf);
+	} else {
+		podf = ((reg & MXC_CCM_CS1CDR_ESAI_CLK_PODF_MASK) >>
+			MXC_CCM_CS1CDR_ESAI_CLK_PODF_OFFSET) + 1;
+
+		return clk_get_rate(clk->parent) / podf;
+	}
+}
+
+static struct clk esai_clk[] = {
+	{
+	 .id = 0,
+	 .parent = &pll3_sw_clk,
+	 .set_parent = _clk_esai_set_parent,
+	 .get_rate = _clk_esai_get_rate,
+	 .secondary = &esai_clk[1],
+	 .enable_reg = MXC_CCM_CCGR6,
+	 .enable_shift = MXC_CCM_CCGRx_CG9_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+	{
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .enable_reg = MXC_CCM_CCGR6,
+	 .enable_shift = MXC_CCM_CCGRx_CG8_OFFSET,
+	 .enable = _clk_enable,
+	 .disable = _clk_disable,
+	 },
+};
+
+static struct clk iim_clk = {
+	.parent = &ipg_clk,
+	.secondary = &aips_tz2_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR0,
+	.enable_shift = MXC_CCM_CCGRx_CG15_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk tmax1_clk = {
+	 .id = 0,
+	 .parent = &ahb_clk,
+	 .secondary = &ahb_max_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CCGR1,
+	 .enable_shift = MXC_CCM_CCGRx_CG0_OFFSET,
+	 .disable = _clk_disable,
+	 };
+
+static struct clk tmax2_clk = {
+	 .id = 0,
+	 .parent = &ahb_clk,
+	 .secondary = &ahb_max_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CCGR1,
+	 .enable_shift = MXC_CCM_CCGRx_CG1_OFFSET,
+	 .disable = _clk_disable,
+};
+
+static struct clk tmax3_clk = {
+	 .id = 0,
+	 .parent = &ahb_clk,
+	 .secondary = &ahb_max_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CCGR1,
+	 .enable_shift = MXC_CCM_CCGRx_CG2_OFFSET,
+	 .disable = _clk_disable,
+};
+
+static unsigned long _clk_usboh3_get_rate(struct clk *clk)
+{
+	u32 reg, prediv, podf;
+
+	reg = __raw_readl(MXC_CCM_CSCDR1);
+	prediv = ((reg & MXC_CCM_CSCDR1_USBOH3_CLK_PRED_MASK) >>
+		  MXC_CCM_CSCDR1_USBOH3_CLK_PRED_OFFSET) + 1;
+	if (prediv == 1)
+		BUG();
+	podf = ((reg & MXC_CCM_CSCDR1_USBOH3_CLK_PODF_MASK) >>
+		MXC_CCM_CSCDR1_USBOH3_CLK_PODF_OFFSET) + 1;
+
+	return clk_get_rate(clk->parent) / (prediv * podf);
+}
+
+static int _clk_usboh3_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	mux = _get_mux(parent, &pll1_sw_clk, &pll2_sw_clk, &pll3_sw_clk,
+		       &lp_apm_clk);
+	reg = __raw_readl(MXC_CCM_CSCMR1) & ~MXC_CCM_CSCMR1_USBOH3_CLK_SEL_MASK;
+	reg |= mux << MXC_CCM_CSCMR1_USBOH3_CLK_SEL_OFFSET;
+	__raw_writel(reg, MXC_CCM_CSCMR1);
+
+	return 0;
+}
+
+static struct clk usboh3_clk[] = {
+	{
+	 .parent = &pll3_sw_clk,
+	 .set_parent = _clk_usboh3_set_parent,
+	 .get_rate = _clk_usboh3_get_rate,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CCGR2,
+	 .enable_shift = MXC_CCM_CCGRx_CG14_OFFSET,
+	 .disable = _clk_disable,
+	 .secondary = &usboh3_clk[1],
+	 .flags = AHB_MED_SET_POINT | CPU_FREQ_TRIG_UPDATE,
+	 },
+	{
+	 .parent = &tmax2_clk,
+#if defined(CONFIG_USB_STATIC_IRAM) \
+    || defined(CONFIG_USB_STATIC_IRAM_PPH)
+	 .secondary = &emi_intr_clk[0],
+#else
+	 .secondary = &emi_fast_clk,
+#endif
+	 },
+};
+
+static struct clk usb_ahb_clk = {
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CCGR2,
+	 .enable_shift = MXC_CCM_CCGRx_CG13_OFFSET,
+	 .disable = _clk_disable,
+};
+
+static unsigned long _clk_usb_phy_get_rate(struct clk *clk)
+{
+	u32 reg, prediv, podf;
+	u32 div = 1;
+
+	if (clk->parent == &pll3_sw_clk) {
+		reg = __raw_readl(MXC_CCM_CDCDR);
+		prediv = ((reg & MXC_CCM_CDCDR_USB_PHY_PRED_MASK) >>
+			  MXC_CCM_CDCDR_USB_PHY_PRED_OFFSET) + 1;
+		podf = ((reg & MXC_CCM_CDCDR_USB_PHY_PODF_MASK) >>
+			MXC_CCM_CDCDR_USB_PHY_PODF_OFFSET) + 1;
+
+		div = (prediv * podf);
+	}
+
+	return clk_get_rate(clk->parent) / div;
+}
+
+static int _clk_usb_phy_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg;
+
+	reg = __raw_readl(MXC_CCM_CSCMR1);
+	if (parent == &osc_clk)
+		reg &= ~MXC_CCM_CSCMR1_USB_PHY_CLK_SEL;
+	else if (parent == &pll3_sw_clk)
+		reg |= MXC_CCM_CSCMR1_USB_PHY_CLK_SEL;
+	else
+		BUG();
+
+	__raw_writel(reg, MXC_CCM_CSCMR1);
+	return 0;
+}
+
+static struct clk usb_phy_clk[] = {
+	{
+	.id = 0,
+	.parent = &pll3_sw_clk,
+	.secondary = &tmax3_clk,
+	.set_parent = _clk_usb_phy_set_parent,
+	.get_rate = _clk_usb_phy_get_rate,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR2,
+	.enable_shift = MXC_CCM_CCGRx_CG0_OFFSET,
+	.disable = _clk_disable,
+	},
+	{
+	.id = 1,
+	.parent = &pll3_sw_clk,
+	.secondary = &tmax3_clk,
+	.set_parent = _clk_usb_phy_set_parent,
+	.get_rate = _clk_usb_phy_get_rate,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR4,
+	.enable_shift = MXC_CCM_CCGRx_CG6_OFFSET,
+	.disable = _clk_disable,
+	}
+};
+
+static struct clk esdhc_dep_clks = {
+	 .parent = &spba_clk,
+	 .secondary = &emi_fast_clk,
+};
+
+static unsigned long _clk_esdhc1_get_rate(struct clk *clk)
+{
+	u32 reg, prediv, podf;
+
+	reg = __raw_readl(MXC_CCM_CSCDR1);
+	prediv = ((reg & MXC_CCM_CSCDR1_ESDHC1_MSHC2_CLK_PRED_MASK) >>
+		  MXC_CCM_CSCDR1_ESDHC1_MSHC2_CLK_PRED_OFFSET) + 1;
+	podf = ((reg & MXC_CCM_CSCDR1_ESDHC1_MSHC2_CLK_PODF_MASK) >>
+		MXC_CCM_CSCDR1_ESDHC1_MSHC2_CLK_PODF_OFFSET) + 1;
+
+	return clk_get_rate(clk->parent) / (prediv * podf);
+}
+
+static int _clk_esdhc1_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	mux = _get_mux(parent, &pll1_sw_clk, &pll2_sw_clk, &pll3_sw_clk,
+		       &lp_apm_clk);
+	reg = __raw_readl(MXC_CCM_CSCMR1) &
+	    ~MXC_CCM_CSCMR1_ESDHC1_MSHC2_CLK_SEL_MASK;
+	reg |= mux << MXC_CCM_CSCMR1_ESDHC1_MSHC2_CLK_SEL_OFFSET;
+	__raw_writel(reg, MXC_CCM_CSCMR1);
+
+	return 0;
+}
+
+
+static int _clk_sdhc1_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg;
+	u32 div;
+	u32 pre, post;
+	u32 parent_rate = clk_get_rate(clk->parent);
+
+	div = parent_rate / rate;
+
+	if ((parent_rate / div) != rate)
+		return -EINVAL;
+
+	 __calc_pre_post_dividers(div, &pre, &post);
+
+	/* Set sdhc1 clock divider */
+	reg = __raw_readl(MXC_CCM_CSCDR1) &
+		~(MXC_CCM_CSCDR1_ESDHC1_MSHC2_CLK_PRED_MASK |
+		MXC_CCM_CSCDR1_ESDHC1_MSHC2_CLK_PODF_MASK);
+	reg |= (post - 1) << MXC_CCM_CSCDR1_ESDHC1_MSHC2_CLK_PODF_OFFSET;
+	reg |= (pre - 1) << MXC_CCM_CSCDR1_ESDHC1_MSHC2_CLK_PRED_OFFSET;
+	__raw_writel(reg, MXC_CCM_CSCDR1);
+
+	return 0;
+}
+
+static struct clk esdhc1_clk[] = {
+	{
+	 .id = 0,
+	 .parent = &pll2_sw_clk,
+	 .set_parent = _clk_esdhc1_set_parent,
+	 .get_rate = _clk_esdhc1_get_rate,
+	 .set_rate = _clk_sdhc1_set_rate,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CCGR3,
+	 .enable_shift = MXC_CCM_CCGRx_CG1_OFFSET,
+	 .disable = _clk_disable,
+	 .secondary = &esdhc1_clk[1],
+	 },
+	{
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .secondary = &esdhc1_clk[2],
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CCGR3,
+	 .enable_shift = MXC_CCM_CCGRx_CG0_OFFSET,
+	 .disable = _clk_disable,
+	 },
+	{
+	 .id = 0,
+	 .parent = &tmax3_clk,
+	 .secondary = &esdhc_dep_clks,
+	 },
+
+};
+
+static unsigned long _clk_esdhc2_get_rate(struct clk *clk)
+{
+	u32 reg, prediv, podf;
+
+	if (cpu_is_mx51()) {
+		reg = __raw_readl(MXC_CCM_CSCDR1);
+		prediv = ((reg & MXC_CCM_CSCDR1_ESDHC2_MSHC2_CLK_PRED_MASK) >>
+			MXC_CCM_CSCDR1_ESDHC2_MSHC2_CLK_PRED_OFFSET) + 1;
+		podf = ((reg & MXC_CCM_CSCDR1_ESDHC2_MSHC2_CLK_PODF_MASK) >>
+			MXC_CCM_CSCDR1_ESDHC2_MSHC2_CLK_PODF_OFFSET) + 1;
+
+		return clk_get_rate(clk->parent) / (prediv * podf);
+	}
+	return clk_get_rate(clk->parent);
+}
+
+static int _clk_esdhc2_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	if (cpu_is_mx51()) {
+		mux = _get_mux(parent, &pll1_sw_clk, &pll2_sw_clk, &pll3_sw_clk,
+			       &lp_apm_clk);
+		reg = __raw_readl(MXC_CCM_CSCMR1) &
+		    ~MXC_CCM_CSCMR1_ESDHC3_MSHC2_CLK_SEL_MASK;
+		reg |= mux << MXC_CCM_CSCMR1_ESDHC3_MSHC2_CLK_SEL_OFFSET;
+	} else { /* MX53  */
+		reg = __raw_readl(MXC_CCM_CSCMR1);
+		if (parent == &esdhc1_clk[0])
+			reg &= ~MXC_CCM_CSCMR1_ESDHC2_CLK_SEL;
+		else if (parent == &esdhc3_clk[0])
+			reg |= MXC_CCM_CSCMR1_ESDHC2_CLK_SEL;
+		else
+			BUG();
+	}
+	__raw_writel(reg, MXC_CCM_CSCMR1);
+	return 0;
+}
+
+static int _clk_esdhc2_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg;
+	u32 div;
+	u32 pre, post;
+	u32 parent_rate = clk_get_rate(clk->parent);
+
+	if (cpu_is_mx51()) {
+		div = parent_rate / rate;
+
+		if ((parent_rate / div) != rate)
+			return -EINVAL;
+
+		 __calc_pre_post_dividers(div, &pre, &post);
+
+		/* Set sdhc1 clock divider */
+		reg = __raw_readl(MXC_CCM_CSCDR1) &
+			~(MXC_CCM_CSCDR1_ESDHC2_MSHC2_CLK_PRED_MASK |
+			MXC_CCM_CSCDR1_ESDHC2_MSHC2_CLK_PODF_MASK);
+		reg |= (post - 1) <<
+				MXC_CCM_CSCDR1_ESDHC2_MSHC2_CLK_PODF_OFFSET;
+		reg |= (pre - 1) <<
+				MXC_CCM_CSCDR1_ESDHC2_MSHC2_CLK_PRED_OFFSET;
+		__raw_writel(reg, MXC_CCM_CSCDR1);
+	}
+	return 0;
+}
+
+static struct clk esdhc2_clk[] = {
+	{
+	 .id = 1,
+	 .parent = &pll3_sw_clk,
+	 .set_parent = _clk_esdhc2_set_parent,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CCGR3,
+	 .enable_shift = MXC_CCM_CCGRx_CG3_OFFSET,
+	 .disable = _clk_disable,
+	 .secondary = &esdhc2_clk[1],
+	 },
+	{
+	 .id = 1,
+	 .parent = &ipg_clk,
+	 .secondary = &esdhc2_clk[2],
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CCGR3,
+	 .enable_shift = MXC_CCM_CCGRx_CG2_OFFSET,
+	 .disable = _clk_disable,
+	 },
+	{
+	 .id = 0,
+	 .parent = &tmax2_clk,
+	 .secondary = &esdhc_dep_clks,
+	 },
+};
+
+static int _clk_esdhc3_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	if (cpu_is_mx51()) {
+		reg = __raw_readl(MXC_CCM_CSCMR1);
+		if (parent == &esdhc1_clk[0])
+			reg &= ~MXC_CCM_CSCMR1_ESDHC3_CLK_SEL_MX51;
+		else if (parent == &esdhc2_clk[0])
+			reg |= MXC_CCM_CSCMR1_ESDHC3_CLK_SEL_MX51;
+		else
+			BUG();
+	} else { /* MX53 */
+		mux = _get_mux(parent, &pll1_sw_clk, &pll2_sw_clk, &pll3_sw_clk,
+			       &lp_apm_clk);
+		reg = __raw_readl(MXC_CCM_CSCMR1) &
+		    ~MXC_CCM_CSCMR1_ESDHC3_MSHC2_CLK_SEL_MASK;
+		reg |= mux << MXC_CCM_CSCMR1_ESDHC3_MSHC2_CLK_SEL_OFFSET;
+	}
+
+	__raw_writel(reg, MXC_CCM_CSCMR1);
+
+	return 0;
+}
+
+static unsigned long _clk_esdhc3_get_rate(struct clk *clk)
+{
+	u32 reg, prediv, podf;
+
+	reg = __raw_readl(MXC_CCM_CSCDR1);
+	prediv = ((reg & MXC_CCM_CSCDR1_ESDHC3_MSHC2_CLK_PRED_MASK) >>
+		  MXC_CCM_CSCDR1_ESDHC3_MSHC2_CLK_PRED_OFFSET) + 1;
+	podf = ((reg & MXC_CCM_CSCDR1_ESDHC3_MSHC2_CLK_PODF_MASK) >>
+		MXC_CCM_CSCDR1_ESDHC3_MSHC2_CLK_PODF_OFFSET) + 1;
+
+	return clk_get_rate(clk->parent) / (prediv * podf);
+}
+
+static int _clk_sdhc3_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg;
+	u32 div;
+	u32 pre, post;
+	u32 parent_rate = clk_get_rate(clk->parent);
+
+	if (cpu_is_mx53()) {
+		div = parent_rate / rate;
+
+		if ((parent_rate / div) != rate)
+			return -EINVAL;
+
+		__calc_pre_post_dividers(div, &pre, &post);
+
+		/* Set sdhc1 clock divider */
+		reg = __raw_readl(MXC_CCM_CSCDR1) &
+			~(MXC_CCM_CSCDR1_ESDHC3_MSHC2_CLK_PRED_MASK |
+			MXC_CCM_CSCDR1_ESDHC3_MSHC2_CLK_PODF_MASK);
+		reg |= (post - 1) << MXC_CCM_CSCDR1_ESDHC3_MSHC2_CLK_PODF_OFFSET;
+		reg |= (pre - 1) << MXC_CCM_CSCDR1_ESDHC3_MSHC2_CLK_PRED_OFFSET;
+		 __raw_writel(reg, MXC_CCM_CSCDR1);
+	}
+	return 0;
+}
+
+
+static struct clk esdhc3_clk[] = {
+	{
+	 .id = 2,
+	 .parent = &esdhc1_clk[0],
+	 .set_parent = _clk_esdhc3_set_parent,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CCGR3,
+	 .enable_shift = MXC_CCM_CCGRx_CG5_OFFSET,
+	 .disable = _clk_disable,
+	 .secondary = &esdhc3_clk[1],
+	 },
+	{
+	 .id = 2,
+	 .parent = &ipg_clk,
+	 .secondary = &esdhc3_clk[2],
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CCGR3,
+	 .enable_shift = MXC_CCM_CCGRx_CG4_OFFSET,
+	 .disable = _clk_disable,
+	 },
+	{
+	 .id = 0,
+	 .parent = &ahb_max_clk,
+	 .secondary = &esdhc_dep_clks,
+	 },
+};
+
+static int _clk_esdhc4_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg;
+	if (cpu_is_mx51()) {
+		reg = __raw_readl(MXC_CCM_CSCMR1);
+		if (parent == &esdhc1_clk[0])
+			reg &= ~MXC_CCM_CSCMR1_ESDHC4_CLK_SEL;
+		else if (parent == &esdhc2_clk[0])
+			reg |= MXC_CCM_CSCMR1_ESDHC4_CLK_SEL;
+		else
+			BUG();
+	} else {/*MX53 */
+		reg = __raw_readl(MXC_CCM_CSCMR1);
+		if (parent == &esdhc1_clk[0])
+			reg &= ~MXC_CCM_CSCMR1_ESDHC4_CLK_SEL;
+		else if (parent == &esdhc3_clk[0])
+			reg |= MXC_CCM_CSCMR1_ESDHC4_CLK_SEL;
+		else
+			BUG();
+	}
+
+	__raw_writel(reg, MXC_CCM_CSCMR1);
+
+	return 0;
+}
+
+static struct clk esdhc4_clk[] = {
+	{
+	 .id = 3,
+	 .parent = &esdhc1_clk[0],
+	 .set_parent = _clk_esdhc4_set_parent,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CCGR3,
+	 .enable_shift = MXC_CCM_CCGRx_CG7_OFFSET,
+	 .disable = _clk_disable,
+	 .secondary = &esdhc4_clk[1],
+	 },
+	{
+	 .id = 3,
+	 .parent = &ipg_clk,
+	 .secondary = &esdhc4_clk[2],
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CCGR3,
+	 .enable_shift = MXC_CCM_CCGRx_CG6_OFFSET,
+	 .disable = _clk_disable,
+	 },
+	{
+	 .id = 0,
+	 .parent = &tmax3_clk,
+	 .secondary = &esdhc_dep_clks,
+	 },
+};
+
+static struct clk sata_clk = {
+	.parent = &ipg_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR4,
+	.enable_shift = MXC_CCM_CCGRx_CG1_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk ieee_1588_clk = {
+	.parent = &ipg_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR7,
+	.enable_shift = MXC_CCM_CCGRx_CG3_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk mlb_clk[] = {
+	{
+	.parent = &ipg_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR7,
+	.enable_shift = MXC_CCM_CCGRx_CG2_OFFSET,
+	.disable = _clk_disable,
+	.secondary = &mlb_clk[1],
+	},
+	{
+	.parent = &emi_fast_clk,
+	.secondary = &emi_intr_clk[1],
+	},
+};
+
+static int _can_root_clk_set(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	mux = _get_mux(parent, &ipg_clk, &ckih_clk, &ckih2_clk, &lp_apm_clk);
+	reg = __raw_readl(MXC_CCM_CSCMR2) & ~MXC_CCM_CSCMR2_CAN_CLK_SEL_MASK;
+	reg |= mux << MXC_CCM_CSCMR2_CAN_CLK_SEL_OFFSET;
+	__raw_writel(reg, MXC_CCM_CSCMR2);
+
+	return 0;
+}
+
+static struct clk can1_clk[] = {
+	{
+	.id = 0,
+	.parent = &lp_apm_clk,
+	.set_parent = _can_root_clk_set,
+	.enable = _clk_enable,
+	.secondary = &can1_clk[1],
+	.enable_reg = MXC_CCM_CCGR6,
+	.enable_shift = MXC_CCM_CCGRx_CG11_OFFSET,
+	.disable = _clk_disable,
+	 },
+	{
+	.id = 0,
+	.parent = &ipg_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR6,
+	.enable_shift = MXC_CCM_CCGRx_CG10_OFFSET,
+	.disable = _clk_disable,
+	 },
+};
+
+static struct clk can2_clk[] = {
+	{
+	.id = 1,
+	.parent = &lp_apm_clk,
+	.set_parent = _can_root_clk_set,
+	.enable = _clk_enable,
+	.secondary = &can2_clk[1],
+	.enable_reg = MXC_CCM_CCGR4,
+	.enable_shift = MXC_CCM_CCGRx_CG4_OFFSET,
+	.disable = _clk_disable,
+	 },
+	{
+	.id = 1,
+	.parent = &ipg_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR4,
+	.enable_shift = MXC_CCM_CCGRx_CG3_OFFSET,
+	.disable = _clk_disable,
+	 },
+};
+
+static int _clk_sim_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	mux = _get_mux(parent, &pll1_sw_clk, &pll2_sw_clk, &pll3_sw_clk, NULL);
+	reg = __raw_readl(MXC_CCM_CSCMR2) & ~MXC_CCM_CSCMR2_SIM_CLK_SEL_MASK;
+	reg |= mux << MXC_CCM_CSCMR2_SIM_CLK_SEL_OFFSET;
+	__raw_writel(reg, MXC_CCM_CSCMR2);
+
+	return 0;
+}
+
+static unsigned long _clk_sim_get_rate(struct clk *clk)
+{
+	u32 reg, pred, podf;
+
+	reg = __raw_readl(MXC_CCM_CSCDR2);
+	pred = ((reg & MXC_CCM_CSCDR2_SIM_CLK_PRED_MASK) >>
+		MXC_CCM_CSCDR2_SIM_CLK_PRED_OFFSET) + 1;
+	podf = ((reg & MXC_CCM_CSCDR2_SIM_CLK_PODF_MASK) >>
+		MXC_CCM_CSCDR2_SIM_CLK_PODF_OFFSET) + 1;
+	return clk_get_rate(clk->parent) / (pred * podf);
+}
+
+static unsigned long _clk_sim_round_rate(struct clk *clk, unsigned long rate)
+{
+	u32 pre, post;
+	u32 parent_rate = clk_get_rate(clk->parent);
+	u32 div = parent_rate / rate;
+	if (parent_rate % rate)
+		div++;
+
+	__calc_pre_post_dividers(div, &pre, &post);
+
+	return parent_rate / (pre * post);
+}
+
+static int _clk_sim_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg;
+	u32 div;
+	u32 pre, post;
+	u32 parent_rate = clk_get_rate(clk->parent);
+
+	div = parent_rate / rate;
+
+	if ((parent_rate / div) != rate)
+		return -EINVAL;
+
+	__calc_pre_post_dividers(div, &pre, &post);
+
+	/* Set SIM clock divider */
+	reg = __raw_readl(MXC_CCM_CSCDR2) &
+	    ~(MXC_CCM_CSCDR2_SIM_CLK_PRED_MASK |
+	      MXC_CCM_CSCDR2_SIM_CLK_PODF_MASK);
+	reg |= (post - 1) << MXC_CCM_CSCDR2_SIM_CLK_PODF_OFFSET;
+	reg |= (pre - 1) << MXC_CCM_CSCDR2_SIM_CLK_PRED_OFFSET;
+	__raw_writel(reg, MXC_CCM_CSCDR2);
+
+	return 0;
+
+}
+
+static struct clk sim_clk[] = {
+	{
+	.parent = &pll3_sw_clk,
+	.set_parent = _clk_sim_set_parent,
+	.secondary = &sim_clk[1],
+	.get_rate = _clk_sim_get_rate,
+	.round_rate = _clk_sim_round_rate,
+	.set_rate = _clk_sim_set_rate,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR4,
+	.enable_shift = MXC_CCM_CCGRx_CG2_OFFSET,
+	.disable = _clk_disable,
+	.flags = AHB_HIGH_SET_POINT | CPU_FREQ_TRIG_UPDATE,
+	 },
+	{
+	.parent = &ipg_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR4,
+	.enable_shift = MXC_CCM_CCGRx_CG1_OFFSET,
+	.disable = _clk_disable,
+	 },
+};
+
+static unsigned long _clk_nfc_get_rate(struct clk *clk)
+{
+	u32 reg, div;
+
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	div = ((reg & MXC_CCM_CBCDR_NFC_PODF_MASK) >>
+	       MXC_CCM_CBCDR_NFC_PODF_OFFSET) + 1;
+	return clk_get_rate(clk->parent) / div;
+}
+
+static unsigned long _clk_nfc_round_rate(struct clk *clk,
+						unsigned long rate)
+{
+	u32 div;
+	u32 parent_rate = clk_get_rate(clk->parent);
+
+	/*
+	 * Compute the divider we'd have to use to reach the target rate.
+	 */
+
+	div = parent_rate / rate;
+	if (div == 0)
+		div++;
+	if (parent_rate / div > MAX_NFC_CLK)
+		div++;
+
+	/*
+	 * The divider for this clock is 3 bits wide, so we can't possibly
+	 * divide the parent by more than eight.
+	 */
+
+	if (div > 8)
+		return -EINVAL;
+
+	return parent_rate / div;
+
+}
+
+static int _clk_nfc_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg, div;
+	struct timespec nstimeofday;
+	struct timespec curtime;
+	u32 parent_rate = clk_get_rate(clk->parent);
+
+	div = parent_rate / rate;
+	if (div == 0)
+		div++;
+	if (((parent_rate / div) != rate) || (div > 8))
+		return -EINVAL;
+
+	if (emi_fast_clk.usecount == 0)
+		emi_fast_clk.enable(&emi_fast_clk);
+	if (emi_slow_clk.usecount == 0)
+		emi_slow_clk.enable(&emi_slow_clk);
+
+
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	reg &= ~MXC_CCM_CBCDR_NFC_PODF_MASK;
+	reg |= (div - 1) << MXC_CCM_CBCDR_NFC_PODF_OFFSET;
+	__raw_writel(reg, MXC_CCM_CBCDR);
+	getnstimeofday(&nstimeofday);
+	while (__raw_readl(MXC_CCM_CDHIPR) &
+			MXC_CCM_CDHIPR_NFC_IPG_INT_MEM_PODF_BUSY){
+		getnstimeofday(&curtime);
+		if ((curtime.tv_nsec - nstimeofday.tv_nsec) > SPIN_DELAY)
+			panic("_clk_nfc_set_rate failed\n");
+	}
+	if (emi_fast_clk.usecount == 0)
+		emi_fast_clk.disable(&emi_fast_clk);
+	if (emi_slow_clk.usecount == 0)
+		emi_slow_clk.disable(&emi_slow_clk);
+
+	return 0;
+}
+
+static struct clk emi_enfc_clk = {
+	.parent = &emi_slow_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR5,
+	.enable_shift = MXC_CCM_CCGRx_CG10_OFFSET,
+	.disable = _clk_disable_inwait,
+	.get_rate = _clk_nfc_get_rate,
+	.round_rate = _clk_nfc_round_rate,
+	.set_rate = _clk_nfc_set_rate,
+};
+
+static int _clk_spdif_xtal_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	mux = _get_mux(parent, &osc_clk, &ckih_clk, &ckih2_clk, NULL);
+	reg = __raw_readl(MXC_CCM_CSCMR1) & ~MXC_CCM_CSCMR1_SPDIF_CLK_SEL_MASK;
+	reg |= mux << MXC_CCM_CSCMR1_SPDIF_CLK_SEL_OFFSET;
+	__raw_writel(reg, MXC_CCM_CSCMR1);
+
+	return 0;
+}
+
+static struct clk spdif_xtal_clk = {
+	.parent = &osc_clk,
+	.set_parent = _clk_spdif_xtal_set_parent,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR5,
+	.enable_shift = MXC_CCM_CCGRx_CG15_OFFSET,
+	.disable = _clk_disable,
+};
+
+static int _clk_spdif0_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	reg = __raw_readl(MXC_CCM_CSCMR2);
+	reg |= MXC_CCM_CSCMR2_SPDIF0_COM;
+	if (parent != &ssi1_clk[0]) {
+		reg &= ~MXC_CCM_CSCMR2_SPDIF0_COM;
+		mux = _get_mux(parent, &pll1_sw_clk, &pll2_sw_clk, &pll3_sw_clk,
+			       &spdif_xtal_clk);
+		reg = (reg & ~MXC_CCM_CSCMR2_SPDIF0_CLK_SEL_MASK) |
+		    (mux << MXC_CCM_CSCMR2_SPDIF0_CLK_SEL_OFFSET);
+	}
+	__raw_writel(reg, MXC_CCM_CSCMR2);
+
+	return 0;
+}
+
+static unsigned long _clk_spdif0_get_rate(struct clk *clk)
+{
+	u32 reg, pred, podf;
+	u32 div = 1;
+
+	if (clk->parent != &ssi1_clk[0]) {
+		reg = __raw_readl(MXC_CCM_CDCDR);
+		pred = ((reg & MXC_CCM_CDCDR_SPDIF0_CLK_PRED_MASK) >>
+			MXC_CCM_CDCDR_SPDIF0_CLK_PRED_OFFSET) + 1;
+		podf = ((reg & MXC_CCM_CDCDR_SPDIF0_CLK_PODF_MASK) >>
+			MXC_CCM_CDCDR_SPDIF0_CLK_PODF_OFFSET) + 1;
+		div = (pred * podf);
+	}
+	return clk_get_rate(clk->parent) / div;
+}
+
+static struct clk spdif0_clk[] = {
+	{
+	.id = 0,
+	.parent = &pll3_sw_clk,
+	.set_parent = _clk_spdif0_set_parent,
+	.get_rate = _clk_spdif0_get_rate,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR5,
+	.enable_shift = MXC_CCM_CCGRx_CG13_OFFSET,
+	.disable = _clk_disable,
+	.flags = AHB_HIGH_SET_POINT | CPU_FREQ_TRIG_UPDATE,
+	},
+	{
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .secondary = &spba_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CCGR5,
+	 .enable_shift = MXC_CCM_CCGRx_CG15_OFFSET,
+	 .disable = _clk_disable,
+	 },
+};
+
+static int _clk_spdif1_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	reg = __raw_readl(MXC_CCM_CSCMR2);
+	reg |= MXC_CCM_CSCMR2_SPDIF1_COM;
+	if (parent != &ssi2_clk[0]) {
+		reg &= ~MXC_CCM_CSCMR2_SPDIF1_COM;
+		mux = _get_mux(parent, &pll1_sw_clk, &pll2_sw_clk, &pll3_sw_clk,
+			       &spdif_xtal_clk);
+		reg = (reg & ~MXC_CCM_CSCMR2_SPDIF1_CLK_SEL_MASK) |
+		    (mux << MXC_CCM_CSCMR2_SPDIF1_CLK_SEL_OFFSET);
+	}
+	__raw_writel(reg, MXC_CCM_CSCMR2);
+
+	return 0;
+}
+
+static unsigned long _clk_spdif1_get_rate(struct clk *clk)
+{
+	u32 reg, pred, podf;
+	u32 div = 1;
+
+	if (clk->parent != &ssi2_clk[0]) {
+		reg = __raw_readl(MXC_CCM_CDCDR);
+		pred = ((reg & MXC_CCM_CDCDR_SPDIF1_CLK_PRED_MASK) >>
+			MXC_CCM_CDCDR_SPDIF1_CLK_PRED_OFFSET) + 1;
+		podf = ((reg & MXC_CCM_CDCDR_SPDIF1_CLK_PODF_MASK) >>
+			MXC_CCM_CDCDR_SPDIF1_CLK_PODF_OFFSET) + 1;
+		div = (pred * podf);
+	}
+	return clk_get_rate(clk->parent) / div;
+}
+
+static struct clk spdif1_clk[] = {
+	{
+	.id = 1,
+	.parent = &pll3_sw_clk,
+	.set_parent = _clk_spdif1_set_parent,
+	.get_rate = _clk_spdif1_get_rate,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR5,
+	.enable_shift = MXC_CCM_CCGRx_CG14_OFFSET,
+	.disable = _clk_disable,
+	.flags = AHB_HIGH_SET_POINT | CPU_FREQ_TRIG_UPDATE,
+	},
+	{
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .secondary = &spba_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CCGR5,
+	 .enable_shift = MXC_CCM_CCGRx_CG15_OFFSET,
+	 .disable = _clk_disable,
+	 },
+};
+
+static int _clk_ddr_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, reg2, mux;
+	struct timespec nstimeofday;
+	struct timespec curtime;
+
+	reg = __raw_readl(MXC_CCM_CBCMR);
+	reg2 = __raw_readl(MXC_CCM_CBCDR);
+	if (cpu_is_mx51()) {
+		clk->parent = &ddr_hf_clk;
+		mux = _get_mux_ddr(parent, &axi_a_clk, &axi_b_clk, &emi_slow_clk, &ahb_clk, &ddr_hf_clk);
+	} else {
+		clk->parent = &axi_a_clk;
+		mux = _get_mux_ddr(parent, &axi_a_clk, &axi_b_clk, &emi_slow_clk, &ahb_clk, NULL);
+	}
+	if (mux < 4) {
+		reg = (reg & ~MXC_CCM_CBCMR_DDR_CLK_SEL_MASK) |
+		    (mux << MXC_CCM_CBCMR_DDR_CLK_SEL_OFFSET);
+		__raw_writel(reg, MXC_CCM_CBCMR);
+		if (cpu_is_mx51())
+			reg2 = (reg2 & ~MXC_CCM_CBCDR_DDR_HF_SEL);
+	} else {
+		reg2 = (reg2 & ~MXC_CCM_CBCDR_DDR_HF_SEL) |
+			(MXC_CCM_CBCDR_DDR_HF_SEL);
+	}
+	if (cpu_is_mx51()) {
+		__raw_writel(reg2, MXC_CCM_CBCDR);
+		getnstimeofday(&nstimeofday);
+		while (__raw_readl(MXC_CCM_CDHIPR) &
+			MXC_CCM_CDHIPR_DDR_HF_CLK_SEL_BUSY){
+			getnstimeofday(&curtime);
+			if ((curtime.tv_nsec - nstimeofday.tv_nsec) > SPIN_DELAY)
+				panic("_clk_ddr_set_parent failed\n");
+		}
+	}
+	return 0;
+}
+
+static struct clk ddr_clk = {
+	.parent = &axi_b_clk,
+	.set_parent = _clk_ddr_set_parent,
+};
+
+static int _clk_arm_axi_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+	reg = __raw_readl(MXC_CCM_CBCMR);
+	mux = _get_mux(parent, &axi_a_clk, &axi_b_clk, &emi_slow_clk, &ahb_clk);
+	reg = (reg & ~MXC_CCM_CBCMR_ARM_AXI_CLK_SEL_MASK) |
+	    (mux << MXC_CCM_CBCMR_ARM_AXI_CLK_SEL_OFFSET);
+	__raw_writel(reg, MXC_CCM_CBCMR);
+
+	return 0;
+}
+
+static struct clk arm_axi_clk = {
+	.parent = &axi_a_clk,
+	.set_parent = _clk_arm_axi_set_parent,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR0,
+	.enable_shift = MXC_CCM_CCGRx_CG1_OFFSET,
+	.disable = _clk_disable,
+};
+
+static int _clk_vpu_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+	reg = __raw_readl(MXC_CCM_CBCMR);
+	mux = _get_mux(parent, &axi_a_clk, &axi_b_clk, &emi_slow_clk, &ahb_clk);
+	reg = (reg & ~MXC_CCM_CBCMR_VPU_AXI_CLK_SEL_MASK) |
+	    (mux << MXC_CCM_CBCMR_VPU_AXI_CLK_SEL_OFFSET);
+	__raw_writel(reg, MXC_CCM_CBCMR);
+
+	return 0;
+}
+
+static int _clk_vpu_enable(struct clk *clk)
+{
+	/* Set VPU's parent to be axi_a or ahb when its enabled. */
+	if (cpu_is_mx51() && (mx51_revision() < IMX_CHIP_REVISION_2_0)) {
+		clk_set_parent(&vpu_clk[0], &ahb_clk);
+		clk_set_parent(&vpu_clk[1], &ahb_clk);
+	} else if (cpu_is_mx51()) {
+		clk_set_parent(&vpu_clk[0], &axi_a_clk);
+		clk_set_parent(&vpu_clk[1], &axi_a_clk);
+	}
+
+	return _clk_enable(clk);
+
+}
+
+static void _clk_vpu_disable(struct clk *clk)
+{
+	_clk_disable(clk);
+
+	/* Set VPU's parent to be axi_b when its disabled. */
+	if (cpu_is_mx51()) {
+		clk_set_parent(&vpu_clk[0], &axi_b_clk);
+		clk_set_parent(&vpu_clk[1], &axi_b_clk);
+	}
+}
+
+static struct clk vpu_clk[] = {
+	{
+	 .set_parent = _clk_vpu_set_parent,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CCGR5,
+	 .enable_shift = MXC_CCM_CCGRx_CG4_OFFSET,
+	 .disable = _clk_disable,
+	 .secondary = &vpu_clk[1],
+	.flags = AHB_HIGH_SET_POINT | CPU_FREQ_TRIG_UPDATE,
+	 },
+	{
+	 .set_parent = _clk_vpu_set_parent,
+	 .enable = _clk_vpu_enable,
+	 .enable_reg = MXC_CCM_CCGR5,
+	 .enable_shift = MXC_CCM_CCGRx_CG3_OFFSET,
+	 .disable = _clk_vpu_disable,
+	 .secondary = &vpu_clk[2],
+	 },
+	{
+	 .parent = &emi_fast_clk,
+#ifdef CONFIG_MXC_VPU_IRAM
+	 .secondary = &emi_intr_clk[0],
+#endif
+	 }
+};
+
+static int _clk_lpsr_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+	reg = __raw_readl(MXC_CCM_CLPCR);
+	mux = _get_mux(parent, &ckil_clk, &osc_clk, NULL, NULL);
+	reg = (reg & ~MXC_CCM_CLPCR_LPSR_CLK_SEL_MASK) |
+	    (mux << MXC_CCM_CLPCR_LPSR_CLK_SEL_OFFSET);
+	__raw_writel(reg, MXC_CCM_CLPCR);
+
+	return 0;
+}
+
+static struct clk lpsr_clk = {
+	.parent = &ckil_clk,
+	.set_parent = _clk_lpsr_set_parent,
+};
+
+static unsigned long _clk_pgc_get_rate(struct clk *clk)
+{
+	u32 reg, div;
+
+	reg = __raw_readl(MXC_CCM_CSCDR1);
+	div = (reg & MXC_CCM_CSCDR1_PGC_CLK_PODF_MASK) >>
+	    MXC_CCM_CSCDR1_PGC_CLK_PODF_OFFSET;
+	div = 1 >> div;
+	return clk_get_rate(clk->parent) / div;
+}
+
+static struct clk pgc_clk = {
+	.parent = &ipg_clk,
+	.get_rate = _clk_pgc_get_rate,
+};
+
+static unsigned long _clk_usb_get_rate(struct clk *clk)
+{
+	return 60000000;
+}
+
+/*usb OTG clock */
+static struct clk usb_clk = {
+	.get_rate = _clk_usb_get_rate,
+};
+
+static struct clk usb_utmi_clk = {
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CSCMR1,
+	.enable_shift = MXC_CCM_CSCMR1_USB_PHY_CLK_SEL_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk rtc_clk = {
+	.parent = &ckil_clk,
+	.secondary = &ipg_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR4,
+	.enable_shift = MXC_CCM_CCGRx_CG14_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk ata_clk = {
+	.parent = &ipg_clk,
+	.secondary = &spba_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR4,
+	.enable_shift = MXC_CCM_CCGRx_CG0_OFFSET,
+	.disable = _clk_disable,
+	.flags = AHB_HIGH_SET_POINT | CPU_FREQ_TRIG_UPDATE,
+};
+
+static struct clk owire_clk = {
+	.parent = &ipg_perclk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR2,
+	.enable_shift = MXC_CCM_CCGRx_CG11_OFFSET,
+	.disable = _clk_disable,
+};
+
+
+static struct clk fec_clk[] = {
+	{
+	.parent = &ipg_clk,
+	.secondary = &fec_clk[1],
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR2,
+	.enable_shift = MXC_CCM_CCGRx_CG12_OFFSET,
+	.disable = _clk_disable,
+	.flags = AHB_HIGH_SET_POINT | CPU_FREQ_TRIG_UPDATE,
+	},
+	{
+	 .parent = &tmax2_clk,
+	 .secondary = &fec_clk[2],
+	},
+	{
+	 .parent = &aips_tz2_clk,
+	 .secondary = &emi_fast_clk,
+	},
+};
+
+static struct clk sahara_clk[] = {
+	{
+	.parent = &ahb_clk,
+	.secondary = &sahara_clk[1],
+	.enable_reg = MXC_CCM_CCGR4,
+	.enable_shift = MXC_CCM_CCGRx_CG7_OFFSET,
+	.enable = _clk_enable,
+	.disable = _clk_disable,
+	},
+	{
+	.parent = &tmax1_clk,
+	.secondary = &emi_fast_clk,
+	}
+};
+
+static struct clk scc_clk[] = {
+	{
+	.parent = &ahb_clk,
+	.secondary = &scc_clk[1],
+	.enable_reg = MXC_CCM_CCGR1,
+	.enable_shift = MXC_CCM_CCGRx_CG15_OFFSET,
+	.enable = _clk_enable,
+	.disable = _clk_disable,
+	},
+	{
+	.parent = &tmax1_clk,
+	.secondary = &emi_fast_clk,
+	}
+};
+
+
+static int _clk_gpu3d_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	reg = __raw_readl(MXC_CCM_CBCMR);
+	mux = _get_mux(parent, &axi_a_clk, &axi_b_clk, &emi_slow_clk, &ahb_clk);
+	reg = (reg & ~MXC_CCM_CBCMR_GPU_CLK_SEL_MASK) |
+	    (mux << MXC_CCM_CBCMR_GPU_CLK_SEL_OFFSET);
+	__raw_writel(reg, MXC_CCM_CBCMR);
+
+	return 0;
+}
+
+
+static struct clk garb_clk = {
+	.parent = &axi_a_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR5,
+	.enable_shift = MXC_CCM_CCGRx_CG2_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk gpu3d_clk = {
+	.parent = &axi_a_clk,
+	.set_parent = _clk_gpu3d_set_parent,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR5,
+	.enable_shift = MXC_CCM_CCGRx_CG1_OFFSET,
+	.disable = _clk_disable,
+	.flags = AHB_HIGH_SET_POINT | CPU_FREQ_TRIG_UPDATE,
+	.secondary = &garb_clk,
+};
+
+static int _clk_gpu2d_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg, mux;
+
+	reg = __raw_readl(MXC_CCM_CBCMR);
+	mux = _get_mux(parent, &axi_a_clk, &axi_b_clk, &emi_slow_clk, &ahb_clk);
+	reg = (reg & ~MXC_CCM_CBCMR_GPU2D_CLK_SEL_MASK) |
+	    (mux << MXC_CCM_CBCMR_GPU2D_CLK_SEL_OFFSET);
+	__raw_writel(reg, MXC_CCM_CBCMR);
+
+	return 0;
+}
+
+static struct clk gpu2d_clk = {
+	.parent = &axi_a_clk,
+	.set_parent = _clk_gpu2d_set_parent,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR6,
+	.enable_shift = MXC_CCM_CCGRx_CG7_OFFSET,
+	.disable = _clk_disable,
+	.flags = AHB_HIGH_SET_POINT | CPU_FREQ_TRIG_UPDATE,
+};
+
+static unsigned long cko1_get_rate(struct clk *clk)
+{
+	u32 reg;
+
+	reg = __raw_readl(MXC_CCM_CCOSR);
+	reg &= MXC_CCM_CCOSR_CKOL_DIV_MASK;
+	reg = reg >> MXC_CCM_CCOSR_CKOL_DIV_OFFSET;
+	return clk_get_rate(clk->parent) / (reg + 1);
+}
+
+static int cko1_enable(struct clk *clk)
+{
+	u32 reg;
+
+	reg = __raw_readl(MXC_CCM_CCOSR);
+	reg |= MXC_CCM_CCOSR_CKOL_EN;
+	__raw_writel(reg, MXC_CCM_CCOSR);
+	return 0;
+}
+
+static void cko1_disable(struct clk *clk)
+{
+	u32 reg;
+
+	reg = __raw_readl(MXC_CCM_CCOSR);
+	reg &= ~MXC_CCM_CCOSR_CKOL_EN;
+	__raw_writel(reg, MXC_CCM_CCOSR);
+}
+
+static int cko1_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg, div;
+	u32 parent_rate = clk_get_rate(clk->parent);
+
+	div = (parent_rate/rate - 1) & 0x7;
+	reg = __raw_readl(MXC_CCM_CCOSR);
+	reg &= ~MXC_CCM_CCOSR_CKOL_DIV_MASK;
+	reg |= div << MXC_CCM_CCOSR_CKOL_DIV_OFFSET;
+	__raw_writel(reg, MXC_CCM_CCOSR);
+	return 0;
+}
+
+static unsigned long cko1_round_rate(struct clk *clk, unsigned long rate)
+{
+	u32 div;
+	u32 parent_rate = clk_get_rate(clk->parent);
+
+	div = parent_rate / rate;
+	div = div < 1 ? 1 : div;
+	div = div > 8 ? 8 : div;
+	return parent_rate / div;
+}
+
+static int cko1_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 sel, reg;
+
+	if (parent == &cpu_clk)
+		sel = 0;
+	else if (parent == &pll1_sw_clk)
+		sel = 1;
+	else if (parent == &pll2_sw_clk)
+		sel = 2;
+	else if (parent == &pll3_sw_clk)
+		sel = 3;
+	else if (parent == &emi_slow_clk)
+		sel = 4;
+	else if (parent == &pll4_sw_clk)
+		sel = 5;
+	else if (parent == &emi_enfc_clk)
+		sel = 6;
+	else if (parent == &ipu_di_clk[0])
+		sel = 8;
+	else if (parent == &ahb_clk)
+		sel = 11;
+	else if (parent == &ipg_clk)
+		sel = 12;
+	else if (parent == &ipg_perclk)
+		sel = 13;
+	else if (parent == &ckil_clk)
+		sel = 14;
+	else
+		return -EINVAL;
+
+	reg = __raw_readl(MXC_CCM_CCOSR);
+	reg &= ~MXC_CCM_CCOSR_CKOL_SEL_MASK;
+	reg |= sel << MXC_CCM_CCOSR_CKOL_SEL_OFFSET;
+	__raw_writel(reg, MXC_CCM_CCOSR);
+	return 0;
+}
+static struct clk cko1_clk = {
+	.get_rate = cko1_get_rate,
+	.enable = cko1_enable,
+	.disable = cko1_disable,
+	.set_rate = cko1_set_rate,
+	.round_rate = cko1_round_rate,
+	.set_parent = cko1_set_parent,
+};
+static int _clk_asrc_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg;
+
+	reg = __raw_readl(MXC_CCM_CSCMR2);
+	if (parent == &pll4_sw_clk)
+		reg |= MXC_CCM_CSCMR2_ASRC_CLK_SEL;
+	else
+		reg &= ~MXC_CCM_CSCMR2_ASRC_CLK_SEL;
+	 __raw_writel(reg, MXC_CCM_CSCMR2);
+
+	return 0;
+}
+
+static unsigned long _clk_asrc_get_rate(struct clk *clk)
+{
+	u32 reg, prediv, podf;
+
+	reg = __raw_readl(MXC_CCM_CSCDR2);
+	prediv = ((reg & MXC_CCM_CSCDR2_ASRC_CLK_PRED_MASK) >>
+		MXC_CCM_CSCDR2_ASRC_CLK_PRED_OFFSET) + 1;
+	if (prediv == 1)
+		BUG();
+	podf = ((reg & MXC_CCM_CSCDR2_ASRC_CLK_PODF_MASK) >>
+		MXC_CCM_CSCDR2_ASRC_CLK_PODF_OFFSET) + 1;
+
+	return clk_get_rate(clk->parent) / (prediv * podf);
+}
+
+static int _clk_asrc_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg;
+	u32 div;
+	u32 pre, post;
+	u32 parent_rate = clk_get_rate(clk->parent);
+
+	div = parent_rate / rate;
+
+	if ((parent_rate / div) != rate)
+		return -EINVAL;
+
+	__calc_pre_post_dividers(div, &pre, &post);
+
+	reg = __raw_readl(MXC_CCM_CSCDR2) &
+		~(MXC_CCM_CSCDR2_ASRC_CLK_PRED_MASK |
+		MXC_CCM_CSCDR2_ASRC_CLK_PODF_MASK);
+	reg |= (post - 1) << MXC_CCM_CSCDR2_ASRC_CLK_PODF_OFFSET;
+	reg |= (pre - 1) << MXC_CCM_CSCDR2_ASRC_CLK_PRED_OFFSET;
+	__raw_writel(reg, MXC_CCM_CSCDR2);
+
+	return 0;
+}
+
+static unsigned long _clk_asrc_round_rate(struct clk *clk,
+			unsigned long rate)
+{
+	u32 pre, post;
+	u32 parent_rate = clk_get_rate(clk->parent);
+	u32 div = parent_rate / rate;
+
+	if (parent_rate % rate)
+		div++;
+
+	__calc_pre_post_dividers(div, &pre, &post);
+
+	return parent_rate / (pre * post);
+}
+
+static struct clk asrc_clk[] = {
+	{
+	.id = 0,
+	.parent = &pll4_sw_clk,
+	.set_parent = _clk_asrc_set_parent,
+	.get_rate = _clk_asrc_get_rate,
+	.set_rate = _clk_asrc_set_rate,
+	.round_rate = _clk_asrc_round_rate,
+	.enable_reg = MXC_CCM_CCGR7,
+	.enable_shift = MXC_CCM_CCGRx_CG1_OFFSET,
+	.enable = _clk_enable,
+	.disable = _clk_disable,
+	},
+	{
+	.id = 0,
+	.parent = &ipg_clk,
+	.enable_reg = MXC_CCM_CCGR7,
+	.enable_shift = MXC_CCM_CCGRx_CG0_OFFSET,
+	.enable = _clk_enable,
+	.disable = _clk_disable,
+	},
+};
+
+#define _REGISTER_CLOCK(d, n, c) \
+	{ \
+		.dev_id = d, \
+		.con_id = n, \
+		.clk = &c, \
+	}
+
+static struct clk_lookup lookups[] = {
+	_REGISTER_CLOCK(NULL, "osc", osc_clk),
+	_REGISTER_CLOCK(NULL, "ckih", ckih_clk),
+	_REGISTER_CLOCK(NULL, "ckih2", ckih2_clk),
+	_REGISTER_CLOCK(NULL, "ckil", ckil_clk),
+	_REGISTER_CLOCK(NULL, "pll1_main_clk", pll1_main_clk),
+	_REGISTER_CLOCK(NULL, "pll1_sw_clk", pll1_sw_clk),
+	_REGISTER_CLOCK(NULL, "pll2", pll2_sw_clk),
+	_REGISTER_CLOCK(NULL, "pll3", pll3_sw_clk),
+	_REGISTER_CLOCK(NULL, "gpc_dvfs_clk", gpc_dvfs_clk),
+	_REGISTER_CLOCK(NULL, "lp_apm", lp_apm_clk),
+	_REGISTER_CLOCK(NULL, "cpu_clk", cpu_clk),
+	_REGISTER_CLOCK(NULL, "periph_apm_clk", periph_apm_clk),
+	_REGISTER_CLOCK(NULL, "main_bus_clk", main_bus_clk),
+	_REGISTER_CLOCK(NULL, "axi_a_clk", axi_a_clk),
+	_REGISTER_CLOCK(NULL, "axi_b_clk", axi_b_clk),
+	_REGISTER_CLOCK(NULL, "ahb_clk", ahb_clk),
+	_REGISTER_CLOCK(NULL, "ahb_max_clk", ahb_max_clk),
+	_REGISTER_CLOCK(NULL, "vpu_clk", vpu_clk[0]),
+	_REGISTER_CLOCK(NULL, "vpu_core_clk", vpu_clk[1]),
+	_REGISTER_CLOCK(NULL, "nfc_clk", emi_enfc_clk),
+	_REGISTER_CLOCK("imx-sdma", NULL, sdma_clk[0]),
+	_REGISTER_CLOCK(NULL, "ipu_clk", ipu_clk[0]),
+	_REGISTER_CLOCK(NULL, "ipu_di0_clk", ipu_di_clk[0]),
+	_REGISTER_CLOCK(NULL, "ipu_di1_clk", ipu_di_clk[1]),
+	_REGISTER_CLOCK(NULL, "csi_mclk1", csi0_clk),
+	_REGISTER_CLOCK(NULL, "csi_mclk2", csi1_clk),
+	_REGISTER_CLOCK(NULL, "tve_clk", tve_clk),
+	_REGISTER_CLOCK("imx-uart.0", NULL, uart1_clk[0]),
+	_REGISTER_CLOCK("imx-uart.1", NULL, uart2_clk[0]),
+	_REGISTER_CLOCK("imx-uart.2", NULL, uart3_clk[0]),
+	_REGISTER_CLOCK(NULL, "i2c_clk", i2c_clk[0]),
+	_REGISTER_CLOCK("imx-i2c.1", NULL, i2c_clk[1]),
+	_REGISTER_CLOCK("mxc_pwm.0", NULL, pwm1_clk[0]),
+	_REGISTER_CLOCK("mxc_pwm.1", NULL, pwm2_clk[0]),
+	_REGISTER_CLOCK("mxc_spi.0", NULL, cspi1_clk[0]),
+	_REGISTER_CLOCK("mxc_spi.1", NULL, cspi2_clk[0]),
+	_REGISTER_CLOCK("mxc_spi.2", NULL, cspi3_clk),
+	_REGISTER_CLOCK(NULL, "ssi_lp_apm_clk", ssi_lp_apm_clk),
+	_REGISTER_CLOCK("imx-ssi.0", NULL, ssi1_clk[0]),
+	_REGISTER_CLOCK("imx-ssi.1", NULL, ssi2_clk[0]),
+	_REGISTER_CLOCK("imx-ssi.2", NULL, ssi3_clk[0]),
+	_REGISTER_CLOCK(NULL, "ssi_ext1_clk", ssi_ext1_clk),
+	_REGISTER_CLOCK(NULL, "ssi_ext2_clk", ssi_ext2_clk),
+	_REGISTER_CLOCK(NULL, "iim_clk", iim_clk),
+	_REGISTER_CLOCK(NULL, "usboh3_clk", usboh3_clk[0]),
+	_REGISTER_CLOCK(NULL, "usb_ahb_clk", usb_ahb_clk),
+	_REGISTER_CLOCK(NULL, "usb_phy1_clk", usb_phy_clk[0]),
+	_REGISTER_CLOCK(NULL, "usb_utmi_clk", usb_utmi_clk),
+	_REGISTER_CLOCK(NULL, "usb_clk", usb_clk),
+	_REGISTER_CLOCK("sdhci-esdhc-imx.0", NULL, esdhc1_clk[0]),
+	_REGISTER_CLOCK("sdhci-esdhc-imx.1", NULL, esdhc2_clk[0]),
+	_REGISTER_CLOCK("sdhci-esdhc-imx.2", NULL, esdhc3_clk[0]),
+	_REGISTER_CLOCK("sdhci-esdhc-imx.3", NULL, esdhc4_clk[0]),
+	_REGISTER_CLOCK(NULL, "emi_slow_clk", emi_slow_clk),
+	_REGISTER_CLOCK(NULL, "ddr_clk", ddr_clk),
+	_REGISTER_CLOCK(NULL, "emi_enfc_clk", emi_enfc_clk),
+	_REGISTER_CLOCK(NULL, "emi_fast_clk", emi_fast_clk),
+	_REGISTER_CLOCK(NULL, "emi_intr_clk.0", emi_intr_clk[0]),
+	_REGISTER_CLOCK(NULL, "emi_intr_clk.1", emi_intr_clk[1]),
+	_REGISTER_CLOCK(NULL, "spdif_xtal_clk", spdif_xtal_clk),
+	_REGISTER_CLOCK("mxc_alsa_spdif.0", NULL, spdif0_clk[0]),
+	_REGISTER_CLOCK("mxc_vpu.0", NULL, vpu_clk[0]),
+	_REGISTER_CLOCK(NULL, "lpsr_clk", lpsr_clk),
+	_REGISTER_CLOCK("mxc_rtc.0", NULL, rtc_clk),
+	_REGISTER_CLOCK("pata_fsl", NULL, ata_clk),
+	_REGISTER_CLOCK("mxc_w1.0", NULL, owire_clk),
+	_REGISTER_CLOCK(NULL, "sahara_clk", sahara_clk[0]),
+	_REGISTER_CLOCK(NULL, "gpu3d_clk", gpu3d_clk),
+	_REGISTER_CLOCK(NULL, "garb_clk", garb_clk),
+	_REGISTER_CLOCK(NULL, "gpu2d_clk", gpu2d_clk),
+	_REGISTER_CLOCK("mxc_scc.0", NULL, scc_clk[0]),
+	_REGISTER_CLOCK(NULL, "cko1", cko1_clk),
+	_REGISTER_CLOCK(NULL, "gpt", gpt_clk[0]),
+	_REGISTER_CLOCK("fec.0", NULL, fec_clk[0]),
+	_REGISTER_CLOCK("mxc_w1.0", NULL, owire_clk),
+};
+
+static struct clk_lookup mx51_lookups[] = {
+	_REGISTER_CLOCK("mxc_i2c_hs.3", NULL, hsi2c_serial_clk),
+	_REGISTER_CLOCK("mxc_sim.0", NULL, sim_clk[0]),
+	_REGISTER_CLOCK("mxc_alsa_spdif.0", NULL, spdif1_clk[0]),
+	_REGISTER_CLOCK(NULL, "mipi_hsp_clk", mipi_hsp_clk),
+	_REGISTER_CLOCK(NULL, "ddr_hf_clk", ddr_hf_clk),
+};
+
+static struct clk_lookup mx53_lookups[] = {
+	_REGISTER_CLOCK(NULL, "pll4", pll4_sw_clk),
+	_REGISTER_CLOCK("imx-uart.3", NULL, uart4_clk[0]),
+	_REGISTER_CLOCK("imx-uart.4", NULL, uart5_clk[0]),
+	_REGISTER_CLOCK("imx-i2c.2", NULL, i2c_clk[2]),
+	_REGISTER_CLOCK(NULL, "usb_phy2_clk", usb_phy_clk[1]),
+	_REGISTER_CLOCK(NULL, "ocram_clk", ocram_clk),
+	_REGISTER_CLOCK(NULL, "imx_sata_clk", sata_clk),
+	_REGISTER_CLOCK(NULL, "ieee_1588_clk", ieee_1588_clk),
+	_REGISTER_CLOCK(NULL, "ieee_rtc_clk", ieee_rtc_clk),
+	_REGISTER_CLOCK("mxc_mlb.0", NULL, mlb_clk[0]),
+	_REGISTER_CLOCK("FlexCAN.0", "can_clk", can1_clk[0]),
+	_REGISTER_CLOCK("FlexCAN.1", "can_clk", can2_clk[0]),
+	_REGISTER_CLOCK(NULL, "ldb_di0_clk", ldb_di_clk[0]),
+	_REGISTER_CLOCK(NULL, "ldb_di1_clk", ldb_di_clk[1]),
+	_REGISTER_CLOCK(NULL, "esai_clk", esai_clk[0]),
+	_REGISTER_CLOCK(NULL, "esai_ipg_clk", esai_clk[1]),
+	_REGISTER_CLOCK(NULL, "asrc_clk", asrc_clk[1]),
+	_REGISTER_CLOCK(NULL, "asrc_serial_clk", asrc_clk[0]),
+};
+
+static void clk_tree_init(void)
+{
+	u32 reg, dp_ctl;
+
+	ipg_perclk.set_parent(&ipg_perclk, &lp_apm_clk);
+
+	/*
+	 *Initialise the IPG PER CLK dividers to 3. IPG_PER_CLK should be at
+	 * 8MHz, its derived from lp_apm.
+	 */
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	reg &= ~MXC_CCM_CBCDR_PERCLK_PRED1_MASK;
+	reg &= ~MXC_CCM_CBCDR_PERCLK_PRED2_MASK;
+	reg &= ~MXC_CCM_CBCDR_PERCLK_PODF_MASK;
+	reg |= (2 << MXC_CCM_CBCDR_PERCLK_PRED1_OFFSET);
+	__raw_writel(reg, MXC_CCM_CBCDR);
+
+	/* set pll1_main_clk parent */
+	pll1_main_clk.parent = &osc_clk;
+
+	/* set pll2_sw_clk parent */
+	pll2_sw_clk.parent = &osc_clk;
+
+	/* set pll3_clk parent */
+	pll3_sw_clk.parent = &osc_clk;
+
+	if (cpu_is_mx51()) {
+		dp_ctl = __raw_readl(pll1_base + MXC_PLL_DP_CTL);
+		if ((dp_ctl & MXC_PLL_DP_CTL_REF_CLK_SEL_MASK) == 0)
+			pll1_main_clk.parent = &fpm_clk;
+
+		dp_ctl = __raw_readl(pll2_base + MXC_PLL_DP_CTL);
+		if ((dp_ctl & MXC_PLL_DP_CTL_REF_CLK_SEL_MASK) == 0)
+			pll2_sw_clk.parent = &fpm_clk;
+
+		dp_ctl = __raw_readl(pll3_base + MXC_PLL_DP_CTL);
+		if ((dp_ctl & MXC_PLL_DP_CTL_REF_CLK_SEL_MASK) == 0)
+			pll3_sw_clk.parent = &fpm_clk;
+	} else {
+		/* set pll4_clk parent */
+		pll4_sw_clk.parent = &osc_clk;
+	}
+
+	/* set emi_slow_clk parent */
+	emi_slow_clk.parent = &main_bus_clk;
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	if ((reg & MXC_CCM_CBCDR_EMI_CLK_SEL) != 0)
+		emi_slow_clk.parent = &ahb_clk;
+
+	/* set ipg_perclk parent */
+	ipg_perclk.parent = &lp_apm_clk;
+	reg = __raw_readl(MXC_CCM_CBCMR);
+	if ((reg & MXC_CCM_CBCMR_PERCLK_IPG_CLK_SEL) != 0) {
+		ipg_perclk.parent = &ipg_clk;
+	} else {
+		if ((reg & MXC_CCM_CBCMR_PERCLK_LP_APM_CLK_SEL) == 0)
+			ipg_perclk.parent = &main_bus_clk;
+	}
+}
+
+
+int __init mx51_clocks_init(unsigned long ckil, unsigned long osc, unsigned long ckih1, unsigned long ckih2)
+{
+	__iomem void *base;
+	struct clk *tclk;
+	int i = 0, j = 0, reg;
+	int op_cnt = 0;
+	u32 pll1_rate;
+
+	pll1_base = MX51_DPLL1_BASE;
+	pll2_base = MX51_DPLL2_BASE;
+	pll3_base = MX51_DPLL3_BASE;
+
+	/* Turn off all possible clocks */
+	if (mxc_jtag_enabled) {
+		__raw_writel(1 << MXC_CCM_CCGRx_CG0_OFFSET |
+			      1 << MXC_CCM_CCGRx_CG1_OFFSET |
+			      1 << MXC_CCM_CCGRx_CG2_OFFSET |
+			      3 << MXC_CCM_CCGRx_CG3_OFFSET |
+			      3 << MXC_CCM_CCGRx_CG4_OFFSET |
+			      3 << MXC_CCM_CCGRx_CG8_OFFSET |
+			      3 << MXC_CCM_CCGRx_CG9_OFFSET |
+			      1 << MXC_CCM_CCGRx_CG12_OFFSET |
+			      1 << MXC_CCM_CCGRx_CG13_OFFSET |
+			      1 << MXC_CCM_CCGRx_CG14_OFFSET, MXC_CCM_CCGR0);
+	} else {
+		__raw_writel(1 << MXC_CCM_CCGRx_CG0_OFFSET |
+			      1 << MXC_CCM_CCGRx_CG1_OFFSET |
+			      1 << MXC_CCM_CCGRx_CG2_OFFSET |
+			      3 << MXC_CCM_CCGRx_CG3_OFFSET |
+			      3 << MXC_CCM_CCGRx_CG8_OFFSET |
+			      3 << MXC_CCM_CCGRx_CG9_OFFSET |
+			      1 << MXC_CCM_CCGRx_CG12_OFFSET |
+			      1 << MXC_CCM_CCGRx_CG13_OFFSET |
+			      3 << MXC_CCM_CCGRx_CG14_OFFSET, MXC_CCM_CCGR0);
+	}
+	__raw_writel(0, MXC_CCM_CCGR1);
+	__raw_writel(0, MXC_CCM_CCGR2);
+	__raw_writel(0, MXC_CCM_CCGR3);
+	__raw_writel(1 << MXC_CCM_CCGRx_CG8_OFFSET, MXC_CCM_CCGR4);
+
+	__raw_writel(1 << MXC_CCM_CCGRx_CG2_OFFSET |
+		     1 << MXC_CCM_CCGR5_CG6_1_OFFSET |
+		     1 << MXC_CCM_CCGR5_CG6_2_OFFSET |
+		     3 << MXC_CCM_CCGRx_CG7_OFFSET |
+		     1 << MXC_CCM_CCGRx_CG8_OFFSET |
+		     3 << MXC_CCM_CCGRx_CG9_OFFSET |
+		     1 << MXC_CCM_CCGRx_CG10_OFFSET |
+		     3 << MXC_CCM_CCGRx_CG11_OFFSET, MXC_CCM_CCGR5);
+
+	__raw_writel(1 << MXC_CCM_CCGRx_CG4_OFFSET, MXC_CCM_CCGR6);
+
+	external_low_reference = ckil;
+	external_high_reference = ckih1;
+	ckih2_reference = ckih2;
+	oscillator_reference = osc;
+
+	/* Fix up clocks unique to MX51. */
+	esdhc2_clk[0].get_rate = _clk_esdhc2_get_rate;
+	esdhc2_clk[0].set_rate = _clk_esdhc2_set_rate;
+
+	clk_tree_init();
+
+	for (i = 0; i < ARRAY_SIZE(lookups); i++)
+		clkdev_add(&lookups[i]);
+
+	for (i = 0; i < ARRAY_SIZE(mx51_lookups); i++)
+		clkdev_add(&mx51_lookups[i]);
+
+	max_axi_a_clk = MAX_AXI_A_CLK_MX51;
+	max_axi_b_clk = MAX_AXI_B_CLK_MX51;
+	max_ahb_clk = MAX_AHB_CLK_MX51;
+	max_emi_slow_clk = MAX_AHB_CLK_MX51;
+
+	/* set DDR clock parent */
+	reg = 0;
+	if (mx51_revision() >= IMX_CHIP_REVISION_2_0) {
+		reg = __raw_readl(MXC_CCM_CBCDR) & MXC_CCM_CBCDR_DDR_HF_SEL;
+		reg >>= MXC_CCM_CBCDR_DDR_HF_SEL_OFFSET;
+
+		if (reg)
+			tclk = &ddr_hf_clk;
+	}
+	if (reg == 0) {
+		reg = __raw_readl(MXC_CCM_CBCMR) &
+					MXC_CCM_CBCMR_DDR_CLK_SEL_MASK;
+		reg >>= MXC_CCM_CBCMR_DDR_CLK_SEL_OFFSET;
+
+		if (reg == 0) {
+			tclk = &axi_a_clk;
+		} else if (reg == 1) {
+			tclk = &axi_b_clk;
+		} else if (reg == 2) {
+			tclk = &emi_slow_clk;
+		} else {
+			tclk = &ahb_clk;
+		}
+	}
+	clk_set_parent(&ddr_clk, tclk);
+
+	/*Setup the LPM bypass bits */
+	reg = __raw_readl(MXC_CCM_CLPCR);
+	reg |= MXC_CCM_CLPCR_BYPASS_HSC_LPM_HS
+		| MXC_CCM_CLPCR_BYPASS_IPU_LPM_HS
+		| MXC_CCM_CLPCR_BYPASS_RTIC_LPM_HS
+		| MXC_CCM_CLPCR_BYPASS_SCC_LPM_HS_MX51
+		| MXC_CCM_CLPCR_BYPASS_SDMA_LPM_HS_MX51;
+	__raw_writel(reg, MXC_CCM_CLPCR);
+
+	/* Disable the handshake with HSC block as its not
+	  * initialised right now.
+	  */
+	reg = __raw_readl(MXC_CCM_CCDR);
+	reg |= MXC_CCM_CCDR_HSC_HS_MASK;
+	__raw_writel(reg, MXC_CCM_CCDR);
+
+	clk_enable(&cpu_clk);
+
+	/* Set SDHC parents to be PLL2 */
+	clk_set_parent(&esdhc1_clk[0], &pll2_sw_clk);
+	clk_set_parent(&esdhc2_clk[0], &pll2_sw_clk);
+
+	/* set SDHC root clock as 166.25MHZ*/
+	clk_set_rate(&esdhc1_clk[0], 166250000);
+	clk_set_rate(&esdhc2_clk[0], 166250000);
+
+	/* Initialise the parents to be axi_b, parents are set to
+	 * axi_a when the clocks are enabled.
+	 */
+	clk_set_parent(&vpu_clk[0], &axi_b_clk);
+	clk_set_parent(&vpu_clk[1], &axi_b_clk);
+	clk_set_parent(&gpu3d_clk, &axi_a_clk);
+	clk_set_parent(&gpu2d_clk, &axi_a_clk);
+
+	/* move cspi to 24MHz */
+	clk_set_parent(&cspi_main_clk, &lp_apm_clk);
+	clk_set_rate(&cspi_main_clk, 12000000);
+	/*move the spdif0 to spdif_xtal_ckl */
+	clk_set_parent(&spdif0_clk[0], &spdif_xtal_clk);
+	/*set the SPDIF dividers to 1 */
+	reg = __raw_readl(MXC_CCM_CDCDR);
+	reg &= ~MXC_CCM_CDCDR_SPDIF0_CLK_PODF_MASK;
+	reg &= ~MXC_CCM_CDCDR_SPDIF0_CLK_PRED_MASK;
+	__raw_writel(reg, MXC_CCM_CDCDR);
+
+	/* move the spdif1 to 24MHz */
+	clk_set_parent(&spdif1_clk[0], &spdif_xtal_clk);
+	/* set the spdif1 dividers to 1 */
+	reg = __raw_readl(MXC_CCM_CDCDR);
+	reg &= ~MXC_CCM_CDCDR_SPDIF1_CLK_PODF_MASK;
+	reg &= ~MXC_CCM_CDCDR_SPDIF1_CLK_PRED_MASK;
+	__raw_writel(reg, MXC_CCM_CDCDR);
+
+	/* Move SSI clocks to SSI_LP_APM clock */
+	clk_set_parent(&ssi_lp_apm_clk, &lp_apm_clk);
+
+	clk_set_parent(&ssi1_clk[0], &ssi_lp_apm_clk);
+	/* set the SSI dividers to divide by 2 */
+	reg = __raw_readl(MXC_CCM_CS1CDR);
+	reg &= ~MXC_CCM_CS1CDR_SSI1_CLK_PODF_MASK;
+	reg &= ~MXC_CCM_CS1CDR_SSI1_CLK_PRED_MASK;
+	reg |= 1 << MXC_CCM_CS1CDR_SSI1_CLK_PRED_OFFSET;
+	__raw_writel(reg, MXC_CCM_CS1CDR);
+
+	clk_set_parent(&ssi2_clk[0], &ssi_lp_apm_clk);
+	reg = __raw_readl(MXC_CCM_CS2CDR);
+	reg &= ~MXC_CCM_CS2CDR_SSI2_CLK_PODF_MASK;
+	reg &= ~MXC_CCM_CS2CDR_SSI2_CLK_PRED_MASK;
+	reg |= 1 << MXC_CCM_CS2CDR_SSI2_CLK_PRED_OFFSET;
+	__raw_writel(reg, MXC_CCM_CS2CDR);
+
+	/*
+	 * SSI3 has no clock divide register,
+	 * we always set SSI3 parent clock to SSI1 and freq same to SSI1
+	 */
+	clk_set_parent(&ssi3_clk[0], &ssi1_clk[0]);
+
+	/* Change the SSI_EXT1_CLK to be sourced from SSI1_CLK_ROOT */
+	clk_set_parent(&ssi_ext1_clk, &ssi1_clk[0]);
+	clk_set_parent(&ssi_ext2_clk, &ssi2_clk[0]);
+
+	/* move usb_phy_clk to 24MHz */
+	clk_set_parent(&usb_phy_clk[0], &osc_clk);
+
+	/* set usboh3_clk to pll2 */
+	clk_set_parent(&usboh3_clk[0], &pll2_sw_clk);
+	reg = __raw_readl(MXC_CCM_CSCDR1);
+	reg &= ~MXC_CCM_CSCDR1_USBOH3_CLK_PODF_MASK;
+	reg &= ~MXC_CCM_CSCDR1_USBOH3_CLK_PRED_MASK;
+	reg |= 4 << MXC_CCM_CSCDR1_USBOH3_CLK_PRED_OFFSET;
+	reg |= 1 << MXC_CCM_CSCDR1_USBOH3_CLK_PODF_OFFSET;
+	__raw_writel(reg, MXC_CCM_CSCDR1);
+
+	mx51_cpu_op_init();
+	/* Set the current working point. */
+	cpu_op_tbl = get_cpu_op(&cpu_op_nr);
+	/* Update the cpu working point table based on the PLL1 freq
+	 * at boot time
+	 */
+	pll1_rate = clk_get_rate(&pll1_main_clk);
+	if (pll1_rate <= cpu_op_tbl[cpu_op_nr - 1].cpu_rate)
+		op_cnt = 1;
+	else if (pll1_rate <= cpu_op_tbl[1].cpu_rate &&
+				pll1_rate > cpu_op_tbl[2].cpu_rate)
+		op_cnt = cpu_op_nr - 1;
+	else
+		op_cnt = cpu_op_nr;
+
+	cpu_op_tbl[0].cpu_rate = pll1_rate;
+
+	if (op_cnt == 1) {
+		cpu_op_tbl[0] = cpu_op_tbl[cpu_op_nr - 1];
+		memset(&cpu_op_tbl[cpu_op_nr - 1], 0, sizeof(struct cpu_op));
+		memset(&cpu_op_tbl[cpu_op_nr - 2], 0, sizeof(struct cpu_op));
+	} else if (op_cnt < cpu_op_nr) {
+		for (i = 0; i < op_cnt; i++)
+			cpu_op_tbl[i] = cpu_op_tbl[i+1];
+		memset(&cpu_op_tbl[i], 0, sizeof(struct cpu_op));
+	}
+
+	if (op_cnt < cpu_op_nr) {
+		set_num_cpu_op(op_cnt);
+		cpu_op_tbl = get_cpu_op(&cpu_op_nr);
+	}
+
+	pll1_rate = clk_get_rate(&pll1_main_clk);
+	for (j = 0; j < cpu_op_nr; j++) {
+		if ((ddr_clk.parent == &ddr_hf_clk)) {
+			/* Change the CPU podf divider based on the boot up
+			 * pll1 rate.
+			 */
+			cpu_op_tbl[j].cpu_podf =
+				(pll1_rate / cpu_op_tbl[j].cpu_rate)
+				- 1;
+			if (pll1_rate / (cpu_op_tbl[j].cpu_podf + 1) >
+					cpu_op_tbl[j].cpu_rate) {
+				cpu_op_tbl[j].cpu_podf++;
+				cpu_op_tbl[j].cpu_rate =
+					 pll1_rate /
+					 (1000 * (cpu_op_tbl[j].cpu_podf + 1));
+				cpu_op_tbl[j].cpu_rate *= 1000;
+			}
+			if (pll1_rate / (cpu_op_tbl[j].cpu_podf + 1) <
+						cpu_op_tbl[j].cpu_rate) {
+				cpu_op_tbl[j].cpu_rate = pll1_rate;
+			}
+		}
+	cpu_op_tbl[j].pll_rate = pll1_rate;
+	}
+	/* Set the current working point. */
+	for (i = 0; i < cpu_op_nr; i++) {
+		if (clk_get_rate(&cpu_clk) == cpu_op_tbl[i].cpu_rate) {
+			cpu_curr_op = i;
+			break;
+		}
+	}
+	if (i > cpu_op_nr)
+		BUG();
+
+	clk_set_parent(&arm_axi_clk, &axi_a_clk);
+	clk_set_parent(&ipu_clk[0], &axi_b_clk);
+
+	if (uart_at_24) {
+		/* Move UART to run from lp_apm */
+		clk_set_parent(&uart_main_clk, &lp_apm_clk);
+
+		/* Set the UART dividers to divide, so the UART_CLK is 24MHz. */
+		reg = __raw_readl(MXC_CCM_CSCDR1);
+		reg &= ~MXC_CCM_CSCDR1_UART_CLK_PODF_MASK;
+		reg &= ~MXC_CCM_CSCDR1_UART_CLK_PRED_MASK;
+		reg |= (0 << MXC_CCM_CSCDR1_UART_CLK_PRED_OFFSET) |
+		    (0 << MXC_CCM_CSCDR1_UART_CLK_PODF_OFFSET);
+		__raw_writel(reg, MXC_CCM_CSCDR1);
+	} else {
+		clk_set_parent(&uart_main_clk, &pll2_sw_clk);
+
+		/* Set the UART dividers to divide, so the UART_CLK is 66.5MHz. */
+		reg = __raw_readl(MXC_CCM_CSCDR1);
+		reg &= ~MXC_CCM_CSCDR1_UART_CLK_PODF_MASK;
+		reg &= ~MXC_CCM_CSCDR1_UART_CLK_PRED_MASK;
+		reg |= (4 << MXC_CCM_CSCDR1_UART_CLK_PRED_OFFSET) |
+		    (1 << MXC_CCM_CSCDR1_UART_CLK_PODF_OFFSET);
+		__raw_writel(reg, MXC_CCM_CSCDR1);
+	}
+
+	clk_set_parent(&emi_slow_clk, &ahb_clk);
+	clk_set_rate(&emi_slow_clk, clk_round_rate(&emi_slow_clk, 130000000));
+
+	/* Change the NFC clock rate to be 1:4 ratio with emi clock. */
+	clk_set_rate(&emi_enfc_clk, clk_round_rate(&emi_enfc_clk,
+			(clk_get_rate(&emi_slow_clk))/4));
+
+	/* System timer */
+	mxc_timer_init(&gpt_clk[0], MX51_IO_ADDRESS(MX51_GPT1_BASE_ADDR),
+		MX51_MXC_INT_GPT);
+
+	return 0;
+}
+
+int __init mx53_clocks_init(unsigned long ckil, unsigned long osc, unsigned long ckih1, unsigned long ckih2)
+{
+	__iomem void *base;
+	struct clk *tclk;
+	int i = 0, j = 0, reg;
+	u32 pll1_rate;
+
+	pll1_base = MX53_DPLL1_BASE;
+	pll2_base = MX53_DPLL2_BASE;
+	pll3_base = MX53_DPLL3_BASE;
+	pll4_base = MX53_DPLL4_BASE;
+
+	/* Turn off all possible clocks */
+	if (mxc_jtag_enabled) {
+		__raw_writel(1 << MXC_CCM_CCGRx_CG0_OFFSET |
+			      1 << MXC_CCM_CCGRx_CG1_OFFSET |
+			      1 << MXC_CCM_CCGRx_CG2_OFFSET |
+			      3 << MXC_CCM_CCGRx_CG3_OFFSET |
+			      3 << MXC_CCM_CCGRx_CG4_OFFSET |
+			      3 << MXC_CCM_CCGRx_CG8_OFFSET |
+			      3 << MXC_CCM_CCGRx_CG9_OFFSET |
+			      1 << MXC_CCM_CCGRx_CG12_OFFSET |
+			      1 << MXC_CCM_CCGRx_CG13_OFFSET |
+			      1 << MXC_CCM_CCGRx_CG14_OFFSET, MXC_CCM_CCGR0);
+	} else {
+		__raw_writel(1 << MXC_CCM_CCGRx_CG0_OFFSET |
+			      1 << MXC_CCM_CCGRx_CG1_OFFSET |
+			      3 << MXC_CCM_CCGRx_CG3_OFFSET |
+			      3 << MXC_CCM_CCGRx_CG8_OFFSET |
+			      3 << MXC_CCM_CCGRx_CG9_OFFSET |
+			      1 << MXC_CCM_CCGRx_CG12_OFFSET |
+			      1 << MXC_CCM_CCGRx_CG13_OFFSET |
+			      3 << MXC_CCM_CCGRx_CG14_OFFSET, MXC_CCM_CCGR0);
+	}
+
+	__raw_writel(0, MXC_CCM_CCGR1);
+	__raw_writel(0, MXC_CCM_CCGR2);
+	__raw_writel(0, MXC_CCM_CCGR3);
+	__raw_writel(1 << MXC_CCM_CCGRx_CG8_OFFSET, MXC_CCM_CCGR4);
+
+	__raw_writel(1 << MXC_CCM_CCGRx_CG2_OFFSET |
+		     1 << MXC_CCM_CCGRx_CG6_OFFSET |
+		     3 << MXC_CCM_CCGRx_CG7_OFFSET |
+		     1 << MXC_CCM_CCGRx_CG8_OFFSET |
+		     1 << MXC_CCM_CCGRx_CG9_OFFSET |
+		     3 << MXC_CCM_CCGRx_CG11_OFFSET, MXC_CCM_CCGR5);
+
+	__raw_writel(1 << MXC_CCM_CCGRx_CG0_OFFSET |
+				3 << MXC_CCM_CCGRx_CG1_OFFSET |
+				1 << MXC_CCM_CCGRx_CG4_OFFSET |
+				3 << MXC_CCM_CCGRx_CG12_OFFSET |
+				3 << MXC_CCM_CCGRx_CG13_OFFSET , MXC_CCM_CCGR6);
+
+	__raw_writel(0, MXC_CCM_CCGR7);
+
+	external_low_reference = ckil;
+	external_high_reference = ckih1;
+	ckih2_reference = ckih2;
+	oscillator_reference = osc;
+
+	usb_phy_clk[0].enable_reg = MXC_CCM_CCGR4;
+	usb_phy_clk[0].enable_shift = MXC_CCM_CCGRx_CG5_OFFSET;
+
+	ipumux1_clk.enable_reg = MXC_CCM_CCGR5;
+	ipumux1_clk.enable_shift = MXC_CCM_CCGRx_CG6_OFFSET;
+	ipumux2_clk.enable_reg = MXC_CCM_CCGR6;
+	ipumux2_clk.enable_shift = MXC_CCM_CCGRx_CG0_OFFSET;
+
+	esdhc3_clk[0].get_rate = _clk_esdhc3_get_rate;
+	esdhc3_clk[0].set_rate = _clk_sdhc3_set_rate;
+
+#if defined(CONFIG_USB_STATIC_IRAM) \
+    || defined(CONFIG_USB_STATIC_IRAM_PPH)
+	usboh3_clk[1].secondary = &emi_intr_clk[1];
+#endif
+#ifdef CONFIG_SND_MXC_SOC_IRAM
+	ssi2_clk[2].secondary = &emi_intr_clk[1];
+	ssi1_clk[2].secondary = &emi_intr_clk[1];
+#endif
+#ifdef CONFIG_SDMA_IRAM
+	sdma_clk[1].secondary = &emi_intr_clk[1];
+#endif
+
+	clk_tree_init();
+
+	for (i = 0; i < ARRAY_SIZE(lookups); i++)
+		clkdev_add(&lookups[i]);
+
+	for (i = 0; i < ARRAY_SIZE(mx53_lookups); i++)
+		clkdev_add(&mx53_lookups[i]);
+
+	clk_set_parent(&esai_clk[0], &ckih_clk);
+
+	ldb_di_clk[0].parent = ldb_di_clk[1].parent =
+	tve_clk.parent = &pll4_sw_clk;
+
+	max_axi_a_clk = MAX_AXI_A_CLK_MX53;
+	max_axi_b_clk = MAX_AXI_B_CLK_MX53;
+	max_ahb_clk = MAX_AHB_CLK_MX53;
+	max_emi_slow_clk = MAX_AHB_CLK_MX53;
+
+
+	/* set DDR clock parent */
+	reg = __raw_readl(MXC_CCM_CBCMR) &
+				MXC_CCM_CBCMR_DDR_CLK_SEL_MASK;
+	reg >>= MXC_CCM_CBCMR_DDR_CLK_SEL_OFFSET;
+	if (reg == 0) {
+		tclk = &axi_a_clk;
+	} else if (reg == 1) {
+		tclk = &axi_b_clk;
+	} else if (reg == 2) {
+		tclk = &emi_slow_clk;
+	} else {
+		tclk = &ahb_clk;
+	}
+	clk_set_parent(&ddr_clk, tclk);
+
+	clk_set_parent(&esdhc1_clk[2], &tmax2_clk);
+	clk_set_parent(&esdhc2_clk[0], &esdhc1_clk[0]);
+	clk_set_parent(&esdhc3_clk[0], &pll2_sw_clk);
+
+	clk_set_parent(&ipu_di_clk[0], &pll4_sw_clk);
+
+#if 0
+	/*Setup the LPM bypass bits */
+	reg = __raw_readl(MXC_CCM_CLPCR);
+	reg |= MXC_CCM_CLPCR_BYPASS_IPU_LPM_HS
+		| MXC_CCM_CLPCR_BYPASS_RTIC_LPM_HS
+		| MXC_CCM_CLPCR_BYPASS_SCC_LPM_HS
+		| MXC_CCM_CLPCR_BYPASS_SDMA_LPM_HS;
+	__raw_writel(reg, MXC_CCM_CLPCR);
+#endif
+
+	clk_enable(&cpu_clk);
+
+	clk_enable(&main_bus_clk);
+
+	/* Set AXI_B_CLK to be 200MHz */
+	clk_set_rate(&axi_b_clk, 200000000);
+
+	/* Initialise the parents to be axi_b, parents are set to
+	 * axi_a when the clocks are enabled.
+	 */
+
+	clk_set_parent(&vpu_clk[0], &axi_b_clk);
+	clk_set_parent(&vpu_clk[1], &axi_b_clk);
+
+	/* move cspi to 24MHz */
+	clk_set_parent(&cspi_main_clk, &lp_apm_clk);
+	clk_set_rate(&cspi_main_clk, 12000000);
+	/*move the spdif0 to spdif_xtal_ckl */
+	clk_set_parent(&spdif0_clk[0], &spdif_xtal_clk);
+	/*set the SPDIF dividers to 1 */
+	reg = __raw_readl(MXC_CCM_CDCDR);
+	reg &= ~MXC_CCM_CDCDR_SPDIF0_CLK_PODF_MASK;
+	reg &= ~MXC_CCM_CDCDR_SPDIF0_CLK_PRED_MASK;
+	__raw_writel(reg, MXC_CCM_CDCDR);
+
+	/* Move SSI clocks to SSI_LP_APM clock */
+	clk_set_parent(&ssi_lp_apm_clk, &lp_apm_clk);
+
+	clk_set_parent(&ssi1_clk[0], &ssi_lp_apm_clk);
+	/* set the SSI dividers to divide by 2 */
+	reg = __raw_readl(MXC_CCM_CS1CDR);
+	reg &= ~MXC_CCM_CS1CDR_SSI1_CLK_PODF_MASK;
+	reg &= ~MXC_CCM_CS1CDR_SSI1_CLK_PRED_MASK;
+	reg |= 1 << MXC_CCM_CS1CDR_SSI1_CLK_PRED_OFFSET;
+	__raw_writel(reg, MXC_CCM_CS1CDR);
+
+	clk_set_parent(&ssi2_clk[0], &ssi_lp_apm_clk);
+	reg = __raw_readl(MXC_CCM_CS2CDR);
+	reg &= ~MXC_CCM_CS2CDR_SSI2_CLK_PODF_MASK;
+	reg &= ~MXC_CCM_CS2CDR_SSI2_CLK_PRED_MASK;
+	reg |= 1 << MXC_CCM_CS2CDR_SSI2_CLK_PRED_OFFSET;
+	__raw_writel(reg, MXC_CCM_CS2CDR);
+
+	/* Change the SSI_EXT1_CLK to be sourced from PLL2 for camera */
+	clk_enable(&ssi_ext1_clk);
+	clk_disable(&ssi_ext1_clk);
+	clk_set_parent(&ssi_ext1_clk, &pll2_sw_clk);
+	clk_set_rate(&ssi_ext1_clk, 24000000);
+	clk_set_parent(&ssi_ext2_clk, &ssi2_clk[0]);
+
+	/* move usb_phy_clk to 24MHz */
+	clk_set_parent(&usb_phy_clk[0], &osc_clk);
+	clk_set_parent(&usb_phy_clk[1], &osc_clk);
+
+	/* set usboh3_clk to pll2 */
+	clk_set_parent(&usboh3_clk[0], &pll2_sw_clk);
+	reg = __raw_readl(MXC_CCM_CSCDR1);
+	reg &= ~MXC_CCM_CSCDR1_USBOH3_CLK_PODF_MASK;
+	reg &= ~MXC_CCM_CSCDR1_USBOH3_CLK_PRED_MASK;
+	reg |= 4 << MXC_CCM_CSCDR1_USBOH3_CLK_PRED_OFFSET;
+	reg |= 1 << MXC_CCM_CSCDR1_USBOH3_CLK_PODF_OFFSET;
+	__raw_writel(reg, MXC_CCM_CSCDR1);
+
+	/* set SDHC root clock as 200MHZ*/
+	clk_set_rate(&esdhc1_clk[0], 200000000);
+	clk_set_rate(&esdhc3_clk[0], 200000000);
+
+	 /* Set the 1588 RTC input clocks as 108MHZ */
+	clk_set_parent(&ieee_rtc_clk, &pll3_sw_clk);
+	clk_set_rate(&ieee_rtc_clk, 108000000);
+
+	/* The CPU working point should be set according to part number
+	 * information. But part number information is not clear now.
+	 * So update the cpu working point table based on the PLL1 freq
+	 * at boot time
+	 */
+	pll1_rate = clk_get_rate(&pll1_main_clk);
+
+	if (pll1_rate > 1000000000)
+		mx53_set_cpu_part_number(IMX53_CEC_1_2G);
+	else if (pll1_rate > 800000000)
+		mx53_set_cpu_part_number(IMX53_CEC);
+	else
+		mx53_set_cpu_part_number(IMX53_AEC);
+
+	/* Set the current working point. */
+	cpu_op_tbl = get_cpu_op(&cpu_op_nr);
+	for (i = 0; i < cpu_op_nr; i++) {
+		if (clk_get_rate(&cpu_clk) == cpu_op_tbl[i].cpu_rate) {
+			cpu_curr_op = i;
+			break;
+		}
+	}
+	if (i > cpu_op_nr)
+		BUG();
+
+	clk_set_parent(&arm_axi_clk, &axi_b_clk);
+	clk_set_parent(&ipu_clk[0], &axi_b_clk);
+	clk_set_parent(&uart_main_clk, &pll3_sw_clk);
+	clk_set_parent(&gpu3d_clk, &axi_b_clk);
+	clk_set_parent(&gpu2d_clk, &axi_b_clk);
+
+	clk_set_parent(&emi_slow_clk, &ahb_clk);
+	clk_set_rate(&emi_slow_clk, clk_round_rate(&emi_slow_clk, 133333333));
+
+	clk_set_rate(&emi_enfc_clk, clk_round_rate(&emi_enfc_clk,
+			MAX_NFC_CLK));
+
+	/* set the freq of asrc_serial_clk */
+	clk_set_rate(&asrc_clk[0], clk_round_rate(&asrc_clk[0],
+			1190000));
+
+	/* System timer */
+	mxc_timer_init(&gpt_clk[0], MX53_IO_ADDRESS(MX53_GPT1_BASE_ADDR),
+		MX53_INT_GPT);
+	return 0;
+}
+
+/*!
+ * Setup cpu clock based on working point.
+ * @param	op	cpu freq working point
+ * @return		0 on success or error code on failure.
+ */
+static int cpu_clk_set_op(int op)
+{
+	struct cpu_op *p;
+	u32 reg, pll_hfsm;
+	u32 stat;
+
+	if (op == cpu_curr_op)
+		return 0;
+
+	p = &cpu_op_tbl[op];
+
+	/*
+	 * If DDR clock is sourced from PLL1, we cannot drop PLL1 freq.
+	 * Use the ARM_PODF to change the freq of the core, leave the PLL1
+	 * freq unchanged. Meanwhile, if pll_rate is same, use the ARM_PODF
+	 * to change the freq of core
+	 */
+	if ((ddr_clk.parent == &ddr_hf_clk) ||
+		(p->pll_rate == cpu_op_tbl[cpu_curr_op].pll_rate)) {
+		reg = __raw_readl(MXC_CCM_CACRR);
+		reg &= ~MXC_CCM_CACRR_ARM_PODF_MASK;
+		reg |= cpu_op_tbl[op].cpu_podf << MXC_CCM_CACRR_ARM_PODF_OFFSET;
+		__raw_writel(reg, MXC_CCM_CACRR);
+		cpu_curr_op = op;
+	} else {
+		struct timespec nstimeofday;
+		struct timespec curtime;
+
+		/* Change the ARM clock to requested frequency */
+		/* First move the ARM clock to step clock which is running
+		 * at 24MHz.
+		 */
+
+		/* Change the source of pll1_sw_clk to be the step_clk */
+		reg = __raw_readl(MXC_CCM_CCSR);
+		reg |= MXC_CCM_CCSR_PLL1_SW_CLK_SEL;
+		__raw_writel(reg, MXC_CCM_CCSR);
+
+		/* Stop the PLL */
+		reg = __raw_readl(pll1_base + MXC_PLL_DP_CTL);
+		reg &= ~MXC_PLL_DP_CTL_UPEN;
+		__raw_writel(reg, pll1_base + MXC_PLL_DP_CTL);
+
+		reg = __raw_readl(MXC_CCM_CACRR);
+		reg = (reg & ~MXC_CCM_CACRR_ARM_PODF_MASK)
+			| p->cpu_podf;
+		__raw_writel(reg, MXC_CCM_CACRR);
+
+		reg = __raw_readl(pll1_base + MXC_PLL_DP_CTL);
+		pll_hfsm = reg & MXC_PLL_DP_CTL_HFSM;
+		/* PDF and MFI */
+		reg = p->pdf | p->mfi << MXC_PLL_DP_OP_MFI_OFFSET;
+		if (pll_hfsm == 0) {
+			__raw_writel(reg, pll1_base + MXC_PLL_DP_OP);
+			__raw_writel(p->mfd, pll1_base + MXC_PLL_DP_MFD);
+			__raw_writel(p->mfn, pll1_base + MXC_PLL_DP_MFN);
+		} else {
+			__raw_writel(reg, pll1_base + MXC_PLL_DP_HFS_OP);
+			__raw_writel(p->mfd, pll1_base + MXC_PLL_DP_HFS_MFD);
+			__raw_writel(p->mfn, pll1_base + MXC_PLL_DP_HFS_MFN);
+		}
+
+		reg = __raw_readl(pll1_base + MXC_PLL_DP_CTL);
+		reg |= MXC_PLL_DP_CTL_UPEN;
+		/* Set the UPEN bits */
+		__raw_writel(reg, pll1_base + MXC_PLL_DP_CTL);
+		/* Forcefully restart the PLL */
+		reg |= MXC_PLL_DP_CTL_RST;
+		__raw_writel(reg, pll1_base + MXC_PLL_DP_CTL);
+
+		/* Wait for the PLL to lock */
+		getnstimeofday(&nstimeofday);
+		do {
+			getnstimeofday(&curtime);
+			if ((curtime.tv_nsec - nstimeofday.tv_nsec) > SPIN_DELAY)
+				panic("pll1 relock failed\n");
+			stat = __raw_readl(pll1_base + MXC_PLL_DP_CTL) &
+			    MXC_PLL_DP_CTL_LRF;
+		} while (!stat);
+
+		reg = __raw_readl(MXC_CCM_CCSR);
+		/* Move the PLL1 back to the pll1_main_clk */
+		reg &= ~MXC_CCM_CCSR_PLL1_SW_CLK_SEL;
+		__raw_writel(reg, MXC_CCM_CCSR);
+
+		cpu_curr_op = op;
+	}
+
+#if defined(CONFIG_CPU_FREQ)
+	cpufreq_trig_needed = 1;
+#endif
+	return 0;
+}
diff --git a/arch/arm/mach-mx5/cpu.c b/arch/arm/mach-mx5/cpu.c
old mode 100644
new mode 100755
index 86f87da..39ce625
--- a/arch/arm/mach-mx5/cpu.c
+++ b/arch/arm/mach-mx5/cpu.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008-2011 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * The code contained herein is licensed under the GNU General Public
  * License. You may obtain a copy of the GNU General Public License
@@ -14,11 +14,29 @@
 #include <linux/types.h>
 #include <linux/kernel.h>
 #include <linux/init.h>
+#include <linux/clk.h>
 #include <linux/module.h>
+#include <linux/iram_alloc.h>
 #include <mach/hardware.h>
 #include <asm/io.h>
 
+#define CORTEXA8_PLAT_AMC       0x18
+#define SRPG_NEON_PUPSCR        0x284
+#define SRPG_NEON_PDNSCR        0x288
+#define SRPG_ARM_PUPSCR         0x2A4
+#define SRPG_ARM_PDNSCR         0x2A8
+#define SRPG_EMPGC0_PUPSCR      0x2E4
+#define SRPG_EMPGC0_PDNSCR      0x2E8
+#define SRPG_EMPGC1_PUPSCR      0x304
+#define SRPG_EMPGC1_PDNSCR      0x308
+
+void __iomem *arm_plat_base;
+void __iomem *gpc_base;
+void __iomem *ccm_base;
+void __iomem *databahn_base;
+
 static int cpu_silicon_rev = -1;
+void (*set_num_cpu_op)(int num);
 
 #define IIM_SREV 0x24
 #define MX50_HW_ADADIG_DIGPROG	0xB0
@@ -193,12 +211,16 @@ static int __init post_cpu_init(void)
 {
 	unsigned int reg;
 	void __iomem *base;
+	struct clk *gpcclk = clk_get(NULL, "gpc_dvfs_clk");
 
 	if (cpu_is_mx51() || cpu_is_mx53()) {
-		if (cpu_is_mx51())
+		if (cpu_is_mx51()) {
 			base = MX51_IO_ADDRESS(MX51_AIPS1_BASE_ADDR);
-		else
+			iram_init(MX51_IRAM_BASE_ADDR, MX51_IRAM_SIZE);
+		} else {
 			base = MX53_IO_ADDRESS(MX53_AIPS1_BASE_ADDR);
+			iram_init(MX53_IRAM_BASE_ADDR, MX53_IRAM_SIZE);
+		}
 
 		__raw_writel(0x0, base + 0x40);
 		__raw_writel(0x0, base + 0x44);
@@ -219,6 +241,31 @@ static int __init post_cpu_init(void)
 		reg = __raw_readl(base + 0x50) & 0x00FFFFFF;
 		__raw_writel(reg, base + 0x50);
 	}
+	gpc_base = MX53_IO_ADDRESS(MX53_GPC_BASE_ADDR);
+	ccm_base = MX53_IO_ADDRESS(MX53_CCM_BASE_ADDR);
+
+	clk_enable(gpcclk);
+
+	/* Setup the number of clock cycles to wait for SRPG
+	* power up and power down requests.
+	*/
+	__raw_writel(0x010F0201, gpc_base + SRPG_ARM_PUPSCR);
+	__raw_writel(0x010F0201, gpc_base + SRPG_NEON_PUPSCR);
+	__raw_writel(0x00000008, gpc_base + SRPG_EMPGC0_PUPSCR);
+	__raw_writel(0x00000008, gpc_base + SRPG_EMPGC1_PUPSCR);
+
+	__raw_writel(0x01010101, gpc_base + SRPG_ARM_PDNSCR);
+	__raw_writel(0x01010101, gpc_base + SRPG_NEON_PDNSCR);
+	__raw_writel(0x00000018, gpc_base + SRPG_EMPGC0_PDNSCR);
+	__raw_writel(0x00000018, gpc_base + SRPG_EMPGC1_PDNSCR);
+
+	clk_disable(gpcclk);
+	clk_put(gpcclk);
+
+	/* Set ALP bits to 000. Set ALP_EN bit in Arm Memory Controller reg. */
+	arm_plat_base = MX53_IO_ADDRESS(MX53_ARM_BASE_ADDR);
+		reg = 0x8;
+	__raw_writel(reg, arm_plat_base + CORTEXA8_PLAT_AMC);
 
 	return 0;
 }
diff --git a/arch/arm/mach-mx5/cpu_op-mx51.c b/arch/arm/mach-mx5/cpu_op-mx51.c
old mode 100644
new mode 100755
index 9d34c3d..c721a47
--- a/arch/arm/mach-mx5/cpu_op-mx51.c
+++ b/arch/arm/mach-mx5/cpu_op-mx51.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2010-2011 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -15,15 +15,55 @@
 #include <mach/hardware.h>
 #include <linux/kernel.h>
 
+extern struct cpu_op *(*get_cpu_op)(int *op);
+extern void (*set_num_cpu_op)(int num);
+static int num_cpu_op;
+
+/* working point(wp): 0 - 800MHz; 1 - 166.25MHz; */
 static struct cpu_op mx51_cpu_op[] = {
 	{
-	.cpu_rate = 160000000,},
+	 .pll_rate = 1000000000,
+	 .cpu_rate = 1000000000,
+	 .pdf = 0,
+	 .mfi = 10,
+	 .mfd = 11,
+	 .mfn = 5,
+	 .cpu_podf = 0,
+	 .cpu_voltage = 1175000,},
+	{
+	 .pll_rate = 800000000,
+	 .cpu_rate = 800000000,
+	 .pdf = 0,
+	 .mfi = 8,
+	 .mfd = 2,
+	 .mfn = 1,
+	 .cpu_podf = 0,
+	 .cpu_voltage = 1100000,
+	},
 	{
-	.cpu_rate = 800000000,},
+	 .pll_rate = 800000000,
+	 .cpu_rate = 166250000,
+	 .cpu_podf = 4,
+	 .cpu_voltage = 850000,
+	},
 };
 
 struct cpu_op *mx51_get_cpu_op(int *op)
 {
-	*op = ARRAY_SIZE(mx51_cpu_op);
+	*op = num_cpu_op;
 	return mx51_cpu_op;
 }
+
+void mx51_set_num_cpu_op(int num)
+{
+	num_cpu_op = num;
+	return;
+}
+
+void mx51_cpu_op_init()
+{
+	get_cpu_op = mx51_get_cpu_op;
+	set_num_cpu_op = mx51_set_num_cpu_op;
+
+	num_cpu_op = ARRAY_SIZE(mx51_cpu_op);
+}
diff --git a/arch/arm/mach-mx5/cpu_op-mx51.h b/arch/arm/mach-mx5/cpu_op-mx51.h
old mode 100644
new mode 100755
index 97477fe..df10b7d
--- a/arch/arm/mach-mx5/cpu_op-mx51.h
+++ b/arch/arm/mach-mx5/cpu_op-mx51.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2010-2011 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -11,4 +11,4 @@
  * http://www.gnu.org/copyleft/gpl.html
  */
 
-extern struct cpu_op *mx51_get_cpu_op(int *op);
+extern void mx51_cpu_op_init(void);
diff --git a/arch/arm/mach-mx5/cpu_op-mx53.c b/arch/arm/mach-mx5/cpu_op-mx53.c
new file mode 100755
index 0000000..a0d0700
--- /dev/null
+++ b/arch/arm/mach-mx5/cpu_op-mx53.c
@@ -0,0 +1,159 @@
+/*
+ * Copyright (C) 2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <mach/hardware.h>
+#include "cpu_op-mx53.h"
+
+/*!
+ * @file mach-mx5/cpu_op-mx53.c
+ *
+ * @brief This file contains the information about MX53 CPU working points.
+ *
+ * @ingroup MSL_MX53
+ */
+extern struct cpu_op *(*get_cpu_op)(int *op);
+extern void (*set_num_cpu_op)(int num);
+static int num_cpu_op;
+static struct cpu_op *cpu_op_table;
+
+/* working point for auto*/
+static struct cpu_op cpu_op_aec[] = {
+	{
+	 .pll_rate = 800000000,
+	 .cpu_rate = 800000000,
+	 .pdf = 0,
+	 .mfi = 8,
+	 .mfd = 2,
+	 .mfn = 1,
+	 .cpu_podf = 0,
+	 .cpu_voltage = 1050000,},
+};
+
+/* working point for consumer 1G*/
+static struct cpu_op cpu_op_ces[] = {
+	{
+	 .pll_rate = 1000000000,
+	 .cpu_rate = 1000000000,
+	 .pdf = 0,
+	 .mfi = 10,
+	 .mfd = 11,
+	 .mfn = 5,
+	 .cpu_podf = 0,
+	 .cpu_voltage = 1200000,},
+	{
+	 .pll_rate = 800000000,
+	 .cpu_rate = 800000000,
+	 .pdf = 0,
+	 .mfi = 8,
+	 .mfd = 2,
+	 .mfn = 1,
+	 .cpu_podf = 0,
+	 .cpu_voltage = 1050000,},
+	 {
+	  .pll_rate = 800000000,
+	  .cpu_rate = 400000000,
+	  .cpu_podf = 1,
+	  .cpu_voltage = 950000,},
+	{
+	 .pll_rate = 800000000,
+	 .cpu_rate = 160000000,
+	 .cpu_podf = 4,
+	 .cpu_voltage = 900000,},
+};
+
+/* working point for consumer 1.2G*/
+static struct cpu_op cpu_op_ces_1_2g[] = {
+	{
+	 .pll_rate = 1200000000,
+	 .cpu_rate = 1200000000,
+	 .pdf = 0,
+	 .mfi = 12,
+	 .mfd = 1,
+	 .mfn = 1,
+	 .cpu_podf = 0,
+	 .cpu_voltage = 1300000,},
+	{
+	 .pll_rate = 1000000000,
+	 .cpu_rate = 1000000000,
+	 .pdf = 0,
+	 .mfi = 10,
+	 .mfd = 11,
+	 .mfn = 5,
+	 .cpu_podf = 0,
+	 .cpu_voltage = 1200000,},
+	{
+	 .pll_rate = 800000000,
+	 .cpu_rate = 800000000,
+	 .pdf = 0,
+	 .mfi = 8,
+	 .mfd = 2,
+	 .mfn = 1,
+	 .cpu_podf = 0,
+	 .cpu_voltage = 1050000,},
+	 {
+	  .pll_rate = 800000000,
+	  .cpu_rate = 400000000,
+	  .cpu_podf = 1,
+	  .cpu_voltage = 950000,},
+	{
+	 .pll_rate = 800000000,
+	 .cpu_rate = 160000000,
+	 .cpu_podf = 4,
+	 .cpu_voltage = 900000,},
+};
+
+
+struct cpu_op *mx53_get_cpu_op(int *op)
+{
+	*op = num_cpu_op;
+	return cpu_op_table;
+}
+
+void mx53_set_num_cpu_op(int num)
+{
+	num_cpu_op = num;
+	return;
+}
+
+void mx53_set_cpu_part_number(enum mx53_cpu_part_number part_num)
+{
+	get_cpu_op = mx53_get_cpu_op;
+	set_num_cpu_op = mx53_set_num_cpu_op;
+
+	switch (part_num) {
+	case IMX53_CEC_1_2G:
+		cpu_op_table = cpu_op_ces_1_2g;
+		num_cpu_op = ARRAY_SIZE(cpu_op_ces_1_2g);
+		break;
+	case IMX53_CEC:
+		cpu_op_table = cpu_op_ces;
+		num_cpu_op = ARRAY_SIZE(cpu_op_ces);
+		break;
+	case IMX53_AEC:
+	default:
+		cpu_op_table = cpu_op_aec;
+		num_cpu_op = ARRAY_SIZE(cpu_op_aec);
+		break;
+	}
+}
+
+
diff --git a/arch/arm/mach-mx5/cpu_op-mx53.h b/arch/arm/mach-mx5/cpu_op-mx53.h
new file mode 100755
index 0000000..5bd8f4f
--- /dev/null
+++ b/arch/arm/mach-mx5/cpu_op-mx53.h
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef __ARCH_ARM_MACH_MX53_WP_H__
+#define  __ARCH_ARM_MACH_MX53_WP_H__
+#include <linux/types.h>
+
+/*!
+ * @file mach-mx5/cpu_op-mx53.h
+ *
+ * @brief This file contains the information about MX53 CPU working points.
+ *
+ * @ingroup MSL_MX53
+ */
+enum mx53_cpu_part_number {
+  IMX53_AEC,  /* automative and infotainment AP */
+  IMX53_CEC,  /* Consumer AP, CPU freq is up to 1G */
+  IMX53_CEC_1_2G, /* Consumer AP, CPU freq is up to 1.2GHZ */
+};
+
+void mx53_set_cpu_part_number(enum mx53_cpu_part_number part_num);
+
+#endif /*__ARCH_ARM_MACH_MX53_WP_H__ */
+
+
+
diff --git a/arch/arm/mach-mx5/crm_regs.h b/arch/arm/mach-mx5/crm_regs.h
old mode 100644
new mode 100755
index 87c0c58..de45ff1
--- a/arch/arm/mach-mx5/crm_regs.h
+++ b/arch/arm/mach-mx5/crm_regs.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008-2011 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * The code contained herein is licensed under the GNU General Public
  * License. You may obtain a copy of the GNU General Public License
@@ -11,19 +11,16 @@
 #ifndef __ARCH_ARM_MACH_MX51_CRM_REGS_H__
 #define __ARCH_ARM_MACH_MX51_CRM_REGS_H__
 
-#define MX51_CCM_BASE		MX51_IO_ADDRESS(MX51_CCM_BASE_ADDR)
+#define MXC_CCM_BASE	MX51_IO_ADDRESS(MX51_CCM_BASE_ADDR)
+
 #define MX51_DPLL1_BASE		MX51_IO_ADDRESS(MX51_PLL1_BASE_ADDR)
 #define MX51_DPLL2_BASE		MX51_IO_ADDRESS(MX51_PLL2_BASE_ADDR)
 #define MX51_DPLL3_BASE		MX51_IO_ADDRESS(MX51_PLL3_BASE_ADDR)
-#define MX51_CORTEXA8_BASE	MX51_IO_ADDRESS(MX51_ARM_BASE_ADDR)
-#define MX51_GPC_BASE		MX51_IO_ADDRESS(MX51_GPC_BASE_ADDR)
 
-/*MX53*/
-#define MX53_CCM_BASE		MX53_IO_ADDRESS(MX53_CCM_BASE_ADDR)
 #define MX53_DPLL1_BASE		MX53_IO_ADDRESS(MX53_PLL1_BASE_ADDR)
 #define MX53_DPLL2_BASE		MX53_IO_ADDRESS(MX53_PLL2_BASE_ADDR)
 #define MX53_DPLL3_BASE		MX53_IO_ADDRESS(MX53_PLL3_BASE_ADDR)
-#define MX53_DPLL4_BASE		MX53_IO_ADDRESS(MX53_PLL3_BASE_ADDR)
+#define MX53_DPLL4_BASE		MX53_IO_ADDRESS(MX53_PLL4_BASE_ADDR)
 
 /* PLL Register Offsets */
 #define MXC_PLL_DP_CTL			0x00
@@ -80,41 +77,108 @@
 #define MXC_PLL_DP_DESTAT_TOG_SEL	(1 << 31)
 #define MXC_PLL_DP_DESTAT_MFN		0x07FFFFFF
 
+/* Register addresses of apll and pfd*/
+#define MXC_ANADIG_FRAC0		0x10
+#define MXC_ANADIG_FRAC0_SET		0x14
+#define MXC_ANADIG_FRAC0_CLR		0x18
+#define MXC_ANADIG_FRAC1		0x20
+#define MXC_ANADIG_FRAC1_SET		0x24
+#define MXC_ANADIG_FRAC1_CLR		0x28
+#define MXC_ANADIG_MISC			0x60
+#define MXC_ANADIG_MISC_SET		0x64
+#define MXC_ANADIG_MISC_CLR		0x68
+#define MXC_ANADIG_PLLCTRL		0x70
+#define MXC_ANADIG_PLLCTRL_SET		0x74
+#define MXC_ANADIG_PLLCTRL_CLR		0x78
+
+/* apll and pfd Register Bit definitions */
+
+#define MXC_ANADIG_PFD3_CLKGATE		(1 << 31)
+#define MXC_ANADIG_PFD3_STABLE		(1 << 30)
+#define MXC_ANADIG_PFD3_FRAC_OFFSET	24
+#define MXC_ANADIG_PFD_FRAC_MASK	0x3F
+#define MXC_ANADIG_PFD2_CLKGATE		(1 << 23)
+#define MXC_ANADIG_PFD2_STABLE		(1 << 22)
+#define MXC_ANADIG_PFD2_FRAC_OFFSET	16
+#define MXC_ANADIG_PFD1_CLKGATE		(1 << 15)
+#define MXC_ANADIG_PFD1_STABLE		(1 << 14)
+#define MXC_ANADIG_PFD1_FRAC_OFFSET	8
+#define MXC_ANADIG_PFD0_CLKGATE		(1 << 7)
+#define MXC_ANADIG_PFD0_STABLE		(1 << 6)
+#define MXC_ANADIG_PFD0_FRAC_OFFSET	0
+
+#define MXC_ANADIG_PFD7_CLKGATE		(1 << 31)
+#define MXC_ANADIG_PFD7_STABLE		(1 << 30)
+#define MXC_ANADIG_PFD7_FRAC_OFFSET	24
+#define MXC_ANADIG_PFD6_CLKGATE		(1 << 23)
+#define MXC_ANADIG_PFD6_STABLE		(1 << 22)
+#define MXC_ANADIG_PFD6_FRAC_OFFSET	16
+#define MXC_ANADIG_PFD5_CLKGATE		(1 << 15)
+#define MXC_ANADIG_PFD5_STABLE		(1 << 14)
+#define MXC_ANADIG_PFD5_FRAC_OFFSET	8
+#define MXC_ANADIG_PFD4_CLKGATE		(1 << 7)
+#define MXC_ANADIG_PFD4_STABLE		(1 << 6)
+#define MXC_ANADIG_PFD4_FRAC_OFFSET	0
+
+#define MXC_ANADIG_APLL_LOCK		(1 << 31)
+#define MXC_ANADIG_APLL_FORCE_LOCK	(1 << 30)
+#define MXC_ANADIG_PFD_DIS_OFFSET	16
+#define MXC_ANADIG_PFD_DIS_MASK		0xff
+#define MXC_ANADIG_APLL_LOCK_CNT_OFFSET	0
+#define MXC_ANADIG_APLL_LOCK_CNT_MASK	0xffff
+
 /* Register addresses of CCM*/
-#define MXC_CCM_CCR		(MX51_CCM_BASE + 0x00)
-#define MXC_CCM_CCDR		(MX51_CCM_BASE + 0x04)
-#define MXC_CCM_CSR		(MX51_CCM_BASE + 0x08)
-#define MXC_CCM_CCSR		(MX51_CCM_BASE + 0x0C)
-#define MXC_CCM_CACRR		(MX51_CCM_BASE + 0x10)
-#define MXC_CCM_CBCDR		(MX51_CCM_BASE + 0x14)
-#define MXC_CCM_CBCMR		(MX51_CCM_BASE + 0x18)
-#define MXC_CCM_CSCMR1		(MX51_CCM_BASE + 0x1C)
-#define MXC_CCM_CSCMR2		(MX51_CCM_BASE + 0x20)
-#define MXC_CCM_CSCDR1		(MX51_CCM_BASE + 0x24)
-#define MXC_CCM_CS1CDR		(MX51_CCM_BASE + 0x28)
-#define MXC_CCM_CS2CDR		(MX51_CCM_BASE + 0x2C)
-#define MXC_CCM_CDCDR		(MX51_CCM_BASE + 0x30)
-#define MXC_CCM_CHSCDR		(MX51_CCM_BASE + 0x34)
-#define MXC_CCM_CSCDR2		(MX51_CCM_BASE + 0x38)
-#define MXC_CCM_CSCDR3		(MX51_CCM_BASE + 0x3C)
-#define MXC_CCM_CSCDR4		(MX51_CCM_BASE + 0x40)
-#define MXC_CCM_CWDR		(MX51_CCM_BASE + 0x44)
-#define MXC_CCM_CDHIPR		(MX51_CCM_BASE + 0x48)
-#define MXC_CCM_CDCR		(MX51_CCM_BASE + 0x4C)
-#define MXC_CCM_CTOR		(MX51_CCM_BASE + 0x50)
-#define MXC_CCM_CLPCR		(MX51_CCM_BASE + 0x54)
-#define MXC_CCM_CISR		(MX51_CCM_BASE + 0x58)
-#define MXC_CCM_CIMR		(MX51_CCM_BASE + 0x5C)
-#define MXC_CCM_CCOSR		(MX51_CCM_BASE + 0x60)
-#define MXC_CCM_CGPR		(MX51_CCM_BASE + 0x64)
-#define MXC_CCM_CCGR0		(MX51_CCM_BASE + 0x68)
-#define MXC_CCM_CCGR1		(MX51_CCM_BASE + 0x6C)
-#define MXC_CCM_CCGR2		(MX51_CCM_BASE + 0x70)
-#define MXC_CCM_CCGR3		(MX51_CCM_BASE + 0x74)
-#define MXC_CCM_CCGR4		(MX51_CCM_BASE + 0x78)
-#define MXC_CCM_CCGR5		(MX51_CCM_BASE + 0x7C)
-#define MXC_CCM_CCGR6		(MX51_CCM_BASE + 0x80)
-#define MXC_CCM_CMEOR		(MX51_CCM_BASE + 0x84)
+#define MXC_CCM_CCR		(MXC_CCM_BASE + 0x00)
+#define MXC_CCM_CCDR		(MXC_CCM_BASE + 0x04)
+#define MXC_CCM_CSR		(MXC_CCM_BASE + 0x08)
+#define MXC_CCM_CCSR		(MXC_CCM_BASE + 0x0C)
+#define MXC_CCM_CACRR		(MXC_CCM_BASE + 0x10)
+#define MXC_CCM_CBCDR		(MXC_CCM_BASE + 0x14)
+#define MXC_CCM_CBCMR		(MXC_CCM_BASE + 0x18)
+#define MXC_CCM_CSCMR1		(MXC_CCM_BASE + 0x1C)
+#define MXC_CCM_CSCMR2		(MXC_CCM_BASE + 0x20)
+#define MXC_CCM_CSCDR1		(MXC_CCM_BASE + 0x24)
+#define MXC_CCM_CS1CDR		(MXC_CCM_BASE + 0x28)
+#define MXC_CCM_CS2CDR		(MXC_CCM_BASE + 0x2C)
+#define MXC_CCM_CDCDR		(MXC_CCM_BASE + 0x30)
+#define MXC_CCM_CHSCDR		(MXC_CCM_BASE + 0x34)
+#define MXC_CCM_CSCDR2		(MXC_CCM_BASE + 0x38)
+#define MXC_CCM_CSCDR3		(MXC_CCM_BASE + 0x3C)
+#define MXC_CCM_CSCDR4		(MXC_CCM_BASE + 0x40)
+#define MXC_CCM_CWDR		(MXC_CCM_BASE + 0x44)
+#define MXC_CCM_CDHIPR		(MXC_CCM_BASE + 0x48)
+#define MXC_CCM_CDCR		(MXC_CCM_BASE + 0x4C)
+#define MXC_CCM_CTOR		(MXC_CCM_BASE + 0x50)
+#define MXC_CCM_CLPCR		(MXC_CCM_BASE + 0x54)
+#define MXC_CCM_CISR		(MXC_CCM_BASE + 0x58)
+#define MXC_CCM_CIMR		(MXC_CCM_BASE + 0x5C)
+#define MXC_CCM_CCOSR		(MXC_CCM_BASE + 0x60)
+#define MXC_CCM_CGPR		(MXC_CCM_BASE + 0x64)
+#define MXC_CCM_CCGR0		(MXC_CCM_BASE + 0x68)
+#define MXC_CCM_CCGR1		(MXC_CCM_BASE + 0x6C)
+#define MXC_CCM_CCGR2		(MXC_CCM_BASE + 0x70)
+#define MXC_CCM_CCGR3		(MXC_CCM_BASE + 0x74)
+#define MXC_CCM_CCGR4		(MXC_CCM_BASE + 0x78)
+#define MXC_CCM_CCGR5		(MXC_CCM_BASE + 0x7C)
+#define MXC_CCM_CCGR6		(MXC_CCM_BASE + 0x80)
+#define MXC_CCM_CCGR7		(MXC_CCM_BASE + 0x84)
+#define MXC_CCM_CMEOR		(MXC_CCM_BASE + 0x88)
+#define MXC_CCM_CSR2		(MXC_CCM_BASE + 0x8C)
+#define MXC_CCM_CLKSEQ_BYPASS	(MXC_CCM_BASE + 0x90)
+#define MXC_CCM_CLK_SYS		(MXC_CCM_BASE + 0x94)
+#define MXC_CCM_CLK_DDR		(MXC_CCM_BASE + 0x98)
+#define MXC_CCM_ELCDIFPIX	(MXC_CCM_BASE + 0x9C)
+#define MXC_CCM_EPDCPIX		(MXC_CCM_BASE + 0xA0)
+#define MXC_CCM_DISPLAY_AXI	(MXC_CCM_BASE + 0xA4)
+#define MXC_CCM_EPDC_AXI	(MXC_CCM_BASE + 0xA8)
+#define MXC_CCM_GPMI		(MXC_CCM_BASE + 0xAC)
+#define MXC_CCM_BCH		(MXC_CCM_BASE + 0xB0)
+#define MXC_CCM_MSHC_XMSCKI	(MXC_CCM_BASE + 0xB4)
+
+/* CCM Register Offsets. */
+#define MXC_CCM_CDCR_OFFSET		0x4C
+#define MXC_CCM_CACRR_OFFSET		0x10
+#define MXC_CCM_CDHIPR_OFFSET	0x48
 
 /* Define the bits in register CCR */
 #define MXC_CCM_CCR_COSC_EN		(1 << 12)
@@ -126,9 +190,17 @@
 #define MXC_CCM_CCR_OSCNT_MASK	(0xFF)
 
 /* Define the bits in register CCDR */
+/* MX51 */
 #define MXC_CCM_CCDR_HSC_HS_MASK	(0x1 << 18)
 #define MXC_CCM_CCDR_IPU_HS_MASK	(0x1 << 17)
 #define MXC_CCM_CCDR_EMI_HS_MASK	(0x1 << 16)
+/* MX53 */
+#define MXC_CCM_CCDR_IPU_HS_MX53_MASK	(0x1 << 21)
+#define MXC_CCM_CCDR_EMI_HS_INT2_MASK	(0x1 << 20)
+#define MXC_CCM_CCDR_EMI_HS_INT1_MASK	(0x1 << 19)
+#define MXC_CCM_CCDR_EMI_HS_SLOW_MASK	(0x1 << 18)
+#define MXC_CCM_CCDR_EMI_HS_FAST_MASK	(0x1 << 17)
+#define MXC_CCM_CCDR_EMI_HS_MASK	(0x1 << 16)
 
 /* Define the bits in register CSR */
 #define MXC_CCM_CSR_COSR_READY	(1 << 5)
@@ -136,10 +208,16 @@
 #define MXC_CCM_CSR_CAMP2_READY	(1 << 3)
 #define MXC_CCM_CSR_CAMP1_READY	(1 << 2)
 #define MXC_CCM_CSR_FPM_READY	(1 << 1)
+#define MXC_CCM_CSR_TEMP_MON_ALARM	(1 << 1)
 #define MXC_CCM_CSR_REF_EN_B	(1 << 0)
 
 /* Define the bits in register CCSR */
-#define MXC_CCM_CCSR_LP_APM_SEL		(0x1 << 9)
+#define MXC_CCM_CCSR_PLL3_PFD_EN		(0x1 << 13)
+#define MXC_CCM_CCSR_PLL2_PFD_EN		(0x1 << 12)
+#define MXC_CCM_CCSR_PLL1_PFD_EN		(0x1 << 11)
+#define MXC_CCM_CCSR_LP_APM_SEL			(0x1 << 10)
+#define MXC_CCM_CCSR_LP_APM_SE_MX51L		(0x1 << 9)
+#define MXC_CCM_CCSR_PLL4_SW_CLK_SEL		(1 << 9)
 #define MXC_CCM_CCSR_STEP_SEL_OFFSET	(7)
 #define MXC_CCM_CCSR_STEP_SEL_MASK	(0x3 << 7)
 #define MXC_CCM_CCSR_STEP_SEL_LP_APM	   0
@@ -160,12 +238,17 @@
 #define MXC_CCM_CACRR_ARM_PODF_MASK	(0x7)
 
 /* Define the bits in register CBCDR */
+#define MX50_CCM_CBCDR_WEIM_CLK_SEL		(0x1 << 27)
 #define MXC_CCM_CBCDR_EMI_CLK_SEL		(0x1 << 26)
 #define MXC_CCM_CBCDR_PERIPH_CLK_SEL		(0x1 << 25)
+#define MX50_CCM_CBCDR_PERIPH_CLK_SEL_OFFSET	(25)
+#define MX50_CCM_CBCDR_PERIPH_CLK_SEL_MASK	(0x3 << 25)
 #define MXC_CCM_CBCDR_DDR_HF_SEL_OFFSET		(30)
 #define MXC_CCM_CBCDR_DDR_HF_SEL		(0x1 << 30)
 #define MXC_CCM_CBCDR_DDR_PODF_OFFSET		(27)
 #define MXC_CCM_CBCDR_DDR_PODF_MASK		(0x7 << 27)
+#define MX50_CCM_CBCDR_WEIM_PODF_OFFSET	(22)
+#define MX50_CCM_CBCDR_WEIM_PODF_MASK		(0x7 << 22)
 #define MXC_CCM_CBCDR_EMI_PODF_OFFSET		(22)
 #define MXC_CCM_CBCDR_EMI_PODF_MASK		(0x7 << 22)
 #define MXC_CCM_CBCDR_AXI_B_PODF_OFFSET		(19)
@@ -186,6 +269,8 @@
 #define MXC_CCM_CBCDR_PERCLK_PODF_MASK		(0x7)
 
 /* Define the bits in register CBCMR */
+#define MXC_CCM_CBCMR_GPU2D_CLK_SEL_OFFSET		(16)
+#define MXC_CCM_CBCMR_GPU2D_CLK_SEL_MASK		(0x3 << 16)
 #define MXC_CCM_CBCMR_VPU_AXI_CLK_SEL_OFFSET	(14)
 #define MXC_CCM_CBCMR_VPU_AXI_CLK_SEL_MASK	(0x3 << 14)
 #define MXC_CCM_CBCMR_PERIPH_CLK_SEL_OFFSET	(12)
@@ -198,8 +283,8 @@
 #define MXC_CCM_CBCMR_IPU_HSP_CLK_SEL_MASK	(0x3 << 6)
 #define MXC_CCM_CBCMR_GPU_CLK_SEL_OFFSET	(4)
 #define MXC_CCM_CBCMR_GPU_CLK_SEL_MASK		(0x3 << 4)
-#define MXC_CCM_CBCMR_GPU2D_CLK_SEL_OFFSET	(14)
-#define MXC_CCM_CBCMR_GPU2D_CLK_SEL_MASK	(0x3 << 14)
+#define MXC_CCM_CBCMR_DBG_APB_CLK_SEL_OFFSET	(2)
+#define MXC_CCM_CBCMR_DBG_APB_CLK_SEL_MASK	(0x3 << 2)
 #define MXC_CCM_CBCMR_PERCLK_LP_APM_CLK_SEL	(0x1 << 1)
 #define MXC_CCM_CBCMR_PERCLK_IPG_CLK_SEL	(0x1 << 0)
 
@@ -214,15 +299,19 @@
 #define MXC_CCM_CSCMR1_UART_CLK_SEL_MASK		(0x3 << 24)
 #define MXC_CCM_CSCMR1_USBOH3_CLK_SEL_OFFSET		(22)
 #define MXC_CCM_CSCMR1_USBOH3_CLK_SEL_MASK		(0x3 << 22)
-#define MXC_CCM_CSCMR1_ESDHC1_MSHC1_CLK_SEL_OFFSET	(20)
-#define MXC_CCM_CSCMR1_ESDHC1_MSHC1_CLK_SEL_MASK	(0x3 << 20)
-#define MXC_CCM_CSCMR1_ESDHC3_CLK_SEL			(0x1 << 19)
-#define MXC_CCM_CSCMR1_ESDHC2_MSHC2_MX53_CLK_SEL	(0x1 << 19)
+#define MXC_CCM_CSCMR1_ESDHC1_MSHC2_CLK_SEL_OFFSET	(20)
+#define MXC_CCM_CSCMR1_ESDHC1_MSHC2_CLK_SEL_MASK		(0x3 << 20)
+#define MXC_CCM_CSCMR1_ESDHC3_CLK_SEL_MX51		(0x1 << 19)
+#define MXC_CCM_CSCMR1_ESDHC2_CLK_SEL			(0x1 << 19)
 #define MXC_CCM_CSCMR1_ESDHC4_CLK_SEL			(0x1 << 18)
-#define MXC_CCM_CSCMR1_ESDHC2_MSHC2_CLK_SEL_OFFSET	(16)
-#define MXC_CCM_CSCMR1_ESDHC2_MSHC2_CLK_SEL_MASK	(0x3 << 16)
-#define MXC_CCM_CSCMR1_ESDHC3_MX53_CLK_SEL_OFFSET	(16)
-#define MXC_CCM_CSCMR1_ESDHC3_MX53_CLK_SEL_MASK		(0x3 << 16)
+#define MX50_CCM_CSCMR1_ESDHC1_CLK_SEL_OFFSET	(21)
+#define MX50_CCM_CSCMR1_ESDHC1_CLK_SEL_MASK	(0x3 << 21)
+#define MX50_CCM_CSCMR1_ESDHC2_CLK_SEL			(0x1 << 20)
+#define MX50_CCM_CSCMR1_ESDHC4_CLK_SEL			(0x1 << 19)
+#define MX50_CCM_CSCMR1_ESDHC3_CLK_SEL_OFFSET	(16)
+#define MX50_CCM_CSCMR1_ESDHC3_CLK_SEL_MASK		(0x7 << 16)
+#define MXC_CCM_CSCMR1_ESDHC3_MSHC2_CLK_SEL_OFFSET	(16)
+#define MXC_CCM_CSCMR1_ESDHC3_MSHC2_CLK_SEL_MASK		(0x3 << 16)
 #define MXC_CCM_CSCMR1_SSI1_CLK_SEL_OFFSET		(14)
 #define MXC_CCM_CSCMR1_SSI1_CLK_SEL_MASK		(0x3 << 14)
 #define MXC_CCM_CSCMR1_SSI2_CLK_SEL_OFFSET		(12)
@@ -247,6 +336,7 @@
 #define MXC_CCM_CSCMR2_CSI_MCLK2_CLK_SEL_MASK		(0x3 << 24)
 #define MXC_CCM_CSCMR2_CSI_MCLK1_CLK_SEL_OFFSET		(22)
 #define MXC_CCM_CSCMR2_CSI_MCLK1_CLK_SEL_MASK		(0x3 << 22)
+/* MX51 */
 #define MXC_CCM_CSCMR2_ESC_CLK_SEL_OFFSET		(20)
 #define MXC_CCM_CSCMR2_ESC_CLK_SEL_MASK			(0x3 << 20)
 #define MXC_CCM_CSCMR2_HSC2_CLK_SEL_OFFSET		(18)
@@ -255,13 +345,29 @@
 #define MXC_CCM_CSCMR2_HSC1_CLK_SEL_MASK		(0x3 << 16)
 #define MXC_CCM_CSCMR2_HSI2C_CLK_SEL_OFFSET		(14)
 #define MXC_CCM_CSCMR2_HSI2C_CLK_SEL_MASK		(0x3 << 14)
+/* MX53 */
+#define MXC_CCM_CSCMR2_ASRC_CLK_SEL				(1<<21)
+#define MXC_CCM_CSCMR2_ESAI_PRE_SEL_OFFSET		(19)
+#define MXC_CCM_CSCMR2_ESAI_PRE_SEL_MASK		(0x3 << 19)
+#define MXC_CCM_CSCMR2_ESAI_POST_SEL_OFFSET	(16)
+#define MXC_CCM_CSCMR2_ESAI_POST_SEL_MASK		(0x7 << 16)
+#define MXC_CCM_CSCMR2_IEEE_CLK_SEL_OFFSET		(14)
+#define MXC_CCM_CSCMR2_IEEE_CLK_SEL_MASK		(0x3 << 14)
 #define MXC_CCM_CSCMR2_FIRI_CLK_SEL_OFFSET		(12)
 #define MXC_CCM_CSCMR2_FIRI_CLK_SEL_MASK		(0x3 << 12)
+/* MX51 */
 #define MXC_CCM_CSCMR2_SIM_CLK_SEL_OFFSET		(10)
 #define MXC_CCM_CSCMR2_SIM_CLK_SEL_MASK			(0x3 << 10)
 #define MXC_CCM_CSCMR2_SLIMBUS_COM			(0x1 << 9)
 #define MXC_CCM_CSCMR2_SLIMBUS_CLK_SEL_OFFSET		(6)
 #define MXC_CCM_CSCMR2_SLIMBUS_CLK_SEL_MASK		(0x7 << 6)
+/* MX53 */
+#define MXC_CCM_CSCMR2_LDB_DI1_IPU_DIV			(0x1 << 11)
+#define MXC_CCM_CSCMR2_LDB_DI0_IPU_DIV			(0x1 << 10)
+#define MXC_CCM_CSCMR2_LDB_DI1_CLK_SEL			(0x1 << 9)
+#define MXC_CCM_CSCMR2_LDB_DI0_CLK_SEL			(0x1 << 8)
+#define MXC_CCM_CSCMR2_CAN_CLK_SEL_OFFSET		(6)
+#define MXC_CCM_CSCMR2_CAN_CLK_SEL_MASK		(0x3 << 6)
 #define MXC_CCM_CSCMR2_SPDIF1_COM			(1 << 5)
 #define MXC_CCM_CSCMR2_SPDIF0_COM			(1 << 4)
 #define MXC_CCM_CSCMR2_SPDIF1_CLK_SEL_OFFSET		(2)
@@ -274,16 +380,16 @@
 #define MXC_CCM_CSCDR1_ESDHC2_MSHC2_CLK_PRED_MASK	(0x7 << 22)
 #define MXC_CCM_CSCDR1_ESDHC2_MSHC2_CLK_PODF_OFFSET	(19)
 #define MXC_CCM_CSCDR1_ESDHC2_MSHC2_CLK_PODF_MASK	(0x7 << 19)
-#define MXC_CCM_CSCDR1_ESDHC3_MX53_CLK_PRED_OFFSET	(22)
-#define MXC_CCM_CSCDR1_ESDHC3_MX53_CLK_PRED_MASK	(0x7 << 22)
-#define MXC_CCM_CSCDR1_ESDHC3_MX53_CLK_PODF_OFFSET	(19)
-#define MXC_CCM_CSCDR1_ESDHC3_MX53_CLK_PODF_MASK	(0x7 << 19)
-#define MXC_CCM_CSCDR1_ESDHC1_MSHC1_CLK_PRED_OFFSET	(16)
-#define MXC_CCM_CSCDR1_ESDHC1_MSHC1_CLK_PRED_MASK	(0x7 << 16)
+#define MXC_CCM_CSCDR1_ESDHC3_MSHC2_CLK_PRED_OFFSET	(22)
+#define MXC_CCM_CSCDR1_ESDHC3_MSHC2_CLK_PRED_MASK		(0x7 << 22)
+#define MXC_CCM_CSCDR1_ESDHC3_MSHC2_CLK_PODF_OFFSET	(19)
+#define MXC_CCM_CSCDR1_ESDHC3_MSHC2_CLK_PODF_MASK		(0x7 << 19)
+#define MXC_CCM_CSCDR1_ESDHC1_MSHC2_CLK_PRED_OFFSET	(16)
+#define MXC_CCM_CSCDR1_ESDHC1_MSHC2_CLK_PRED_MASK	(0x7 << 16)
 #define MXC_CCM_CSCDR1_PGC_CLK_PODF_OFFSET		(14)
 #define MXC_CCM_CSCDR1_PGC_CLK_PODF_MASK		(0x3 << 14)
-#define MXC_CCM_CSCDR1_ESDHC1_MSHC1_CLK_PODF_OFFSET	(11)
-#define MXC_CCM_CSCDR1_ESDHC1_MSHC1_CLK_PODF_MASK	(0x7 << 11)
+#define MXC_CCM_CSCDR1_ESDHC1_MSHC2_CLK_PODF_OFFSET	(11)
+#define MXC_CCM_CSCDR1_ESDHC1_MSHC2_CLK_PODF_MASK	(0x7 << 11)
 #define MXC_CCM_CSCDR1_USBOH3_CLK_PRED_OFFSET		(8)
 #define MXC_CCM_CSCDR1_USBOH3_CLK_PRED_MASK		(0x7 << 8)
 #define MXC_CCM_CSCDR1_USBOH3_CLK_PODF_OFFSET		(6)
@@ -294,10 +400,14 @@
 #define MXC_CCM_CSCDR1_UART_CLK_PODF_MASK		(0x7)
 
 /* Define the bits in register CS1CDR and CS2CDR */
+#define MXC_CCM_CS1CDR_ESAI_CLK_PODF_OFFSET	(25)
+#define MXC_CCM_CS1CDR_ESAI_CLK_PODF_MASK		(0x3F << 25)
 #define MXC_CCM_CS1CDR_SSI_EXT1_CLK_PRED_OFFSET		(22)
 #define MXC_CCM_CS1CDR_SSI_EXT1_CLK_PRED_MASK		(0x7 << 22)
 #define MXC_CCM_CS1CDR_SSI_EXT1_CLK_PODF_OFFSET		(16)
 #define MXC_CCM_CS1CDR_SSI_EXT1_CLK_PODF_MASK		(0x3F << 16)
+#define MXC_CCM_CS1CDR_ESAI_CLK_PRED_OFFSET		(9)
+#define MXC_CCM_CS1CDR_ESAI_CLK_PRED_MASK	(0x7 << 9)
 #define MXC_CCM_CS1CDR_SSI1_CLK_PRED_OFFSET		(6)
 #define MXC_CCM_CS1CDR_SSI1_CLK_PRED_MASK		(0x7 << 6)
 #define MXC_CCM_CS1CDR_SSI1_CLK_PODF_OFFSET		(0)
@@ -319,18 +429,23 @@
 #define MXC_CCM_CDCDR_SPDIF0_CLK_PRED_MASK		(0x7 << 25)
 #define MXC_CCM_CDCDR_SPDIF0_CLK_PODF_OFFSET		(19)
 #define MXC_CCM_CDCDR_SPDIF0_CLK_PODF_MASK		(0x3F << 19)
+/* MX51 */
 #define MXC_CCM_CDCDR_SPDIF1_CLK_PRED_OFFSET		(16)
 #define MXC_CCM_CDCDR_SPDIF1_CLK_PRED_MASK		(0x7 << 16)
-#define MXC_CCM_CDCDR_SPDIF1_CLK_PODF_OFFSET		(9)
+/* MX53 */
+#define MXC_CCM_CDCDR_DI_PLL4_PODF_OFFSET		(16)
+#define MXC_CCM_CDCDR_DI_PLL4_PODF_MASK			(0x7 << 16)
+#define MXC_CCM_CDCDR_SPDIF1_CLK_PODF_OFFSET	(9)
 #define MXC_CCM_CDCDR_SPDIF1_CLK_PODF_MASK		(0x3F << 9)
-#define MXC_CCM_CDCDR_DI_CLK_PRED_OFFSET		(6)
-#define MXC_CCM_CDCDR_DI_CLK_PRED_MASK			(0x7 << 6)
+#define MXC_CCM_CDCDR_DI1_CLK_PRED_OFFSET		(6)
+#define MXC_CCM_CDCDR_DI1_CLK_PRED_MASK		(0x7 << 6)
 #define MXC_CCM_CDCDR_USB_PHY_PRED_OFFSET		(3)
 #define MXC_CCM_CDCDR_USB_PHY_PRED_MASK			(0x7 << 3)
 #define MXC_CCM_CDCDR_USB_PHY_PODF_OFFSET		(0)
 #define MXC_CCM_CDCDR_USB_PHY_PODF_MASK			(0x7)
 
 /* Define the bits in register CHSCCDR */
+/* MX51 */
 #define MXC_CCM_CHSCCDR_ESC_CLK_PRED_OFFSET		(12)
 #define MXC_CCM_CHSCCDR_ESC_CLK_PRED_MASK		(0x7 << 12)
 #define MXC_CCM_CHSCCDR_ESC_CLK_PODF_OFFSET		(6)
@@ -339,12 +454,24 @@
 #define MXC_CCM_CHSCCDR_HSC2_CLK_PODF_MASK		(0x7 << 3)
 #define MXC_CCM_CHSCCDR_HSC1_CLK_PODF_OFFSET		(0)
 #define MXC_CCM_CHSCCDR_HSC1_CLK_PODF_MASK		(0x7)
+/* MX53 */
+#define MXC_CCM_CHSCCDR_ESAI_HCKT_SEL_OFFSET		(6)
+#define MXC_CCM_CHSCCDR_ESAI_HCKT_SEL_MASK			(0x3 << 6)
+#define MXC_CCM_CHSCCDR_ESAI_HCKR_SEL_OFFSET		(4)
+#define MXC_CCM_CHSCCDR_ESAI_HCKR_SEL_MASK			(0x3 << 4)
+#define MXC_CCM_CHSCCDR_SSI2_MLB_SPDIF_SRC_OFFSET		(2)
+#define MXC_CCM_CHSCCDR_SSI2_MLB_SPDIF_SRC_MASK		(0x3 << 2)
+#define MXC_CCM_CHSCCDR_SSI1_MLB_SPDIF_SRC_OFFSET		(0)
+#define MXC_CCM_CHSCCDR_SSI1_MLB_SPDIF_SRC_MASK		(0x3)
 
 /* Define the bits in register CSCDR2 */
+#define MXC_CCM_CSCDR2_ASRC_CLK_PRED_OFFSET	(28)
+#define MXC_CCM_CSCDR2_ASRC_CLK_PRED_MASK		(0x7 << 28)
 #define MXC_CCM_CSCDR2_CSPI_CLK_PRED_OFFSET		(25)
 #define MXC_CCM_CSCDR2_CSPI_CLK_PRED_MASK		(0x7 << 25)
 #define MXC_CCM_CSCDR2_CSPI_CLK_PODF_OFFSET		(19)
 #define MXC_CCM_CSCDR2_CSPI_CLK_PODF_MASK		(0x3F << 19)
+/* MX51 */
 #define MXC_CCM_CSCDR2_SIM_CLK_PRED_OFFSET		(16)
 #define MXC_CCM_CSCDR2_SIM_CLK_PRED_MASK		(0x7 << 16)
 #define MXC_CCM_CSCDR2_SIM_CLK_PODF_OFFSET		(9)
@@ -353,6 +480,13 @@
 #define MXC_CCM_CSCDR2_SLIMBUS_PRED_MASK		(0x7 << 6)
 #define MXC_CCM_CSCDR2_SLIMBUS_PODF_OFFSET		(0)
 #define MXC_CCM_CSCDR2_SLIMBUS_PODF_MASK		(0x3F)
+/* MX53 */
+#define MXC_CCM_CSCDR2_ASRC_CLK_PODF_OFFSET	(9)
+#define MXC_CCM_CSCDR2_ASRC_CLK_PODF_MASK		(0x3F << 9)
+#define MXC_CCM_CSCDR2_IEEE_CLK_PRED_OFFSET		(6)
+#define MXC_CCM_CSCDR2_IEEE_CLK_PRED_MASK		(0x7 << 6)
+#define MXC_CCM_CSCDR2_IEEE_CLK_PODF_OFFSET	(0)
+#define MXC_CCM_CSCDR2_IEEE_CLK_PODF_MASK		(0x3F)
 
 /* Define the bits in register CSCDR3 */
 #define MXC_CCM_CSCDR3_HSI2C_CLK_PRED_OFFSET		(16)
@@ -387,16 +521,30 @@
 #define MXC_CCM_CDHIPR_AXI_A_PODF_BUSY			(1 << 0)
 
 /* Define the bits in register CDCR */
+#define MX50_CCM_CDCR_SW_PERIPH_CLK_DIV_REQ_STATUS	(0x1 << 7)
+#define MX50_CCM_CDCR_SW_PERIPH_CLK_DIV_REQ		(0x1 << 6)
+#define MX50_CCM_CDCR_SW_DVFS_EN				(0x1 << 5)
 #define MXC_CCM_CDCR_ARM_FREQ_SHIFT_DIVIDER		(0x1 << 2)
 #define MXC_CCM_CDCR_PERIPH_CLK_DVFS_PODF_OFFSET	(0)
 #define MXC_CCM_CDCR_PERIPH_CLK_DVFS_PODF_MASK		(0x3)
 
 /* Define the bits in register CLPCR */
+/* MX51 */
 #define MXC_CCM_CLPCR_BYPASS_HSC_LPM_HS		(0x1 << 23)
-#define MXC_CCM_CLPCR_BYPASS_SCC_LPM_HS		(0x1 << 22)
-#define MX51_CCM_CLPCR_BYPASS_MAX_LPM_HS		(0x1 << 21)
-#define MX53_CCM_CLPCR_BYPASS_MAX_LPM_HS		(0x1 << 25)
-#define MXC_CCM_CLPCR_BYPASS_SDMA_LPM_HS	(0x1 << 20)
+#define MXC_CCM_CLPCR_BYPASS_SCC_LPM_HS_MX51		(0x1 << 22)
+#define MXC_CCM_CLPCR_BYPASS_MAX_LPM_HS_MX51		(0x1 << 21)
+#define MXC_CCM_CLPCR_BYPASS_SDMA_LPM_HS_MX51		(0x1 << 20)
+/* MX53 */
+#define MXC_CCM_CLPCR_BYPASS_CAN2_LPM_HS			(0x1 << 27)
+#define MXC_CCM_CLPCR_BYPASS_CAN1_LPM_HS			(0x1 << 27)
+#define MXC_CCM_CLPCR_BYPASS_SCC_LPM_HS_MX53			(0x1 << 26)
+#define MXC_CCM_CLPCR_BYPASS_MAX_LPM_HS			(0x1 << 25)
+#define MXC_CCM_CLPCR_BYPASS_SDMA_LPM_HS			(0x1 << 24)
+#define MXC_CCM_CLPCR_BYPASS_EMI_INT2_LPM_HS		(0x1 << 23)
+#define MX50_CCM_CLPCR_BYPASS_RNGB_LPM_HS		(0x1 << 23)
+#define MXC_CCM_CLPCR_BYPASS_EMI_INT1_LPM_HS		(0x1 << 22)
+#define MXC_CCM_CLPCR_BYPASS_EMI_SLOW_LPM_HS		(0x1 << 21)
+#define MXC_CCM_CLPCR_BYPASS_EMI_FAST_LPM_HS		(0x1 << 20)
 #define MXC_CCM_CLPCR_BYPASS_EMI_LPM_HS		(0x1 << 19)
 #define MXC_CCM_CLPCR_BYPASS_IPU_LPM_HS		(0x1 << 18)
 #define MXC_CCM_CLPCR_BYPASS_RTIC_LPM_HS	(0x1 << 17)
@@ -410,11 +558,16 @@
 #define MXC_CCM_CLPCR_ARM_CLK_DIS_ON_LPM	(0x1 << 5)
 #define MXC_CCM_CLPCR_LPSR_CLK_SEL_OFFSET	(3)
 #define MXC_CCM_CLPCR_LPSR_CLK_SEL_MASK		(0x3 << 3)
+#define MXC_CCM_CLPCR_BYPASS_PMIC_VFUNC_READY		(0x1 << 2)
 #define MXC_CCM_CLPCR_LPM_OFFSET		(0)
 #define MXC_CCM_CLPCR_LPM_MASK			(0x3)
 
 /* Define the bits in register CISR */
-#define MXC_CCM_CISR_ARM_PODF_LOADED			(0x1 << 25)
+#define MXC_CCM_CISR_ARM_PODF_LOADED_MX51		(0x1 << 25)
+#define MXC_CCM_CISR_ARM_PODF_LOADED		(0x1 << 26)
+#define MXC_CCM_CISR_TEMP_MON_ALARM				(0x1 << 25)
+#define MXC_CCM_CISR_EMI_CLK_SEL_LOADED			(0x1 << 23)
+#define MXC_CCM_CISR_PER_CLK_SEL_LOADED			(0x1 << 22)
 #define MXC_CCM_CISR_NFC_IPG_INT_MEM_PODF_LOADED	(0x1 << 21)
 #define MXC_CCM_CISR_AHB_PODF_LOADED			(0x1 << 20)
 #define MXC_CCM_CISR_EMI_PODF_LOADED			(0x1 << 19)
@@ -424,22 +577,36 @@
 #define MXC_CCM_CISR_COSC_READY				(0x1 << 6)
 #define MXC_CCM_CISR_CKIH2_READY			(0x1 << 5)
 #define MXC_CCM_CISR_CKIH_READY				(0x1 << 4)
+#define MX50_CCM_CISR_CAMP1_READY			(0x1 << 4)
 #define MXC_CCM_CISR_FPM_READY				(0x1 << 3)
 #define MXC_CCM_CISR_LRF_PLL3				(0x1 << 2)
 #define MXC_CCM_CISR_LRF_PLL2				(0x1 << 1)
 #define MXC_CCM_CISR_LRF_PLL1				(0x1)
 
 /* Define the bits in register CIMR */
-#define MXC_CCM_CIMR_MASK_ARM_PODF_LOADED		(0x1 << 25)
+#define MXC_CCM_CIMR_MASK_ARM_PODF_LOADED_MX51		(0x1 << 25)
+#define MXC_CCM_CIMR_MASK_EMI_PODF_LOADED_MX51		(0x1 << 20)
+#define MXC_CCM_CIMR_MASK_AXI_C_PODF_LOADED_MX51	(0x1 << 19)
+#define MXC_CCM_CIMR_MASK_ARM_PODF_LOADED		(0x1 << 26)
+#define MXC_CCM_CIMR_MASK_TEMP_MON_ALARM		(0x1 << 25)
+#define MXC_CCM_CIMR_MASK_EMI_CLK_SEL_LOADED		(0x1 << 23)
+#define MXC_CCM_CIMR_MASK_PER_CLK_SEL_LOADED		(0x1 << 22)
 #define MXC_CCM_CIMR_MASK_NFC_IPG_INT_MEM_PODF_LOADED	(0x1 << 21)
-#define MXC_CCM_CIMR_MASK_EMI_PODF_LOADED		(0x1 << 20)
-#define MXC_CCM_CIMR_MASK_AXI_C_PODF_LOADED		(0x1 << 19)
+#define MXC_CCM_CIMR_MASK_AHB_PODF_LOADED_MX53		(0x1 << 20)
+#define MXC_CCM_CIMR_MASK_EMI_SLOW_PODF_LOADED_MX53		(0x1 << 19)
+#define MX50_CCM_CIMR_MASK_WEIM_PODF_LOADED		(0x1 << 19)
 #define MXC_CCM_CIMR_MASK_AXI_B_PODF_LOADED		(0x1 << 18)
 #define MXC_CCM_CIMR_MASK_AXI_A_PODF_LOADED		(0x1 << 17)
 #define MXC_CCM_CIMR_MASK_DIVIDER_LOADED		(0x1 << 16)
-#define MXC_CCM_CIMR_MASK_COSC_READY			(0x1 << 5)
+/* MX51 */
+#define MXC_CCM_CIMR_MASK_COSC_READY_MX51			(0x1 << 5)
 #define MXC_CCM_CIMR_MASK_CKIH_READY			(0x1 << 4)
 #define MXC_CCM_CIMR_MASK_FPM_READY			(0x1 << 3)
+/* MX53/MX50 */
+#define MXC_CCM_CIMR_MASK_COSC_READY			(0x1 << 6)
+#define MXC_CCM_CIMR_MASK_CAMP2_READY			(0x1 << 5)
+#define MXC_CCM_CIMR_MASK_CAMP1_READY			(0x1 << 4)
+#define MXC_CCM_CIMR_MASK_LRF_PLL4			(0x1 << 3)
 #define MXC_CCM_CIMR_MASK_LRF_PLL3			(0x1 << 2)
 #define MXC_CCM_CIMR_MASK_LRF_PLL2			(0x1 << 1)
 #define MXC_CCM_CIMR_MASK_LRF_PLL1			(0x1)
@@ -457,11 +624,20 @@
 #define MXC_CCM_CCOSR_CKOL_SEL_MASK			(0xF)
 
 /* Define the bits in registers CGPR */
+#define MXC_CCM_CGPR_ARM_CLK_INPUT_SEL				(0x1 << 24)
+#define MXC_CCM_CGPR_ARM_ASYNC_REF_EN				(0x1 << 23)
 #define MXC_CCM_CGPR_EFUSE_PROG_SUPPLY_GATE		(0x1 << 4)
 #define MXC_CCM_CGPR_FPM_SEL				(0x1 << 3)
 #define MXC_CCM_CGPR_VL_L2BIST_CLKDIV_OFFSET		(0)
 #define MXC_CCM_CGPR_VL_L2BIST_CLKDIV_MASK		(0x7)
 
+#define MX50_CCM_CCOSR_CKO1_SLOW_SEL			(0x1 << 8)
+#define MX50_CCM_CCOSR_CKO1_EN				(0x1 << 7)
+#define MX50_CCM_CCOSR_CKO1_DIV_OFFSET			(4)
+#define MX50_CCM_CCOSR_CKO1_DIV_MASK			(0x7 << 4)
+#define MX50_CCM_CCOSR_CKO1_SEL_OFFSET			(0)
+#define MX50_CCM_CCOSR_CKO1_SEL_MASK			(0xF)
+
 /* Define the bits in registers CCGRx */
 #define MXC_CCM_CCGRx_CG_MASK				0x3
 #define MXC_CCM_CCGRx_MOD_OFF				0x0
@@ -500,30 +676,120 @@
 #define MXC_CCM_CCGRx_CG1_OFFSET			2
 #define MXC_CCM_CCGRx_CG0_OFFSET			0
 
-#define MXC_DPTC_LP_BASE	(MX51_GPC_BASE + 0x80)
-#define MXC_DPTC_GP_BASE	(MX51_GPC_BASE + 0x100)
-#define MXC_DVFS_CORE_BASE	(MX51_GPC_BASE + 0x180)
-#define MXC_DPTC_PER_BASE	(MX51_GPC_BASE + 0x1C0)
-#define MXC_PGC_IPU_BASE	(MX51_GPC_BASE + 0x220)
-#define MXC_PGC_VPU_BASE	(MX51_GPC_BASE + 0x240)
-#define MXC_PGC_GPU_BASE	(MX51_GPC_BASE + 0x260)
-#define MXC_SRPG_NEON_BASE	(MX51_GPC_BASE + 0x280)
-#define MXC_SRPG_ARM_BASE	(MX51_GPC_BASE + 0x2A0)
-#define MXC_SRPG_EMPGC0_BASE	(MX51_GPC_BASE + 0x2C0)
-#define MXC_SRPG_EMPGC1_BASE	(MX51_GPC_BASE + 0x2D0)
-#define MXC_SRPG_MEGAMIX_BASE	(MX51_GPC_BASE + 0x2E0)
-#define MXC_SRPG_EMI_BASE	(MX51_GPC_BASE + 0x300)
+#define MXC_CCM_CCGR5_CG6_1_OFFSET			12
+#define MXC_CCM_CCGR5_CG6_2_OFFSET			13
+
+/* Define the bits in registers CSR2  */
+#define MXC_CCM_CSR2_ELCDIF_PIX_BUSY			(0x1 << 9)
+#define MXC_CCM_CSR2_EPDC_PIX_BUSY			(0x1 << 8)
+#define MXC_CCM_CSR2_EPDC_AXI_BUSY			(0x1 << 4)
+#define MXC_CCM_CSR2_DISPLAY_AXI_BUSY			(0x1 << 3)
+
+/* Define the bits in registers CLKSEQ_BYPASS  */
+#define MXC_CCM_CLKSEQ_BYPASS_BYPASS_ELCDIF_PIX_CLK_SEL_OFFSET	14
+#define MXC_CCM_CLKSEQ_BYPASS_BYPASS_ELCDIF_PIX_CLK_SEL_MASK	(0x3 << 14)
+#define MXC_CCM_CLKSEQ_BYPASS_BYPASS_EPDC_PIX_CLK_SEL_OFFSET	12
+#define MXC_CCM_CLKSEQ_BYPASS_BYPASS_EPDC_PIX_CLK_SEL_MASK	(0x3 << 12)
+#define MXC_CCM_CLKSEQ_BYPASS_BYPASS_GPMI_CLK_SEL_OFFSET	6
+#define MXC_CCM_CLKSEQ_BYPASS_BYPASS_GPMI_CLK_SEL_MASK		(0x3 << 6)
+#define MXC_CCM_CLKSEQ_BYPASS_BYPASS_BCH_CLK_SEL_OFFSET		8
+#define MXC_CCM_CLKSEQ_BYPASS_BYPASS_BCH_CLK_SEL_MASK		(0x3 << 8)
+#define MXC_CCM_CLKSEQ_BYPASS_BYPASS_EPDC_AXI_CLK_SEL_OFFSET	4
+#define MXC_CCM_CLKSEQ_BYPASS_BYPASS_EPDC_AXI_CLK_SEL_MASK	(0x3 << 4)
+#define MXC_CCM_CLKSEQ_BYPASS_BYPASS_DISPLAY_AXI_CLK_SEL_OFFSET	2
+#define MXC_CCM_CLKSEQ_BYPASS_BYPASS_DISPLAY_AXI_CLK_SEL_MASK	(0x3 << 2)
+
+/* Define the bits in registers CLK_SYS */
+#define MXC_CCM_CLK_SYS_SYS_XTAL_CLKGATE_OFFSET	(30)
+#define MXC_CCM_CLK_SYS_SYS_XTAL_CLKGATE_MASK	(0x3 << 30)
+#define MXC_CCM_CLK_SYS_SYS_PLL_CLKGATE_OFFSET		(28)
+#define MXC_CCM_CLK_SYS_SYS_PLL_CLKGATE_MASK	(0x3 << 28)
+#define MXC_CCM_CLK_SYS_DIV_XTAL_OFFSET			(6)
+#define MXC_CCM_CLK_SYS_DIV_XTAL_MASK			(0xF << 6)
+#define MXC_CCM_CLK_SYS_DIV_PLL_OFFSET			(0)
+#define MXC_CCM_CLK_SYS_DIV_PLL_MASK				(0x3F)
+
+/* Define the bits in registers CLK_DDR */
+#define MXC_CCM_CLK_DDR_DDR_CLKGATE_OFFSET	(30)
+#define MXC_CCM_CLK_DDR_DDR_CLKGATE_MASK	(0x3 << 30)
+#define MXC_CCM_CLK_DDR_DDR_PFD_SEL		(1 << 6)
+#define MXC_CCM_CLK_DDR_DDR_DIV_PLL_OFFSET	(0)
+#define MXC_CCM_CLK_DDR_DDR_DIV_PLL_MASK	(0x3F)
+
+/* Define the bits in register DISPLAY_AXI */
+#define MXC_CCM_DISPLAY_AXI_CLKGATE_OFFSET	(30)
+#define MXC_CCM_DISPLAY_AXI_CLKGATE_MASK	(0x3 << 30)
+#define MXC_CCM_DISPLAY_AXI_PXP_ASM_EN		(1 << 13)
+#define MXC_CCM_DISPLAY_AXI_PXP_ASM_DIV_MASK	(0x7 << 10)
+#define MXC_CCM_DISPLAY_AXI_PXP_ASM_DIV_OFFSET	10
+#define MXC_CCM_DISPLAY_AXI_DIV_OFFSET		(0)
+#define MXC_CCM_DISPLAY_AXI_DIV_MASK		(0x3F)
+
+/* Define the bits in register EPDC_AXI */
+#define MXC_CCM_EPDC_AXI_CLKGATE_OFFSET	(30)
+#define MXC_CCM_EPDC_AXI_CLKGATE_MASK	(0x3 << 30)
+#define MXC_CCM_EPDC_AXI_ASM_EN			(1 << 9)
+#define MXC_CCM_EPDC_AXI_ASM_DIV_OFFSET		(6)
+#define MXC_CCM_EPDC_AXI_ASM_DIV_MASK		(0x7 << 6)
+#define MXC_CCM_EPDC_AXI_DIV_OFFSET		(0)
+#define MXC_CCM_EPDC_AXI_DIV_MASK		(0x3F)
+
+/* Define the bits in register EPDCPIX */
+#define MXC_CCM_EPDC_PIX_CLKGATE_OFFSET		(30)
+#define MXC_CCM_EPDC_PIX_CLKGATE_MASK		(0x3 << 30)
+#define MXC_CCM_EPDC_PIX_CLK_PRED_OFFSET	(12)
+#define MXC_CCM_EPDC_PIX_CLK_PRED_MASK		(0x3 << 12)
+#define MXC_CCM_EPDC_PIX_CLK_PODF_OFFSET	(0)
+#define MXC_CCM_EPDC_PIX_CLK_PODF_MASK		(0xFFF)
+
+/* Define the bits in register ELCDIFPIX */
+#define MXC_CCM_ELCDIFPIX_CLKGATE_OFFSET	(30)
+#define MXC_CCM_ELCDIFPIX_CLKGATE_MASK		(0x3 << 30)
+#define MXC_CCM_ELCDIFPIX_CLK_PRED_OFFSET	(12)
+#define MXC_CCM_ELCDIFPIX_CLK_PRED_MASK		(0x3 << 12)
+#define MXC_CCM_ELCDIFPIX_CLK_PODF_OFFSET	(0)
+#define MXC_CCM_ELCDIFPIX_CLK_PODF_MASK		(0xFFF)
+
+
+/* Define the bits in register GPMI */
+#define MXC_CCM_GPMI_CLKGATE_OFFSET		(30)
+#define MXC_CCM_GPMI_CLKGATE_MASK		(0x3 << 30)
+#define MXC_CCM_GPMI_CLK_DIV_OFFSET		(0)
+#define MXC_CCM_GPMI_CLK_DIV_MASK		(0x3F)
+
+/* Define the bits in register BCH */
+#define MXC_CCM_BCH_CLKGATE_OFFSET		(30)
+#define MXC_CCM_BCH_CLKGATE_MASK		(0x3 << 30)
+#define MXC_CCM_BCH_CLK_DIV_OFFSET		(0)
+#define MXC_CCM_BCH_CLK_DIV_MASK		(0x3F)
+
+#define MXC_GPC_BASE		(MX51_IO_ADDRESS(MX51_GPC_BASE_ADDR))
+#define MXC_DPTC_LP_BASE	(MXC_GPC_BASE + 0x80)
+#define MXC_DPTC_GP_BASE	(MXC_GPC_BASE + 0x100)
+#define MXC_DVFS_CORE_BASE	(MXC_GPC_BASE + 0x180)
+#define MXC_DVFS_PER_BASE	(MXC_GPC_BASE + 0x1C4)
+#define MXC_PGC_IPU_BASE	(MXC_GPC_BASE + 0x220)
+#define MXC_PGC_VPU_BASE	(MXC_GPC_BASE + 0x240)
+#define MXC_PGC_GPU_BASE	(MXC_GPC_BASE + 0x260)
+#define MXC_SRPG_NEON_BASE	(MXC_GPC_BASE + 0x280)
+#define MXC_SRPG_ARM_BASE	(MXC_GPC_BASE + 0x2A0)
+#define MXC_SRPG_EMPGC0_BASE	(MXC_GPC_BASE + 0x2C0)
+#define MXC_SRPG_EMPGC1_BASE	(MXC_GPC_BASE + 0x2D0)
+#define MXC_SRPG_MEGAMIX_BASE	(MXC_GPC_BASE + 0x2E0)
+#define MXC_SRPG_EMI_BASE	(MXC_GPC_BASE + 0x300)
 
 /* CORTEXA8 platform */
-#define MXC_CORTEXA8_PLAT_PVID		(MX51_CORTEXA8_BASE + 0x0)
-#define MXC_CORTEXA8_PLAT_GPC		(MX51_CORTEXA8_BASE + 0x4)
-#define MXC_CORTEXA8_PLAT_PIC		(MX51_CORTEXA8_BASE + 0x8)
-#define MXC_CORTEXA8_PLAT_LPC		(MX51_CORTEXA8_BASE + 0xC)
-#define MXC_CORTEXA8_PLAT_NEON_LPC	(MX51_CORTEXA8_BASE + 0x10)
-#define MXC_CORTEXA8_PLAT_ICGC		(MX51_CORTEXA8_BASE + 0x14)
-#define MXC_CORTEXA8_PLAT_AMC		(MX51_CORTEXA8_BASE + 0x18)
-#define MXC_CORTEXA8_PLAT_NMC		(MX51_CORTEXA8_BASE + 0x20)
-#define MXC_CORTEXA8_PLAT_NMS		(MX51_CORTEXA8_BASE + 0x24)
+extern void __iomem *arm_plat_base;
+#define MXC_CORTEXA8_BASE		(arm_plat_base)
+#define MXC_CORTEXA8_PLAT_PVID		(arm_plat_base + 0x0)
+#define MXC_CORTEXA8_PLAT_GPC		(arm_plat_base + 0x4)
+#define MXC_CORTEXA8_PLAT_PIC		(arm_plat_base + 0x8)
+#define MXC_CORTEXA8_PLAT_LPC		(arm_plat_base + 0xC)
+#define MXC_CORTEXA8_PLAT_NEON_LPC	(arm_plat_base + 0x10)
+#define MXC_CORTEXA8_PLAT_ICGC		(arm_plat_base + 0x14)
+#define MXC_CORTEXA8_PLAT_AMC		(arm_plat_base + 0x18)
+#define MXC_CORTEXA8_PLAT_NMC		(arm_plat_base + 0x20)
+#define MXC_CORTEXA8_PLAT_NMS		(arm_plat_base + 0x24)
 
 /* DVFS CORE */
 #define MXC_DVFSTHRS		(MXC_DVFS_CORE_BASE + 0x00)
@@ -544,28 +810,23 @@
 #define MXC_DVFSPT2 		(MXC_DVFS_CORE_BASE + 0x3C)
 #define MXC_DVFSPT3 		(MXC_DVFS_CORE_BASE + 0x40)
 
-/* GPC */
-#define MXC_GPC_CNTR		(MX51_GPC_BASE + 0x0)
-#define MXC_GPC_PGR		(MX51_GPC_BASE + 0x4)
-#define MXC_GPC_VCR		(MX51_GPC_BASE + 0x8)
-#define MXC_GPC_ALL_PU		(MX51_GPC_BASE + 0xC)
-#define MXC_GPC_NEON		(MX51_GPC_BASE + 0x10)
-#define MXC_GPC_PGR_ARMPG_OFFSET	8
-#define MXC_GPC_PGR_ARMPG_MASK		(3 << 8)
-
-/* PGC */
-#define MXC_PGC_IPU_PGCR	(MXC_PGC_IPU_BASE + 0x0)
-#define MXC_PGC_IPU_PGSR	(MXC_PGC_IPU_BASE + 0xC)
-#define MXC_PGC_VPU_PGCR	(MXC_PGC_VPU_BASE + 0x0)
-#define MXC_PGC_VPU_PGSR	(MXC_PGC_VPU_BASE + 0xC)
-#define MXC_PGC_GPU_PGCR	(MXC_PGC_GPU_BASE + 0x0)
-#define MXC_PGC_GPU_PGSR	(MXC_PGC_GPU_BASE + 0xC)
-
-#define MXC_PGCR_PCR		1
-#define MXC_SRPGCR_PCR		1
-#define MXC_EMPGCR_PCR		1
-#define MXC_PGSR_PSR		1
+/* DVFS PER */
+#define MXC_DVFSPER_LTR0	(MXC_DVFS_PER_BASE)
+#define MXC_DVFSPER_LTR1	(MXC_DVFS_PER_BASE + 0x04)
+#define MXC_DVFSPER_LTR2	(MXC_DVFS_PER_BASE + 0x08)
+#define MXC_DVFSPER_LTR3	(MXC_DVFS_PER_BASE + 0x0C)
+#define MXC_DVFSPER_LTBR0	(MXC_DVFS_PER_BASE + 0x10)
+#define MXC_DVFSPER_LTBR1	(MXC_DVFS_PER_BASE + 0x14)
+#define MXC_DVFSPER_PMCR0	(MXC_DVFS_PER_BASE + 0x18)
+#define MXC_DVFSPER_PMCR1	(MXC_DVFS_PER_BASE + 0x1C)
 
+/* GPC */
+#define MXC_GPC_CNTR				(MXC_GPC_BASE  + 0x0)
+#define MXC_GPC_PGR				(MXC_GPC_BASE  + 0x4)
+#define MXC_GPC_VCR				(MXC_GPC_BASE  + 0x8)
+#define MXC_GPC_CNTR_OFFSET		0x0
+#define MXC_GPC_PGR_OFFSET		0x4
+#define MXC_GPC_VCR_OFFSET		0x8
 
 #define MXC_CORTEXA8_PLAT_LPC_DSM	(1 << 0)
 #define MXC_CORTEXA8_PLAT_LPC_DBG_DSM	(1 << 1)
diff --git a/arch/arm/mach-mx5/devices-imx50.h b/arch/arm/mach-mx5/devices-imx50.h
old mode 100644
new mode 100755
index 7216667..699d5da
--- a/arch/arm/mach-mx5/devices-imx50.h
+++ b/arch/arm/mach-mx5/devices-imx50.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2010-2011 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -32,3 +32,6 @@ extern const struct imx_fec_data imx50_fec_data;
 extern const struct imx_imx_i2c_data imx50_imx_i2c_data[];
 #define imx50_add_imx_i2c(id, pdata)	\
 	imx_add_imx_i2c(&imx50_imx_i2c_data[id], pdata)
+extern const struct imx_mxc_gpu_data imx50_gpu_data __initconst;
+#define imx50_add_mxc_gpu(pdata) \
+	imx_add_mxc_gpu(&imx50_gpu_data, pdata)
diff --git a/arch/arm/mach-mx5/devices-imx51.h b/arch/arm/mach-mx5/devices-imx51.h
old mode 100644
new mode 100755
index e11bc0e..e5861c7
--- a/arch/arm/mach-mx5/devices-imx51.h
+++ b/arch/arm/mach-mx5/devices-imx51.h
@@ -52,3 +52,6 @@ extern const struct imx_mxc_pwm_data imx51_mxc_pwm_data[];
 extern const struct imx_imx_keypad_data imx51_imx_keypad_data;
 #define imx51_add_imx_keypad(pdata)	\
 	imx_add_imx_keypad(&imx51_imx_keypad_data, pdata)
+extern const struct imx_mxc_gpu_data imx51_gpu_data __initconst;
+#define imx51_add_mxc_gpu(pdata) \
+	imx_add_mxc_gpu(&imx51_gpu_data, pdata)
diff --git a/arch/arm/mach-mx5/devices-imx53.h b/arch/arm/mach-mx5/devices-imx53.h
old mode 100644
new mode 100755
index 48f4c8c..02c3c12
--- a/arch/arm/mach-mx5/devices-imx53.h
+++ b/arch/arm/mach-mx5/devices-imx53.h
@@ -32,3 +32,55 @@ extern const struct imx_spi_imx_data imx53_ecspi_data[];
 extern const struct imx_imx2_wdt_data imx53_imx2_wdt_data[];
 #define imx53_add_imx2_wdt(id, pdata)	\
 	imx_add_imx2_wdt(&imx53_imx2_wdt_data[id])
+
+extern const struct imx_mxc_pwm_data imx53_mxc_pwm_data[] __initconst;
+#define imx53_add_mxc_pwm(id)	\
+	imx_add_mxc_pwm(&imx53_mxc_pwm_data[id])
+
+#define imx53_add_mxc_pwm_backlight(id, pdata)                 \
+	platform_device_register_resndata(NULL, "pwm-backlight",\
+			id, NULL, 0, pdata, sizeof(*pdata));
+
+extern const struct imx_ipuv3_data imx53_ipuv3_data __initconst;
+#define imx53_add_ipuv3(pdata)	imx_add_ipuv3(&imx53_ipuv3_data, pdata)
+
+extern const struct imx_vpu_data imx53_vpu_data __initconst;
+#define imx53_add_vpu()	imx_add_vpu(&imx53_vpu_data)
+
+extern const struct imx_tve_data imx53_tve_data __initconst;
+#define imx53_add_tve(pdata)	\
+	imx_add_tve(&imx53_tve_data, pdata)
+
+extern const struct imx_dvfs_core_data imx53_dvfs_core_data __initconst;
+#define imx53_add_dvfs_core(pdata)	\
+	imx_add_dvfs_core(&imx53_dvfs_core_data, pdata)
+
+#define imx53_add_busfreq(pdata)	imx_add_busfreq(pdata)
+
+extern const struct imx_srtc_data imx53_imx_srtc_data __initconst;
+#define imx53_add_srtc()	\
+	imx_add_srtc(&imx53_imx_srtc_data)
+
+#define imx53_add_v4l2_output(id)	\
+	platform_device_register_resndata(NULL, "mxc_v4l2_output",\
+			id, NULL, 0, NULL, 0);
+
+#define imx53_add_v4l2_capture(id)	\
+	platform_device_register_resndata(NULL, "mxc_v4l2_capture",\
+			id, NULL, 0, NULL, 0);
+
+extern const struct imx_ahci_imx_data imx53_ahci_imx_data[] __initconst;
+#define imx53_add_ahci_imx(id, pdata)		\
+	imx_add_ahci_imx(&imx53_ahci_imx_data[id], pdata)
+
+extern const struct imx_imx_ssi_data imx53_imx_ssi_data[] __initconst;
+#define imx53_add_imx_ssi(id, pdata)		\
+	imx_add_imx_ssi(&imx53_imx_ssi_data[id], pdata)
+
+extern const struct imx_iim_data imx53_imx_iim_data __initconst;
+#define imx53_add_iim(pdata) \
+	imx_add_iim(&imx53_imx_iim_data, pdata)
+
+extern const struct imx_mxc_gpu_data imx53_gpu_data __initconst;
+#define imx53_add_mxc_gpu(pdata) \
+	imx_add_mxc_gpu(&imx53_gpu_data, pdata)
diff --git a/arch/arm/mach-mx5/devices.c b/arch/arm/mach-mx5/devices.c
old mode 100644
new mode 100755
index 153ada5..890d311
--- a/arch/arm/mach-mx5/devices.c
+++ b/arch/arm/mach-mx5/devices.c
@@ -1,6 +1,6 @@
 /*
  * Copyright 2009 Amit Kucheria <amit.kucheria@canonical.com>
- * Copyright (C) 2010 Freescale Semiconductor, Inc.
+ * Copyright (C) 2010-2011 Freescale Semiconductor, Inc.
  *
  * The code contained herein is licensed under the GNU General Public
  * License. You may obtain a copy of the GNU General Public License
@@ -37,9 +37,14 @@ struct platform_device mxc_hsi2c_device = {
 	.resource = mxc_hsi2c_resources
 };
 
+struct platform_device mxc_pm_device = {
+	.name = "mx5_pm",
+	.id = 0,
+};
+
 static u64 usb_dma_mask = DMA_BIT_MASK(32);
 
-static struct resource usbotg_resources[] = {
+static struct resource usbotg_udc_resources[] = {
 	{
 		.start = MX51_OTG_BASE_ADDR,
 		.end = MX51_OTG_BASE_ADDR + 0x1ff,
@@ -55,25 +60,78 @@ static struct resource usbotg_resources[] = {
 struct platform_device mxc_usbdr_udc_device = {
 	.name		= "fsl-usb2-udc",
 	.id		= -1,
-	.num_resources	= ARRAY_SIZE(usbotg_resources),
-	.resource	= usbotg_resources,
+	.num_resources	= ARRAY_SIZE(usbotg_udc_resources),
+	.resource	= usbotg_udc_resources,
 	.dev		= {
 		.dma_mask		= &usb_dma_mask,
 		.coherent_dma_mask	= DMA_BIT_MASK(32),
 	},
 };
 
+static struct resource usbotg_host_resources[] = {
+	{
+		.start = MX51_OTG_BASE_ADDR,
+		.end = MX51_OTG_BASE_ADDR + 0x1ff,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = MX51_MXC_INT_USB_OTG,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
 struct platform_device mxc_usbdr_host_device = {
-	.name = "mxc-ehci",
+	.name = "fsl-ehci",
 	.id = 0,
-	.num_resources = ARRAY_SIZE(usbotg_resources),
-	.resource = usbotg_resources,
+	.num_resources = ARRAY_SIZE(usbotg_host_resources),
+	.resource = usbotg_host_resources,
 	.dev = {
 		.dma_mask = &usb_dma_mask,
 		.coherent_dma_mask = DMA_BIT_MASK(32),
 	},
 };
 
+static struct resource usbotg_wakeup_resources[] = {
+	{
+		.start = MX51_MXC_INT_USB_OTG,/* wakeup irq */
+		.flags = IORESOURCE_IRQ,
+	},
+	{
+		.start = MX51_MXC_INT_USB_OTG,/* usb core irq */
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device mxc_usbdr_wakeup_device = {
+	.name = "usb_wakeup",
+	.id   = 0,
+	.num_resources = ARRAY_SIZE(usbotg_wakeup_resources),
+	.resource = usbotg_wakeup_resources,
+};
+
+static struct resource usbotg_xcvr_resources[] = {
+	{
+		.start = MX51_OTG_BASE_ADDR,
+		.end = MX51_OTG_BASE_ADDR + 0x1ff,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = MX51_MXC_INT_USB_OTG,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device mxc_usbdr_otg_device = {
+	.name = "fsl-usb2-otg",
+	.id = -1,
+	.dev		= {
+		.dma_mask		= &usb_dma_mask,
+		.coherent_dma_mask	= DMA_BIT_MASK(32),
+	},
+	.resource      = usbotg_xcvr_resources,
+	.num_resources = ARRAY_SIZE(usbotg_xcvr_resources),
+};
+
 static struct resource usbh1_resources[] = {
 	{
 		.start = MX51_OTG_BASE_ADDR + 0x200,
@@ -87,7 +145,7 @@ static struct resource usbh1_resources[] = {
 };
 
 struct platform_device mxc_usbh1_device = {
-	.name = "mxc-ehci",
+	.name = "fsl-ehci",
 	.id = 1,
 	.num_resources = ARRAY_SIZE(usbh1_resources),
 	.resource = usbh1_resources,
@@ -97,6 +155,24 @@ struct platform_device mxc_usbh1_device = {
 	},
 };
 
+static struct resource usbh1_wakeup_resources[] = {
+	{
+		.start = MX51_MXC_INT_USB_H1, /*wakeup irq*/
+		.flags = IORESOURCE_IRQ,
+	},
+	{
+		.start = MX51_MXC_INT_USB_H1,
+		.flags = IORESOURCE_IRQ,/* usb core irq */
+	},
+};
+
+struct platform_device mxc_usbh1_wakeup_device = {
+	.name = "usb_wakeup",
+	.id   = 1,
+	.num_resources = ARRAY_SIZE(usbh1_wakeup_resources),
+	.resource = usbh1_wakeup_resources,
+};
+
 static struct resource usbh2_resources[] = {
 	{
 		.start = MX51_OTG_BASE_ADDR + 0x400,
@@ -110,7 +186,7 @@ static struct resource usbh2_resources[] = {
 };
 
 struct platform_device mxc_usbh2_device = {
-	.name = "mxc-ehci",
+	.name = "fsl-ehci",
 	.id = 2,
 	.num_resources = ARRAY_SIZE(usbh2_resources),
 	.resource = usbh2_resources,
@@ -120,6 +196,24 @@ struct platform_device mxc_usbh2_device = {
 	},
 };
 
+static struct resource usbh2_wakeup_resources[] = {
+	{
+		.start = MX51_MXC_INT_USB_H2,
+		.flags = IORESOURCE_IRQ,/* wakeup irq */
+	},
+	{
+		.start = MX51_MXC_INT_USB_H2,
+		.flags = IORESOURCE_IRQ,/* usb core irq */
+	},
+};
+
+struct platform_device mxc_usbh2_wakeup_device = {
+	.name = "usb_wakeup",
+	.id   = 2,
+	.num_resources = ARRAY_SIZE(usbh2_wakeup_resources),
+	.resource = usbh2_wakeup_resources,
+};
+
 static struct mxc_gpio_port mxc_gpio_ports[] = {
 	{
 		.chip.label = "gpio-0",
diff --git a/arch/arm/mach-mx5/devices.h b/arch/arm/mach-mx5/devices.h
old mode 100644
new mode 100755
index 55a5129..53ee474
--- a/arch/arm/mach-mx5/devices.h
+++ b/arch/arm/mach-mx5/devices.h
@@ -3,3 +3,12 @@ extern struct platform_device mxc_usbh1_device;
 extern struct platform_device mxc_usbh2_device;
 extern struct platform_device mxc_usbdr_udc_device;
 extern struct platform_device mxc_hsi2c_device;
+extern struct platform_device mxc_pwm1_backlight_device;
+extern struct platform_device mxc_pwm2_backlight_device;
+extern struct platform_device mxc_v4l2cap_device;
+extern struct platform_device mxc_v4l2out_device;
+extern struct platform_device mxc_pm_device;
+extern struct platform_device mxc_usbdr_otg_device;
+extern struct platform_device mxc_usbdr_wakeup_device;
+extern struct platform_device mxc_usbh1_wakeup_device;
+extern struct platform_device mxc_usbh2_wakeup_device;
diff --git a/arch/arm/mach-mx5/mx53_loco_pmic_da9053.c b/arch/arm/mach-mx5/mx53_loco_pmic_da9053.c
new file mode 100755
index 0000000..2b4d2d8
--- /dev/null
+++ b/arch/arm/mach-mx5/mx53_loco_pmic_da9053.c
@@ -0,0 +1,289 @@
+/*
+ * Copyright (C) 2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+
+/*
+ * mx53_loco_pmic_da9053.c  --  i.MX53 LOCO driver for pmic da9053
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/err.h>
+#include <linux/regulator/machine.h>
+#include <linux/regulator/fixed.h>
+#include <linux/mfd/da9052/da9052.h>
+#include <linux/mfd/da9052/pm.h>
+#include <linux/mfd/da9052/led.h>
+#include <linux/mfd/da9052/tsi.h>
+#include <mach/irqs.h>
+#include <mach/iomux-mx53.h>
+#include <mach/gpio.h>
+
+#define DA9052_LDO(max, min, rname, suspend_mv) \
+{\
+	.constraints = {\
+		.name		= (rname), \
+		.max_uV		= (max) * 1000,\
+		.min_uV		= (min) * 1000,\
+		.valid_ops_mask	= REGULATOR_CHANGE_VOLTAGE\
+		|REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_MODE,\
+		.valid_modes_mask = REGULATOR_MODE_NORMAL,\
+		.state_mem = { \
+			.uV = suspend_mv * 1000, \
+			.mode = REGULATOR_MODE_NORMAL, \
+			.enabled = (0 == suspend_mv) ? 0 : 1, \
+			.disabled = 0, \
+		}, \
+	},\
+}
+
+#ifdef CONFIG_SND_SOC_SGTL5000
+
+static struct regulator_consumer_supply sgtl5000_consumer[] = {
+	REGULATOR_SUPPLY("VDDA", NULL),
+	REGULATOR_SUPPLY("VDDIO", NULL),
+};
+
+static struct regulator_init_data sgtl5000_reg_initdata = {
+	.constraints = {
+		.valid_ops_mask = REGULATOR_CHANGE_STATUS,
+	},
+	.num_consumer_supplies = ARRAY_SIZE(sgtl5000_consumer),
+	.consumer_supplies = &sgtl5000_consumer[0],
+};
+
+static struct fixed_voltage_config sgtl5000_reg_config = {
+	.supply_name		= "VDDA",
+	.microvolts		= 3200000,
+	.gpio			= -1,
+	.init_data		= &sgtl5000_reg_initdata,
+};
+
+static struct platform_device sgtl5000_reg_devices = {
+
+	.name	= "reg-fixed-voltage",
+	.id	= 1,
+	.dev	= {
+		.platform_data = &sgtl5000_reg_config,
+	},
+};
+#endif /* CONFIG_SND_SOC_SGTL5000 */
+
+/* currently the suspend_mv here takes no effects for DA9053
+preset-voltage have to be done in the latest stage during
+suspend*/
+static struct regulator_init_data da9052_regulators_init[] = {
+	DA9052_LDO(DA9052_LDO1_VOLT_UPPER,
+		DA9052_LDO1_VOLT_LOWER, "DA9052_LDO1", 1300),
+	DA9052_LDO(DA9052_LDO2_VOLT_UPPER,
+		DA9052_LDO2_VOLT_LOWER, "DA9052_LDO2", 1300),
+	DA9052_LDO(DA9052_LDO34_VOLT_UPPER,
+		DA9052_LDO34_VOLT_LOWER, "DA9052_LDO3", 3300),
+	DA9052_LDO(DA9052_LDO34_VOLT_UPPER,
+		DA9052_LDO34_VOLT_LOWER, "DA9052_LDO4", 2775),
+	DA9052_LDO(DA9052_LDO567810_VOLT_UPPER,
+		DA9052_LDO567810_VOLT_LOWER, "DA9052_LDO5", 1300),
+	DA9052_LDO(DA9052_LDO567810_VOLT_UPPER,
+		DA9052_LDO567810_VOLT_LOWER, "DA9052_LDO6", 1200),
+	DA9052_LDO(DA9052_LDO567810_VOLT_UPPER,
+		DA9052_LDO567810_VOLT_LOWER, "DA9052_LDO7", 2750),
+	DA9052_LDO(DA9052_LDO567810_VOLT_UPPER,
+		DA9052_LDO567810_VOLT_LOWER, "DA9052_LDO8", 1800),
+	DA9052_LDO(DA9052_LDO9_VOLT_UPPER,
+		DA9052_LDO9_VOLT_LOWER, "DA9052_LDO9", 2500),
+	DA9052_LDO(DA9052_LDO567810_VOLT_UPPER,
+		DA9052_LDO567810_VOLT_LOWER, "DA9052_LDO10", 1200),
+
+	/* BUCKS */
+	DA9052_LDO(DA9052_BUCK_CORE_PRO_VOLT_UPPER,
+		DA9052_BUCK_CORE_PRO_VOLT_LOWER, "DA9052_BUCK_CORE", 850),
+	DA9052_LDO(DA9052_BUCK_CORE_PRO_VOLT_UPPER,
+		DA9052_BUCK_CORE_PRO_VOLT_LOWER, "DA9052_BUCK_PRO", 950),
+	DA9052_LDO(DA9052_BUCK_MEM_VOLT_UPPER,
+		DA9052_BUCK_MEM_VOLT_LOWER, "DA9052_BUCK_MEM", 1500),
+	DA9052_LDO(DA9052_BUCK_PERI_VOLT_UPPER,
+		DA9052_BUCK_PERI_VOLT_LOWER, "DA9052_BUCK_PERI", 2500)
+};
+
+
+static struct da9052_tsi_platform_data da9052_tsi = {
+	.pen_up_interval = 50,
+	.tsi_delay_bit_shift = 6,
+	.tsi_skip_bit_shift = 3,
+	.num_gpio_tsi_register = 3,
+	.tsi_supply_voltage = 2500,
+	 /* This is the DA9052 LDO number used for powering the TSI */
+	.tsi_ref_source = 9,
+	.max_tsi_delay = TSI_DELAY_4SLOTS,
+	.max_tsi_skip_slot = TSI_SKIP_330SLOTS,
+};
+
+static struct da9052_led_platform_data da9052_gpio_led[] = {
+	{
+		.id = DA9052_LED_4,
+		.name = "LED_GPIO14",
+	},
+	{
+		.id = DA9052_LED_5,
+		.name = "LED_GPIO15",
+	},
+};
+
+static struct da9052_leds_platform_data da9052_gpio_leds = {
+	.num_leds = ARRAY_SIZE(da9052_gpio_led),
+	.led = da9052_gpio_led,
+};
+
+
+static void da9052_init_ssc_cache(struct da9052 *da9052)
+{
+	unsigned char cnt;
+
+	/* First initialize all registers as Non-volatile */
+	for (cnt = 0; cnt < DA9052_REG_CNT; cnt++) {
+		da9052->ssc_cache[cnt].type = NON_VOLATILE;
+		da9052->ssc_cache[cnt].status = INVALID;
+		da9052->ssc_cache[cnt].val = 0;
+	}
+
+	/* Now selectively set type for all Volatile registers */
+	/* Reg 1 - 9 */
+	da9052->ssc_cache[DA9052_STATUSA_REG].type = VOLATILE;
+	da9052->ssc_cache[DA9052_STATUSB_REG].type = VOLATILE;
+	da9052->ssc_cache[DA9052_STATUSC_REG].type = VOLATILE;
+	da9052->ssc_cache[DA9052_STATUSD_REG].type = VOLATILE;
+	da9052->ssc_cache[DA9052_EVENTA_REG].type = VOLATILE;
+	da9052->ssc_cache[DA9052_EVENTB_REG].type = VOLATILE;
+	da9052->ssc_cache[DA9052_EVENTC_REG].type = VOLATILE;
+	da9052->ssc_cache[DA9052_EVENTD_REG].type = VOLATILE;
+	da9052->ssc_cache[DA9052_FAULTLOG_REG].type = VOLATILE;
+
+	/* Reg 15 */
+	da9052->ssc_cache[DA9052_CONTROLB_REG].type = VOLATILE;
+	/* Reg - 17 */
+	da9052->ssc_cache[DA9052_CONTROLD_REG].type = VOLATILE;
+	/* Reg - 60 */
+	da9052->ssc_cache[DA9052_SUPPLY_REG].type = VOLATILE;
+	/* Reg - 62 */
+	da9052->ssc_cache[DA9052_CHGBUCK_REG].type = VOLATILE;
+
+	/* Reg 67 - 68 */
+	da9052->ssc_cache[DA9052_INPUTCONT_REG].type = VOLATILE;
+	da9052->ssc_cache[DA9052_CHGTIME_REG].type = VOLATILE;
+
+	/* Reg - 70 */
+	da9052->ssc_cache[DA9052_BOOST_REG].type = VOLATILE;
+
+	/* Reg - 81 */
+	da9052->ssc_cache[DA9052_ADCMAN_REG].type = VOLATILE;
+
+	/* Reg - 83 - 85 */
+	da9052->ssc_cache[DA9052_ADCRESL_REG].type = VOLATILE;
+	da9052->ssc_cache[DA9052_ADCRESH_REG].type = VOLATILE;
+	da9052->ssc_cache[DA9052_VDDRES_REG].type = VOLATILE;
+
+	/* Reg - 87 */
+	da9052->ssc_cache[DA9052_ICHGAV_REG].type = VOLATILE;
+
+	/* Reg - 90 */
+	da9052->ssc_cache[DA9052_TBATRES_REG].type = VOLATILE;
+
+	/* Reg - 95 */
+	da9052->ssc_cache[DA9052_ADCIN4RES_REG].type = VOLATILE;
+
+	/* Reg - 98 */
+	da9052->ssc_cache[DA9052_ADCIN5RES_REG].type = VOLATILE;
+
+	/* Reg - 101 */
+	da9052->ssc_cache[DA9052_ADCIN6RES_REG].type = VOLATILE;
+
+	/* Reg - 104 */
+	da9052->ssc_cache[DA9052_TJUNCRES_REG].type = VOLATILE;
+
+	/* Reg 106 - 110 */
+	da9052->ssc_cache[DA9052_TSICONTB_REG].type	= VOLATILE;
+	da9052->ssc_cache[DA9052_TSIXMSB_REG].type	= VOLATILE;
+	da9052->ssc_cache[DA9052_TSIYMSB_REG].type	= VOLATILE;
+	da9052->ssc_cache[DA9052_TSILSB_REG].type	= VOLATILE;
+	da9052->ssc_cache[DA9052_TSIZMSB_REG].type	= VOLATILE;
+
+	/* Reg 111 - 117 */
+	da9052->ssc_cache[DA9052_COUNTS_REG].type	= VOLATILE;
+	da9052->ssc_cache[DA9052_COUNTMI_REG].type	= VOLATILE;
+	da9052->ssc_cache[DA9052_COUNTH_REG].type	= VOLATILE;
+	da9052->ssc_cache[DA9052_COUNTD_REG].type	= VOLATILE;
+	da9052->ssc_cache[DA9052_COUNTMO_REG].type	= VOLATILE;
+	da9052->ssc_cache[DA9052_COUNTY_REG].type	= VOLATILE;
+	da9052->ssc_cache[DA9052_ALARMMI_REG].type	= VOLATILE;
+
+	/* Reg 122 - 125 */
+	da9052->ssc_cache[DA9052_SECONDA_REG].type	= VOLATILE;
+	da9052->ssc_cache[DA9052_SECONDB_REG].type	= VOLATILE;
+	da9052->ssc_cache[DA9052_SECONDC_REG].type	= VOLATILE;
+	da9052->ssc_cache[DA9052_SECONDD_REG].type	= VOLATILE;
+
+	/* Following addresses are not assigned to any register */
+	da9052->ssc_cache[126].type			= VOLATILE;
+	da9052->ssc_cache[127].type			= VOLATILE;
+}
+
+
+#define MX53_LOCO_DA9052_IRQ			(6*32 + 11)	/* GPIO7_11 */
+
+static int __init loco_da9052_init(struct da9052 *da9052)
+{
+	/* Configuring for DA9052 interrupt servce */
+	/* s3c_gpio_setpull(DA9052_IRQ_PIN, S3C_GPIO_PULL_UP);*/
+
+	/* Set interrupt as LOW LEVEL interrupt source */
+	set_irq_type(gpio_to_irq(MX53_LOCO_DA9052_IRQ), IRQF_TRIGGER_LOW);
+
+	da9052_init_ssc_cache(da9052);
+
+#ifdef CONFIG_SND_SOC_SGTL5000
+	platform_device_register(&sgtl5000_reg_devices);
+#endif
+
+	return 0;
+}
+
+static struct da9052_platform_data __initdata da9052_plat = {
+	.init = loco_da9052_init,
+	.num_regulators = ARRAY_SIZE(da9052_regulators_init),
+	.regulators = da9052_regulators_init,
+	.led_data = &da9052_gpio_leds,
+	.tsi_data = &da9052_tsi,
+	/* .bat_data = &da9052_bat, */
+	/* .gpio_base = GPIO_BOARD_START, */
+};
+
+
+static struct i2c_board_info __initdata da9052_i2c_device = {
+	I2C_BOARD_INFO(DA9052_SSC_I2C_DEVICE_NAME, DA9052_I2C_ADDR >> 1),
+	.irq = gpio_to_irq(MX53_LOCO_DA9052_IRQ),
+	.platform_data = &da9052_plat,
+};
+
+int __init mx53_loco_init_da9052(void)
+{
+	return i2c_register_board_info(0, &da9052_i2c_device, 1);
+}
diff --git a/arch/arm/mach-mx5/mx53_smd_pmic_da9053.c b/arch/arm/mach-mx5/mx53_smd_pmic_da9053.c
new file mode 100755
index 0000000..ae39b84
--- /dev/null
+++ b/arch/arm/mach-mx5/mx53_smd_pmic_da9053.c
@@ -0,0 +1,314 @@
+/*
+ * Copyright (C) 2010-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+
+/*
+ * mx53_smd_pmic_da9053.c  --  i.MX53 SMD driver for pmic da9053
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/err.h>
+#include <linux/regulator/machine.h>
+#include <linux/regulator/fixed.h>
+#include <linux/mfd/da9052/da9052.h>
+#include <linux/mfd/da9052/pm.h>
+#include <linux/mfd/da9052/led.h>
+#include <linux/mfd/da9052/tsi.h>
+#include <mach/irqs.h>
+#include <mach/iomux-mx53.h>
+#include <mach/gpio.h>
+
+#define DA9052_LDO(max, min, rname, suspend_mv) \
+{\
+	.constraints = {\
+		.name		= (rname), \
+		.max_uV		= (max) * 1000,\
+		.min_uV		= (min) * 1000,\
+		.valid_ops_mask	= REGULATOR_CHANGE_VOLTAGE\
+		|REGULATOR_CHANGE_STATUS | REGULATOR_CHANGE_MODE,\
+		.valid_modes_mask = REGULATOR_MODE_NORMAL,\
+		.state_mem = { \
+			.uV = suspend_mv * 1000, \
+			.mode = REGULATOR_MODE_NORMAL, \
+			.enabled = (0 == suspend_mv) ? 0 : 1, \
+			.disabled = 0, \
+		}, \
+	},\
+}
+
+/* currently the suspend_mv field here takes no effects for DA9053
+preset-voltage have to be done in the latest stage during
+suspend*/
+static struct regulator_init_data da9052_regulators_init[] = {
+	DA9052_LDO(DA9052_LDO1_VOLT_UPPER,
+		DA9052_LDO1_VOLT_LOWER, "DA9052_LDO1", 1300),
+	DA9052_LDO(DA9052_LDO2_VOLT_UPPER,
+		DA9052_LDO2_VOLT_LOWER, "DA9052_LDO2", 1300),
+	DA9052_LDO(DA9052_LDO34_VOLT_UPPER,
+		DA9052_LDO34_VOLT_LOWER, "DA9052_LDO3", 3300),
+	DA9052_LDO(DA9052_LDO34_VOLT_UPPER,
+		DA9052_LDO34_VOLT_LOWER, "DA9052_LDO4", 2775),
+	DA9052_LDO(DA9052_LDO567810_VOLT_UPPER,
+		DA9052_LDO567810_VOLT_LOWER, "DA9052_LDO5", 1300),
+	DA9052_LDO(DA9052_LDO567810_VOLT_UPPER,
+		DA9052_LDO567810_VOLT_LOWER, "DA9052_LDO6", 1200),
+	DA9052_LDO(DA9052_LDO567810_VOLT_UPPER,
+		DA9052_LDO567810_VOLT_LOWER, "DA9052_LDO7", 2750),
+	DA9052_LDO(DA9052_LDO567810_VOLT_UPPER,
+		DA9052_LDO567810_VOLT_LOWER, "DA9052_LDO8", 1800),
+	DA9052_LDO(DA9052_LDO9_VOLT_UPPER,
+		DA9052_LDO9_VOLT_LOWER, "DA9052_LDO9", 2500),
+	DA9052_LDO(DA9052_LDO567810_VOLT_UPPER,
+		DA9052_LDO567810_VOLT_LOWER, "DA9052_LDO10", 1200),
+
+	/* BUCKS */
+	DA9052_LDO(DA9052_BUCK_CORE_PRO_VOLT_UPPER,
+		DA9052_BUCK_CORE_PRO_VOLT_LOWER, "DA9052_BUCK_CORE", 850),
+	DA9052_LDO(DA9052_BUCK_CORE_PRO_VOLT_UPPER,
+		DA9052_BUCK_CORE_PRO_VOLT_LOWER, "DA9052_BUCK_PRO", 950),
+	DA9052_LDO(DA9052_BUCK_MEM_VOLT_UPPER,
+		DA9052_BUCK_MEM_VOLT_LOWER, "DA9052_BUCK_MEM", 1500),
+	DA9052_LDO(DA9052_BUCK_PERI_VOLT_UPPER,
+		DA9052_BUCK_PERI_VOLT_LOWER, "DA9052_BUCK_PERI", 2500)
+};
+
+
+#define MX53_SMD_WiFi_BT_PWR_EN		(2*32 + 10)	/*GPIO_3_10 */
+struct regulator_init_data wifi_bt_reg_initdata = {
+	.constraints = {
+		.valid_ops_mask = REGULATOR_CHANGE_STATUS,
+	},
+};
+
+static struct fixed_voltage_config wifi_bt_reg_config = {
+	.supply_name		= "wifi_bt",
+	.microvolts		= 3300000,
+	.gpio			= MX53_SMD_WiFi_BT_PWR_EN,
+	.enable_high		= 1,
+	.enabled_at_boot	= 0,
+	.init_data		= &wifi_bt_reg_initdata,
+};
+
+static struct platform_device wifi_bt_reg_device = {
+	.name	= "reg-fixed-voltage",
+	.id	= 0,
+	.dev	= {
+		.platform_data = &wifi_bt_reg_config,
+	},
+};
+
+#ifdef CONFIG_SND_SOC_SGTL5000
+
+static struct regulator_consumer_supply sgtl5000_consumer[] = {
+	REGULATOR_SUPPLY("VDDA", NULL),
+	REGULATOR_SUPPLY("VDDIO", NULL),
+};
+
+static struct regulator_init_data sgtl5000_reg_initdata = {
+	.constraints = {
+		.valid_ops_mask = REGULATOR_CHANGE_STATUS,
+	},
+	.num_consumer_supplies = ARRAY_SIZE(sgtl5000_consumer),
+	.consumer_supplies = &sgtl5000_consumer[0],
+};
+
+static struct fixed_voltage_config sgtl5000_reg_config = {
+	.supply_name		= "VDDA",
+	.microvolts		= 3300000,
+	.gpio			= -1,
+	.init_data		= &sgtl5000_reg_initdata,
+};
+
+static struct platform_device sgtl5000_reg_devices = {
+
+	.name	= "reg-fixed-voltage",
+	.id	= 1,
+	.dev	= {
+		.platform_data = &sgtl5000_reg_config,
+	},
+};
+#endif /* CONFIG_SND_SOC_SGTL5000 */
+
+static struct da9052_tsi_platform_data da9052_tsi = {
+	.pen_up_interval = 50,
+	.tsi_delay_bit_shift = 6,
+	.tsi_skip_bit_shift = 3,
+	.num_gpio_tsi_register = 3,
+	.tsi_supply_voltage = 2500,
+	 /* This is the DA9052 LDO number used for powering the TSI */
+	.tsi_ref_source = 9,
+	.max_tsi_delay = TSI_DELAY_4SLOTS,
+	.max_tsi_skip_slot = TSI_SKIP_330SLOTS,
+};
+
+static struct da9052_led_platform_data da9052_gpio_led[] = {
+	{
+		.id = DA9052_LED_4,
+		.name = "LED_GPIO14",
+	},
+	{
+		.id = DA9052_LED_5,
+		.name = "LED_GPIO15",
+	},
+};
+
+static struct da9052_leds_platform_data da9052_gpio_leds = {
+	.num_leds = ARRAY_SIZE(da9052_gpio_led),
+	.led = da9052_gpio_led,
+};
+
+
+static void da9052_init_ssc_cache(struct da9052 *da9052)
+{
+	unsigned char cnt;
+
+	/* First initialize all registers as Non-volatile */
+	for (cnt = 0; cnt < DA9052_REG_CNT; cnt++) {
+		da9052->ssc_cache[cnt].type = NON_VOLATILE;
+		da9052->ssc_cache[cnt].status = INVALID;
+		da9052->ssc_cache[cnt].val = 0;
+	}
+
+	/* Now selectively set type for all Volatile registers */
+	/* Reg 1 - 9 */
+	da9052->ssc_cache[DA9052_STATUSA_REG].type = VOLATILE;
+	da9052->ssc_cache[DA9052_STATUSB_REG].type = VOLATILE;
+	da9052->ssc_cache[DA9052_STATUSC_REG].type = VOLATILE;
+	da9052->ssc_cache[DA9052_STATUSD_REG].type = VOLATILE;
+	da9052->ssc_cache[DA9052_EVENTA_REG].type = VOLATILE;
+	da9052->ssc_cache[DA9052_EVENTB_REG].type = VOLATILE;
+	da9052->ssc_cache[DA9052_EVENTC_REG].type = VOLATILE;
+	da9052->ssc_cache[DA9052_EVENTD_REG].type = VOLATILE;
+	da9052->ssc_cache[DA9052_FAULTLOG_REG].type = VOLATILE;
+
+	/* Reg 15 */
+	da9052->ssc_cache[DA9052_CONTROLB_REG].type = VOLATILE;
+	/* Reg - 17 */
+	da9052->ssc_cache[DA9052_CONTROLD_REG].type = VOLATILE;
+	/* Reg - 60 */
+	da9052->ssc_cache[DA9052_SUPPLY_REG].type = VOLATILE;
+	/* Reg - 62 */
+	da9052->ssc_cache[DA9052_CHGBUCK_REG].type = VOLATILE;
+
+	/* Reg 67 - 68 */
+	da9052->ssc_cache[DA9052_INPUTCONT_REG].type = VOLATILE;
+	da9052->ssc_cache[DA9052_CHGTIME_REG].type = VOLATILE;
+
+	/* Reg - 70 */
+	da9052->ssc_cache[DA9052_BOOST_REG].type = VOLATILE;
+
+	/* Reg - 81 */
+	da9052->ssc_cache[DA9052_ADCMAN_REG].type = VOLATILE;
+
+	/* Reg - 83 - 85 */
+	da9052->ssc_cache[DA9052_ADCRESL_REG].type = VOLATILE;
+	da9052->ssc_cache[DA9052_ADCRESH_REG].type = VOLATILE;
+	da9052->ssc_cache[DA9052_VDDRES_REG].type = VOLATILE;
+
+	/* Reg - 87 */
+	da9052->ssc_cache[DA9052_ICHGAV_REG].type = VOLATILE;
+
+	/* Reg - 90 */
+	da9052->ssc_cache[DA9052_TBATRES_REG].type = VOLATILE;
+
+	/* Reg - 95 */
+	da9052->ssc_cache[DA9052_ADCIN4RES_REG].type = VOLATILE;
+
+	/* Reg - 98 */
+	da9052->ssc_cache[DA9052_ADCIN5RES_REG].type = VOLATILE;
+
+	/* Reg - 101 */
+	da9052->ssc_cache[DA9052_ADCIN6RES_REG].type = VOLATILE;
+
+	/* Reg - 104 */
+	da9052->ssc_cache[DA9052_TJUNCRES_REG].type = VOLATILE;
+
+	/* Reg 106 - 110 */
+	da9052->ssc_cache[DA9052_TSICONTB_REG].type	= VOLATILE;
+	da9052->ssc_cache[DA9052_TSIXMSB_REG].type	= VOLATILE;
+	da9052->ssc_cache[DA9052_TSIYMSB_REG].type	= VOLATILE;
+	da9052->ssc_cache[DA9052_TSILSB_REG].type	= VOLATILE;
+	da9052->ssc_cache[DA9052_TSIZMSB_REG].type	= VOLATILE;
+
+	/* Reg 111 - 117 */
+	da9052->ssc_cache[DA9052_COUNTS_REG].type	= VOLATILE;
+	da9052->ssc_cache[DA9052_COUNTMI_REG].type	= VOLATILE;
+	da9052->ssc_cache[DA9052_COUNTH_REG].type	= VOLATILE;
+	da9052->ssc_cache[DA9052_COUNTD_REG].type	= VOLATILE;
+	da9052->ssc_cache[DA9052_COUNTMO_REG].type	= VOLATILE;
+	da9052->ssc_cache[DA9052_COUNTY_REG].type	= VOLATILE;
+	da9052->ssc_cache[DA9052_ALARMMI_REG].type	= VOLATILE;
+
+	/* Reg 122 - 125 */
+	da9052->ssc_cache[DA9052_SECONDA_REG].type	= VOLATILE;
+	da9052->ssc_cache[DA9052_SECONDB_REG].type	= VOLATILE;
+	da9052->ssc_cache[DA9052_SECONDC_REG].type	= VOLATILE;
+	da9052->ssc_cache[DA9052_SECONDD_REG].type	= VOLATILE;
+
+	/* Following addresses are not assigned to any register */
+	da9052->ssc_cache[126].type			= VOLATILE;
+	da9052->ssc_cache[127].type			= VOLATILE;
+}
+
+
+#define MX53_SMD_DA9052_IRQ			(6*32 + 11)	/* GPIO7_11 */
+
+static int __init smd_da9052_init(struct da9052 *da9052)
+{
+	/* Configuring for DA9052 interrupt servce */
+	/* s3c_gpio_setpull(DA9052_IRQ_PIN, S3C_GPIO_PULL_UP);*/
+	int ret;
+	/* Set interrupt as LOW LEVEL interrupt source */
+	set_irq_type(gpio_to_irq(MX53_SMD_DA9052_IRQ), IRQF_TRIGGER_LOW);
+
+	da9052_init_ssc_cache(da9052);
+#ifdef CONFIG_SND_SOC_SGTL5000
+	platform_device_register(&sgtl5000_reg_devices);
+#endif
+	ret = platform_device_register(&wifi_bt_reg_device);
+
+	return 0;
+}
+
+static struct da9052_platform_data __initdata da9052_plat = {
+	.init = smd_da9052_init,
+	.num_regulators = ARRAY_SIZE(da9052_regulators_init),
+	.regulators = da9052_regulators_init,
+	.led_data = &da9052_gpio_leds,
+	.tsi_data = &da9052_tsi,
+	/* .bat_data = &da9052_bat, */
+	/* .gpio_base = GPIO_BOARD_START, */
+};
+
+
+static struct i2c_board_info __initdata da9052_i2c_device = {
+	I2C_BOARD_INFO(DA9052_SSC_I2C_DEVICE_NAME, DA9052_I2C_ADDR >> 1),
+	.irq = gpio_to_irq(MX53_SMD_DA9052_IRQ),
+	.platform_data = &da9052_plat,
+};
+
+int __init mx53_smd_init_da9052(void)
+{
+	return i2c_register_board_info(0, &da9052_i2c_device, 1);
+}
diff --git a/arch/arm/mach-mx5/pm.c b/arch/arm/mach-mx5/pm.c
new file mode 100755
index 0000000..453ab16
--- /dev/null
+++ b/arch/arm/mach-mx5/pm.c
@@ -0,0 +1,281 @@
+/*
+ *  Copyright (C) 2008-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/clk.h>
+#include <linux/i2c.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
+#include <linux/suspend.h>
+#include <linux/regulator/machine.h>
+#include <linux/proc_fs.h>
+#include <linux/cpufreq.h>
+#include <linux/iram_alloc.h>
+#include <linux/fsl_devices.h>
+#include <asm/mach-types.h>
+#include <asm/cacheflush.h>
+#include <asm/tlb.h>
+#include <asm/delay.h>
+#include <asm/mach/map.h>
+#include <mach/hardware.h>
+#include <mach/gpio.h>
+#ifdef CONFIG_ARCH_MX50
+#include <mach/iomux-mx50.h>
+#endif
+#include "crm_regs.h"
+
+#define DATABAHN_CTL_REG0	0
+#define DATABAHN_CTL_REG19	0x4c
+#define DATABAHN_CTL_REG79	0x13c
+#define DATABAHN_PHY_REG25	0x264
+#define MX53_OFFSET 0x20000000
+
+static struct cpu_op *cpu_op_tbl;
+static int cpu_op_nr;
+static struct clk *cpu_clk;
+static struct mxc_pm_platform_data *pm_data;
+
+#if defined(CONFIG_CPU_FREQ)
+static int org_freq;
+extern int set_cpu_freq(int wp);
+#endif
+
+
+static struct device *pm_dev;
+struct clk *gpc_dvfs_clk;
+extern void cpu_do_suspend_workaround(u32 sdclk_iomux_addr);
+extern void mx50_suspend(u32 databahn_addr);
+extern struct cpu_op *(*get_cpu_op)(int *wp);
+extern void __iomem *databahn_base;
+extern void da9053_suspend_cmd(void);
+extern void da9053_resume_dump(void);
+extern void pm_da9053_i2c_init(u32 base_addr);
+
+extern int iram_ready;
+void *suspend_iram_base;
+void (*suspend_in_iram)(void *sdclk_iomux_addr) = NULL;
+void __iomem *suspend_param1;
+
+#define TZIC_WAKEUP0_OFFSET            0x0E00
+#define TZIC_WAKEUP1_OFFSET            0x0E04
+#define TZIC_WAKEUP2_OFFSET            0x0E08
+#define TZIC_WAKEUP3_OFFSET            0x0E0C
+#define GPIO7_0_11_IRQ_BIT		(0x1<<11)
+
+static void mx53_smd_loco_irq_wake_fixup(void)
+{
+	void __iomem *tzic_base;
+	tzic_base = ioremap(MX53_TZIC_BASE_ADDR, SZ_4K);
+	if (NULL == tzic_base) {
+		pr_err("fail to map MX53_TZIC_BASE_ADDR\n");
+		return;
+	}
+	__raw_writel(0, tzic_base + TZIC_WAKEUP0_OFFSET);
+	__raw_writel(0, tzic_base + TZIC_WAKEUP1_OFFSET);
+	__raw_writel(0, tzic_base + TZIC_WAKEUP2_OFFSET);
+	/* only enable irq wakeup for da9053 */
+	__raw_writel(GPIO7_0_11_IRQ_BIT, tzic_base + TZIC_WAKEUP3_OFFSET);
+	iounmap(tzic_base);
+	pr_debug("only da9053 irq is wakeup-enabled\n");
+}
+
+static int mx5_suspend_enter(suspend_state_t state)
+{
+	if (gpc_dvfs_clk == NULL)
+		gpc_dvfs_clk = clk_get(NULL, "gpc_dvfs_clk");
+	/* gpc clock is needed for SRPG */
+	clk_enable(gpc_dvfs_clk);
+	switch (state) {
+	case PM_SUSPEND_MEM:
+		mxc_cpu_lp_set(STOP_POWER_OFF);
+		break;
+	case PM_SUSPEND_STANDBY:
+		mxc_cpu_lp_set(WAIT_UNCLOCKED_POWER_OFF);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (tzic_enable_wake(0) != 0)
+		return -EAGAIN;
+
+	if (state == PM_SUSPEND_MEM) {
+		local_flush_tlb_all();
+		flush_cache_all();
+
+		if (pm_data && pm_data->suspend_enter)
+			pm_data->suspend_enter();
+
+		suspend_in_iram(suspend_param1);
+
+		if (pm_data && pm_data->suspend_exit)
+			pm_data->suspend_exit();
+	} else {
+			cpu_do_idle();
+	}
+	clk_disable(gpc_dvfs_clk);
+
+	return 0;
+}
+
+
+/*
+ * Called after processes are frozen, but before we shut down devices.
+ */
+static int mx5_suspend_prepare(void)
+{
+#if defined(CONFIG_CPU_FREQ)
+#define MX53_SUSPEND_CPU_WP 1000000000
+	struct cpufreq_freqs freqs;
+	u32 suspend_wp = 0;
+	org_freq = clk_get_rate(cpu_clk);
+	/* workaround for mx53 to suspend on 400MHZ wp */
+	if (cpu_is_mx53())
+		for (suspend_wp = 0; suspend_wp < cpu_op_nr; suspend_wp++)
+			if (cpu_op_tbl[suspend_wp].cpu_rate
+				== MX53_SUSPEND_CPU_WP)
+				break;
+	if (suspend_wp == cpu_op_nr)
+		suspend_wp = 0;
+	pr_info("suspend wp cpu=%d\n", cpu_op_tbl[suspend_wp].cpu_rate);
+	freqs.old = org_freq / 1000;
+	freqs.new = cpu_op_tbl[suspend_wp].cpu_rate / 1000;
+	freqs.cpu = 0;
+	freqs.flags = 0;
+
+	if (clk_get_rate(cpu_clk) != cpu_op_tbl[suspend_wp].cpu_rate) {
+		set_cpu_freq(cpu_op_tbl[suspend_wp].cpu_rate);
+		cpufreq_notify_transition(&freqs, CPUFREQ_PRECHANGE);
+		cpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);
+	}
+#endif
+	return 0;
+}
+
+/*
+ * Called before devices are re-setup.
+ */
+static void mx5_suspend_finish(void)
+{
+#if defined(CONFIG_CPU_FREQ)
+	struct cpufreq_freqs freqs;
+
+	freqs.old = clk_get_rate(cpu_clk) / 1000;
+	freqs.new = org_freq / 1000;
+	freqs.cpu = 0;
+	freqs.flags = 0;
+
+
+	if (org_freq != clk_get_rate(cpu_clk)) {
+		set_cpu_freq(org_freq);
+		cpufreq_notify_transition(&freqs, CPUFREQ_PRECHANGE);
+		cpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);
+	}
+#endif
+}
+
+/*
+ * Called after devices are re-setup, but before processes are thawed.
+ */
+static void mx5_suspend_end(void)
+{
+}
+
+static int mx5_pm_valid(suspend_state_t state)
+{
+	return (state > PM_SUSPEND_ON && state <= PM_SUSPEND_MAX);
+}
+
+struct platform_suspend_ops mx5_suspend_ops = {
+	.valid = mx5_pm_valid,
+	.prepare = mx5_suspend_prepare,
+	.enter = mx5_suspend_enter,
+	.finish = mx5_suspend_finish,
+	.end = mx5_suspend_end,
+};
+
+static int __devinit mx5_pm_probe(struct platform_device *pdev)
+{
+	pm_dev = &pdev->dev;
+	pm_data = pdev->dev.platform_data;
+
+	return 0;
+}
+
+static struct platform_driver mx5_pm_driver = {
+	.driver = {
+		   .name = "mx5_pm",
+		   },
+	.probe = mx5_pm_probe,
+};
+
+static int __init pm_init(void)
+{
+	unsigned long iram_paddr, cpaddr;
+
+	pr_info("Static Power Management for Freescale i.MX5\n");
+	if (platform_driver_register(&mx5_pm_driver) != 0) {
+		printk(KERN_ERR "mx5_pm_driver register failed\n");
+		return -ENODEV;
+	}
+	suspend_set_ops(&mx5_suspend_ops);
+	/* Move suspend routine into iRAM */
+	cpaddr = iram_alloc(SZ_4K, &iram_paddr);
+	/* Need to remap the area here since we want the memory region
+		 to be executable. */
+	suspend_iram_base = __arm_ioremap(iram_paddr, SZ_4K,
+					  MT_HIGH_VECTORS);
+	pr_info("cpaddr = %x suspend_iram_base=%x\n", cpaddr, suspend_iram_base);
+
+	if (cpu_is_mx51() || cpu_is_mx53()) {
+		suspend_param1 = MX51_IO_ADDRESS(MX51_IOMUXC_BASE_ADDR + 0x4b8);
+		memcpy(cpaddr, cpu_do_suspend_workaround,
+			SZ_4K);
+	} else if (cpu_is_mx50()) {
+		/*
+		 * Need to run the suspend code from IRAM as the DDR needs
+		 * to be put into self refresh mode manually.
+		 */
+		memcpy(suspend_iram_base, mx50_suspend, SZ_4K);
+
+		suspend_param1 = databahn_base;
+	}
+	suspend_in_iram = (void *)suspend_iram_base;
+
+	cpu_op_tbl = get_cpu_op(&cpu_op_nr);
+
+	cpu_clk = clk_get(NULL, "cpu_clk");
+	if (IS_ERR(cpu_clk)) {
+		printk(KERN_DEBUG "%s: failed to get cpu_clk\n", __func__);
+		return PTR_ERR(cpu_clk);
+	}
+	printk(KERN_INFO "PM driver module loaded\n");
+
+	return 0;
+}
+
+
+static void __exit pm_cleanup(void)
+{
+	/* Unregister the device structure */
+	platform_driver_unregister(&mx5_pm_driver);
+}
+
+module_init(pm_init);
+module_exit(pm_cleanup);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("PM driver");
+MODULE_LICENSE("GPL");
diff --git a/arch/arm/mach-mx5/sdram_autogating.c b/arch/arm/mach-mx5/sdram_autogating.c
new file mode 100755
index 0000000..ca75739
--- /dev/null
+++ b/arch/arm/mach-mx5/sdram_autogating.c
@@ -0,0 +1,201 @@
+/*
+ * Copyright (C) 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file sdram_autogating.c
+ *
+ * @brief Enable auto clock gating of the EMI_FAST clock using M4IF.
+ *
+ * The APIs are for enabling and disabling automatic clock gating of EMI_FAST.
+ *
+ * @ingroup PM
+ */
+#include <asm/io.h>
+#include <linux/proc_fs.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
+#include <mach/hardware.h>
+#include <mach/clock.h>
+#include <mach/sdram_autogating.h>
+#include "crm_regs.h"
+
+static struct device *sdram_autogating_dev;
+#define M4IF_CNTL_REG0		0x8c
+#define M4IF_CNTL_REG1		0x90
+
+/* Flag used to indicate if SDRAM M4IF autoclock gating feature is active. */
+static int sdram_autogating_is_active;
+static int sdram_autogating_paused;
+static void __iomem *m4if_base;
+
+void start_sdram_autogating(void);
+void stop_sdram_autogating(void);
+int sdram_autogating_active(void);
+
+static void enable(void)
+{
+	u32 reg;
+
+	/* Set the Fast arbitration Power saving timer */
+	reg = __raw_readl(m4if_base + M4IF_CNTL_REG1);
+	reg &= ~0xFF;
+	reg |= 0x09;
+	__raw_writel(reg, m4if_base + M4IF_CNTL_REG1);
+	/*Allow for automatic gating of the EMI internal clock.
+	 * If this is done, emi_intr CCGR bits should be set to 11.
+	 */
+	reg = __raw_readl(m4if_base + M4IF_CNTL_REG0);
+	reg &= ~0x5;
+	__raw_writel(reg, m4if_base + M4IF_CNTL_REG0);
+
+	sdram_autogating_is_active = 1;
+}
+
+static void disable(void)
+{
+	u32 reg;
+
+	reg = __raw_readl(m4if_base + M4IF_CNTL_REG0);
+	reg |= 0x4;
+	__raw_writel(reg, m4if_base + M4IF_CNTL_REG0);
+	sdram_autogating_is_active = 0;
+}
+
+int sdram_autogating_active()
+{
+	return sdram_autogating_is_active;
+}
+
+void start_sdram_autogating()
+{
+	if (cpu_is_mx50())
+		return;
+	if (sdram_autogating_paused) {
+		enable();
+		sdram_autogating_paused = 0;
+	}
+}
+
+void  stop_sdram_autogating()
+{
+	if (cpu_is_mx50())
+		return;
+
+	if (sdram_autogating_is_active) {
+		sdram_autogating_paused = 1;
+		disable();
+	}
+}
+
+static ssize_t sdram_autogating_enable_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	if (sdram_autogating_is_active)
+		return sprintf(buf,
+			"M4IF autoclock gating for EMI_FAST enabled\n");
+	else
+		return sprintf(buf,
+			"M4IF autoclock gating for EMI_FAST disabled\n");
+}
+
+static ssize_t sdram_autogating_enable_store(struct device *dev,
+				 struct device_attribute *attr,
+				 const char *buf, size_t size)
+{
+	if (strstr(buf, "1") != NULL)
+		enable();
+	else if (strstr(buf, "0") != NULL) {
+		if (sdram_autogating_is_active)
+			disable();
+	}
+	return size;
+}
+
+static DEVICE_ATTR(enable, 0644, sdram_autogating_enable_show,
+			sdram_autogating_enable_store);
+
+/*!
+ * This is the probe routine for the auto clockgating of sdram driver.
+ *
+ * @param   pdev   The platform device structure
+ *
+ * @return         The function returns 0 on success
+ *
+ */
+static int __devinit sdram_autogating_probe(struct platform_device *pdev)
+{
+	struct resource *res;
+	int err = 0;
+
+	sdram_autogating_dev = &pdev->dev;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		return -ENOMEM;
+	}
+	m4if_base = ioremap(res->start, res->end - res->start + 1);
+
+	err = sysfs_create_file(&sdram_autogating_dev->kobj,
+							&dev_attr_enable.attr);
+	if (err) {
+		printk(KERN_ERR
+		       "Unable to register sysdev entry for sdram_autogating");
+		return err;
+	}
+
+	sdram_autogating_is_active = 0;
+
+	return 0;
+}
+
+static struct platform_driver sdram_autogating_driver = {
+	.driver = {
+		   .name = "sdram_autogating",
+		},
+	.probe = sdram_autogating_probe,
+};
+
+/*!
+ * Initialise the sdram_autogating_driver.
+ *
+ * @return  The function always returns 0.
+ */
+
+static int __init sdram_autogating_init(void)
+{
+	if (platform_driver_register(&sdram_autogating_driver) != 0) {
+		printk(KERN_ERR "sdram_autogating_driver register failed\n");
+		return -ENODEV;
+	}
+
+	printk(KERN_INFO "sdram autogating driver module loaded\n");
+	return 0;
+}
+
+static void __exit sdram_autogating_cleanup(void)
+{
+	sysfs_remove_file(&sdram_autogating_dev->kobj, &dev_attr_enable.attr);
+
+	/* Unregister the device structure */
+	platform_driver_unregister(&sdram_autogating_driver);
+}
+
+module_init(sdram_autogating_init);
+module_exit(sdram_autogating_cleanup);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("sdram_autogating driver");
+MODULE_LICENSE("GPL");
+
diff --git a/arch/arm/mach-mx5/suspend.S b/arch/arm/mach-mx5/suspend.S
new file mode 100755
index 0000000..c7937ec
--- /dev/null
+++ b/arch/arm/mach-mx5/suspend.S
@@ -0,0 +1,162 @@
+/*
+ * Copyright (C) 2008-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/linkage.h>
+
+#define ARM_CTRL_DCACHE  1 << 2
+#define ARM_CTRL_ICACHE  1 << 12
+#define ARM_AUXCR_L2EN   1 << 1
+
+
+/*
+ *	cpu_do_suspend_workaround()
+ *
+ *	Suspend the processor (eg, wait for interrupt).
+ *
+ *	IRQs are already disabled.
+ */
+ENTRY(cpu_do_suspend_workaround)
+    stmfd   sp!, {r4,r5,r6,r7,r9,r10,r11}     @ Save registers
+
+   mov    r6, r0                       @save iomux address
+    /* Disable L1 caches */
+    mrc     p15, 0, r0, c1, c0, 0    @ R0 = system control reg
+    bic     r0, r0, #ARM_CTRL_ICACHE @ Disable ICache
+    bic     r0, r0, #ARM_CTRL_DCACHE @ Disable DCache
+    mcr     p15, 0, r0, c1, c0, 0    @ Update system control reg
+
+    mrc     p15, 1, r0, c0, c0, 1   @ Read CLIDR
+    ands    r3, r0, #0x7000000       @ Isolate level of coherency
+    mov     r3, r3, lsr #23         @ Cache level value (naturally aligned)
+    beq     FinishedClean
+    mov     r10, #0
+Loop1Clean:
+    add     r2, r10, r10, lsr #1    @ Work out cache level
+    mov     r1, r0, lsr r2          @ R0 bottom 3 bits = Cache Type for this level
+    and     r1, r1, #7              @ Get those 3 bits alone
+    cmp     r1, #2
+    blt     SkipClean                @ No cache or only instruction cache at this level
+    mcr     p15, 2, r10, c0, c0, 0  @ Write the Cache Size selection register
+    mov     r1, #0
+    .long   0xF57FF06F              @ ISB
+    mrc     p15, 1, r1, c0, c0, 0   @ Reads current Cache Size ID register
+    and     r2, r1, #7             @ Extract the line length field
+    add     r2, r2, #4              @ Add 4 for the line length offset (log2 16 bytes)
+    ldr     r4, =0x3FF
+    ands    r4, r4, r1, lsr #3      @ R4 is the max number on the way size (right aligned)
+    clz     r5, r4                  @ R5 is the bit position of the way size increment
+    ldr     r7, =0x00007FFF
+    ands    r7, r7, r1, lsr #13     @ R7 is the max number of the index size (right aligned)
+Loop2Clean:
+    mov     r9, r4                  @ R9 working copy of the max way size (right aligned)
+Loop3Clean:
+    orr     r11, r10, r9, lsl r5    @ Factor in the way number and cache number into R11
+    orr     r11, r11, r7, lsl r2    @ Factor in the index number
+    mcr     p15, 0, r11, c7, c14, 2 @ Clean and invalidate by set/way
+    subs    r9, r9, #1              @ Decrement the way number
+    bge     Loop3Clean
+    subs    r7, r7, #1              @ Decrement the index
+    bge     Loop2Clean
+SkipClean:
+    add     r10, r10, #2            @ Increment the cache number
+    cmp     r3, r10
+    bgt     Loop1Clean
+
+FinishedClean:
+
+    /* Disable L2 cache */
+    mrc     p15, 0, r0, c1, c0, 1   @ R0 = auxiliary control reg
+    bic     r0, r0, #ARM_AUXCR_L2EN @ Disable L2 cache
+    mcr     p15, 0, r0, c1, c0, 1   @ Update aux control reg
+
+#if 0
+	/*Set the DDR drive strength to low */
+	ldr        r10, [r6]
+	and       r10, r10, #0xF1        @ clear bits 2-1
+	str        r10, [r6]
+#endif
+
+    .long     0xe320f003              @ Opcode for WFI
+
+#if 0
+	/*Set the DDR drive strength to max */
+	orr       r10, r10, #0x06        @ set bits 2-1
+	str        r10, [r6]
+#endif
+
+	ldr     r11, =0x0000fFFF
+TestLoop:
+	subs    r11,r11, #1              @ Decrement the index
+	bge     TestLoop
+
+    mov     r0, #0
+    mcr     p15, 0, r0, c7, c5, 0   @ Invalidate inst cache
+
+    /* Invalidate data caches */
+    mrc     p15, 1, r0, c0, c0, 1   @ Read CLIDR
+    ands    r3, r0, #0x7000000      @ Isolate level of coherency
+    mov     r3, r3, lsr #23         @ Cache level value (naturally aligned)
+    beq     FinishedInvalidate
+    mov     r10, #0
+Loop1Invalidate:
+    add     r2, r10, r10, lsr #1    @ Work out cache level
+    mov     r1, r0, lsr r2          @ R0 bottom 3 bits = Cache Type for this level
+    and     r1, r1, #7              @ Get those 3 bits alone
+    cmp     r1, #2
+    blt     SkipInvalidate          @ No cache or only instruction cache at this level
+    mcr     p15, 2, r10, c0, c0, 0  @ Write the Cache Size selection register
+    mov     r1, #0
+    .long   0xF57FF06F              @ ISB
+    mrc     p15, 1, r1, c0, c0, 0   @ Reads current Cache Size ID register
+    and     r2, r1, #7              @ Extract the line length field
+    add     r2, r2, #4              @ Add 4 for the line length offset (log2 16 bytes)
+    ldr     r4, =0x3FF
+    ands    r4, r4, r1, lsr #3      @ R4 is the max number on the way size (right aligned)
+    clz     r5, r4                  @ R5 is the bit position of the way size increment
+    ldr     r7, =0x00007FFF
+    ands    r7, r7, r1, lsr #13     @ R7 is the max number of the index size (right aligned)
+Loop2Invalidate:
+    mov     r9, r4                  @ R9 working copy of the max way size (right aligned)
+Loop3Invalidate:
+    orr     r11, r10, r9, lsl r5    @ Factor in the way number and cache number into R11
+    orr     r11, r11, r7, lsl r2    @ Factor in the index number
+    mcr     p15, 0, r11, c7, c6, 2  @ Invalidate by set/way
+    subs    r9, r9, #1              @ Decrement the way number
+    bge     Loop3Invalidate
+    subs    r7, r7, #1              @ Decrement the index
+    bge     Loop2Invalidate
+SkipInvalidate:
+    add     r10, r10, #2            @ Increment the cache number
+    cmp     r3, r10
+    bgt     Loop1Invalidate
+
+FinishedInvalidate:
+
+    /* Enable L2 cache */
+    mrc     p15, 0, r0, c1, c0, 1   @ R0 = auxiliary control reg
+    orr     r0, r0, #ARM_AUXCR_L2EN @ Enable L2 cache
+    mcr     p15, 0, r0, c1, c0, 1   @ Update aux control reg
+
+    /* Enable L1 caches */
+    mrc     p15, 0, r0, c1, c0, 0    @ R0 = system control reg
+    orr     r0, r0, #ARM_CTRL_ICACHE @ Enable ICache
+    orr     r0, r0, #ARM_CTRL_DCACHE @ Enable DCache
+    mcr     p15, 0, r0, c1, c0, 0    @ Update system control reg
+
+    /* Restore registers */
+    ldmfd sp!, {r4,r5,r6,r7,r9,r10,r11}
+    mov		pc, lr
+
+	.type	cpu_do_suspend, #object
+ENTRY(cpu_do_suspend)
+	.word	cpu_do_suspend_workaround
+	.size	cpu_do_suspend_workaround, . - cpu_do_suspend_workaround
diff --git a/arch/arm/mach-mx5/system.c b/arch/arm/mach-mx5/system.c
old mode 100644
new mode 100755
index 76ae8dc..7066744
--- a/arch/arm/mach-mx5/system.c
+++ b/arch/arm/mach-mx5/system.c
@@ -17,7 +17,52 @@
 
 /* set cpu low power mode before WFI instruction. This function is called
   * mx5 because it can be used for mx50, mx51, and mx53.*/
-void mx5_cpu_lp_set(enum mxc_cpu_pwr_mode mode)
+
+#include <linux/kernel.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
+#include <asm/io.h>
+#include <mach/common.h>
+#include <mach/hardware.h>
+#include <mach/clock.h>
+#include <asm/proc-fns.h>
+#include <asm/system.h>
+#include "crm_regs.h"
+
+/*!
+ * @defgroup MSL_MX51 i.MX51 Machine Specific Layer (MSL)
+ */
+
+/*!
+ * @file mach-mx51/system.c
+ * @brief This file contains idle and reset functions.
+ *
+ * @ingroup MSL_MX51
+ */
+
+extern int mxc_jtag_enabled;
+extern int iram_ready;
+extern int dvfs_core_is_active;
+extern void __iomem *ccm_base;
+extern void __iomem *databahn_base;
+extern int low_bus_freq_mode;
+extern void (*wait_in_iram)(void *ccm_addr, void *databahn_addr);
+extern void mx50_wait(u32 ccm_base, u32 databahn_addr);
+extern void stop_dvfs(void);
+extern void *wait_in_iram_base;
+extern void __iomem *apll_base;
+
+static struct clk *gpc_dvfs_clk;
+static struct regulator *vpll;
+static struct clk *pll1_sw_clk;
+static struct clk *osc;
+static struct clk *pll1_main_clk;
+static struct clk *ddr_clk ;
+static int dvfs_core_paused;
+
+/* set cpu low power mode before WFI instruction */
+void mxc_cpu_lp_set(enum mxc_cpu_pwr_mode mode)
 {
 	u32 plat_lpc, arm_srpgcr, ccm_clpcr;
 	u32 empgc0, empgc1;
@@ -82,3 +127,158 @@ void mx5_cpu_lp_set(enum mxc_cpu_pwr_mode mode)
 		__raw_writel(empgc1, MXC_SRPG_EMPGC1_SRPGCR);
 	}
 }
+
+/* To change the idle power mode, need to set arch_idle_mode to a different
+ * power mode as in enum mxc_cpu_pwr_mode.
+ * May allow dynamically changing the idle mode.
+ */
+static int arch_idle_mode = WAIT_UNCLOCKED_POWER_OFF;
+/*!
+ * This function puts the CPU into idle mode. It is called by default_idle()
+ * in process.c file.
+ */
+void arch_idle(void)
+{
+	if (likely(!mxc_jtag_enabled)) {
+		if (ddr_clk == NULL)
+			ddr_clk = clk_get(NULL, "ddr_clk");
+		if (gpc_dvfs_clk == NULL)
+			gpc_dvfs_clk = clk_get(NULL, "gpc_dvfs_clk");
+		/* gpc clock is needed for SRPG */
+		clk_enable(gpc_dvfs_clk);
+		mxc_cpu_lp_set(arch_idle_mode);
+
+		if (cpu_is_mx50() && (clk_get_usecount(ddr_clk) == 0)) {
+			memcpy(wait_in_iram_base, mx50_wait, SZ_4K);
+			wait_in_iram = (void *)wait_in_iram_base;
+			if (low_bus_freq_mode) {
+				u32 reg, cpu_podf;
+
+				reg = __raw_readl(apll_base + 0x50);
+				reg = 0x120490;
+				__raw_writel(reg, apll_base + 0x50);
+				reg = __raw_readl(apll_base + 0x80);
+				reg |= 1;
+				__raw_writel(reg, apll_base + 0x80);
+
+				/* Move ARM to be sourced from 24MHz XTAL.
+				 * when ARM is in WFI.
+				 */
+				if (pll1_sw_clk == NULL)
+					pll1_sw_clk = clk_get(NULL,
+							"pll1_sw_clk");
+				if (osc == NULL)
+					osc = clk_get(NULL, "lp_apm");
+				if (pll1_main_clk == NULL)
+					pll1_main_clk = clk_get(NULL,
+							"pll1_main_clk");
+
+				clk_set_parent(pll1_sw_clk, osc);
+				/* Set the ARM-PODF divider to 1. */
+				cpu_podf = __raw_readl(MXC_CCM_CACRR);
+				__raw_writel(0x01, MXC_CCM_CACRR);
+
+				wait_in_iram(ccm_base, databahn_base);
+
+				/* Set the ARM-POD divider back
+				 * to the original.
+				 */
+				__raw_writel(cpu_podf, MXC_CCM_CACRR);
+				clk_set_parent(pll1_sw_clk, pll1_main_clk);
+			} else
+				wait_in_iram(ccm_base, databahn_base);
+		} else
+			cpu_do_idle();
+		clk_disable(gpc_dvfs_clk);
+		clk_put(ddr_clk);
+	}
+}
+
+static int __mxs_reset_block(void __iomem *hwreg, int just_enable)
+{
+	u32 c;
+	int timeout;
+
+	/* the process of software reset of IP block is done
+	   in several steps:
+
+	   - clear SFTRST and wait for block is enabled;
+	   - clear clock gating (CLKGATE bit);
+	   - set the SFTRST again and wait for block is in reset;
+	   - clear SFTRST and wait for reset completion.
+	 */
+	c = __raw_readl(hwreg);
+	c &= ~(1 << 31);	/* clear SFTRST */
+	__raw_writel(c, hwreg);
+	for (timeout = 1000000; timeout > 0; timeout--)
+		/* still in SFTRST state ? */
+		if ((__raw_readl(hwreg) & (1 << 31)) == 0)
+			break;
+	if (timeout <= 0) {
+		printk(KERN_ERR "%s(%p): timeout when enabling\n",
+		       __func__, hwreg);
+		return -ETIME;
+	}
+
+	c = __raw_readl(hwreg);
+	c &= ~(1 << 30);	/* clear CLKGATE */
+	__raw_writel(c, hwreg);
+
+	if (!just_enable) {
+		c = __raw_readl(hwreg);
+		c |= (1 << 31);	/* now again set SFTRST */
+		__raw_writel(c, hwreg);
+		for (timeout = 1000000; timeout > 0; timeout--)
+			/* poll until CLKGATE set */
+			if (__raw_readl(hwreg) & (1 << 30))
+				break;
+		if (timeout <= 0) {
+			printk(KERN_ERR "%s(%p): timeout when resetting\n",
+			       __func__, hwreg);
+			return -ETIME;
+		}
+
+		c = __raw_readl(hwreg);
+		c &= ~(1 << 31);	/* clear SFTRST */
+		__raw_writel(c, hwreg);
+		for (timeout = 1000000; timeout > 0; timeout--)
+			/* still in SFTRST state ? */
+			if ((__raw_readl(hwreg) & (1 << 31)) == 0)
+				break;
+		if (timeout <= 0) {
+			printk(KERN_ERR "%s(%p): timeout when enabling "
+			       "after reset\n", __func__, hwreg);
+			return -ETIME;
+		}
+
+		c = __raw_readl(hwreg);
+		c &= ~(1 << 30);	/* clear CLKGATE */
+		__raw_writel(c, hwreg);
+	}
+	for (timeout = 1000000; timeout > 0; timeout--)
+		/* still in SFTRST state ? */
+		if ((__raw_readl(hwreg) & (1 << 30)) == 0)
+			break;
+
+	if (timeout <= 0) {
+		printk(KERN_ERR "%s(%p): timeout when unclockgating\n",
+		       __func__, hwreg);
+		return -ETIME;
+	}
+
+	return 0;
+}
+
+int mxs_reset_block(void __iomem *hwreg, int just_enable)
+{
+	int try = 10;
+	int r;
+
+	while (try--) {
+		r = __mxs_reset_block(hwreg, just_enable);
+		if (!r)
+			break;
+		pr_debug("%s: try %d failed\n", __func__, 10 - try);
+	}
+	return r;
+}
diff --git a/arch/arm/mach-mx5/usb.h b/arch/arm/mach-mx5/usb.h
new file mode 100755
index 0000000..c059f74
--- /dev/null
+++ b/arch/arm/mach-mx5/usb.h
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2005-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <mach/common.h>
+#include "devices.h"
+
+extern int usbotg_init(struct platform_device *pdev);
+extern void usbotg_uninit(struct fsl_usb2_platform_data *pdata);
+extern struct platform_device *host_pdev_register(struct resource *res,
+		  int n_res, struct fsl_usb2_platform_data *config);
+
+extern int fsl_usb_host_init(struct platform_device *pdev);
+extern void fsl_usb_host_uninit(struct fsl_usb2_platform_data *pdata);
+extern int gpio_usbotg_utmi_active(void);
+extern void gpio_usbotg_utmi_inactive(void);
+
+extern void __init mx5_usb_dr_init(void);
+extern void __init mx5_usbh1_init(void);
+extern void __init mx5_usbh2_init(void);
+
+typedef void (*driver_vbus_func)(bool);
+extern void mx5_set_host1_vbus_func(driver_vbus_func);
+extern void mx5_set_otghost_vbus_func(driver_vbus_func);
+/*
+ * Used to set pdata->operating_mode before registering the platform_device.
+ * If OTG is configured, the controller operates in OTG mode,
+ * otherwise it's either host or device.
+ */
+#ifdef CONFIG_USB_OTG
+#define DR_UDC_MODE	FSL_USB2_DR_OTG
+#define DR_HOST_MODE	FSL_USB2_DR_OTG
+#else
+#define DR_UDC_MODE	FSL_USB2_DR_DEVICE
+#define DR_HOST_MODE	FSL_USB2_DR_HOST
+#endif
+
+extern void __iomem *imx_otg_base;
diff --git a/arch/arm/mach-mx5/usb_dr.c b/arch/arm/mach-mx5/usb_dr.c
new file mode 100755
index 0000000..3dd51d3
--- /dev/null
+++ b/arch/arm/mach-mx5/usb_dr.c
@@ -0,0 +1,334 @@
+/*
+ * Copyright (C) 2005-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <linux/fsl_devices.h>
+#include <mach/arc_otg.h>
+#include <mach/hardware.h>
+#include <linux/delay.h>
+#include "usb.h"
+static int usbotg_init_ext(struct platform_device *pdev);
+static void usbotg_uninit_ext(struct platform_device *pdev);
+static void usbotg_clock_gate(bool on);
+
+static struct clk *usb_phy1_clk;
+static struct clk *usb_oh3_clk;
+static struct clk *usb_ahb_clk;
+static void usbotg_wakeup_event_clear(void);
+extern int clk_get_usecount(struct clk *clk);
+
+/* Beginning of Common operation for DR port */
+
+/*
+ * platform data structs
+ * 	- Which one to use is determined by CONFIG options in usb.h
+ * 	- operating_mode plugged at run time
+ */
+static struct fsl_usb2_platform_data dr_utmi_config = {
+	.name              = "DR",
+	.init              = usbotg_init_ext,
+	.exit              = usbotg_uninit_ext,
+	.phy_mode          = FSL_USB2_PHY_UTMI_WIDE,
+	.power_budget      = 500,		/* 500 mA max power */
+	.usb_clock_for_pm  = usbotg_clock_gate,
+	.transceiver       = "utmi",
+};
+
+/* Platform data for wakeup operation */
+static struct fsl_usb2_wakeup_platform_data dr_wakeup_config = {
+	.name = "DR wakeup",
+	.usb_clock_for_pm  = usbotg_clock_gate,
+	.usb_wakeup_exhandle = usbotg_wakeup_event_clear,
+};
+/* Notes: configure USB clock*/
+static int usbotg_init_ext(struct platform_device *pdev)
+{
+	struct clk *usb_clk;
+
+	/* the usb_ahb_clk will be enabled in usb_otg_init */
+	usb_ahb_clk = clk_get(NULL, "usb_ahb_clk");
+
+	usb_clk = clk_get(NULL, "usboh3_clk");
+	clk_enable(usb_clk);
+	usb_oh3_clk = usb_clk;
+
+	usb_clk = clk_get(NULL, "usb_phy1_clk");
+	clk_enable(usb_clk);
+	usb_phy1_clk = usb_clk;
+
+	return usbotg_init(pdev);
+}
+
+static void usbotg_uninit_ext(struct platform_device *pdev)
+{
+	struct fsl_usb2_platform_data *pdata = pdev->dev.platform_data;
+
+	clk_disable(usb_phy1_clk);
+	clk_put(usb_phy1_clk);
+
+	clk_disable(usb_oh3_clk);
+	clk_put(usb_oh3_clk);
+
+	/* usb_ahb_clk will be disabled at usb_common.c */
+	usbotg_uninit(pdata);
+	clk_put(usb_ahb_clk);
+}
+
+/* Below two macros are used at otg mode to indicate usb mode*/
+#define ENABLED_BY_HOST   (0x1 << 0)
+#define ENABLED_BY_DEVICE (0x1 << 1)
+static u32 wakeup_irq_enable_src; /* only useful at otg mode */
+static void __wakeup_irq_enable(bool on, int source)
+ {
+	/* otg host and device share the OWIE bit, only when host and device
+	 * all enable the wakeup irq, we can enable the OWIE bit
+	 */
+	if (on) {
+#ifdef CONFIG_USB_OTG
+		wakeup_irq_enable_src |= source;
+		if (wakeup_irq_enable_src == (ENABLED_BY_HOST | ENABLED_BY_DEVICE)) {
+			USBCTRL |= UCTRL_OWIE;
+			USB_PHY_CTR_FUNC |= USB_UTMI_PHYCTRL_CONF2;
+		}
+#else
+		USBCTRL |= UCTRL_OWIE;
+		USB_PHY_CTR_FUNC |= USB_UTMI_PHYCTRL_CONF2;
+#endif
+	} else {
+		USB_PHY_CTR_FUNC &= ~USB_UTMI_PHYCTRL_CONF2;
+		USBCTRL &= ~UCTRL_OWIE;
+		wakeup_irq_enable_src &= ~source;
+		/* The interrupt must be disabled for at least 3 clock
+		 * cycles of the standby clock(32k Hz) , that is 0.094 ms*/
+		udelay(100);
+	}
+}
+
+static u32 low_power_enable_src; /* only useful at otg mode */
+static void __phy_lowpower_suspend(bool enable, int source)
+{
+	if (enable) {
+		low_power_enable_src |= source;
+#ifdef CONFIG_USB_OTG
+		if (low_power_enable_src == (ENABLED_BY_HOST | ENABLED_BY_DEVICE)) {
+			pr_debug("phy lowpower enabled\n");
+			UOG_PORTSC1 |= PORTSC_PHCD;
+		}
+#else
+		UOG_PORTSC1 |= PORTSC_PHCD;
+#endif
+	} else {
+		pr_debug("phy lowpower disable\n");
+		UOG_PORTSC1 &= ~PORTSC_PHCD;
+		low_power_enable_src &= ~source;
+	}
+}
+
+static void usbotg_clock_gate(bool on)
+{
+	pr_debug("%s: on is %d\n", __func__, on);
+	if (on) {
+		clk_enable(usb_ahb_clk);
+		clk_enable(usb_oh3_clk);
+		clk_enable(usb_phy1_clk);
+	} else {
+		clk_disable(usb_phy1_clk);
+		clk_disable(usb_oh3_clk);
+		clk_disable(usb_ahb_clk);
+	}
+	pr_debug("usb_ahb_ref_count:%d, usb_phy_clk1_ref_count:%d\n", clk_get_usecount(usb_ahb_clk), clk_get_usecount(usb_phy1_clk));
+}
+
+void mx5_set_otghost_vbus_func(driver_vbus_func driver_vbus)
+{
+	dr_utmi_config.platform_driver_vbus = driver_vbus;
+}
+
+/* The wakeup operation for DR port, it will clear the wakeup irq status
+ * and re-enable the wakeup
+ */
+static void usbotg_wakeup_event_clear(void)
+{
+	int wakeup_req = USBCTRL & UCTRL_OWIR;
+
+	if (wakeup_req != 0) {
+		printk(KERN_INFO "Unknown wakeup.(OTGSC 0x%x)\n", UOG_OTGSC);
+		/* Disable OWIE to clear OWIR, wait 3 clock
+		 * cycles of standly clock(32KHz)
+		 */
+		USBCTRL &= ~UCTRL_OWIE;
+		udelay(100);
+		USBCTRL |= UCTRL_OWIE;
+	}
+}
+/* End of Common operation for DR port */
+
+
+#ifdef CONFIG_USB_EHCI_ARC_OTG
+extern void fsl_usb_recover_hcd(struct platform_device *pdev);
+/* Beginning of host related operation for DR port */
+static void _host_wakeup_enable(struct fsl_usb2_platform_data *pdata, bool enable)
+{
+	__wakeup_irq_enable(enable, ENABLED_BY_HOST);
+	/* host only care the ID change wakeup event */
+	if (enable) {
+		pr_debug("host wakeup enable\n");
+		USBCTRL_HOST2 |= UCTRL_H2OIDWK_EN;
+	} else {
+		pr_debug("host wakeup disable\n");
+		USBCTRL_HOST2 &= ~UCTRL_H2OIDWK_EN;
+		/* The interrupt must be disabled for at least 3 clock
+		 * cycles of the standby clock(32k Hz) , that is 0.094 ms*/
+		udelay(100);
+	}
+}
+
+static void _host_phy_lowpower_suspend(struct fsl_usb2_platform_data *pdata, bool enable)
+{
+	__phy_lowpower_suspend(enable, ENABLED_BY_HOST);
+}
+
+static enum usb_wakeup_event _is_host_wakeup(struct fsl_usb2_platform_data *pdata)
+{
+	int wakeup_req = USBCTRL & UCTRL_OWIR;
+	int otgsc = UOG_OTGSC;
+
+	/* if ID change sts, it is a host wakeup event */
+	if (wakeup_req && (otgsc & OTGSC_IS_USB_ID)) {
+		printk(KERN_INFO "otg host ID wakeup\n");
+		/* if host ID wakeup, we must clear the b session change sts */
+		UOG_OTGSC = otgsc & (~OTGSC_IS_USB_ID);
+		return WAKEUP_EVENT_ID;
+	}
+	if (wakeup_req && (!(otgsc & OTGSC_STS_USB_ID))) {
+		printk(KERN_INFO "otg host Remote wakeup\n");
+		return WAKEUP_EVENT_DPDM;
+	}
+
+	return WAKEUP_EVENT_INVALID;
+}
+
+static void host_wakeup_handler(struct fsl_usb2_platform_data *pdata)
+{
+	_host_wakeup_enable(pdata, false);
+	_host_phy_lowpower_suspend(pdata, false);
+	fsl_usb_recover_hcd(&mxc_usbdr_host_device);
+}
+/* End of host related operation for DR port */
+#endif /* CONFIG_USB_EHCI_ARC_OTG */
+
+
+#ifdef CONFIG_USB_GADGET_ARC
+/* Beginning of device related operation for DR port */
+static void _device_wakeup_enable(struct fsl_usb2_platform_data *pdata, bool enable)
+{
+	__wakeup_irq_enable(enable, ENABLED_BY_DEVICE);
+	/* if udc is not used by any gadget, we can not enable the vbus wakeup */
+	if (!pdata->port_enables) {
+		USBCTRL_HOST2 &= ~UCTRL_H2OVBWK_EN;
+		return;
+	}
+	if (enable) {
+		pr_debug("device wakeup enable\n");
+		USBCTRL_HOST2 |= UCTRL_H2OVBWK_EN;
+	} else {
+		pr_debug("device wakeup disable\n");
+		USBCTRL_HOST2 &= ~UCTRL_H2OVBWK_EN;
+	}
+}
+
+static void _device_phy_lowpower_suspend(struct fsl_usb2_platform_data *pdata, bool enable)
+{
+	__phy_lowpower_suspend(enable, ENABLED_BY_DEVICE);
+}
+
+static enum usb_wakeup_event _is_device_wakeup(struct fsl_usb2_platform_data *pdata)
+{
+	int wakeup_req = USBCTRL & UCTRL_OWIR;
+	u32 otgsc = 0;
+
+	otgsc = UOG_OTGSC;
+	if (wakeup_req  &&
+		(otgsc & OTGSC_STS_USB_ID) &&
+		(otgsc & OTGSC_IS_B_SESSION_VALID)) {
+		printk(KERN_INFO "otg udc wakeup\n");
+		return WAKEUP_EVENT_VBUS;
+	}
+	return WAKEUP_EVENT_INVALID;
+
+}
+
+static void device_wakeup_handler(struct fsl_usb2_platform_data *pdata)
+{
+	_device_wakeup_enable(pdata, false);
+	_device_phy_lowpower_suspend(pdata, false);
+}
+
+/* end of device related operation for DR port */
+#endif /* CONFIG_USB_GADGET_ARC */
+
+#define MX53_OFFSET	0x20000000
+
+void __init mx5_usb_dr_init(void)
+{
+	int ret = 0;
+#ifdef CONFIG_USB_OTG
+	if (cpu_is_mx53() || cpu_is_mx50()) {
+		mxc_usbdr_otg_device.resource[0].start	-= MX53_OFFSET;
+		mxc_usbdr_otg_device.resource[0].end	-= MX53_OFFSET;
+	}
+	/* wake_up_enalbe is useless, just for usb_register_remote_wakeup execution*/
+	dr_utmi_config.wake_up_enable = _device_wakeup_enable;
+	dr_utmi_config.operating_mode = FSL_USB2_DR_OTG;
+	dr_utmi_config.wakeup_pdata = &dr_wakeup_config;
+	ret |= platform_device_add_data(&mxc_usbdr_otg_device, &dr_utmi_config, sizeof(dr_utmi_config));
+	ret |= platform_device_register(&mxc_usbdr_otg_device);
+	dr_wakeup_config.usb_pdata[0] = mxc_usbdr_otg_device.dev.platform_data;
+#endif
+#ifdef CONFIG_USB_EHCI_ARC_OTG
+	if (cpu_is_mx53() || cpu_is_mx50()) {
+		mxc_usbdr_host_device.resource[0].start	-= MX53_OFFSET;
+		mxc_usbdr_host_device.resource[0].end	-= MX53_OFFSET;
+	}
+	dr_utmi_config.operating_mode = DR_HOST_MODE;
+	dr_utmi_config.wake_up_enable = _host_wakeup_enable;
+	dr_utmi_config.phy_lowpower_suspend = _host_phy_lowpower_suspend;
+	dr_utmi_config.is_wakeup_event = _is_host_wakeup;
+	dr_utmi_config.wakeup_pdata = &dr_wakeup_config;
+	dr_utmi_config.wakeup_handler = host_wakeup_handler;
+	ret |= platform_device_add_data(&mxc_usbdr_host_device, &dr_utmi_config, sizeof(dr_utmi_config));
+	ret |= platform_device_register(&mxc_usbdr_host_device);
+	dr_wakeup_config.usb_pdata[1] = mxc_usbdr_host_device.dev.platform_data;
+#endif
+#ifdef CONFIG_USB_GADGET_ARC
+	if (cpu_is_mx53() || cpu_is_mx50()) {
+		mxc_usbdr_udc_device.resource[0].start	-= MX53_OFFSET;
+		mxc_usbdr_udc_device.resource[0].end	-= MX53_OFFSET;
+	}
+	dr_utmi_config.operating_mode = DR_UDC_MODE;
+	dr_utmi_config.wake_up_enable = _device_wakeup_enable;
+	dr_utmi_config.phy_lowpower_suspend = _device_phy_lowpower_suspend;
+	dr_utmi_config.is_wakeup_event = _is_device_wakeup;
+	dr_utmi_config.wakeup_pdata = &dr_wakeup_config;
+	dr_utmi_config.wakeup_handler = device_wakeup_handler;
+	ret |= platform_device_add_data(&mxc_usbdr_udc_device, &dr_utmi_config, sizeof(dr_utmi_config));
+	ret |= platform_device_register(&mxc_usbdr_udc_device);
+	dr_wakeup_config.usb_pdata[2] = mxc_usbdr_udc_device.dev.platform_data;
+#endif
+	ret |= mxc_register_device(&mxc_usbdr_wakeup_device, &dr_wakeup_config);
+	if (ret)
+		printk(KERN_ERR "%s(%d): error occures while init usb dr \n", __func__, __LINE__);
+}
diff --git a/arch/arm/mach-mx5/usb_h1.c b/arch/arm/mach-mx5/usb_h1.c
new file mode 100755
index 0000000..21ee87b
--- /dev/null
+++ b/arch/arm/mach-mx5/usb_h1.c
@@ -0,0 +1,272 @@
+/*
+ * Copyright (C) 2005-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <linux/fsl_devices.h>
+#include <linux/gpio.h>
+
+#include <asm/delay.h>
+#include <mach/arc_otg.h>
+#include <mach/iomux-mx51.h>
+#include <mach/iomux-mx53.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include "usb.h"
+
+static struct clk *usb_phy2_clk;
+static struct clk *usb_oh3_clk;
+static struct clk *usb_ahb_clk;
+extern int clk_get_usecount(struct clk *clk);
+
+#define MX5X_USBH1_STP		IMX_GPIO_NR(1, 27)
+#define MX51_3DS_PHY_RESET	IMX_GPIO_NR(2, 5)
+
+#ifdef CONFIG_USB_EHCI_ARC
+extern void fsl_usb_recover_hcd(struct platform_device *pdev);
+#else
+static void fsl_usb_recover_hcd(struct platform_device *pdev)
+{; }
+#endif
+/*
+ * USB Host1 HS port
+ */
+static int gpio_usbh1_active(void)
+{
+	iomux_v3_cfg_t usbh1stp_gpio = MX51_PAD_USBH1_STP__GPIO1_27;
+	iomux_v3_cfg_t phyreset_gpio = MX51_PAD_EIM_D17__GPIO2_1;
+	int ret;
+
+	/* Set USBH1_STP to GPIO and toggle it */
+	mxc_iomux_v3_setup_pad(usbh1stp_gpio);
+	ret = gpio_request(MX5X_USBH1_STP, "usbh1_stp");
+
+	if (ret) {
+		pr_debug("failed to get MX51_PAD_USBH1_STP__GPIO_1_27: %d\n", ret);
+		return ret;
+	}
+	gpio_direction_output(MX5X_USBH1_STP, 0);
+	gpio_set_value(MX5X_USBH1_STP, 1);
+
+	/* Signal only used on MX51-3DS for reset to PHY.*/
+	if (machine_is_mx51_3ds()) {
+		mxc_iomux_v3_setup_pad(phyreset_gpio);
+		ret = gpio_request(MX51_3DS_PHY_RESET, "eim_d17");
+		if (ret) {
+			pr_debug("failed to get MX51_PAD_EIM_D17__GPIO2_1: %d\n", ret);
+			return ret;
+		}
+		gpio_direction_output(MX51_3DS_PHY_RESET, 0);
+		gpio_set_value(MX51_3DS_PHY_RESET, 1);
+	}
+
+	msleep(100);
+
+	return 0;
+}
+
+static void gpio_usbh1_inactive(void)
+{
+	/* Signal only used on MX51-3DS for reset to PHY.*/
+	if (machine_is_mx51_3ds()) {
+		gpio_free(MX51_3DS_PHY_RESET);
+	}
+	gpio_free(MX5X_USBH1_STP);
+}
+
+
+static void _wake_up_enable(struct fsl_usb2_platform_data *pdata, bool enable)
+{
+	pr_debug("host1, %s, enable is %d\n", __func__, enable);
+	if (enable)
+		USBCTRL |= UCTRL_H1WIE;
+	else {
+		USBCTRL &= ~UCTRL_H1WIE;
+		/* The interrupt must be disabled for at least 3
+		* cycles of the standby clock(32k Hz) , that is 0.094 ms*/
+		udelay(100);
+	}
+}
+
+static void _phy_lowpower_suspend(struct fsl_usb2_platform_data *pdata, bool enable)
+{
+	pr_debug("host1, %s, enable is %d\n", __func__, enable);
+	if (enable) {
+		UH1_PORTSC1 |= PORTSC_PHCD;
+	} else {
+		UH1_PORTSC1 &= ~PORTSC_PHCD;
+	}
+}
+
+static void usbh1_clock_gate(bool on)
+{
+	pr_debug("%s: on is %d\n", __func__, on);
+	if (on) {
+		clk_enable(usb_ahb_clk);
+		clk_enable(usb_oh3_clk);
+		clk_enable(usb_phy2_clk);
+	} else {
+		clk_disable(usb_phy2_clk);
+		clk_disable(usb_oh3_clk);
+		clk_disable(usb_ahb_clk);
+	}
+}
+
+static enum usb_wakeup_event _is_usbh1_wakeup(struct fsl_usb2_platform_data *pdata)
+{
+	int wakeup_req = USBCTRL & UCTRL_H1WIR;
+
+	if (wakeup_req)
+		return !WAKEUP_EVENT_INVALID;
+
+	return WAKEUP_EVENT_INVALID;
+}
+
+static void h1_wakeup_handler(struct fsl_usb2_platform_data *pdata)
+{
+	_wake_up_enable(pdata, false);
+	_phy_lowpower_suspend(pdata, false);
+	fsl_usb_recover_hcd(&mxc_usbh1_device);
+}
+
+static void usbh1_wakeup_event_clear(void)
+{
+	int wakeup_req = USBCTRL & UCTRL_H1WIR;
+
+	if (wakeup_req != 0) {
+		printk(KERN_INFO "Unknown wakeup.(OTGSC 0x%x)\n", UOG_OTGSC);
+		/* Disable H1WIE to clear H1WIR, wait 3 clock
+		 * cycles of standly clock(32KHz)
+		 */
+		USBCTRL &= ~UCTRL_H1WIE;
+		udelay(100);
+		USBCTRL |= UCTRL_H1WIE;
+	}
+}
+static int fsl_usb_host_init_ext(struct platform_device *pdev)
+{
+	int ret;
+	struct clk *usb_clk;
+
+	/* the usb_ahb_clk will be enabled in usb_otg_init */
+	usb_ahb_clk = clk_get(NULL, "usb_ahb_clk");
+
+	if (cpu_is_mx53()) {
+		usb_clk = clk_get(NULL, "usboh3_clk");
+		clk_enable(usb_clk);
+		usb_oh3_clk = usb_clk;
+
+		usb_clk = clk_get(NULL, "usb_phy2_clk");
+		clk_enable(usb_clk);
+		usb_phy2_clk = usb_clk;
+	} else if (cpu_is_mx50()) {
+		usb_clk = clk_get(NULL, "usb_phy2_clk");
+		clk_enable(usb_clk);
+		usb_phy2_clk = usb_clk;
+	} else if (cpu_is_mx51()) {
+		usb_clk = clk_get(NULL, "usboh3_clk");
+		clk_enable(usb_clk);
+		usb_oh3_clk = usb_clk;
+	}
+
+	ret = fsl_usb_host_init(pdev);
+	if (ret)
+		return ret;
+
+	if (cpu_is_mx51()) {
+		/* setback USBH1_STP to be function */
+#if 0	/* Jasper: Need to do... */
+		mxc_request_iomux(MX51_PIN_USBH1_STP, IOMUX_CONFIG_ALT0);
+		mxc_iomux_set_pad(MX51_PIN_USBH1_STP, PAD_CTL_SRE_FAST |
+				  PAD_CTL_DRV_HIGH | PAD_CTL_ODE_OPENDRAIN_NONE |
+				  PAD_CTL_PUE_KEEPER | PAD_CTL_PKE_ENABLE |
+				  PAD_CTL_HYS_ENABLE | PAD_CTL_DDR_INPUT_CMOS |
+				  PAD_CTL_DRV_VOT_LOW);
+		gpio_free(IOMUX_TO_GPIO(MX51_PIN_USBH1_STP));
+#endif
+	}
+
+	/* disable remote wakeup irq */
+	USBCTRL &= ~UCTRL_H1WIE;
+	return 0;
+}
+
+static void fsl_usb_host_uninit_ext(struct platform_device *pdev)
+{
+	struct fsl_usb2_platform_data *pdata = pdev->dev.platform_data;
+	if (cpu_is_mx53()) {
+		clk_disable(usb_oh3_clk);
+		clk_put(usb_oh3_clk);
+
+		clk_disable(usb_phy2_clk);
+		clk_put(usb_phy2_clk);
+	} else if (cpu_is_mx50()) {
+		clk_disable(usb_phy2_clk);
+		clk_put(usb_phy2_clk);
+	} else if (cpu_is_mx51()) {
+		clk_disable(usb_oh3_clk);
+		clk_put(usb_oh3_clk);
+	}
+
+	fsl_usb_host_uninit(pdata);
+	/* usb_ahb_clk will be disabled at usb_common.c */
+	clk_put(usb_ahb_clk);
+}
+
+static struct fsl_usb2_platform_data usbh1_config = {
+	.name		= "Host 1",
+	.init		= fsl_usb_host_init_ext,
+	.exit		= fsl_usb_host_uninit_ext,
+	.operating_mode = FSL_USB2_MPH_HOST,
+	.phy_mode = FSL_USB2_PHY_UTMI_WIDE,
+	.power_budget = 500,	/* 500 mA max power */
+	.wake_up_enable = _wake_up_enable,
+	.usb_clock_for_pm  = usbh1_clock_gate,
+	.phy_lowpower_suspend = _phy_lowpower_suspend,
+	.is_wakeup_event = _is_usbh1_wakeup,
+	.wakeup_handler = h1_wakeup_handler,
+	.transceiver = "utmi",
+};
+static struct fsl_usb2_wakeup_platform_data usbh1_wakeup_config = {
+		.name = "USBH1 wakeup",
+		.usb_clock_for_pm  = usbh1_clock_gate,
+		.usb_pdata = {&usbh1_config, NULL, NULL},
+		.usb_wakeup_exhandle = usbh1_wakeup_event_clear,
+};
+
+void mx5_set_host1_vbus_func(driver_vbus_func driver_vbus)
+{
+	usbh1_config.platform_driver_vbus = driver_vbus;
+}
+
+#define MX53_OFFSET	0x20000000
+void __init mx5_usbh1_init(void)
+{
+	if (cpu_is_mx51()) {
+		usbh1_config.phy_mode = FSL_USB2_PHY_ULPI;
+		usbh1_config.transceiver = "isp1504";
+		usbh1_config.gpio_usb_active = gpio_usbh1_active;
+		usbh1_config.gpio_usb_inactive = gpio_usbh1_inactive;
+	}
+	if (cpu_is_mx53() || cpu_is_mx50()) {
+		mxc_usbh1_device.resource[0].start	-= MX53_OFFSET;
+		mxc_usbh1_device.resource[0].end	-= MX53_OFFSET;
+	}
+	mxc_register_device(&mxc_usbh1_device, &usbh1_config);
+	usbh1_config.wakeup_pdata = &usbh1_wakeup_config;
+	mxc_register_device(&mxc_usbh1_wakeup_device, &usbh1_wakeup_config);
+}
+
diff --git a/arch/arm/mach-mx5/usb_h2.c b/arch/arm/mach-mx5/usb_h2.c
new file mode 100755
index 0000000..b7f146a
--- /dev/null
+++ b/arch/arm/mach-mx5/usb_h2.c
@@ -0,0 +1,215 @@
+/*
+ * Copyright (C) 2005-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+#include <linux/fsl_devices.h>
+
+#include <mach/arc_otg.h>
+#include <mach/iomux-mx51.h>
+#include <mach/iomux-mx53.h>
+#include "usb.h"
+
+#define MX5X_USBH2_STP	IMX_GPIO_NR(2, 20)
+
+#ifdef CONFIG_USB_EHCI_ARC
+extern void fsl_usb_recover_hcd(struct platform_device *pdev);
+#else
+static void fsl_usb_recover_hcd(struct platform_device *pdev)
+{; }
+#endif
+/*
+ * USB Host2 HS port
+ */
+static int gpio_usbh2_active(void)
+{
+	iomux_v3_cfg_t usbh2stp_gpio = MX51_PAD_EIM_A26__GPIO2_20;
+	int ret = 0;
+
+	/* Set USBH2_STP to GPIO and toggle it */
+	mxc_iomux_v3_setup_pad(usbh2stp_gpio);
+	ret = gpio_request(MX5X_USBH2_STP, "eim_a26");
+	if (ret) {
+		pr_debug("failed to get MX51_PAD_EIM_A26__GPIO2_20: %d\n", ret);
+		return ret;
+	}
+
+	gpio_direction_output(MX5X_USBH2_STP, 0);
+	gpio_set_value(MX5X_USBH2_STP, 1);
+	msleep(100);
+
+	return 0;
+}
+
+static void gpio_usbh2_inactive(void)
+{
+	gpio_free(MX5X_USBH2_STP);
+}
+
+static void _wake_up_enable(struct fsl_usb2_platform_data *pdata, bool enable)
+{
+	printk(KERN_DEBUG "host2, %s, enable is %d\n", __func__, enable);
+	if (enable)
+		USBCTRL_HOST2 |= UCTRL_H2WIE;
+	else {
+		USBCTRL_HOST2 &= ~UCTRL_H2WIE;
+		/* The interrupt must be disabled for at least 3
+		* cycles of the standby clock(32k Hz) , that is 0.094 ms*/
+		udelay(100);
+	}
+}
+
+static void _phy_lowpower_suspend(struct fsl_usb2_platform_data *pdata, bool enable)
+{
+	printk(KERN_DEBUG "host2, %s, enable is %d\n", __func__, enable);
+	if (enable) {
+		UH2_PORTSC1 |= PORTSC_PHCD;
+	} else {
+		UH2_PORTSC1 &= ~PORTSC_PHCD;
+	}
+}
+
+static void fsl_usbh2_clock_gate(bool on)
+{
+	struct clk *usb_clk;
+	if (on) {
+		usb_clk = clk_get(NULL, "usb_ahb_clk");
+		clk_enable(usb_clk);
+		clk_put(usb_clk);
+
+		usb_clk = clk_get(NULL, "usboh3_clk");
+		clk_enable(usb_clk);
+		clk_put(usb_clk);
+	} else {
+		usb_clk = clk_get(NULL, "usb_ahb_clk");
+		clk_disable(usb_clk);
+		clk_put(usb_clk);
+
+		usb_clk = clk_get(NULL, "usboh3_clk");
+		clk_disable(usb_clk);
+		clk_put(usb_clk);
+	}
+}
+
+static enum usb_wakeup_event _is_usbh2_wakeup(struct fsl_usb2_platform_data *pdata)
+{
+	int wakeup_req = USBCTRL & UCTRL_H2WIR;
+
+	if (wakeup_req)
+		return !WAKEUP_EVENT_INVALID;
+
+	return WAKEUP_EVENT_INVALID;
+}
+
+static void h2_wakeup_handler(struct fsl_usb2_platform_data *pdata)
+{
+	_wake_up_enable(pdata, false);
+	_phy_lowpower_suspend(pdata, false);
+	fsl_usb_recover_hcd(&mxc_usbh2_device);
+}
+
+static void usbh2_wakeup_event_clear(void)
+{
+	int wakeup_req = USBCTRL & UCTRL_H2WIR;
+
+	if (wakeup_req != 0) {
+		printk(KERN_INFO "Unknown wakeup.(OTGSC 0x%x)\n", UOG_OTGSC);
+		/* Disable H2WIE to clear H2WIR, wait 3 clock
+		 * cycles of standly clock(32KHz)
+		 */
+		USBCTRL &= ~UCTRL_H2WIE;
+		udelay(100);
+		USBCTRL |= UCTRL_H2WIE;
+	}
+}
+static int fsl_usb_host_init_ext(struct platform_device *pdev)
+{
+	int ret = 0;
+	struct clk *usb_clk;
+
+	usb_clk = clk_get(NULL, "usboh3_clk");
+	clk_enable(usb_clk);
+	clk_put(usb_clk);
+
+	/* on mx53, there is a hardware limitation that when switch the host2's clk mode
+	 * ,usb phy1 clk must be on, after finish switching this clk can be off */
+	if (cpu_is_mx53()) {
+		usb_clk = clk_get(NULL, "usb_phy1_clk");
+		clk_enable(usb_clk);
+		clk_put(usb_clk);
+	}
+
+	ret = fsl_usb_host_init(pdev);
+
+	if (cpu_is_mx53()) {
+		usb_clk = clk_get(NULL, "usb_phy1_clk");
+		clk_disable(usb_clk);
+		clk_put(usb_clk);
+	}
+
+	/* setback USBH2_STP to be function */
+	mxc_iomux_v3_setup_pad(MX51_PAD_EIM_A26__USBH2_STP);
+
+	return ret;
+}
+
+static void fsl_usb_host_uninit_ext(struct platform_device *pdev)
+{
+	struct fsl_usb2_platform_data *pdata = pdev->dev.platform_data;
+	struct clk *usb_clk;
+
+	usb_clk = clk_get(NULL, "usboh3_clk");
+	clk_disable(usb_clk);
+	clk_put(usb_clk);
+
+	fsl_usb_host_uninit(pdata);
+}
+
+static struct fsl_usb2_platform_data usbh2_config = {
+	.name		= "Host 2",
+	.init		= fsl_usb_host_init_ext,
+	.exit		= fsl_usb_host_uninit_ext,
+	.operating_mode = FSL_USB2_MPH_HOST,
+	.phy_mode = FSL_USB2_PHY_ULPI,
+	.power_budget = 500,	/* 500 mA max power */
+	.wake_up_enable = _wake_up_enable,
+	.usb_clock_for_pm  = fsl_usbh2_clock_gate,
+	.phy_lowpower_suspend = _phy_lowpower_suspend,
+	.gpio_usb_active = gpio_usbh2_active,
+	.gpio_usb_inactive = gpio_usbh2_inactive,
+	.is_wakeup_event = _is_usbh2_wakeup,
+	.wakeup_handler = h2_wakeup_handler,
+	.transceiver = "isp1504",
+};
+static struct fsl_usb2_wakeup_platform_data usbh2_wakeup_config = {
+	.name = "USBH2 wakeup",
+	.usb_clock_for_pm  = fsl_usbh2_clock_gate,
+	.usb_pdata = {&usbh2_config, NULL, NULL},
+	.usb_wakeup_exhandle = usbh2_wakeup_event_clear,
+};
+
+#define MX53_OFFSET	0x20000000
+void __init mx5_usbh2_init(void)
+{
+	if (cpu_is_mx53() || cpu_is_mx50()) {
+		mxc_usbh2_device.resource[0].start	-= MX53_OFFSET;
+		mxc_usbh2_device.resource[0].end	-= MX53_OFFSET;
+	}
+	usbh2_config.wakeup_pdata = &usbh2_wakeup_config;
+	mxc_register_device(&mxc_usbh2_device, &usbh2_config);
+	mxc_register_device(&mxc_usbh2_wakeup_device, &usbh2_wakeup_config);
+}
diff --git a/arch/arm/plat-mxc/Kconfig b/arch/arm/plat-mxc/Kconfig
old mode 100644
new mode 100755
index a5353fc..7da7344
--- a/arch/arm/plat-mxc/Kconfig
+++ b/arch/arm/plat-mxc/Kconfig
@@ -54,6 +54,17 @@ source "arch/arm/mach-imx/Kconfig"
 source "arch/arm/mach-mx5/Kconfig"
 
 endmenu
+## Freescale private USB driver support
+# set if we need the 1504 transceiver
+config ISP1504_MXC
+	bool
+	default y
+
+# set if we need the UTMI transceiver
+config UTMI_MXC
+	bool
+	default y
+	depends on ARCH_MX25 || ARCH_MX35 || ARCH_MX37 || ARCH_MX5
 
 config MXC_IRQ_PRIOR
 	bool "Use IRQ priority"
@@ -120,6 +131,14 @@ config ARCH_MXC_AUDMUX_V2
 
 config IRAM_ALLOC
 	bool
+        default y
 	select GENERIC_ALLOCATOR
 
+config DMA_ZONE_SIZE
+        int "DMA memory zone size"
+        range 0 96
+        default 24
+        help
+          This is the size in MB for the DMA zone. The DMA zone is used for
+          dedicated memory for large contiguous video buffers
 endif
diff --git a/arch/arm/plat-mxc/Makefile b/arch/arm/plat-mxc/Makefile
old mode 100644
new mode 100755
index a138787..3500b76
--- a/arch/arm/plat-mxc/Makefile
+++ b/arch/arm/plat-mxc/Makefile
@@ -3,7 +3,7 @@
 #
 
 # Common support
-obj-y := clock.o gpio.o time.o devices.o cpu.o system.o irq-common.o
+obj-y := clock.o gpio.o time.o devices.o cpu.o system.o irq-common.o usb_common.o usb_wakeup.o
 
 # MX51 uses the TZIC interrupt controller, older platforms use AVIC
 obj-$(CONFIG_MXC_TZIC) += tzic.o
@@ -25,3 +25,13 @@ obj-y += ssi-fiq-ksym.o
 endif
 
 obj-y += devices/
+
+obj-$(CONFIG_ARCH_MX5) += dvfs_core.o
+
+# DVFS-PER support
+obj-$(CONFIG_MXC_DVFS_PER) 	+= dvfs_per.o
+
+# USB support
+obj-$(CONFIG_ISP1504_MXC) += isp1504xc.o
+obj-$(CONFIG_UTMI_MXC)    += utmixc.o
+obj-$(CONFIG_USB)         += serialxc.o
diff --git a/arch/arm/plat-mxc/clock.c b/arch/arm/plat-mxc/clock.c
old mode 100644
new mode 100755
index 2ed3ab1..2c9bfa1
--- a/arch/arm/plat-mxc/clock.c
+++ b/arch/arm/plat-mxc/clock.c
@@ -4,7 +4,7 @@
  * Copyright (C) 2004 - 2005 Nokia corporation
  * Written by Tuukka Tikkanen <tuukka.tikkanen@elektrobit.com>
  * Modified for omap shared clock framework by Tony Lindgren <tony@atomide.com>
- * Copyright 2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2007-2011 Freescale Semiconductor, Inc. All Rights Reserved.
  * Copyright 2008 Juergen Beisert, kernel@pengutronix.de
  *
  * This program is free software; you can redistribute it and/or
@@ -110,6 +110,25 @@ void clk_disable(struct clk *clk)
 }
 EXPORT_SYMBOL(clk_disable);
 
+/*!
+ * @brief Function to get the usage count for the requested clock.
+ *
+ * This function returns the reference count for the clock.
+ *
+ * @param clk 	Handle to clock to disable.
+ *
+ * @return Returns the usage count for the requested clock.
+ */
+int clk_get_usecount(struct clk *clk)
+{
+	if (clk == NULL || IS_ERR(clk))
+		return 0;
+
+	return clk->usecount;
+}
+
+EXPORT_SYMBOL(clk_get_usecount);
+
 /* Retrieve the *current* clock rate. If the clock itself
  * does not provide a special calculation routine, ask
  * its parent and so on, until one is able to return
diff --git a/arch/arm/plat-mxc/cpu.c b/arch/arm/plat-mxc/cpu.c
old mode 100644
new mode 100755
index 386e0d5..ef5a062
--- a/arch/arm/plat-mxc/cpu.c
+++ b/arch/arm/plat-mxc/cpu.c
@@ -9,3 +9,25 @@ void mxc_set_cpu_type(unsigned int type)
 	__mxc_cpu_type = type;
 }
 
+int mxc_jtag_enabled;		/* OFF: 0 (default), ON: 1 */
+int uart_at_24; 			/* OFF: 0 (default); ON: 1 */
+/*
+ * Here are the JTAG options from the command line. By default JTAG
+ * is OFF which means JTAG is not connected and WFI is enabled
+ *
+ *       "on" --  JTAG is connected, so WFI is disabled
+ *       "off" -- JTAG is disconnected, so WFI is enabled
+ */
+
+static int __init jtag_wfi_setup(char *p)
+{
+	if (memcmp(p, "on", 2) == 0) {
+		mxc_jtag_enabled = 1;
+		p += 2;
+	} else if (memcmp(p, "off", 3) == 0) {
+		mxc_jtag_enabled = 0;
+		p += 3;
+	}
+	return 0;
+}
+early_param("jtag", jtag_wfi_setup);
diff --git a/arch/arm/plat-mxc/cpufreq.c b/arch/arm/plat-mxc/cpufreq.c
old mode 100644
new mode 100755
index 74aac96..24a6d35
--- a/arch/arm/plat-mxc/cpufreq.c
+++ b/arch/arm/plat-mxc/cpufreq.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2010-2011 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -38,7 +38,7 @@ static struct cpufreq_frequency_table *imx_freq_table;
 static int cpu_op_nr;
 static struct cpu_op *cpu_op_tbl;
 
-static int set_cpu_freq(int freq)
+int set_cpu_freq(int freq)
 {
 	int ret = 0;
 	int org_cpu_rate;
diff --git a/arch/arm/plat-mxc/devices/Kconfig b/arch/arm/plat-mxc/devices/Kconfig
old mode 100644
new mode 100755
index bd294ad..bdc3104
--- a/arch/arm/plat-mxc/devices/Kconfig
+++ b/arch/arm/plat-mxc/devices/Kconfig
@@ -15,15 +15,19 @@ config IMX_HAVE_PLATFORM_GPIO_KEYS
 
 config IMX_HAVE_PLATFORM_IMX21_HCD
 	bool
-	
+
 config IMX_HAVE_PLATFORM_IMX2_WDT
 	bool
 
 config IMX_HAVE_PLATFORM_IMXDI_RTC
 	bool
 
+config IMX_HAVE_PLATFORM_IMX_SRTC
+	bool
+
 config IMX_HAVE_PLATFORM_IMX_FB
 	bool
+	select HAVE_FB_IMX
 
 config IMX_HAVE_PLATFORM_IMX_I2C
 	bool
@@ -76,3 +80,24 @@ config IMX_HAVE_PLATFORM_SDHCI_ESDHC_IMX
 
 config IMX_HAVE_PLATFORM_SPI_IMX
 	bool
+
+config IMX_HAVE_PLATFORM_IMX_IPUV3
+	bool
+
+config IMX_HAVE_PLATFORM_IMX_TVE
+	bool
+
+config IMX_HAVE_PLATFORM_IMX_VPU
+	bool
+
+config IMX_HAVE_PLATFORM_IMX_DVFS
+	bool
+
+config IMX_HAVE_PLATFORM_SATA_AHCI
+	bool
+
+config IMX_HAVE_PLATFORM_IMX_IIM
+	bool
+
+config IMX_HAVE_PLATFORM_MXC_GPU
+	bool
diff --git a/arch/arm/plat-mxc/devices/Makefile b/arch/arm/plat-mxc/devices/Makefile
old mode 100644
new mode 100755
index ad2922a..2d317a9
--- a/arch/arm/plat-mxc/devices/Makefile
+++ b/arch/arm/plat-mxc/devices/Makefile
@@ -5,6 +5,7 @@ obj-$(CONFIG_IMX_HAVE_PLATFORM_GPIO_KEYS) += platform-gpio_keys.o
 obj-$(CONFIG_IMX_HAVE_PLATFORM_IMX21_HCD) += platform-imx21-hcd.o
 obj-$(CONFIG_IMX_HAVE_PLATFORM_IMX2_WDT) += platform-imx2-wdt.o
 obj-$(CONFIG_IMX_HAVE_PLATFORM_IMXDI_RTC) += platform-imxdi_rtc.o
+obj-$(CONFIG_IMX_HAVE_PLATFORM_IMX_SRTC) += platform-imx_srtc.o
 obj-y += platform-imx-dma.o
 obj-$(CONFIG_IMX_HAVE_PLATFORM_IMX_FB) += platform-imx-fb.o
 obj-$(CONFIG_IMX_HAVE_PLATFORM_IMX_I2C) += platform-imx-i2c.o
@@ -24,3 +25,10 @@ obj-$(CONFIG_IMX_HAVE_PLATFORM_MXC_RTC) += platform-mxc_rtc.o
 obj-$(CONFIG_IMX_HAVE_PLATFORM_MXC_W1) += platform-mxc_w1.o
 obj-$(CONFIG_IMX_HAVE_PLATFORM_SDHCI_ESDHC_IMX) += platform-sdhci-esdhc-imx.o
 obj-$(CONFIG_IMX_HAVE_PLATFORM_SPI_IMX) +=  platform-spi_imx.o
+obj-$(CONFIG_IMX_HAVE_PLATFORM_IMX_IPUV3) +=  platform-imx_ipuv3.o
+obj-$(CONFIG_IMX_HAVE_PLATFORM_IMX_TVE) += platform-imx_tve.o
+obj-$(CONFIG_IMX_HAVE_PLATFORM_IMX_VPU) +=  platform-imx_vpu.o
+obj-$(CONFIG_IMX_HAVE_PLATFORM_IMX_DVFS) +=  platform-imx_dvfs.o
+obj-$(CONFIG_IMX_HAVE_PLATFORM_SATA_AHCI) +=  platform-ahci-imx.o
+obj-$(CONFIG_IMX_HAVE_PLATFORM_IMX_IIM)	+= platform-imx-iim.o
+obj-$(CONFIG_IMX_HAVE_PLATFORM_MXC_GPU) +=  platform-mxc_gpu.o
diff --git a/arch/arm/plat-mxc/devices/platform-ahci-imx.c b/arch/arm/plat-mxc/devices/platform-ahci-imx.c
new file mode 100755
index 0000000..9f730f1
--- /dev/null
+++ b/arch/arm/plat-mxc/devices/platform-ahci-imx.c
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <asm/sizes.h>
+#include <mach/hardware.h>
+#include <mach/devices-common.h>
+
+#define imx_ahci_data_entry_single(soc)					\
+	{								\
+		.iobase = soc ## _SATA_BASE_ADDR,			\
+		.irq = soc ## _INT_SATA,					\
+	}
+
+#ifdef CONFIG_SOC_IMX53
+const struct imx_ahci_imx_data imx53_ahci_imx_data __initconst =
+	imx_ahci_data_entry_single(MX53);
+#endif
+
+struct platform_device *__init imx_add_ahci_imx(
+		const struct imx_ahci_imx_data *data,
+		const struct ahci_platform_data *pdata)
+{
+	struct resource res[] = {
+		{
+			.start = data->iobase,
+			.end = data->iobase + SZ_4K - 1,
+			.flags = IORESOURCE_MEM,
+		}, {
+			.start = data->irq,
+			.end = data->irq,
+			.flags = IORESOURCE_IRQ,
+		},
+	};
+
+	return imx_add_platform_device_dmamask("ahci", 0 /* -1? */,
+			res, ARRAY_SIZE(res),
+			pdata, sizeof(*pdata),  DMA_BIT_MASK(32));
+}
diff --git a/arch/arm/plat-mxc/devices/platform-imx-dma.c b/arch/arm/plat-mxc/devices/platform-imx-dma.c
old mode 100644
new mode 100755
index b130f60..f4ad784
--- a/arch/arm/plat-mxc/devices/platform-imx-dma.c
+++ b/arch/arm/plat-mxc/devices/platform-imx-dma.c
@@ -51,6 +51,11 @@ struct imx_imx_sdma_data imx51_imx_sdma_data __initconst =
 	imx_imx_sdma_data_entry_single(MX51, 2, "imx51", 0);
 #endif /* ifdef CONFIG_SOC_IMX51 */
 
+#ifdef CONFIG_SOC_IMX53
+struct imx_imx_sdma_data imx53_imx_sdma_data __initconst =
+	imx_imx_sdma_data_entry_single(MX53, 2, "imx53", 1);
+#endif /* ifdef CONFIG_SOC_IMX51 */
+
 static struct platform_device __init __maybe_unused *imx_add_imx_sdma(
 		const struct imx_imx_sdma_data *data)
 {
@@ -76,7 +81,7 @@ static struct platform_device __init __maybe_unused *imx_add_imx_dma(void)
 	return imx_add_platform_device("imx-dma", -1, NULL, 0, NULL, 0);
 }
 
-#ifdef CONFIG_ARCH_MX25
+#ifdef CONFIG_SOC_IMX25
 static struct sdma_script_start_addrs addr_imx25_to1 = {
 	.ap_2_ap_addr = 729,
 	.uart_2_mcu_addr = 904,
@@ -139,7 +144,7 @@ static struct sdma_script_start_addrs addr_imx35_to2 = {
 #endif
 
 #ifdef CONFIG_SOC_IMX51
-static struct sdma_script_start_addrs addr_imx51 = {
+static struct sdma_script_start_addrs addr_imx51_to3 = {
 	.ap_2_ap_addr = 642,
 	.uart_2_mcu_addr = 817,
 	.mcu_2_app_addr = 747,
@@ -153,6 +158,21 @@ static struct sdma_script_start_addrs addr_imx51 = {
 };
 #endif
 
+#ifdef CONFIG_SOC_IMX53
+static struct sdma_script_start_addrs addr_imx53_to1 = {
+	.ap_2_ap_addr = 642,
+	.uart_2_mcu_addr = 817,
+	.mcu_2_app_addr = 747,
+	.per_2_per_addr = 6331,
+	.uartsh_2_mcu_addr = 1032,
+	.mcu_2_shp_addr = 960,
+	.app_2_mcu_addr = 683,
+	.shp_2_mcu_addr = 891,
+	.spdif_2_mcu_addr = 1100,
+	.mcu_2_spdif_addr = 1134,
+};
+#endif
+
 static int __init imxXX_add_imx_dma(void)
 {
 	struct platform_device *ret;
@@ -198,10 +218,20 @@ static int __init imxXX_add_imx_dma(void)
 	if (cpu_is_mx51()) {
 		int to_version = mx51_revision() >> 4;
 		imx51_imx_sdma_data.pdata.to_version = to_version;
-		imx51_imx_sdma_data.pdata.script_addrs = &addr_imx51;
+		if (to_version == 3)
+			imx51_imx_sdma_data.pdata.script_addrs = &addr_imx51_to3;
 		ret = imx_add_imx_sdma(&imx51_imx_sdma_data);
 	} else
 #endif
+#if defined(CONFIG_SOC_IMX53)
+	if (cpu_is_mx53()) {
+		int to_version = 1;
+		imx53_imx_sdma_data.pdata.to_version = to_version;
+		if (to_version == 1)
+			imx53_imx_sdma_data.pdata.script_addrs = &addr_imx53_to1;
+		ret = imx_add_imx_sdma(&imx53_imx_sdma_data);
+	} else
+#endif
 		ret = ERR_PTR(-ENODEV);
 
 	if (IS_ERR(ret))
diff --git a/arch/arm/plat-mxc/devices/platform-imx-i2c.c b/arch/arm/plat-mxc/devices/platform-imx-i2c.c
old mode 100644
new mode 100755
index 2ab74f0..9073895
--- a/arch/arm/plat-mxc/devices/platform-imx-i2c.c
+++ b/arch/arm/plat-mxc/devices/platform-imx-i2c.c
@@ -94,6 +94,7 @@ const struct imx_imx_i2c_data imx53_imx_i2c_data[] __initconst = {
 	imx_imx_i2c_data_entry(MX53, _id, _hwid, SZ_4K)
 	imx53_imx_i2c_data_entry(0, 1),
 	imx53_imx_i2c_data_entry(1, 2),
+	imx53_imx_i2c_data_entry(2, 3),
 };
 #endif /* ifdef CONFIG_SOC_IMX51 */
 
diff --git a/arch/arm/plat-mxc/devices/platform-imx-iim.c b/arch/arm/plat-mxc/devices/platform-imx-iim.c
new file mode 100755
index 0000000..74043de
--- /dev/null
+++ b/arch/arm/plat-mxc/devices/platform-imx-iim.c
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) 2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <mach/hardware.h>
+#include <mach/devices-common.h>
+
+#define imx5_iim_data_entry_single(soc)				\
+	{							\
+		.iobase = soc ## _IIM_BASE_ADDR,		\
+		.irq = soc ## _INT_IIM,				\
+	}
+
+#ifdef CONFIG_SOC_IMX51
+const struct imx_iim_data imx51_imx_iim_data __initconst =
+			imx5_iim_data_entry_single(MX51);
+#endif /* ifdef CONFIG_SOC_IMX51 */
+
+#ifdef CONFIG_SOC_IMX53
+const struct imx_iim_data imx53_imx_iim_data __initconst =
+			imx5_iim_data_entry_single(MX53);
+#endif /* ifdef CONFIG_SOC_IMX53 */
+
+struct platform_device *__init imx_add_iim(
+		const struct imx_iim_data *data,
+		const struct mxc_iim_platform_data *pdata)
+{
+	struct resource res[] = {
+		{
+			.start = data->iobase,
+			.end = data->iobase + SZ_16 - 1,
+			.flags = IORESOURCE_MEM,
+		}, {
+			.start = data->irq,
+			.end = data->irq,
+			.flags = IORESOURCE_IRQ,
+		},
+	};
+
+	return imx_add_platform_device("mxc_iim", 0,
+			res, ARRAY_SIZE(res), pdata, sizeof(*pdata));
+}
+
diff --git a/arch/arm/plat-mxc/devices/platform-imx-ssi.c b/arch/arm/plat-mxc/devices/platform-imx-ssi.c
old mode 100644
new mode 100755
index 2569c8d..5467c3b
--- a/arch/arm/plat-mxc/devices/platform-imx-ssi.c
+++ b/arch/arm/plat-mxc/devices/platform-imx-ssi.c
@@ -76,6 +76,16 @@ const struct imx_imx_ssi_data imx51_imx_ssi_data[] __initconst = {
 };
 #endif /* ifdef CONFIG_SOC_IMX51 */
 
+#ifdef CONFIG_SOC_IMX53
+const struct imx_imx_ssi_data imx53_imx_ssi_data[] __initconst = {
+#define imx53_imx_ssi_data_entry(_id, _hwid)				\
+	imx_imx_ssi_data_entry(MX53, _id, _hwid, SZ_4K)
+	imx53_imx_ssi_data_entry(0, 1),
+	imx53_imx_ssi_data_entry(1, 2),
+	imx53_imx_ssi_data_entry(2, 3),
+};
+#endif /* ifdef CONFIG_SOC_IMX53 */
+
 struct platform_device *__init imx_add_imx_ssi(
 		const struct imx_imx_ssi_data *data,
 		const struct imx_ssi_platform_data *pdata)
diff --git a/arch/arm/plat-mxc/devices/platform-imx_dvfs.c b/arch/arm/plat-mxc/devices/platform-imx_dvfs.c
new file mode 100755
index 0000000..1f40fdd
--- /dev/null
+++ b/arch/arm/plat-mxc/devices/platform-imx_dvfs.c
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Jason Chen <jason.chen@freescale.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License version 2 as published by the
+ * Free Software Foundation.
+ */
+#include <mach/hardware.h>
+#include <mach/devices-common.h>
+
+#define imx5_dvfs_core_data_entry_single(soc)				\
+	{							\
+		.iobase = soc ## _DVFSCORE_BASE_ADDR,		\
+		.irq = soc ## _INT_GPC1,				\
+	}
+
+#ifdef CONFIG_SOC_IMX51
+const struct imx_dvfs_core_data imx51_dvfs_core_data __initconst =
+			imx5_dvfs_core_data_entry_single(MX51);
+#endif /* ifdef CONFIG_SOC_IMX51 */
+
+#ifdef CONFIG_SOC_IMX53
+const struct imx_dvfs_core_data imx53_dvfs_core_data __initconst =
+			imx5_dvfs_core_data_entry_single(MX53);
+#endif /* ifdef CONFIG_SOC_IMX53 */
+
+struct platform_device *__init imx_add_dvfs_core(
+		const struct imx_dvfs_core_data *data,
+		const struct mxc_dvfs_platform_data *pdata)
+{
+	struct resource res[] = {
+		{
+			.start = data->iobase,
+			.end = data->iobase + 4 * SZ_16 - 1,
+			.flags = IORESOURCE_MEM,
+		}, {
+			.start = data->irq,
+			.end = data->irq,
+			.flags = IORESOURCE_IRQ,
+		},
+	};
+
+	return imx_add_platform_device("mxc_dvfs_core", 0,
+			res, ARRAY_SIZE(res), pdata, sizeof(*pdata));
+}
+
+struct platform_device *__init imx_add_busfreq(
+		const struct mxc_bus_freq_platform_data *pdata)
+{
+	return imx_add_platform_device("busfreq", 0,
+			NULL, 0, pdata, sizeof(*pdata));
+}
diff --git a/arch/arm/plat-mxc/devices/platform-imx_ipuv3.c b/arch/arm/plat-mxc/devices/platform-imx_ipuv3.c
new file mode 100755
index 0000000..6da2c34
--- /dev/null
+++ b/arch/arm/plat-mxc/devices/platform-imx_ipuv3.c
@@ -0,0 +1,164 @@
+/*
+ * Copyright (C) 2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <mach/hardware.h>
+#include <mach/devices-common.h>
+#include <linux/clk.h>
+
+#define imx5_ipuv3_data_entry_single(soc, size, ipu_init, ipu_pg)	\
+	{								\
+		.iobase = soc ## _IPU_CTRL_BASE_ADDR,			\
+		.irq_err = soc ## _INT_IPU_ERR,				\
+		.irq = soc ## _INT_IPU_SYN,				\
+		.iosize = size,						\
+		.init = ipu_init,					\
+		.pg = ipu_pg,						\
+	}
+
+#ifdef CONFIG_SOC_IMX51
+/*
+ * The MIPI HSC unit has been removed from the i.MX51 Reference Manual by
+ * the Freescale marketing division. However this did not remove the
+ * hardware from the chip which still needs to be configured...
+ */
+static int __init ipu_mipi_setup(void)
+{
+	struct clk *hsc_clk;
+	void __iomem *hsc_addr;
+	int ret = 0;
+
+	hsc_addr = ioremap(MX51_MIPI_HSC_BASE_ADDR, PAGE_SIZE);
+	if (!hsc_addr)
+		return -ENOMEM;
+
+	hsc_clk = clk_get_sys(NULL, "mipi_hsp");
+	if (IS_ERR(hsc_clk)) {
+		ret = PTR_ERR(hsc_clk);
+		goto unmap;
+	}
+	clk_enable(hsc_clk);
+
+	/* setup MIPI module to legacy mode */
+	__raw_writel(0xF00, hsc_addr);
+
+	/* CSI mode: reserved; DI control mode: legacy (from Freescale BSP) */
+	__raw_writel(__raw_readl(hsc_addr + 0x800) | 0x30ff,
+			hsc_addr + 0x800);
+
+	clk_disable(hsc_clk);
+	clk_put(hsc_clk);
+unmap:
+	iounmap(hsc_addr);
+
+	return ret;
+}
+
+int __init mx51_ipuv3_init(void)
+{
+	int ret = 0;
+	u32 val;
+
+	ret = ipu_mipi_setup();
+
+	/* hard reset the IPU */
+	val = readl(MX51_IO_ADDRESS(MX51_SRC_BASE_ADDR));
+	val |= 1 << 3;
+	writel(val, MX51_IO_ADDRESS(MX51_SRC_BASE_ADDR));
+
+	return ret;
+}
+
+void mx51_ipuv3_pg(int enable)
+{
+	if (enable) {
+		__raw_writel(MXC_PGCR_PCR, MX51_PGC_IPU_PGCR);
+		__raw_writel(MXC_PGSR_PSR, MX51_PGC_IPU_PGSR);
+	} else {
+		__raw_writel(0x0, MX51_PGC_IPU_PGCR);
+		if (__raw_readl(MX51_PGC_IPU_PGSR) & MXC_PGSR_PSR)
+			printk(KERN_DEBUG "power gating successful\n");
+		__raw_writel(MXC_PGSR_PSR, MX51_PGC_IPU_PGSR);
+	}
+}
+
+const struct imx_ipuv3_data imx51_ipuv3_data __initconst =
+			imx5_ipuv3_data_entry_single(MX51, SZ_512M,
+					mx51_ipuv3_init, mx51_ipuv3_pg);
+#endif
+
+#ifdef CONFIG_SOC_IMX53
+int __init mx53_ipuv3_init(void)
+{
+	int ret = 0;
+	u32 val;
+
+	/* hard reset the IPU */
+	val = readl(MX53_IO_ADDRESS(MX53_SRC_BASE_ADDR));
+	val |= 1 << 3;
+	writel(val, MX53_IO_ADDRESS(MX53_SRC_BASE_ADDR));
+
+	return ret;
+}
+
+void mx53_ipuv3_pg(int enable)
+{
+	if (enable) {
+		__raw_writel(MXC_PGCR_PCR, MX53_PGC_IPU_PGCR);
+		__raw_writel(MXC_PGSR_PSR, MX53_PGC_IPU_PGSR);
+	} else {
+		__raw_writel(0x0, MX53_PGC_IPU_PGCR);
+		if (__raw_readl(MX53_PGC_IPU_PGSR) & MXC_PGSR_PSR)
+			printk(KERN_DEBUG "power gating successful\n");
+		__raw_writel(MXC_PGSR_PSR, MX53_PGC_IPU_PGSR);
+	}
+}
+
+const struct imx_ipuv3_data imx53_ipuv3_data __initconst =
+			imx5_ipuv3_data_entry_single(MX53, SZ_128M,
+					mx53_ipuv3_init, mx53_ipuv3_pg);
+#endif
+
+struct platform_device *__init imx_add_ipuv3(
+		const struct imx_ipuv3_data *data,
+		struct imx_ipuv3_platform_data *pdata)
+{
+	struct resource res[] = {
+		{
+			.start = data->iobase,
+			.end = data->iobase + data->iosize - 1,
+			.flags = IORESOURCE_MEM,
+		}, {
+			.start = data->irq_err,
+			.end = data->irq_err,
+			.flags = IORESOURCE_IRQ,
+		}, {
+			.start = data->irq,
+			.end = data->irq,
+			.flags = IORESOURCE_IRQ,
+		},
+	};
+
+	pdata->init = data->init;
+	pdata->pg = data->pg;
+
+	return imx_add_platform_device("imx-ipuv3", -1,
+			res, ARRAY_SIZE(res), pdata, sizeof(*pdata));
+}
+
diff --git a/arch/arm/plat-mxc/devices/platform-imx_srtc.c b/arch/arm/plat-mxc/devices/platform-imx_srtc.c
new file mode 100755
index 0000000..7dd2305
--- /dev/null
+++ b/arch/arm/plat-mxc/devices/platform-imx_srtc.c
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <asm/sizes.h>
+#include <mach/hardware.h>
+#include <mach/devices-common.h>
+
+#define imx_imx_srtc_data_entry_single(soc)				\
+	{								\
+		.iobase = soc ## _SRTC_BASE_ADDR,			\
+		.irq = soc ## _INT_SRTC_NTZ,				\
+	}
+
+#ifdef CONFIG_SOC_IMX53
+const struct imx_srtc_data imx53_imx_srtc_data __initconst =
+	imx_imx_srtc_data_entry_single(MX53);
+#endif /* ifdef CONFIG_SOC_IMX53 */
+
+struct platform_device *__init imx_add_srtc(
+		const struct imx_srtc_data *data)
+{
+	struct resource res[] = {
+		{
+			.start = data->iobase,
+			.end = data->iobase + SZ_16K,
+			.flags = IORESOURCE_MEM,
+		}, {
+			.start = data->irq,
+			.end = data->irq,
+			.flags = IORESOURCE_IRQ,
+		},
+	};
+
+	return imx_add_platform_device("mxc_rtc", 0,
+			res, ARRAY_SIZE(res), NULL, 0);
+}
diff --git a/arch/arm/plat-mxc/devices/platform-imx_tve.c b/arch/arm/plat-mxc/devices/platform-imx_tve.c
new file mode 100755
index 0000000..6dc23d5
--- /dev/null
+++ b/arch/arm/plat-mxc/devices/platform-imx_tve.c
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Jason Chen <jason.chen@freescale.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License version 2 as published by the
+ * Free Software Foundation.
+ */
+#include <mach/hardware.h>
+#include <mach/devices-common.h>
+
+#define imx5_tve_data_entry_single(soc)				\
+	{							\
+		.iobase = soc ## _TVE_BASE_ADDR,		\
+		.irq = soc ## _INT_TVE,				\
+	}
+
+#ifdef CONFIG_SOC_IMX51
+const struct imx_tve_data imx51_tve_data __initconst =
+			imx5_tve_data_entry_single(MX51);
+#endif /* ifdef CONFIG_SOC_IMX51 */
+
+#ifdef CONFIG_SOC_IMX53
+const struct imx_tve_data imx53_tve_data __initconst =
+			imx5_tve_data_entry_single(MX53);
+#endif /* ifdef CONFIG_SOC_IMX53 */
+
+struct platform_device *__init imx_add_tve(
+		const struct imx_tve_data *data,
+		const struct fsl_mxc_tve_platform_data *pdata)
+{
+	struct resource res[] = {
+		{
+			.start = data->iobase,
+			.end = data->iobase + SZ_4K - 1,
+			.flags = IORESOURCE_MEM,
+		}, {
+			.start = data->irq,
+			.end = data->irq,
+			.flags = IORESOURCE_IRQ,
+		},
+	};
+
+	return imx_add_platform_device("mxc_tve", -1,
+			res, ARRAY_SIZE(res), pdata, sizeof(*pdata));
+}
+
diff --git a/arch/arm/plat-mxc/devices/platform-imx_vpu.c b/arch/arm/plat-mxc/devices/platform-imx_vpu.c
new file mode 100755
index 0000000..599592d
--- /dev/null
+++ b/arch/arm/plat-mxc/devices/platform-imx_vpu.c
@@ -0,0 +1,121 @@
+/*
+ * Copyright (C) 2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Jason Chen <jason.chen@freescale.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License version 2 as published by the
+ * Free Software Foundation.
+ */
+#include <mach/hardware.h>
+#include <mach/devices-common.h>
+
+#define imx5_vpu_data_entry_single(soc, vpu_reset, vpu_pg)	\
+	{							\
+		.iobase = soc ## _VPU_BASE_ADDR,		\
+		.irq = soc ## _INT_VPU,				\
+		.reset = vpu_reset,				\
+		.pg = vpu_pg,					\
+	}
+
+#ifdef CONFIG_SOC_IMX51
+void mx51_vpu_reset(void)
+{
+	u32 reg;
+	void __iomem *src_base;
+
+	src_base = ioremap(MX51_SRC_BASE_ADDR, PAGE_SIZE);
+
+	/* mask interrupt due to vpu passed reset */
+	reg = __raw_readl(src_base + 0x18);
+	reg |= 0x02;
+	__raw_writel(reg, src_base + 0x18);
+
+	reg = __raw_readl(src_base);
+	reg |= 0x5;    /* warm reset vpu */
+	__raw_writel(reg, src_base);
+	while (__raw_readl(src_base) & 0x04)
+		;
+
+	iounmap(src_base);
+}
+
+void mx51_vpu_pg(int enable)
+{
+	if (enable) {
+		__raw_writel(MXC_PGCR_PCR, MX51_PGC_VPU_PGCR);
+		__raw_writel(MXC_PGSR_PSR, MX51_PGC_VPU_PGSR);
+	} else {
+		__raw_writel(0x0, MX51_PGC_VPU_PGCR);
+		if (__raw_readl(MX51_PGC_VPU_PGSR) & MXC_PGSR_PSR)
+			printk(KERN_DEBUG "power gating successful\n");
+		__raw_writel(MXC_PGSR_PSR, MX51_PGC_VPU_PGSR);
+	}
+}
+const struct imx_vpu_data imx51_vpu_data __initconst =
+			imx5_vpu_data_entry_single(MX51,
+			mx51_vpu_reset, mx51_vpu_pg);
+#endif
+
+#ifdef CONFIG_SOC_IMX53
+void mx53_vpu_reset(void)
+{
+	u32 reg;
+	void __iomem *src_base;
+
+	src_base = ioremap(MX53_SRC_BASE_ADDR, PAGE_SIZE);
+
+	/* mask interrupt due to vpu passed reset */
+	reg = __raw_readl(src_base + 0x18);
+	reg |= 0x02;
+	__raw_writel(reg, src_base + 0x18);
+
+	reg = __raw_readl(src_base);
+	reg |= 0x5;    /* warm reset vpu */
+	__raw_writel(reg, src_base);
+	while (__raw_readl(src_base) & 0x04)
+		;
+
+	iounmap(src_base);
+}
+
+void mx53_vpu_pg(int enable)
+{
+	if (enable) {
+		__raw_writel(MXC_PGCR_PCR, MX53_PGC_VPU_PGCR);
+		__raw_writel(MXC_PGSR_PSR, MX53_PGC_VPU_PGSR);
+	} else {
+		__raw_writel(0x0, MX53_PGC_VPU_PGCR);
+		if (__raw_readl(MX53_PGC_VPU_PGSR) & MXC_PGSR_PSR)
+			printk(KERN_DEBUG "power gating successful\n");
+		__raw_writel(MXC_PGSR_PSR, MX53_PGC_VPU_PGSR);
+	}
+}
+
+const struct imx_vpu_data imx53_vpu_data __initconst =
+			imx5_vpu_data_entry_single(MX53,
+			mx53_vpu_reset, mx53_vpu_pg);
+#endif
+
+struct platform_device *__init imx_add_vpu(
+		const struct imx_vpu_data *data)
+{
+	struct mxc_vpu_platform_data pdata;
+	struct resource res[] = {
+		{
+			.start = data->iobase,
+			.end = data->iobase + SZ_4K - 1,
+			.flags = IORESOURCE_MEM,
+		}, {
+			.start = data->irq,
+			.end = data->irq,
+			.flags = IORESOURCE_IRQ,
+		},
+	};
+
+	pdata.reset = data->reset;
+	pdata.pg = data->pg;
+
+	return imx_add_platform_device("mxc_vpu", -1,
+			res, ARRAY_SIZE(res), &pdata, sizeof(pdata));
+}
+
diff --git a/arch/arm/plat-mxc/devices/platform-mxc_gpu.c b/arch/arm/plat-mxc/devices/platform-mxc_gpu.c
new file mode 100755
index 0000000..f30fe85
--- /dev/null
+++ b/arch/arm/plat-mxc/devices/platform-mxc_gpu.c
@@ -0,0 +1,107 @@
+/*
+ * Copyright (C) 2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <asm/sizes.h>
+#include <mach/hardware.h>
+#include <mach/devices-common.h>
+
+#define imx_mxc_gpu_entry_3d_2d(soc)					\
+	{								\
+		.irq_3d = soc ## _INT_GPU,				\
+		.irq_2d = soc ## _INT_GPU2_IRQ,				\
+		.iobase_3d = soc ## _GPU_BASE_ADDR,			\
+		.iobase_2d = soc ## _GPU2D_BASE_ADDR,			\
+		.gmem_base = soc ## _GPU_GMEM_BASE_ADDR,		\
+		.gmem_size = soc ## _GPU_GMEM_SIZE,			\
+	}
+
+#define imx_mxc_gpu_entry_2d(soc)					\
+	{								\
+		.irq_2d = soc ## _INT_GPU2_IRQ,				\
+		.iobase_2d = soc ## _GPU2D_BASE_ADDR,			\
+	}
+
+#ifdef CONFIG_SOC_IMX35
+const struct imx_mxc_gpu_data imx35_gpu_data __initconst =
+	imx_mxc_gpu_entry_2d(MX35);
+#endif
+
+#ifdef CONFIG_SOC_IMX50
+const struct imx_mxc_gpu_data imx50_gpu_data __initconst =
+	imx_mxc_gpu_entry_2d(MX50);
+#endif
+
+#ifdef CONFIG_SOC_IMX51
+const struct imx_mxc_gpu_data imx51_gpu_data __initconst =
+	imx_mxc_gpu_entry_3d_2d(MX51);
+#endif
+
+#ifdef CONFIG_SOC_IMX53
+const struct imx_mxc_gpu_data imx53_gpu_data __initconst =
+	imx_mxc_gpu_entry_3d_2d(MX53);
+#endif
+
+struct platform_device *__init imx_add_mxc_gpu(
+		const struct imx_mxc_gpu_data *data,
+		const int *pdata)
+{
+	struct resource res[] = {
+		{
+			.start = data->irq_2d,
+			.end = data->irq_2d,
+			.name = "gpu_2d_irq",
+			.flags = IORESOURCE_IRQ,
+		},
+		{
+			.start = data->irq_3d,
+			.end = data->irq_3d,
+			.name = "gpu_3d_irq",
+			.flags = IORESOURCE_IRQ,
+		},
+		{
+			.start = data->iobase_2d,
+			.end = data->iobase_2d + SZ_4K - 1,
+			.name = "gpu_2d_registers",
+			.flags = IORESOURCE_MEM,
+		},
+		{
+			.start = data->iobase_3d,
+			.end = data->iobase_3d + SZ_128K - 1,
+			.name = "gpu_3d_registers",
+			.flags = IORESOURCE_MEM,
+		},
+		{
+			.start = data->gmem_base,
+			.end = data->gmem_base + data->gmem_size - 1,
+			.name = "gpu_graphics_mem",
+			.flags = IORESOURCE_MEM,
+		},
+		{
+			.start = 0,
+			.end = 0,
+			.name = "gpu_reserved_mem",
+			.flags = IORESOURCE_MEM,
+		},
+	};
+
+	return imx_add_platform_device_dmamask("mxc_gpu", 0,
+			res, ARRAY_SIZE(res),
+			pdata, sizeof(*pdata), DMA_BIT_MASK(32));
+}
diff --git a/arch/arm/plat-mxc/devices/platform-mxc_pwm.c b/arch/arm/plat-mxc/devices/platform-mxc_pwm.c
old mode 100644
new mode 100755
index b0c4ae2..18cfd07
--- a/arch/arm/plat-mxc/devices/platform-mxc_pwm.c
+++ b/arch/arm/plat-mxc/devices/platform-mxc_pwm.c
@@ -49,6 +49,15 @@ const struct imx_mxc_pwm_data imx51_mxc_pwm_data[] __initconst = {
 };
 #endif /* ifdef CONFIG_SOC_IMX51 */
 
+#ifdef CONFIG_SOC_IMX53
+const struct imx_mxc_pwm_data imx53_mxc_pwm_data[] __initconst = {
+#define imx53_mxc_pwm_data_entry(_id, _hwid)				\
+	imx_mxc_pwm_data_entry(MX53, _id, _hwid, SZ_16K)
+	imx53_mxc_pwm_data_entry(0, 1),
+	imx53_mxc_pwm_data_entry(1, 2),
+};
+#endif /* ifdef CONFIG_SOC_IMX53 */
+
 struct platform_device *__init imx_add_mxc_pwm(
 		const struct imx_mxc_pwm_data *data)
 {
diff --git a/arch/arm/plat-mxc/dvfs_core.c b/arch/arm/plat-mxc/dvfs_core.c
new file mode 100755
index 0000000..6f6e9c5
--- /dev/null
+++ b/arch/arm/plat-mxc/dvfs_core.c
@@ -0,0 +1,994 @@
+/*
+ * Copyright 2008-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file dvfs_core.c
+ *
+ * @brief A simplied driver for the Freescale Semiconductor MXC DVFS module.
+ *
+ * Upon initialization, the DVFS driver initializes the DVFS hardware
+ * sets up driver nodes attaches to the DVFS interrupt and initializes internal
+ * data structures. When the DVFS interrupt occurs the driver checks the cause
+ * of the interrupt (lower frequency, increase frequency or emergency) and
+ * changes the CPU voltage according to translation table that is loaded into
+ * the driver.
+ *
+ * @ingroup PM
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/fs.h>
+#include <linux/interrupt.h>
+#include <linux/jiffies.h>
+#include <linux/device.h>
+#include <linux/sysdev.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/regulator/consumer.h>
+#include <linux/input.h>
+#include <linux/platform_device.h>
+#include <linux/cpufreq.h>
+#include <mach/hardware.h>
+#include <mach/mxc_dvfs.h>
+
+#define MXC_DVFSTHRS_UPTHR_MASK               0x0FC00000
+#define MXC_DVFSTHRS_UPTHR_OFFSET             22
+#define MXC_DVFSTHRS_DNTHR_MASK               0x003F0000
+#define MXC_DVFSTHRS_DNTHR_OFFSET             16
+#define MXC_DVFSTHRS_PNCTHR_MASK              0x0000003F
+#define MXC_DVFSTHRS_PNCTHR_OFFSET            0
+
+#define MXC_DVFSCOUN_DNCNT_MASK               0x00FF0000
+#define MXC_DVFSCOUN_DNCNT_OFFSET             16
+#define MXC_DVFSCOUN_UPCNT_MASK              0x000000FF
+#define MXC_DVFSCOUN_UPCNT_OFFSET            0
+
+#define MXC_DVFSEMAC_EMAC_MASK               0x000001FF
+#define MXC_DVFSEMAC_EMAC_OFFSET             0
+
+#define MXC_DVFSCNTR_DVFEV                   0x10000000
+#define MXC_DVFSCNTR_LBMI                    0x08000000
+#define MXC_DVFSCNTR_LBFL                    0x06000000
+#define MXC_DVFSCNTR_DVFIS                   0x01000000
+#define MXC_DVFSCNTR_FSVAIM                  0x00400000
+#define MXC_DVFSCNTR_FSVAI_MASK              0x00300000
+#define MXC_DVFSCNTR_FSVAI_OFFSET            20
+#define MXC_DVFSCNTR_WFIM                    0x00080000
+#define MXC_DVFSCNTR_WFIM_OFFSET             19
+#define MXC_DVFSCNTR_MAXF_MASK               0x00040000
+#define MXC_DVFSCNTR_MAXF_OFFSET             18
+#define MXC_DVFSCNTR_MINF_MASK               0x00020000
+#define MXC_DVFSCNTR_MINF_OFFSET             17
+#define MXC_DVFSCNTR_LTBRSR_MASK             0x00000018
+#define MXC_DVFSCNTR_LTBRSR_OFFSET           3
+#define MXC_DVFSCNTR_DVFEN                   0x00000001
+
+#define CCM_CDCR_SW_DVFS_EN			0x20
+#define CCM_CDCR_ARM_FREQ_SHIFT_DIVIDER		0x4
+
+int dvfs_core_is_active;
+extern void setup_pll(void);
+static struct mxc_dvfs_platform_data *dvfs_data;
+static struct device *dvfs_dev;
+static struct cpu_op *cpu_op_tbl;
+int dvfs_core_resume;
+int curr_op;
+int old_op;
+
+int cpufreq_trig_needed;
+struct timeval core_prev_intr;
+
+void dump_dvfs_core_regs(void);
+void stop_dvfs(void);
+static struct delayed_work dvfs_core_handler;
+
+/*
+ * Clock structures
+ */
+static struct clk *pll1_sw_clk;
+static struct clk *cpu_clk;
+static struct clk *dvfs_clk;
+static struct regulator *core_regulator;
+
+extern int cpu_op_nr;
+#ifdef CONFIG_ARCH_MX5
+extern struct cpu_op *(*get_cpu_op)(int *op);
+#endif
+
+enum {
+	FSVAI_FREQ_NOCHANGE = 0x0,
+	FSVAI_FREQ_INCREASE,
+	FSVAI_FREQ_DECREASE,
+	FSVAI_FREQ_EMERG,
+};
+
+/*
+ * Load tracking buffer source: 1 for ld_add; 0 for pre_ld_add; 2 for after EMA
+ */
+#define DVFS_LTBRSR		(2 << MXC_DVFSCNTR_LTBRSR_OFFSET)
+
+extern struct dvfs_wp dvfs_core_setpoint[4];
+extern int low_bus_freq_mode;
+extern int high_bus_freq_mode;
+extern int set_low_bus_freq(void);
+extern int set_high_bus_freq(int high_bus_speed);
+extern int low_freq_bus_used(void);
+
+DEFINE_SPINLOCK(mxc_dvfs_core_lock);
+
+static void dvfs_load_config(int set_point)
+{
+	u32 reg;
+	reg = 0;
+
+	reg |= dvfs_core_setpoint[set_point].upthr << MXC_DVFSTHRS_UPTHR_OFFSET;
+	reg |= dvfs_core_setpoint[set_point].downthr <<
+	    MXC_DVFSTHRS_DNTHR_OFFSET;
+	reg |= dvfs_core_setpoint[set_point].panicthr;
+	__raw_writel(reg, dvfs_data->membase + MXC_DVFSCORE_THRS);
+
+	reg = 0;
+	reg |= dvfs_core_setpoint[set_point].downcnt <<
+	    MXC_DVFSCOUN_DNCNT_OFFSET;
+	reg |= dvfs_core_setpoint[set_point].upcnt << MXC_DVFSCOUN_UPCNT_OFFSET;
+	__raw_writel(reg, dvfs_data->membase + MXC_DVFSCORE_COUN);
+
+	/* Set EMAC value */
+	__raw_writel((dvfs_core_setpoint[set_point].emac <<
+					MXC_DVFSEMAC_EMAC_OFFSET),
+					dvfs_data->membase
+					+ MXC_DVFSCORE_EMAC);
+
+
+}
+
+static int set_cpu_freq(int op)
+{
+	int arm_podf;
+	int podf;
+	int vinc = 0;
+	int ret = 0;
+	int org_cpu_rate;
+	unsigned long rate = 0;
+	int gp_volt = 0;
+	u32 reg;
+	u32 reg1;
+	u32 en_sw_dvfs = 0;
+	unsigned long flags;
+
+	if (cpu_op_tbl[op].pll_rate != cpu_op_tbl[old_op].pll_rate) {
+		org_cpu_rate = clk_get_rate(cpu_clk);
+		rate = cpu_op_tbl[op].cpu_rate;
+
+		if (org_cpu_rate == rate)
+			return ret;
+
+		gp_volt = cpu_op_tbl[op].cpu_voltage;
+		if (gp_volt == 0)
+			return ret;
+
+		/*Set the voltage for the GP domain. */
+		if (rate > org_cpu_rate) {
+			ret = regulator_set_voltage(core_regulator, gp_volt,
+						    gp_volt);
+			if (ret < 0) {
+				printk(KERN_DEBUG "COULD NOT SET GP VOLTAGE\n");
+				return ret;
+			}
+			udelay(dvfs_data->delay_time);
+		}
+		spin_lock_irqsave(&mxc_dvfs_core_lock, flags);
+		/* PLL_RELOCK, set ARM_FREQ_SHIFT_DIVIDER */
+		reg = __raw_readl(ccm_base + dvfs_data->ccm_cdcr_offset);
+		/* Check if software_dvfs_en bit set */
+		if ((reg & CCM_CDCR_SW_DVFS_EN) != 0)
+			en_sw_dvfs = CCM_CDCR_SW_DVFS_EN;
+		else
+			en_sw_dvfs = 0x0;
+		reg &= ~(CCM_CDCR_SW_DVFS_EN);
+		reg &= 0xFFFFFFFB;
+		__raw_writel(reg, ccm_base + dvfs_data->ccm_cdcr_offset);
+
+		setup_pll();
+		/* START the GPC main control FSM */
+		/* set VINC */
+		reg = __raw_readl(gpc_base + dvfs_data->gpc_vcr_offset);
+		reg &= ~(MXC_GPCVCR_VINC_MASK | MXC_GPCVCR_VCNTU_MASK |
+			 MXC_GPCVCR_VCNT_MASK);
+
+		if (rate > org_cpu_rate)
+			reg |= 1 << MXC_GPCVCR_VINC_OFFSET;
+
+		reg |= (1 << MXC_GPCVCR_VCNTU_OFFSET) |
+		       (1 << MXC_GPCVCR_VCNT_OFFSET);
+		__raw_writel(reg, gpc_base + dvfs_data->gpc_vcr_offset);
+
+		reg = __raw_readl(gpc_base + dvfs_data->gpc_cntr_offset);
+		reg &= ~(MXC_GPCCNTR_ADU_MASK | MXC_GPCCNTR_FUPD_MASK);
+		reg |= MXC_GPCCNTR_FUPD;
+		reg |= MXC_GPCCNTR_ADU;
+		__raw_writel(reg, gpc_base + dvfs_data->gpc_cntr_offset);
+
+		reg |= MXC_GPCCNTR_STRT;
+		__raw_writel(reg, gpc_base + dvfs_data->gpc_cntr_offset);
+		while (__raw_readl(gpc_base + dvfs_data->gpc_cntr_offset)
+				& 0x4000)
+			udelay(10);
+		spin_unlock_irqrestore(&mxc_dvfs_core_lock, flags);
+
+		if (rate < org_cpu_rate) {
+			ret = regulator_set_voltage(core_regulator,
+						    gp_volt, gp_volt);
+			if (ret < 0) {
+				printk(KERN_DEBUG
+				       "COULD NOT SET GP VOLTAGE!!!!\n");
+				return ret;
+			}
+			udelay(dvfs_data->delay_time);
+		}
+		/* set software_dvfs_en bit back to original setting*/
+		reg = __raw_readl(ccm_base + dvfs_data->ccm_cdcr_offset);
+		reg &= ~(CCM_CDCR_SW_DVFS_EN);
+		reg |= en_sw_dvfs;
+		clk_set_rate(cpu_clk, rate);
+	} else {
+		podf = cpu_op_tbl[op].cpu_podf;
+		gp_volt = cpu_op_tbl[op].cpu_voltage;
+
+		/* Change arm_podf only */
+		/* set ARM_FREQ_SHIFT_DIVIDER */
+		reg = __raw_readl(ccm_base + dvfs_data->ccm_cdcr_offset);
+
+		/* Check if software_dvfs_en bit set */
+		if ((reg & CCM_CDCR_SW_DVFS_EN) != 0)
+			en_sw_dvfs = CCM_CDCR_SW_DVFS_EN;
+		else
+			en_sw_dvfs = 0x0;
+
+		reg &= ~(CCM_CDCR_SW_DVFS_EN | CCM_CDCR_ARM_FREQ_SHIFT_DIVIDER);
+		reg |= CCM_CDCR_ARM_FREQ_SHIFT_DIVIDER;
+		__raw_writel(reg, ccm_base + dvfs_data->ccm_cdcr_offset);
+
+		/* Get ARM_PODF */
+		reg = __raw_readl(ccm_base + dvfs_data->ccm_cacrr_offset);
+		arm_podf = reg & 0x07;
+		if (podf == arm_podf) {
+			printk(KERN_DEBUG
+			       "No need to change freq and voltage!!!!\n");
+			return 0;
+		}
+
+		/* Check if FSVAI indicate freq up */
+		if (podf < arm_podf) {
+			ret = regulator_set_voltage(core_regulator,
+						    gp_volt, gp_volt);
+			if (ret < 0) {
+				printk(KERN_DEBUG
+				       "COULD NOT SET GP VOLTAGE!!!!\n");
+				return 0;
+			}
+			udelay(dvfs_data->delay_time);
+			vinc = 1;
+		} else {
+			vinc = 0;
+		}
+
+		arm_podf = podf;
+		/* Set ARM_PODF */
+		reg &= 0xFFFFFFF8;
+		reg |= arm_podf;
+		spin_lock_irqsave(&mxc_dvfs_core_lock, flags);
+
+		reg1 = __raw_readl(ccm_base + dvfs_data->ccm_cdhipr_offset);
+		if ((reg1 & 0x00010000) == 0)
+			__raw_writel(reg,
+				ccm_base + dvfs_data->ccm_cacrr_offset);
+		else {
+			printk(KERN_DEBUG "ARM_PODF still in busy!!!!\n");
+			return 0;
+		}
+		/* set VINC */
+		reg = __raw_readl(gpc_base + dvfs_data->gpc_vcr_offset);
+		reg &=
+		    ~(MXC_GPCVCR_VINC_MASK | MXC_GPCVCR_VCNTU_MASK |
+		      MXC_GPCVCR_VCNT_MASK);
+		reg |= (1 << MXC_GPCVCR_VCNTU_OFFSET) |
+		    (100 << MXC_GPCVCR_VCNT_OFFSET) |
+		    (vinc << MXC_GPCVCR_VINC_OFFSET);
+		__raw_writel(reg, gpc_base + dvfs_data->gpc_vcr_offset);
+
+		reg = __raw_readl(gpc_base + dvfs_data->gpc_cntr_offset);
+		reg &= (~(MXC_GPCCNTR_ADU | MXC_GPCCNTR_FUPD
+				| MXC_GPCCNTR_STRT));
+		__raw_writel(reg, gpc_base + dvfs_data->gpc_cntr_offset);
+		reg = __raw_readl(gpc_base + dvfs_data->gpc_cntr_offset);
+		reg |= MXC_GPCCNTR_ADU | MXC_GPCCNTR_FUPD;
+		__raw_writel(reg, gpc_base + dvfs_data->gpc_cntr_offset);
+		reg = __raw_readl(gpc_base + dvfs_data->gpc_cntr_offset);
+		reg |= MXC_GPCCNTR_STRT;
+		__raw_writel(reg, gpc_base + dvfs_data->gpc_cntr_offset);
+
+		/* Wait for arm podf Enable */
+		while ((__raw_readl(gpc_base + dvfs_data->gpc_cntr_offset) &
+			MXC_GPCCNTR_STRT) == MXC_GPCCNTR_STRT) {
+			printk(KERN_DEBUG "Waiting arm_podf enabled!\n");
+			udelay(10);
+		}
+		spin_unlock_irqrestore(&mxc_dvfs_core_lock, flags);
+
+		if (vinc == 0) {
+			ret = regulator_set_voltage(core_regulator,
+						    gp_volt, gp_volt);
+			if (ret < 0) {
+				printk(KERN_DEBUG
+				       "COULD NOT SET GP VOLTAGE!!!!\n");
+				return ret;
+			}
+			udelay(dvfs_data->delay_time);
+		}
+
+		/* Clear the ARM_FREQ_SHIFT_DIVIDER and */
+		/* set software_dvfs_en bit back to original setting*/
+		reg = __raw_readl(ccm_base + dvfs_data->ccm_cdcr_offset);
+		reg &= ~(CCM_CDCR_SW_DVFS_EN | CCM_CDCR_ARM_FREQ_SHIFT_DIVIDER);
+		reg |= en_sw_dvfs;
+		__raw_writel(reg, ccm_base + dvfs_data->ccm_cdcr_offset);
+	}
+#if defined(CONFIG_CPU_FREQ)
+		cpufreq_trig_needed = 1;
+#endif
+	old_op = op;
+	return ret;
+}
+
+static int start_dvfs(void)
+{
+	u32 reg, cpu_rate;
+	unsigned long flags;
+
+	if (dvfs_core_is_active)
+		return 0;
+
+	spin_lock_irqsave(&mxc_dvfs_core_lock, flags);
+
+	clk_enable(dvfs_clk);
+
+	dvfs_load_config(0);
+
+	/* get current working point */
+	cpu_rate = clk_get_rate(cpu_clk);
+	curr_op = cpu_op_nr - 1;
+	do {
+		if (cpu_rate <= cpu_op_tbl[curr_op].cpu_rate)
+			break;
+	} while (--curr_op >= 0);
+	old_op = curr_op;
+	/* config reg GPC_CNTR */
+	reg = __raw_readl(gpc_base + dvfs_data->gpc_cntr_offset);
+
+	reg &= ~MXC_GPCCNTR_GPCIRQM;
+	/* GPCIRQ=1, select ARM IRQ */
+	reg |= MXC_GPCCNTR_GPCIRQ_ARM;
+	/* ADU=1, select ARM domain */
+	reg |= MXC_GPCCNTR_ADU;
+	__raw_writel(reg, gpc_base + dvfs_data->gpc_cntr_offset);
+
+	/* Set PREDIV bits */
+	reg = __raw_readl(dvfs_data->membase + MXC_DVFSCORE_CNTR);
+	reg = (reg & ~(dvfs_data->prediv_mask));
+	reg |= (dvfs_data->prediv_val) << (dvfs_data->prediv_offset);
+	__raw_writel(reg, dvfs_data->membase + MXC_DVFSCORE_CNTR);
+
+	/* Enable DVFS interrupt */
+	reg = __raw_readl(dvfs_data->membase + MXC_DVFSCORE_CNTR);
+	/* FSVAIM=0 */
+	reg = (reg & ~MXC_DVFSCNTR_FSVAIM);
+	/* Set MAXF, MINF */
+	reg = (reg & ~(MXC_DVFSCNTR_MAXF_MASK | MXC_DVFSCNTR_MINF_MASK));
+	reg |= 1 << MXC_DVFSCNTR_MAXF_OFFSET;
+	/* Select ARM domain */
+	reg |= MXC_DVFSCNTR_DVFIS;
+	/* Enable DVFS frequency adjustment interrupt */
+	reg = (reg & ~MXC_DVFSCNTR_FSVAIM);
+	/* Set load tracking buffer register source */
+	reg = (reg & ~MXC_DVFSCNTR_LTBRSR_MASK);
+	reg |= DVFS_LTBRSR;
+	/* Set DIV3CK */
+	reg = (reg & ~(dvfs_data->div3ck_mask));
+	reg |= (dvfs_data->div3ck_val) << (dvfs_data->div3ck_offset);
+	__raw_writel(reg, dvfs_data->membase + MXC_DVFSCORE_CNTR);
+
+	/* Enable DVFS */
+	reg = __raw_readl(dvfs_data->membase + MXC_DVFSCORE_CNTR);
+	reg |= MXC_DVFSCNTR_DVFEN;
+	__raw_writel(reg, dvfs_data->membase + MXC_DVFSCORE_CNTR);
+
+	dvfs_core_is_active = 1;
+
+	spin_unlock_irqrestore(&mxc_dvfs_core_lock, flags);
+
+	printk(KERN_DEBUG "DVFS is started\n");
+
+	return 0;
+}
+
+/*!
+ * This function is called for module initialization.
+ * It sets up the DVFS hardware.
+ * It sets default values for DVFS thresholds and counters. The default
+ * values was chosen from a set of different reasonable values. They was tested
+ * and the default values in the driver gave the best results.
+ * More work should be done to find optimal values.
+ *
+ * @return   0 if successful; non-zero otherwise.
+ *
+ */
+static int init_dvfs_controller(void)
+{
+	/* DVFS loading config */
+	dvfs_load_config(0);
+
+	return 0;
+}
+
+static irqreturn_t dvfs_irq(int irq, void *dev_id)
+{
+	u32 reg;
+
+	/* Check if DVFS0 (ARM) id requesting for freqency/voltage update */
+	if ((__raw_readl(gpc_base + dvfs_data->gpc_cntr_offset)
+			& MXC_GPCCNTR_DVFS0CR) == 0)
+		return IRQ_NONE;
+
+	/* Mask DVFS irq */
+	reg = __raw_readl(dvfs_data->membase + MXC_DVFSCORE_CNTR);
+	/* FSVAIM=1 */
+	reg |= MXC_DVFSCNTR_FSVAIM;
+	__raw_writel(reg, dvfs_data->membase + MXC_DVFSCORE_CNTR);
+
+	/* Mask GPC1 irq */
+	reg = __raw_readl(gpc_base + dvfs_data->gpc_cntr_offset);
+	reg |= MXC_GPCCNTR_GPCIRQM | 0x1000000;
+	__raw_writel(reg, gpc_base + dvfs_data->gpc_cntr_offset);
+
+	schedule_delayed_work(&dvfs_core_handler, 0);
+	return IRQ_HANDLED;
+}
+
+static void dvfs_core_work_handler(struct work_struct *work)
+{
+	u32 fsvai;
+	u32 reg;
+	u32 curr_cpu;
+	int ret = 0;
+	int maxf = 0, minf = 0;
+	int low_freq_bus_ready = 0;
+	int bus_incr = 0, cpu_dcr = 0;
+
+	low_freq_bus_ready = low_freq_bus_used();
+
+	/* Check DVFS frequency adjustment interrupt status */
+	reg = __raw_readl(dvfs_data->membase + MXC_DVFSCORE_CNTR);
+	fsvai = (reg & MXC_DVFSCNTR_FSVAI_MASK) >> MXC_DVFSCNTR_FSVAI_OFFSET;
+	/* Check FSVAI, FSVAI=0 is error */
+	if (fsvai == FSVAI_FREQ_NOCHANGE) {
+		/* Do nothing. Freq change is not required */
+		goto END;
+	}
+	curr_cpu = clk_get_rate(cpu_clk);
+	/* If FSVAI indicate freq down,
+	   check arm-clk is not in lowest frequency 200 MHz */
+	if (fsvai == FSVAI_FREQ_DECREASE) {
+		if (curr_cpu == cpu_op_tbl[cpu_op_nr - 1].cpu_rate) {
+			minf = 1;
+			if (low_bus_freq_mode)
+				goto END;
+		} else {
+			/* freq down */
+			curr_op++;
+			if (curr_op >= cpu_op_nr) {
+				curr_op = cpu_op_nr - 1;
+				goto END;
+			}
+
+			if (curr_op == cpu_op_nr - 1 && !low_freq_bus_ready) {
+				minf = 1;
+				dvfs_load_config(1);
+			} else {
+				cpu_dcr = 1;
+			}
+		}
+	} else {
+		if (curr_cpu == cpu_op_tbl[0].cpu_rate) {
+			maxf = 1;
+			goto END;
+		} else {
+			if (!high_bus_freq_mode && !cpu_is_mx50()) {
+				/* bump up LP freq first. */
+				bus_incr = 1;
+				dvfs_load_config(2);
+			} else {
+				/* freq up */
+				curr_op = 0;
+				maxf = 1;
+				dvfs_load_config(0);
+			}
+		}
+	}
+
+	low_freq_bus_ready = low_freq_bus_used();
+	if ((curr_op == cpu_op_nr - 1) && (!low_bus_freq_mode)
+	    && (low_freq_bus_ready) && !bus_incr) {
+		if (cpu_dcr)
+			ret = set_cpu_freq(curr_op);
+		if (!cpu_dcr) {
+			set_low_bus_freq();
+			dvfs_load_config(3);
+		} else {
+			dvfs_load_config(2);
+			cpu_dcr = 0;
+		}
+	} else {
+		if (!high_bus_freq_mode)
+			set_high_bus_freq(1);
+		if (!bus_incr)
+			ret = set_cpu_freq(curr_op);
+		bus_incr = 0;
+	}
+
+
+END:	/* Set MAXF, MINF */
+	reg = __raw_readl(dvfs_data->membase + MXC_DVFSCORE_CNTR);
+	reg = (reg & ~(MXC_DVFSCNTR_MAXF_MASK | MXC_DVFSCNTR_MINF_MASK));
+	reg |= maxf << MXC_DVFSCNTR_MAXF_OFFSET;
+	reg |= minf << MXC_DVFSCNTR_MINF_OFFSET;
+
+	/* Enable DVFS interrupt */
+	/* FSVAIM=0 */
+	reg = (reg & ~MXC_DVFSCNTR_FSVAIM);
+	reg |= FSVAI_FREQ_NOCHANGE;
+	/* LBFL=1 */
+	reg = (reg & ~MXC_DVFSCNTR_LBFL);
+	reg |= MXC_DVFSCNTR_LBFL;
+	__raw_writel(reg, dvfs_data->membase + MXC_DVFSCORE_CNTR);
+	/*Unmask GPC1 IRQ */
+	reg = __raw_readl(gpc_base + dvfs_data->gpc_cntr_offset);
+	reg &= ~MXC_GPCCNTR_GPCIRQM;
+	__raw_writel(reg, gpc_base + dvfs_data->gpc_cntr_offset);
+
+#if defined(CONFIG_CPU_FREQ)
+	if (cpufreq_trig_needed == 1) {
+		cpufreq_trig_needed = 0;
+		cpufreq_update_policy(0);
+	}
+#endif
+}
+
+
+/*!
+ * This function disables the DVFS module.
+ */
+void stop_dvfs(void)
+{
+	u32 reg = 0;
+	unsigned long flags;
+	u32 curr_cpu;
+
+	if (dvfs_core_is_active) {
+
+		/* Mask dvfs irq, disable DVFS */
+		reg = __raw_readl(dvfs_data->membase
+				  + MXC_DVFSCORE_CNTR);
+		/* FSVAIM=1 */
+		reg |= MXC_DVFSCNTR_FSVAIM;
+		__raw_writel(reg, dvfs_data->membase
+				  + MXC_DVFSCORE_CNTR);
+
+		curr_op = 0;
+		if (!high_bus_freq_mode)
+			set_high_bus_freq(1);
+
+		curr_cpu = clk_get_rate(cpu_clk);
+		if (curr_cpu != cpu_op_tbl[curr_op].cpu_rate) {
+			set_cpu_freq(curr_op);
+#if defined(CONFIG_CPU_FREQ)
+			if (cpufreq_trig_needed == 1) {
+				cpufreq_trig_needed = 0;
+				cpufreq_update_policy(0);
+			}
+#endif
+		}
+		spin_lock_irqsave(&mxc_dvfs_core_lock, flags);
+
+		reg = __raw_readl(dvfs_data->membase
+				  + MXC_DVFSCORE_CNTR);
+		reg = (reg & ~MXC_DVFSCNTR_DVFEN);
+		__raw_writel(reg, dvfs_data->membase
+				  + MXC_DVFSCORE_CNTR);
+
+		spin_unlock_irqrestore(&mxc_dvfs_core_lock, flags);
+
+		dvfs_core_is_active = 0;
+
+		clk_disable(dvfs_clk);
+	}
+
+	printk(KERN_DEBUG "DVFS is stopped\n");
+}
+
+void dump_dvfs_core_regs()
+{
+	struct timeval cur;
+	u32 diff = 0;
+	if (core_prev_intr.tv_sec == 0)
+		do_gettimeofday(&core_prev_intr);
+	else {
+		do_gettimeofday(&cur);
+		diff = (cur.tv_sec - core_prev_intr.tv_sec)*1000000
+			 + (cur.tv_usec - core_prev_intr.tv_usec);
+		core_prev_intr = cur;
+	}
+	if (diff < 90000)
+		printk(KERN_DEBUG "diff = %d\n", diff);
+
+	printk(KERN_INFO "THRS = 0x%08x\n",
+			__raw_readl(dvfs_data->membase
+				    + MXC_DVFSCORE_THRS));
+	printk(KERN_INFO "COUNT = 0x%08x\n",
+			__raw_readl(dvfs_data->membase
+				    + MXC_DVFSCORE_THRS + 0x04));
+	printk(KERN_INFO "SIG1 = 0x%08x\n",
+			__raw_readl(dvfs_data->membase
+				    + MXC_DVFSCORE_THRS + 0x08));
+	printk(KERN_INFO "SIG0 = 0x%08x\n",
+			__raw_readl(dvfs_data->membase
+				    + MXC_DVFSCORE_THRS + 0x0c));
+	printk(KERN_INFO "GPC0 = 0x%08x\n",
+			__raw_readl(dvfs_data->membase
+				    + MXC_DVFSCORE_THRS + 0x10));
+	printk(KERN_INFO "GPC1 = 0x%08x\n",
+			__raw_readl(dvfs_data->membase
+				    + MXC_DVFSCORE_THRS + 0x14));
+	printk(KERN_INFO "GPBT = 0x%08x\n",
+			__raw_readl(dvfs_data->membase
+				    + MXC_DVFSCORE_THRS + 0x18));
+	printk(KERN_INFO "EMAC = 0x%08x\n",
+			__raw_readl(dvfs_data->membase
+				    + MXC_DVFSCORE_THRS + 0x1c));
+	printk(KERN_INFO "CNTR = 0x%08x\n",
+			__raw_readl(dvfs_data->membase
+				    + MXC_DVFSCORE_THRS + 0x20));
+	printk(KERN_INFO "LTR0_0 = 0x%08x\n",
+			__raw_readl(dvfs_data->membase
+				    + MXC_DVFSCORE_THRS + 0x24));
+	printk(KERN_INFO "LTR0_1 = 0x%08x\n",
+			__raw_readl(dvfs_data->membase
+				    + MXC_DVFSCORE_THRS + 0x28));
+	printk(KERN_INFO "LTR1_0 = 0x%08x\n",
+			__raw_readl(dvfs_data->membase
+				    + MXC_DVFSCORE_THRS + 0x2c));
+	printk(KERN_DEBUG "LTR1_1 = 0x%08x\n",
+			__raw_readl(dvfs_data->membase
+				    + MXC_DVFSCORE_THRS + 0x30));
+	printk(KERN_INFO "PT0 = 0x%08x\n",
+			__raw_readl(dvfs_data->membase
+				    + MXC_DVFSCORE_THRS + 0x34));
+	printk(KERN_INFO "PT1 = 0x%08x\n",
+			__raw_readl(dvfs_data->membase
+				    + MXC_DVFSCORE_THRS + 0x38));
+	printk(KERN_INFO "PT2 = 0x%08x\n",
+			__raw_readl(dvfs_data->membase
+				    + MXC_DVFSCORE_THRS + 0x3c));
+	printk(KERN_INFO "PT3 = 0x%08x\n",
+			__raw_readl(dvfs_data->membase
+				    + MXC_DVFSCORE_THRS + 0x40));
+}
+
+static ssize_t downthreshold_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%u\n", dvfs_core_setpoint[0].downthr);
+}
+
+static ssize_t downthreshold_store(struct device *dev,
+				 struct device_attribute *attr,
+				 const char *buf, size_t size)
+{
+	int ret = 0;
+	int val;
+	ret = sscanf(buf, "%u", &val);
+	dvfs_core_setpoint[0].downthr = val;
+
+	return size;
+}
+
+static ssize_t downcount_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%u\n", dvfs_core_setpoint[0].downcnt);
+}
+
+static ssize_t downcount_store(struct device *dev,
+				 struct device_attribute *attr,
+				 const char *buf, size_t size)
+{
+	int ret = 0;
+	int val;
+	ret = sscanf(buf, "%u", &val);
+	dvfs_core_setpoint[0].downcnt = val;
+
+	return size;
+}
+
+
+static ssize_t dvfs_enable_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	if (dvfs_core_is_active)
+		return sprintf(buf, "DVFS is enabled\n");
+	else
+		return sprintf(buf, "DVFS is disabled\n");
+}
+
+static ssize_t dvfs_enable_store(struct device *dev,
+				 struct device_attribute *attr,
+				 const char *buf, size_t size)
+{
+	if (strstr(buf, "1") != NULL) {
+		if (start_dvfs() != 0)
+			printk(KERN_ERR "Failed to start DVFS\n");
+	} else if (strstr(buf, "0") != NULL)
+		stop_dvfs();
+
+	return size;
+}
+
+static ssize_t dvfs_regs_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	if (dvfs_core_is_active)
+		dump_dvfs_core_regs();
+	return 0;
+}
+
+static ssize_t dvfs_regs_store(struct device *dev,
+				 struct device_attribute *attr,
+				 const char *buf, size_t size)
+{
+	if (dvfs_core_is_active)
+		dump_dvfs_core_regs();
+	return 0;
+
+	return size;
+}
+
+static DEVICE_ATTR(enable, 0644, dvfs_enable_show, dvfs_enable_store);
+static DEVICE_ATTR(show_regs, 0644, dvfs_regs_show, dvfs_regs_store);
+
+static DEVICE_ATTR(down_threshold, 0644, downthreshold_show,
+						downthreshold_store);
+static DEVICE_ATTR(down_count, 0644, downcount_show, downcount_store);
+
+/*!
+ * This is the probe routine for the DVFS driver.
+ *
+ * @param   pdev   The platform device structure
+ *
+ * @return         The function returns 0 on success
+ */
+static int __devinit mxc_dvfs_core_probe(struct platform_device *pdev)
+{
+	int err = 0;
+	struct resource *res;
+
+	printk(KERN_INFO "mxc_dvfs_core_probe\n");
+	dvfs_dev = &pdev->dev;
+	dvfs_data = pdev->dev.platform_data;
+
+	INIT_DELAYED_WORK(&dvfs_core_handler, dvfs_core_work_handler);
+
+	pll1_sw_clk = clk_get(NULL, "pll1_sw_clk");
+	if (IS_ERR(pll1_sw_clk)) {
+		printk(KERN_INFO "%s: failed to get pll1_sw_clk\n", __func__);
+		return PTR_ERR(pll1_sw_clk);
+	}
+
+	cpu_clk = clk_get(NULL, dvfs_data->clk1_id);
+	if (IS_ERR(cpu_clk)) {
+		printk(KERN_ERR "%s: failed to get cpu clock\n", __func__);
+		return PTR_ERR(cpu_clk);
+	}
+
+	dvfs_clk = clk_get(NULL, dvfs_data->clk2_id);
+	if (IS_ERR(dvfs_clk)) {
+		printk(KERN_ERR "%s: failed to get dvfs clock\n", __func__);
+		return PTR_ERR(dvfs_clk);
+	}
+
+	core_regulator = regulator_get(NULL, dvfs_data->reg_id);
+	if (IS_ERR(core_regulator)) {
+		clk_put(cpu_clk);
+		clk_put(dvfs_clk);
+		printk(KERN_ERR "%s: failed to get gp regulator\n", __func__);
+		return PTR_ERR(core_regulator);
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res == NULL) {
+		err = -ENODEV;
+		goto err1;
+	}
+	dvfs_data->membase = ioremap(res->start, res->end - res->start + 1);
+	/*
+	 * Request the DVFS interrupt
+	 */
+	dvfs_data->irq = platform_get_irq(pdev, 0);
+	if (dvfs_data->irq < 0) {
+		err = dvfs_data->irq;
+		goto err2;
+	}
+
+	/* request the DVFS interrupt */
+	err = request_irq(dvfs_data->irq, dvfs_irq, IRQF_SHARED, "dvfs",
+			  dvfs_dev);
+	if (err) {
+		printk(KERN_ERR
+		       "DVFS: Unable to attach to DVFS interrupt,err = %d",
+		       err);
+		goto err2;
+	}
+
+	clk_enable(dvfs_clk);
+	err = init_dvfs_controller();
+	if (err) {
+		printk(KERN_ERR "DVFS: Unable to initialize DVFS");
+		return err;
+	}
+	clk_disable(dvfs_clk);
+
+	err = sysfs_create_file(&dvfs_dev->kobj, &dev_attr_enable.attr);
+	if (err) {
+		printk(KERN_ERR
+		       "DVFS: Unable to register sysdev entry for DVFS");
+		goto err3;
+	}
+
+	err = sysfs_create_file(&dvfs_dev->kobj, &dev_attr_show_regs.attr);
+	if (err) {
+		printk(KERN_ERR
+		       "DVFS: Unable to register sysdev entry for DVFS");
+		goto err3;
+	}
+
+
+	err = sysfs_create_file(&dvfs_dev->kobj, &dev_attr_down_threshold.attr);
+	if (err) {
+		printk(KERN_ERR
+		       "DVFS: Unable to register sysdev entry for DVFS");
+		goto err3;
+	}
+
+	err = sysfs_create_file(&dvfs_dev->kobj, &dev_attr_down_count.attr);
+	if (err) {
+		printk(KERN_ERR
+		       "DVFS: Unable to register sysdev entry for DVFS");
+		goto err3;
+	}
+
+	/* Set the current working point. */
+	cpu_op_tbl = get_cpu_op(&cpu_op_nr);
+	old_op = 0;
+	curr_op = 0;
+	dvfs_core_resume = 0;
+	cpufreq_trig_needed = 0;
+
+	return err;
+err3:
+	free_irq(dvfs_data->irq, dvfs_dev);
+err2:
+	iounmap(dvfs_data->membase);
+err1:
+	dev_err(&pdev->dev, "Failed to probe DVFS CORE\n");
+	return err;
+}
+
+/*!
+ * This function is called to put DVFS in a low power state.
+ *
+ * @param   pdev  the device structure
+ * @param   state the power state the device is entering
+ *
+ * @return  The function always returns 0.
+ */
+static int mxc_dvfs_core_suspend(struct platform_device *pdev,
+				 pm_message_t state)
+{
+	if (dvfs_core_is_active) {
+		dvfs_core_resume = 1;
+		stop_dvfs();
+	}
+
+	return 0;
+}
+
+/*!
+ * This function is called to resume the MU from a low power state.
+ *
+ * @param   dev   the device structure
+ * @param   level the stage in device suspension process that we want the
+ *                device to be put in
+ *
+ * @return  The function always returns 0.
+ */
+static int mxc_dvfs_core_resume(struct platform_device *pdev)
+{
+	if (dvfs_core_resume) {
+		dvfs_core_resume = 0;
+		start_dvfs();
+	}
+
+	return 0;
+}
+
+static struct platform_driver mxc_dvfs_core_driver = {
+	.driver = {
+		   .name = "mxc_dvfs_core",
+		   },
+	.probe = mxc_dvfs_core_probe,
+	.suspend = mxc_dvfs_core_suspend,
+	.resume = mxc_dvfs_core_resume,
+};
+
+static int __init dvfs_init(void)
+{
+	if (platform_driver_register(&mxc_dvfs_core_driver) != 0) {
+		printk(KERN_ERR "mxc_dvfs_core_driver register failed\n");
+		return -ENODEV;
+	}
+
+	dvfs_core_is_active = 0;
+	printk(KERN_INFO "DVFS driver module loaded\n");
+	return 0;
+}
+
+static void __exit dvfs_cleanup(void)
+{
+	stop_dvfs();
+
+	/* release the DVFS interrupt */
+	free_irq(dvfs_data->irq, dvfs_dev);
+
+	sysfs_remove_file(&dvfs_dev->kobj, &dev_attr_enable.attr);
+
+	/* Unregister the device structure */
+	platform_driver_unregister(&mxc_dvfs_core_driver);
+
+	iounmap(ccm_base);
+	iounmap(dvfs_data->membase);
+	clk_put(cpu_clk);
+	clk_put(dvfs_clk);
+
+	dvfs_core_is_active = 0;
+	printk(KERN_INFO "DVFS driver module unloaded\n");
+
+}
+
+module_init(dvfs_init);
+module_exit(dvfs_cleanup);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("DVFS driver");
+MODULE_LICENSE("GPL");
diff --git a/arch/arm/plat-mxc/dvfs_per.c b/arch/arm/plat-mxc/dvfs_per.c
new file mode 100755
index 0000000..74b1014
--- /dev/null
+++ b/arch/arm/plat-mxc/dvfs_per.c
@@ -0,0 +1,936 @@
+/*
+ * Copyright (C) 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file dvfs_per.c
+ *
+ * @brief A simplied driver for the Freescale Semiconductor MXC DVFS module.
+ *
+ * Upon initialization, the DVFS driver initializes the DVFS hardware
+ * sets up driver nodes attaches to the DVFS interrupt and initializes internal
+ * data structures. When the DVFS interrupt occurs the driver checks the cause
+ * of the interrupt (lower frequency, increase frequency or emergency) and
+ * changes the CPU voltage according to translation table that is loaded into
+ * the driver.
+ *
+ * @ingroup PM
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/interrupt.h>
+#include <linux/jiffies.h>
+#include <linux/device.h>
+#include <linux/sysdev.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/regulator/consumer.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <linux/workqueue.h>
+#include <linux/io.h>
+#include <linux/slab.h>
+
+#include <mach/hardware.h>
+#include <mach/mxc_dvfs.h>
+#include <mach/sdram_autogating.h>
+#include <mach/clock.h>
+#if defined(CONFIG_ARCH_MX37)
+#include <mach/mxc_dptc.h>
+#endif
+
+/* DVFS PER */
+#define MXC_DVFS_PER_LTR0	0x00
+#define MXC_DVFS_PER_LTR1	0x04
+#define MXC_DVFS_PER_LTR2	0x08
+#define MXC_DVFS_PER_LTR3	0x0C
+#define MXC_DVFS_PER_LTBR0	0x10
+#define MXC_DVFS_PER_LTBR1	0x14
+#define MXC_DVFS_PER_PMCR0	0x18
+#define MXC_DVFS_PER_PMCR1	0x1C
+
+#define DRIVER_NAME "DVFSPER"
+#define DVFS_PER_DEBUG 0
+
+static int dvfs_per_stop;
+static int dvfs_per_low_freq;
+static int dvfs_per_suspended;
+static volatile int freq_increased;
+static int cur_setpoint;
+static struct delayed_work dvfs_per_work;
+static struct clk *dvfs_clk;
+static struct clk *main_bus_clk;
+static struct clk *pll2;
+static struct clk *lpapm;
+static struct clk *cpu_clk;
+static struct clk *axi_b_clk;
+static struct clk *ahb_clk;
+static struct clk *ddr_hf_clk;
+static struct regulator *lp_regulator;
+
+/* Flag used to indicate if dvfs_per is active. */
+static int dvfs_per_is_active;
+static int dvfs_per_is_paused;
+static int ipu_freq_scaled;
+
+struct dvfsper_device *dvfsper_device_data;
+/* DVFS platform data pointer */
+struct mxc_dvfsper_data *dvfsper_plt_data;
+struct timeval prev_intr;
+
+int start_dvfs_per(void);
+void stop_dvfs_per(void);
+int dvfs_per_active(void);
+int dvfs_per_divider_active(void);
+int dvfs_per_pixel_clk_limit(void);
+
+extern int low_bus_freq_mode;
+extern int bus_freq_scaling_is_active;
+
+
+/*!
+ * In case the MXC device has multiple DVFS modules, this structure is used to
+ * store information specific to each DVFS module.
+ */
+struct dvfsper_device {
+	/* DVFS delayed work */
+	struct delayed_work dvfs_work;
+	/* DVFS regulator */
+	struct regulator *dvfs_reg;
+	/* DVFS clock */
+	struct clk *dvfs_clk;
+	/* The interrupt number used by the DVFS device */
+	int irq;
+};
+struct dvfs_wp dvfs_per_setpoint[] = {{33, 7, 33, 20, 40, 0x10},
+				{18, 0, 33, 25, 10, 0x10},
+				/* When LP is at 24MHz */
+				{8, 0, 10, 5, 5, 0x2E},};
+
+enum {
+	FSVAI_FREQ_NOCHANGE = 0x0,
+	FSVAI_FREQ_INCREASE,
+	FSVAI_FREQ_DECREASE,
+	FSVAI_FREQ_EMERG,
+};
+
+#define LOW_BUS_FREQ 24000000
+
+DEFINE_SPINLOCK(mxc_dvfs_per_lock);
+
+static void dvfs_per_load_config(void)
+{
+	u32 reg;
+
+	reg = __raw_readl(dvfsper_plt_data->membase + MXC_DVFS_PER_LTR0);
+	reg &= ~MXC_DVFSLTR0_UPTHR_MASK;
+	reg &= ~MXC_DVFSLTR0_DNTHR_MASK;
+	reg |= dvfs_per_setpoint[cur_setpoint].upthr <<
+						MXC_DVFSLTR0_UPTHR_OFFSET;
+	reg |= dvfs_per_setpoint[cur_setpoint].downthr <<
+						MXC_DVFSLTR0_DNTHR_OFFSET;
+	__raw_writel(reg, dvfsper_plt_data->membase + MXC_DVFS_PER_LTR0);
+
+	reg = __raw_readl(dvfsper_plt_data->membase + MXC_DVFS_PER_LTR1);
+	reg &= ~MXC_DVFSLTR1_PNCTHR_MASK;
+	reg &= ~MXC_DVFSLTR1_DNCNT_MASK;
+	reg &= ~MXC_DVFSLTR1_UPCNT_MASK;
+	reg |= dvfs_per_setpoint[cur_setpoint].downcnt <<
+				MXC_DVFSLTR1_DNCNT_OFFSET;
+	reg |= dvfs_per_setpoint[cur_setpoint].upcnt <<
+				MXC_DVFSLTR1_UPCNT_OFFSET;
+	reg |= dvfs_per_setpoint[cur_setpoint].panicthr <<
+				MXC_DVFSLTR1_PNCTHR_OFFSET;
+	__raw_writel(reg, dvfsper_plt_data->membase + MXC_DVFS_PER_LTR1);
+
+	reg = dvfs_per_setpoint[cur_setpoint].emac <<
+				MXC_DVFSLTR2_EMAC_OFFSET;
+	__raw_writel(reg, dvfsper_plt_data->membase + MXC_DVFS_PER_LTR2);
+}
+
+/*!
+ * This function is called for module initialization.
+ * It sets up the DVFS hardware.
+ * It sets default values for DVFS thresholds and counters. The default
+ * values was chosen from a set of different reasonable values. They was tested
+ * and the default values in the driver gave the best results.
+ * More work should be done to find optimal values.
+ *
+ * @return   0 if successful; non-zero otherwise.
+ *
+ */
+static int init_dvfs_per_controller(void)
+{
+	u32 reg;
+
+	reg = __raw_readl(dvfsper_plt_data->membase + MXC_DVFS_PER_LTR0);
+	/* DIV3CLK */
+	reg &= ~dvfsper_plt_data->div3_mask;
+	reg |= (dvfsper_plt_data->div3_div <<
+		  dvfsper_plt_data->div3_offset);
+	__raw_writel(reg, dvfsper_plt_data->membase + MXC_DVFS_PER_LTR0);
+
+	reg = __raw_readl(dvfsper_plt_data->membase + MXC_DVFS_PER_LTR1);
+	/* Set load tracking buffer register source */
+	reg &= ~MXC_DVFSLTR1_LTBRSR;
+	reg |= MXC_DVFSLTR1_LTBRSR;
+	reg &= ~MXC_DVFSLTR1_LTBRSH;
+	__raw_writel(reg, dvfsper_plt_data->membase + MXC_DVFS_PER_LTR1);
+
+	/* Enable all the peripheral signals, but VPU and IPU panic*/
+	__raw_writel(0x30000, dvfsper_plt_data->membase + MXC_DVFS_PER_PMCR1);
+	/* Disable weighted load tracking signals */
+	__raw_writel(0, dvfsper_plt_data->membase + MXC_DVFS_PER_LTR3);
+
+	reg = __raw_readl(dvfsper_plt_data->membase + MXC_DVFS_PER_PMCR0);
+	reg &= ~MXC_DVFSPMCR0_DVFEV;
+	reg |= MXC_DVFSPMCR0_LBMI;
+	__raw_writel(reg, dvfsper_plt_data->membase + MXC_DVFS_PER_PMCR0);
+
+	/* DVFS loading config */
+	dvfs_per_load_config();
+	return 0;
+}
+
+#if DVFS_PER_DEBUG
+static void dump_dvfs_per_regs(void)
+{
+	struct timeval cur;
+	u32 diff = 0;
+	if (prev_intr.tv_sec == 0)
+		do_gettimeofday(&prev_intr);
+	else {
+		do_gettimeofday(&cur);
+		diff = (cur.tv_sec - prev_intr.tv_sec)*1000000
+			 + (cur.tv_usec - prev_intr.tv_usec);
+		prev_intr = cur;
+	}
+	if (diff < 90000)
+		printk(KERN_INFO "diff = %d\n", diff);
+
+	printk(KERN_INFO "LTRO = 0x%08x\n",
+		__raw_readl(dvfsper_plt_data->membase + MXC_DVFS_PER_LTR0));
+	printk(KERN_INFO "LTR1 = 0x%08x\n",
+		__raw_readl(dvfsper_plt_data->membase + MXC_DVFS_PER_LTR1));
+	printk(KERN_INFO "LTR2 = 0x%08x\n",
+		__raw_readl(dvfsper_plt_data->membase + MXC_DVFS_PER_LTR2));
+	printk(KERN_INFO "LTR3 = 0x%08x\n",
+		__raw_readl(dvfsper_plt_data->membase + MXC_DVFS_PER_LTR3));
+	printk(KERN_INFO "LBTR0 = 0x%08x\n",
+		__raw_readl(dvfsper_plt_data->membase + MXC_DVFS_PER_LTBR0));
+	printk(KERN_INFO "LBTR1 = 0x%08x\n",
+		__raw_readl(dvfsper_plt_data->membase + MXC_DVFS_PER_LTBR1));
+	printk(KERN_INFO "PMCR0 = 0x%08x\n",
+		__raw_readl(dvfsper_plt_data->membase + MXC_DVFS_PER_PMCR0));
+	printk(KERN_INFO "PMCR1 = 0x%08x\n",
+		__raw_readl(dvfsper_plt_data->membase + MXC_DVFS_PER_PMCR1));
+}
+#endif
+
+static irqreturn_t dvfs_per_irq(int irq, void *dev_id)
+{
+	u32 reg;
+
+	/* Check if DVFS1 (PER) id requesting for freqency/voltage update */
+	if ((__raw_readl(dvfsper_plt_data->gpc_cntr_reg_addr) &
+						MXC_GPCCNTR_DVFS1CR) == 0)
+		return IRQ_NONE;
+	/* Mask DVFS irq */
+	reg = __raw_readl(dvfsper_plt_data->membase + MXC_DVFS_PER_PMCR0);
+	/* FSVAIM=1 */
+	reg |= MXC_DVFSPMCR0_FSVAIM;
+	__raw_writel(reg, dvfsper_plt_data->membase + MXC_DVFS_PER_PMCR0);
+	/* Mask GPC1 irq */
+	reg = __raw_readl(dvfsper_plt_data->gpc_cntr_reg_addr);
+	reg |= MXC_GPCCNTR_GPCIRQM | 0x1000000;
+	__raw_writel(reg, dvfsper_plt_data->gpc_cntr_reg_addr);
+
+	reg = __raw_readl(dvfsper_plt_data->membase + MXC_DVFS_PER_PMCR0);
+	if (reg & MXC_DVFSPMCR0_LBFL) {
+		/* clear LBFL */
+		reg = (reg & ~MXC_DVFSPMCR0_LBFL);
+		reg |= MXC_DVFSPMCR0_LBFL;
+		__raw_writel(reg, dvfsper_plt_data->membase
+				  + MXC_DVFS_PER_PMCR0);
+	}
+	schedule_delayed_work(&dvfs_per_work, 0);
+	return IRQ_HANDLED;
+}
+
+static void dvfs_per_handler(struct work_struct *work)
+{
+	u32 fsvai;
+	u32 reg;
+	u32 ret;
+	unsigned long flags;
+	int retry = 20;
+
+	/* Check DVFS frequency adjustment interrupt status */
+	reg = __raw_readl(dvfsper_plt_data->membase + MXC_DVFS_PER_PMCR0);
+	fsvai = (reg & MXC_DVFSPMCR0_FSVAI_MASK) >> MXC_DVFSPMCR0_FSVAI_OFFSET;
+	/* Check FSVAI, FSVAI=0 is error */
+	if (fsvai == FSVAI_FREQ_NOCHANGE) {
+		/* Do nothing. Freq change is not required */
+		goto END;
+	}
+
+#if DVFS_PER_DEBUG
+	dump_dvfs_per_regs();
+#endif
+	/* If FSVAI indicate freq down. */
+	if (fsvai == FSVAI_FREQ_DECREASE) {
+		if (cpu_is_mx51()) {
+			/*Change the DDR freq to 133Mhz. */
+			clk_set_rate(ddr_hf_clk,
+				clk_round_rate(ddr_hf_clk, 133000000));
+		}
+
+#ifndef DVFS_SW_WORKAROUND
+		spin_lock_irqsave(&mxc_dvfs_per_lock, flags);
+		reg = __raw_readl(dvfsper_plt_data->membase
+				  + MXC_DVFS_PER_PMCR0);
+		reg &= ~MXC_DVFSPMCR0_UDCS;
+		__raw_writel(reg, dvfsper_plt_data->membase
+				  + MXC_DVFS_PER_PMCR0);
+
+		/* Set the peripheral divider */
+		reg = __raw_readl(dvfsper_plt_data->gpc_cntr_reg_addr);
+		reg &= ~(MXC_GPCCNTR_ADU_MASK | MXC_GPCCNTR_FUPD_MASK);
+		reg |= MXC_GPCCNTR_FUPD;
+		__raw_writel(reg, dvfsper_plt_data->gpc_cntr_reg_addr);
+
+		reg = __raw_readl(dvfsper_plt_data->gpc_vcr_reg_addr);
+		reg &= ~(MXC_GPCVCR_VINC_MASK | MXC_GPCVCR_VCNTU_MASK |
+		      MXC_GPCVCR_VCNT_MASK);
+		reg |= (1 << MXC_GPCVCR_VCNTU_OFFSET) |
+			(1 << MXC_GPCVCR_VCNT_OFFSET);
+		__raw_writel(reg, dvfsper_plt_data->gpc_vcr_reg_addr);
+
+		reg = __raw_readl(dvfsper_plt_data->gpc_cntr_reg_addr);
+		reg |= MXC_GPCCNTR_STRT;
+		__raw_writel(reg, dvfsper_plt_data->gpc_cntr_reg_addr);
+
+		retry = 10;
+		while ((__raw_readl(
+			dvfsper_plt_data->gpc_cntr_reg_addr) & 0x4000)
+			&& retry > 0) {
+			udelay(10);
+			retry--;
+		}
+		spin_unlock_irqrestore(&mxc_dvfs_per_lock, flags);
+#else
+		/*Set the frequencies manually */
+		rate = clk_get_rate(axi_b_clk);
+		clk_set_rate(axi_b_clk, clk_round_rate(axi_b_clk, rate/2));
+
+		rate = clk_get_rate(ahb_clk);
+		clk_set_rate(ahb_clk, clk_round_rate(ahb_clk, rate/2));
+#endif
+		dvfs_per_low_freq = 1;
+		if (clk_get_rate(main_bus_clk) == LOW_BUS_FREQ) {
+			cur_setpoint = 2;
+		} else {
+#if defined(CONFIG_ARCH_MX37)
+			dptc_suspend(DPTC_LP_ID);
+#endif
+			cur_setpoint = 1;
+#ifndef DVFS_SW_WORKAROUND
+			clk_set_parent(main_bus_clk, clk_get(NULL, "pll2"));
+#endif
+		}
+#ifndef DVFS_SW_WORKAROUND
+		/* Drop the LP domain voltage */
+		ret = regulator_set_voltage(lp_regulator,
+					dvfsper_plt_data->lp_low,
+					dvfsper_plt_data->lp_low);
+		if (ret < 0) {
+			printk(KERN_DEBUG "COULD NOT SET LP VOLTAGE\n");
+			return;
+		}
+		udelay(100);
+#endif
+		dvfs_per_load_config();
+	} else if ((fsvai == FSVAI_FREQ_INCREASE) ||
+			(fsvai == FSVAI_FREQ_EMERG)) {
+#ifndef DVFS_SW_WORKAROUND
+		/* Increase the LP domain voltage first. */
+		ret = regulator_set_voltage(lp_regulator,
+					dvfsper_plt_data->lp_high,
+					dvfsper_plt_data->lp_high);
+		if (ret < 0) {
+			printk(KERN_DEBUG "COULD NOT SET LP VOLTAGE\n");
+			return;
+		}
+		udelay(100);
+#endif
+
+#ifndef DVFS_SW_WORKAROUND
+		spin_lock_irqsave(&mxc_dvfs_per_lock, flags);
+		reg = __raw_readl(dvfsper_plt_data->membase
+				  + MXC_DVFS_PER_PMCR0);
+		reg |= MXC_DVFSPMCR0_UDCS;
+		__raw_writel(reg, dvfsper_plt_data->membase
+				  + MXC_DVFS_PER_PMCR0);
+
+		reg = __raw_readl(dvfsper_plt_data->gpc_cntr_reg_addr);
+		reg &= ~(MXC_GPCCNTR_ADU_MASK | MXC_GPCCNTR_FUPD_MASK);
+		reg |= MXC_GPCCNTR_FUPD;
+		__raw_writel(reg, dvfsper_plt_data->gpc_cntr_reg_addr);
+
+		reg = __raw_readl(dvfsper_plt_data->gpc_vcr_reg_addr);
+		reg &= ~(MXC_GPCVCR_VINC_MASK | MXC_GPCVCR_VCNTU_MASK |
+		      MXC_GPCVCR_VCNT_MASK);
+		reg |= (1 << MXC_GPCVCR_VINC_OFFSET |
+			1 << MXC_GPCVCR_VCNTU_OFFSET |
+			1 << MXC_GPCVCR_VCNT_OFFSET);
+		__raw_writel(reg, dvfsper_plt_data->gpc_vcr_reg_addr);
+
+		reg = __raw_readl(dvfsper_plt_data->gpc_cntr_reg_addr);
+		reg &= ~MXC_GPCCNTR_ADU;
+		reg |= MXC_GPCCNTR_STRT;
+		__raw_writel(reg, dvfsper_plt_data->gpc_cntr_reg_addr);
+		retry = 10;
+		while ((__raw_readl(
+				dvfsper_plt_data->gpc_cntr_reg_addr) & 0x4000)
+				&& retry > 0) {
+			udelay(10);
+			retry--;
+		}
+		spin_unlock_irqrestore(&mxc_dvfs_per_lock, flags);
+
+	if (retry < 0)
+		printk(KERN_ERR "****ERROR- DVFS\n");
+#else
+		/*Set the frequencies manually */
+		rate = clk_get_rate(axi_b_clk);
+		clk_set_rate(axi_b_clk, clk_round_rate(axi_b_clk, 130000000));
+		rate = clk_get_rate(ahb_clk);
+		clk_set_rate(ahb_clk, clk_round_rate(ahb_clk, 130000000));
+#endif
+		if (cpu_is_mx51()) {
+			/*Change the DDR freq to 200Mhz. */
+			clk_set_rate(ddr_hf_clk, clk_round_rate(ddr_hf_clk,
+						200000000));
+		}
+		dvfs_per_low_freq = 0;
+		if (clk_get_rate(main_bus_clk) == LOW_BUS_FREQ) {
+			cur_setpoint = 2;
+		} else {
+			cur_setpoint = 0;
+#if defined(CONFIG_ARCH_MX37)
+			dptc_resume(DPTC_LP_ID);
+#endif
+#ifndef DVFS_SW_WORKAROUND
+			clk_set_parent(main_bus_clk, clk_get(NULL, "pll2"));
+#endif
+		}
+		dvfs_per_load_config();
+		freq_increased = 1;
+	}
+
+END:
+#if DVFS_PER_DEBUG
+	dump_dvfs_per_regs(void)();
+#endif
+	if (dvfs_per_is_active) {
+		reg = __raw_readl(dvfsper_plt_data->membase
+				  + MXC_DVFS_PER_PMCR0);
+		/* Enable dVFS interrupt */
+		/* FSVAIM=0 */
+		reg &= ~MXC_DVFSPMCR0_FSVAI_MASK;
+		reg |= FSVAI_FREQ_NOCHANGE;
+		reg = (reg & ~MXC_DVFSPMCR0_FSVAIM);
+		__raw_writel(reg, dvfsper_plt_data->membase
+				  + MXC_DVFS_PER_PMCR0);
+		/*Unmask GPC1 IRQ */
+		reg = __raw_readl(dvfsper_plt_data->gpc_cntr_reg_addr);
+		reg &= ~MXC_GPCCNTR_GPCIRQM;
+		__raw_writel(reg, dvfsper_plt_data->gpc_cntr_reg_addr);
+	}
+}
+
+static void force_freq_change(void)
+{
+	u32 reg;
+	int retry = 50;
+
+	freq_increased = 0;
+
+	reg = __raw_readl(dvfsper_plt_data->membase + MXC_DVFS_PER_PMCR0);
+	reg |= MXC_DVFSPMCR0_UDCS;
+	__raw_writel(reg, dvfsper_plt_data->membase + MXC_DVFS_PER_PMCR0);
+
+	if (cpu_is_mx51()) {
+		/*Change the DDR freq to 133Mhz. */
+		clk_set_rate(ddr_hf_clk, clk_round_rate(ddr_hf_clk, 200000000));
+	}
+
+#ifndef DVFS_SW_WORKAROUND
+	reg = __raw_readl(dvfsper_plt_data->gpc_cntr_reg_addr);
+	reg |= MXC_GPCCNTR_FUPD;
+	__raw_writel(reg, dvfsper_plt_data->gpc_cntr_reg_addr);
+	reg = __raw_readl(dvfsper_plt_data->gpc_vcr_reg_addr);
+	reg &= ~(MXC_GPCVCR_VINC_MASK | MXC_GPCVCR_VCNTU_MASK |
+	      MXC_GPCVCR_VCNT_MASK);
+	reg |= (1 << MXC_GPCVCR_VINC_OFFSET |
+		1 << MXC_GPCVCR_VCNTU_OFFSET |
+		20 << MXC_GPCVCR_VCNT_OFFSET);
+	__raw_writel(reg, dvfsper_plt_data->gpc_vcr_reg_addr);
+	reg = __raw_readl(dvfsper_plt_data->gpc_cntr_reg_addr);
+	reg &= ~MXC_GPCCNTR_ADU;
+	reg |= MXC_GPCCNTR_STRT;
+	__raw_writel(reg, dvfsper_plt_data->gpc_cntr_reg_addr);
+	while ((__raw_readl(
+			dvfsper_plt_data->gpc_cntr_reg_addr) & 0x4000)
+			&& retry > 0) {
+		udelay(30);
+		retry--;
+	}
+	freq_increased = 1;
+	if (retry <= 0)
+		printk(KERN_ERR "Cannot stop DVFS-PER\n");
+#else
+	/* Set the frequencies manually */
+	rate = clk_get_rate(axi_b_clk);
+	clk_set_rate(axi_b_clk, clk_round_rate(axi_b_clk, 130000000));
+	rate = clk_get_rate(ahb_clk);
+	clk_set_rate(ahb_clk, clk_round_rate(ahb_clk, 130000000));
+#endif
+	dvfs_per_low_freq = 0;
+
+#ifndef DVFS_SW_WORKAROUND
+	clk_set_parent(main_bus_clk, pll2);
+#endif
+}
+
+static int start(void)
+{
+	u32 reg;
+	unsigned long flags;
+
+	if (dvfs_per_is_active || dvfs_per_stop)
+		return 0;
+
+	if (low_bus_freq_mode)
+		return 0;
+
+	if (bus_freq_scaling_is_active) {
+		dvfs_per_is_paused = 1;
+		printk(KERN_INFO "Cannot start DVFS-PER since bus_freq_scaling\
+			is active\n");
+		return 0;
+	}
+
+	if (!dvfs_per_pixel_clk_limit()) {
+		dvfs_per_is_paused = 1;
+		printk(KERN_INFO "Cannot start DVFS-PER since pixel clock is\
+			above 60MHz or divider is not even\n");
+		return 0;
+	}
+
+	stop_sdram_autogating();
+
+	spin_lock_irqsave(&mxc_dvfs_per_lock, flags);
+
+	clk_enable(dvfs_clk);
+
+	cur_setpoint = 0;
+	init_dvfs_per_controller();
+
+	/* config reg GPC_CNTR */
+	reg = __raw_readl(dvfsper_plt_data->gpc_cntr_reg_addr);
+	/* ADU=0, select PER domain */
+	reg &= ~MXC_GPCCNTR_ADU;
+	__raw_writel(reg, dvfsper_plt_data->gpc_cntr_reg_addr);
+
+	reg = __raw_readl(dvfsper_plt_data->membase + MXC_DVFS_PER_PMCR0);
+	/* Select ARM domain */
+	reg |= MXC_DVFSPMCR0_DVFIS;
+	/* Set the UDCS bit */
+	reg |= MXC_DVFSPMCR0_UDCS;
+	/* Enable DVFS interrupt */
+	/* FSVAIM=0 */
+	reg &= ~MXC_DVFSPMCR0_FSVAIM;
+	/*Set the FSVAI to no_freq_change */
+	reg &= ~MXC_DVFSPMCR0_FSVAI_MASK;
+	reg |= FSVAI_FREQ_NOCHANGE << MXC_DVFSPMCR0_FSVAI_OFFSET;
+	__raw_writel(reg, dvfsper_plt_data->membase + MXC_DVFS_PER_PMCR0);
+
+	/* config reg GPC_CNTR */
+	reg = __raw_readl(dvfsper_plt_data->gpc_cntr_reg_addr);
+	/* GPCIRQ=1, select ARM IRQ */
+	reg |= MXC_GPCCNTR_GPCIRQ_ARM;
+	reg &= ~MXC_GPCCNTR_GPCIRQM;
+	__raw_writel(reg, dvfsper_plt_data->gpc_cntr_reg_addr);
+
+	/* Enable DVFS */
+	reg = __raw_readl(dvfsper_plt_data->membase + MXC_DVFS_PER_PMCR0);
+	reg |= MXC_DVFSPMCR0_DVFEN;
+	__raw_writel(reg, dvfsper_plt_data->membase + MXC_DVFS_PER_PMCR0);
+
+	dvfs_per_is_active = 1;
+	spin_unlock_irqrestore(&mxc_dvfs_per_lock, flags);
+
+	printk(KERN_DEBUG "DVFS PER is started\n");
+
+	return 0;
+}
+
+/*!
+ * This function disables the DVFS module.
+ */
+static void stop(void)
+{
+	u32 reg = 0;
+	unsigned long flags;
+	u32 ret = 0;
+
+	if (dvfs_per_is_active) {
+		dvfs_per_is_active = 0;
+#ifndef DVFS_SW_WORKAROUND
+		/* Increase the LP domain voltage first. */
+		ret = regulator_set_voltage(
+				lp_regulator, dvfsper_plt_data->lp_high,
+				dvfsper_plt_data->lp_high);
+		if (ret < 0) {
+			printk(KERN_DEBUG "COULD NOT SET LP VOLTAGE\n");
+			return;
+		}
+		udelay(100);
+#endif
+
+		spin_lock_irqsave(&mxc_dvfs_per_lock, flags);
+
+		/* Mask dvfs irq, disable DVFS */
+		reg = __raw_readl(dvfsper_plt_data->membase
+				  + MXC_DVFS_PER_PMCR0);
+		/* FSVAIM=1 */
+		reg |= MXC_DVFSPMCR0_FSVAIM;
+		__raw_writel(reg, dvfsper_plt_data->membase
+				  + MXC_DVFS_PER_PMCR0);
+
+		if (cur_setpoint != 0)
+			force_freq_change();
+
+		reg = __raw_readl(dvfsper_plt_data->membase
+				  + MXC_DVFS_PER_PMCR0);
+		reg = (reg & ~MXC_DVFSPMCR0_DVFEN);
+		__raw_writel(reg, dvfsper_plt_data->membase
+				  + MXC_DVFS_PER_PMCR0);
+
+		spin_unlock_irqrestore(&mxc_dvfs_per_lock, flags);
+		clk_disable(dvfs_clk);
+
+		start_sdram_autogating();
+	}
+}
+
+
+int dvfs_per_active()
+{
+	return dvfs_per_is_active;
+}
+
+int dvfs_per_divider_active()
+{
+	return dvfs_per_low_freq;
+}
+
+int dvfs_per_pixel_clk_limit()
+{
+	struct clk *disp0_pixel_clk;
+	struct clk *disp1_pixel_clk;
+	int disp0_rate = 0;
+	int disp1_rate = 0;
+	int div1 = 0;
+	int div2 = 0;
+	int even_div1 = 1;
+	int even_div2  = 1;
+
+	disp0_pixel_clk = clk_get(NULL, "pixel_clk.0");
+	disp1_pixel_clk = clk_get(NULL, "pixel_clk.1");
+
+	if (disp0_pixel_clk != NULL)
+		disp0_rate = clk_get_rate(disp0_pixel_clk);
+
+	if (disp1_pixel_clk != NULL)
+		disp1_rate = clk_get_rate(disp1_pixel_clk);
+
+	/* DVFS-PER will not work if pixel clock divider is odd */
+	if (disp0_rate != 0)
+		div1  = (clk_get_rate(
+			clk_get_parent(disp0_pixel_clk)) * 10) / disp0_rate;
+
+	if ((div1 % 2) || ((div1 / 10) % 2))
+		even_div1 = 0;
+
+	if ((div2 % 2) || ((div2 / 10) % 2))
+		even_div2 = 0;
+
+	if (disp1_rate != 0)
+		div2  = (clk_get_rate(
+			clk_get_parent(disp1_pixel_clk)) * 10) / disp1_rate;
+
+	if (((disp0_rate < DVFS_MAX_PIX_CLK && even_div1) ||
+		!clk_get_usecount(disp0_pixel_clk)) &&
+		((disp1_rate < DVFS_MAX_PIX_CLK && even_div2) ||
+		!clk_get_usecount(disp1_pixel_clk)))
+		ipu_freq_scaled = 1;
+	else
+		ipu_freq_scaled = 0;
+
+	clk_put(disp0_pixel_clk);
+	clk_put(disp1_pixel_clk);
+
+	return ipu_freq_scaled;
+}
+
+int start_dvfs_per(void)
+{
+	if (dvfs_per_is_paused) {
+		dvfs_per_is_paused = 0;
+		return start();
+	}
+	return 0;
+}
+
+void stop_dvfs_per(void)
+{
+	if (dvfs_per_is_active) {
+		dvfs_per_is_paused = 1;
+		stop();
+	}
+}
+
+/*!
+ * Enable DVFS Peripheral
+ *
+ */
+int dvfs_enable(struct device *dev)
+{
+	if (dvfs_per_is_active)
+		return 0;
+	return start();
+}
+
+static ssize_t dvfsper_enable_store(struct device *dev,
+					struct device_attribute *attr,
+					const char *buf, size_t size)
+{
+	if (strstr(buf, "1") != NULL) {
+		dvfs_per_stop = 0;
+		if (dvfs_enable(dev) != 0)
+			printk(KERN_ERR "Failed to start DVFS\n");
+	} else if (strstr(buf, "0") != NULL) {
+		dvfs_per_stop = 1;
+		stop();
+	}
+	return size;
+}
+
+static ssize_t dvfsper_status_show(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
+{
+	int size = 0;
+
+	if (dvfs_per_is_active)
+		size = sprintf(buf, "DVFS PER is enabled\n");
+	else
+		size = sprintf(buf, "DVFS PEr is disabled\n");
+
+	return size;
+}
+
+static DEVICE_ATTR(enable, 0644, dvfsper_status_show, dvfsper_enable_store);
+
+/*!
+ * This is the probe routine for the DVFS PER driver.
+ *
+ * @param   pdev   The platform device structure
+ *
+ * @return         The function returns 0 on success
+ *
+ */
+static int __devinit mxc_dvfsper_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+	struct resource *res;
+	struct mxc_dvfsper_data *dvfsper_data = pdev->dev.platform_data;
+
+	if (dvfsper_data == NULL) {
+		printk(KERN_ERR "DVFS: Pointer to DVFS data is NULL\
+				not started\n");
+		return -1;
+	}
+
+	/* Set driver data */
+	platform_set_drvdata(pdev, dvfsper_device_data);
+
+	dvfsper_plt_data = pdev->dev.platform_data;
+	dvfsper_device_data = kzalloc(sizeof(struct dvfsper_device),
+								GFP_KERNEL);
+	if (!dvfsper_device_data)
+		return -ENOMEM;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res == NULL) {
+		ret = -ENODEV;
+		goto err1;
+	}
+	dvfsper_plt_data->membase = ioremap(res->start,
+					    res->end - res->start + 1);
+
+	/*
+	 * Request the DVFSPER interrupt
+	 */
+	dvfsper_device_data->irq = platform_get_irq(pdev, 0);
+	if (dvfsper_device_data->irq < 0) {
+		ret = dvfsper_device_data->irq;
+		goto err1;
+	}
+
+	ret =
+	    request_irq(dvfsper_device_data->irq, dvfs_per_irq, IRQF_SHARED,
+			pdev->name, &pdev->dev);
+	if (ret) {
+		printk(KERN_ERR "DVFS: Unable to attach to DVFS interrupt\n");
+		goto err1;
+	}
+
+	lp_regulator = regulator_get(NULL, dvfsper_data->reg_id);
+	if (IS_ERR(lp_regulator)) {
+		printk(KERN_ERR "%s: failed to get lp regulator\n", __func__);
+		return PTR_ERR(lp_regulator);
+	}
+
+	INIT_DELAYED_WORK(&dvfs_per_work, dvfs_per_handler);
+
+	main_bus_clk = clk_get(NULL, "main_bus_clk");
+	pll2 = clk_get(NULL, "pll2");
+	lpapm = clk_get(NULL, "lp_apm");
+	cpu_clk = clk_get(NULL, "cpu_clk");
+	ahb_clk = clk_get(NULL, "ahb_clk");
+	axi_b_clk = clk_get(NULL, "axi_b_clk");
+
+	if (cpu_is_mx51())
+		ddr_hf_clk = clk_get(NULL, "ddr_hf_clk");
+
+	dvfsper_device_data->dvfs_clk = clk_get(NULL, dvfsper_data->clk_id);
+	dvfs_clk = dvfsper_device_data->dvfs_clk;
+
+	ret = sysfs_create_file(&pdev->dev.kobj, &dev_attr_enable.attr);
+
+	if (ret) {
+		printk(KERN_ERR
+		       "DVFS: Unable to register sysdev entry for dvfs");
+		goto err1;
+	}
+
+	return 0;
+err1:
+	dev_err(&pdev->dev, "Failed to probe DVFS\n");
+	kfree(dvfsper_device_data);
+
+	return ret;
+}
+
+/*!
+ * This function is called to put DVFS in a low power state.
+ *
+ * @param   pdev  the device structure
+ * @param   state the power state the device is entering
+ *
+ * @return  The function always returns 0.
+ */
+static int mxc_dvfs_suspend(struct platform_device *pdev,
+					pm_message_t state)
+{
+	if (dvfs_per_is_active) {
+		stop_dvfs_per();
+		dvfs_per_suspended = 1;
+	}
+	return 0;
+}
+
+/*!
+ * This function is called to resume the DVFS from a low power state.
+ *
+ * @param   dev   the device structure
+ * @param   level the stage in device suspension process that we want the
+ *                device to be put in
+ *
+ * @return  The function always returns 0.
+ */
+static int mxc_dvfs_resume(struct platform_device *pdev)
+{
+	if (dvfs_per_suspended) {
+		dvfs_per_suspended = 0;
+		return start_dvfs_per();
+	}
+
+	return 0;
+}
+
+static struct platform_driver mxc_dvfsper_driver = {
+	.driver = {
+		   .name = "mxc_dvfsper",
+		   .owner = THIS_MODULE,
+		   },
+	.probe = mxc_dvfsper_probe,
+	.suspend = mxc_dvfs_suspend,
+	.resume = mxc_dvfs_resume,
+};
+
+static int __init dvfs_per_init(void)
+{
+	int err = 0;
+
+	if (platform_driver_register(&mxc_dvfsper_driver) != 0) {
+		printk(KERN_ERR "mxc_dvfsper_driver register failed\n");
+		return -ENODEV;
+	}
+	printk(KERN_INFO "DVFS PER driver module loaded\n");
+
+	return err;
+}
+
+static void __exit dvfs_per_cleanup(void)
+{
+	stop_dvfs_per();
+
+	/* release the DVFS interrupt */
+	free_irq(dvfsper_device_data->irq, NULL);
+
+	clk_put(dvfs_clk);
+	clk_put(main_bus_clk);
+	clk_put(pll2);
+	clk_put(lpapm);
+	clk_put(cpu_clk);
+	clk_put(ahb_clk);
+	clk_put(axi_b_clk);
+	if (cpu_is_mx51())
+		clk_put(ddr_hf_clk);
+
+	/* Unregister the device structure */
+	platform_driver_unregister(&mxc_dvfsper_driver);
+}
+
+module_init(dvfs_per_init);
+module_exit(dvfs_per_cleanup);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("DVFS PERIPHERAL  driver");
+MODULE_LICENSE("GPL");
diff --git a/arch/arm/plat-mxc/gpio.c b/arch/arm/plat-mxc/gpio.c
old mode 100644
new mode 100755
index 6cd6d7f..cd09dc7
--- a/arch/arm/plat-mxc/gpio.c
+++ b/arch/arm/plat-mxc/gpio.c
@@ -3,7 +3,7 @@
  * Copyright 2008 Juergen Beisert, kernel@pengutronix.de
  *
  * Based on code from Freescale,
- * Copyright (C) 2004-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2004-2011 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -336,7 +336,8 @@ int __init mxc_gpio_init(struct mxc_gpio_port *port, int cnt)
 		/* its a serious configuration bug when it fails */
 		BUG_ON( gpiochip_add(&port[i].chip) < 0 );
 
-		if (cpu_is_mx1() || cpu_is_mx3() || cpu_is_mx25() || cpu_is_mx51()) {
+		if (cpu_is_mx1() || cpu_is_mx3() || cpu_is_mx25() ||
+			cpu_is_mx51() || cpu_is_mx53()) {
 			/* setup one handler for each entry */
 			irq_set_chained_handler(port[i].irq,
 						mx3_gpio_irq_handler);
diff --git a/arch/arm/plat-mxc/include/mach/ahci_sata.h b/arch/arm/plat-mxc/include/mach/ahci_sata.h
new file mode 100755
index 0000000..25df23e
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/ahci_sata.h
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef __PLAT_MXC_AHCI_SATA_H__
+#define __PLAT_MXC_AHCI_SATA_H__
+
+enum {
+	HOST_CAP = 0x00,
+	HOST_CAP_SSS = (1 << 27), /* Staggered Spin-up */
+	HOST_PORTS_IMPL	= 0x0c,
+	HOST_TIMER1MS = 0xe0, /* Timer 1-ms */
+	/* Offest used to control the MPLL input clk */
+	PHY_CR_CLOCK_FREQ_OVRD = 0x12,
+	/* Port0 SATA Status */
+	PORT_SATA_SR = 0x128,
+	/* Port0 PHY Control */
+	PORT_PHY_CTL = 0x178,
+	/* PORT_PHY_CTL bits */
+	PORT_PHY_CTL_CAP_ADR_LOC = 0x10000,
+	PORT_PHY_CTL_CAP_DAT_LOC = 0x20000,
+	PORT_PHY_CTL_WRITE_LOC = 0x40000,
+	PORT_PHY_CTL_READ_LOC = 0x80000,
+	/* Port0 PHY Status */
+	PORT_PHY_SR = 0x17c,
+	/* PORT_PHY_SR */
+	PORT_PHY_STAT_DATA_LOC = 0,
+	PORT_PHY_STAT_ACK_LOC = 18,
+	/* SATA PHY Register */
+	SATA_PHY_CR_CLOCK_CRCMP_LT_LIMIT = 0x0001,
+	SATA_PHY_CR_CLOCK_DAC_CTL = 0x0008,
+	SATA_PHY_CR_CLOCK_RTUNE_CTL = 0x0009,
+	SATA_PHY_CR_CLOCK_ADC_OUT = 0x000A,
+	SATA_PHY_CR_CLOCK_MPLL_TST = 0x0017,
+};
+
+#endif /* __PLAT_MXC_AHCI_SATA_H__ */
diff --git a/arch/arm/plat-mxc/include/mach/arc_otg.h b/arch/arm/plat-mxc/include/mach/arc_otg.h
new file mode 100755
index 0000000..f121dc1
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/arc_otg.h
@@ -0,0 +1,377 @@
+/*
+ * Copyright (C) 2005-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __ASM_ARCH_MXC_ARC_OTG_H__
+#define __ASM_ARCH_MXC_ARC_OTG_H__
+
+#ifdef CONFIG_ARCH_MX3
+extern volatile u32 *mx3_usb_otg_addr;
+#define OTG_BASE_ADDR		mx3_usb_otg_addr
+#else
+extern void __iomem *imx_otg_base;
+#define OTG_BASE_ADDR           imx_otg_base
+#endif
+
+#define USB_OTGREGS_BASE	(OTG_BASE_ADDR + 0x000)
+#define USB_H1REGS_BASE		(OTG_BASE_ADDR + 0x200)
+#define USB_H2REGS_BASE		(OTG_BASE_ADDR + 0x400)
+#ifdef CONFIG_ARCH_MX5
+#define USB_H3REGS_BASE		(OTG_BASE_ADDR + 0x600)
+#define USB_OTHERREGS_BASE	(OTG_BASE_ADDR + 0x800)
+#else
+#define USB_OTHERREGS_BASE	(OTG_BASE_ADDR + 0x600)
+#endif
+
+
+#define USBOTG_REG32(offset)	(*((volatile u32 __force *)(USB_OTGREGS_BASE + (offset))))
+#define USBOTG_REG16(offset)	(*((volatile u16 __force *)(USB_OTGREGS_BASE + (offset))))
+
+#define USBH1_REG32(offset)	(*((volatile u32 __force *)(USB_H1REGS_BASE + (offset))))
+#define USBH1_REG16(offset)	(*((volatile u16 __force *)(USB_H1REGS_BASE + (offset))))
+
+#define USBH2_REG32(offset)	(*((volatile u32 __force *)(USB_H2REGS_BASE + (offset))))
+#define USBH2_REG16(offset)	(*((volatile u16 __force *)(USB_H2REGS_BASE + (offset))))
+
+#define USBOTHER_REG(offset)	(*((volatile u32 __force *)(USB_OTHERREGS_BASE + (offset))))
+
+/*
+ * OTG registers
+ */
+#define UOG_ID			USBOTG_REG32(0x00)	/* Host ID */
+#define UOG_HWGENERAL		USBOTG_REG32(0x04)	/* Host General */
+#define UOG_HWHOST		USBOTG_REG32(0x08)	/* Host h/w params */
+#define UOG_HWTXBUF		USBOTG_REG32(0x10)	/* TX buffer h/w params */
+#define UOG_HWRXBUF		USBOTG_REG32(0x14)	/* RX buffer h/w params */
+#define UOG_CAPLENGTH		USBOTG_REG16(0x100)	/* Capability register length */
+#define UOG_HCIVERSION		USBOTG_REG16(0x102)	/* Host Interface version */
+#define UOG_HCSPARAMS		USBOTG_REG32(0x104)	/* Host control structural params */
+#define UOG_HCCPARAMS		USBOTG_REG32(0x108)	/* control capability params */
+#define UOG_DCIVERSION		USBOTG_REG32(0x120)	/* device interface version */
+/* start EHCI registers: */
+#define UOG_USBCMD		USBOTG_REG32(0x140)	/* USB command register */
+#define UOG_USBSTS		USBOTG_REG32(0x144)	/* USB status register */
+#define UOG_USBINTR		USBOTG_REG32(0x148)	/* interrupt enable register */
+#define UOG_FRINDEX		USBOTG_REG32(0x14c)	/* USB frame index */
+/*      segment                             (0x150)	   addr bits 63:32 if needed */
+#define UOG_PERIODICLISTBASE	USBOTG_REG32(0x154)	/* host crtlr frame list base addr */
+#define UOG_DEVICEADDR		USBOTG_REG32(0x154)	/* device crtlr device address */
+#define UOG_ASYNCLISTADDR	USBOTG_REG32(0x158)	/* host ctrlr next async addr */
+#define UOG_EPLISTADDR		USBOTG_REG32(0x158)	/* device ctrlr endpoint list addr */
+#define UOG_BURSTSIZE		USBOTG_REG32(0x160)	/* host ctrlr embedded TT async buf status */
+#define UOG_TXFILLTUNING	USBOTG_REG32(0x164)	/* TX FIFO fill tuning */
+#define UOG_ULPIVIEW		USBOTG_REG32(0x170)	/* ULPI viewport */
+#define UOG_CFGFLAG		USBOTG_REG32(0x180)	/* configflag (supports HS) */
+#define UOG_PORTSC1		USBOTG_REG32(0x184)	/* port status and control */
+/* end EHCI registers: */
+#define UOG_OTGSC		USBOTG_REG32(0x1a4)	/* OTG status and control */
+#define UOG_USBMODE		USBOTG_REG32(0x1a8)	/* USB device mode */
+#define UOG_ENDPTSETUPSTAT	USBOTG_REG32(0x1ac)	/* endpoint setup status */
+#define UOG_ENDPTPRIME		USBOTG_REG32(0x1b0)	/* endpoint initialization */
+#define UOG_ENDPTFLUSH		USBOTG_REG32(0x1b4)	/* endpoint de-initialize */
+#define UOG_ENDPTSTAT		USBOTG_REG32(0x1b8)	/* endpoint status */
+#define UOG_ENDPTCOMPLETE	USBOTG_REG32(0x1bc)	/* endpoint complete */
+#define UOG_EPCTRL0		USBOTG_REG32(0x1c0)	/* endpoint control0 */
+#define UOG_EPCTRL1		USBOTG_REG32(0x1c4)	/* endpoint control1 */
+#define UOG_EPCTRL2		USBOTG_REG32(0x1c8)	/* endpoint control2 */
+#define UOG_EPCTRL3		USBOTG_REG32(0x1cc)	/* endpoint control3 */
+#define UOG_EPCTRL4		USBOTG_REG32(0x1d0)	/* endpoint control4 */
+#define UOG_EPCTRL5		USBOTG_REG32(0x1d4)	/* endpoint control5 */
+#define UOG_EPCTRL6		USBOTG_REG32(0x1d8)	/* endpoint control6 */
+#define UOG_EPCTRL7		USBOTG_REG32(0x1dc)	/* endpoint control7 */
+
+/*
+ * Host 1 registers
+ */
+#define UH1_ID			USBH1_REG32(0x00)	/* Host ID */
+#define UH1_HWGENERAL		USBH1_REG32(0x04)	/* Host General */
+#define UH1_HWHOST		USBH1_REG32(0x08)	/* Host h/w params */
+#define UH1_HWTXBUF		USBH1_REG32(0x10)	/* TX buffer h/w params */
+#define UH1_HWRXBUF		USBH1_REG32(0x14)	/* RX buffer h/w params */
+#define UH1_CAPLENGTH		USBH1_REG16(0x100)	/* Capability register length */
+#define UH1_HCIVERSION		USBH1_REG16(0x102)	/* Host Interface version */
+#define UH1_HCSPARAMS		USBH1_REG32(0x104)	/* Host control structural params */
+#define UH1_HCCPARAMS		USBH1_REG32(0x108)	/* control capability params */
+/* start EHCI registers: */
+#define UH1_USBCMD		USBH1_REG32(0x140)	/* USB command register */
+#define UH1_USBSTS		USBH1_REG32(0x144)	/* USB status register */
+#define UH1_USBINTR		USBH1_REG32(0x148)	/* interrupt enable register */
+#define UH1_FRINDEX		USBH1_REG32(0x14c)	/* USB frame index */
+/*      segment                            (0x150)	   addr bits 63:32 if needed */
+#define UH1_PERIODICLISTBASE	USBH1_REG32(0x154)	/* host crtlr frame list base addr */
+#define UH1_ASYNCLISTADDR	USBH1_REG32(0x158)	/* host ctrlr nest async addr */
+#define UH1_BURSTSIZE		USBH1_REG32(0x160)	/* host ctrlr embedded TT async buf status */
+#define UH1_TXFILLTUNING	USBH1_REG32(0x164)	/* TX FIFO fill tuning */
+/*      configured_flag                    (0x180)	   configflag (supports HS) */
+#define UH1_PORTSC1		USBH1_REG32(0x184)	/* port status and control */
+/* end EHCI registers: */
+#define UH1_USBMODE		USBH1_REG32(0x1a8)	/* USB device mode */
+
+/*
+ * Host 2 registers
+ */
+#define UH2_ID			USBH2_REG32(0x00)	/* Host ID */
+#define UH2_HWGENERAL		USBH2_REG32(0x04)	/* Host General */
+#define UH2_HWHOST		USBH2_REG32(0x08)	/* Host h/w params */
+#define UH2_HWTXBUF		USBH2_REG32(0x10)	/* TX buffer h/w params */
+#define UH2_HWRXBUF		USBH2_REG32(0x14)	/* RX buffer h/w params */
+#define UH2_CAPLENGTH		USBH2_REG16(0x100)	/* Capability register length */
+#define UH2_HCIVERSION		USBH2_REG16(0x102)	/* Host Interface version */
+#define UH2_HCSPARAMS		USBH2_REG32(0x104)	/* Host control structural params */
+#define UH2_HCCPARAMS		USBH2_REG32(0x108)	/* control capability params */
+/* start EHCI registers: */
+#define UH2_USBCMD		USBH2_REG32(0x140)	/* USB command register */
+#define UH2_USBSTS		USBH2_REG32(0x144)	/* USB status register */
+#define UH2_USBINTR		USBH2_REG32(0x148)	/* interrupt enable register */
+#define UH2_FRINDEX		USBH2_REG32(0x14c)	/* USB frame index */
+/*      segment                            (0x150)	   addr bits 63:32 if needed */
+#define UH2_PERIODICLISTBASE	USBH2_REG32(0x154)	/* host crtlr frame list base addr */
+#define UH2_ASYNCLISTADDR	USBH2_REG32(0x158)	/* host ctrlr nest async addr */
+#define UH2_BURSTSIZE		USBH2_REG32(0x160)	/* host ctrlr embedded TT async buf status */
+#define UH2_TXFILLTUNING	USBH2_REG32(0x164)	/* TX FIFO fill tuning */
+#define UH2_ULPIVIEW		USBH2_REG32(0x170)	/* ULPI viewport */
+/*      configured_flag                    (0x180)	   configflag (supports HS) */
+#define UH2_PORTSC1		USBH2_REG32(0x184)	/* port status and control */
+/* end EHCI registers */
+#define UH2_USBMODE		USBH2_REG32(0x1a8)	/* USB device mode */
+
+/*
+ * other regs (not part of ARC core)
+ */
+#define USBCTRL			USBOTHER_REG(0x00)	/* USB Control register */
+#define USB_OTG_MIRROR		USBOTHER_REG(0x04)	/* USB OTG mirror register */
+#define USB_PHY_CTR_FUNC	USBOTHER_REG(0x08)      /* OTG UTMI PHY Function Control register */
+#define USB_PHY_CTR_FUNC2	USBOTHER_REG(0x0c)      /* OTG UTMI PHY Function Control register */
+#define USB_CTRL_1		USBOTHER_REG(0x10)	/* USB Cotrol Register 1*/
+#define USBCTRL_HOST2		USBOTHER_REG(0x14)	/* USB Cotrol Register 1*/
+#define USBCTRL_HOST3		USBOTHER_REG(0x18)	/* USB Cotrol Register 1*/
+#define USBH1_PHY_CTRL0		USBOTHER_REG(0x1c)	/* USB Cotrol Register 1*/
+#define USBH1_PHY_CTRL1		USBOTHER_REG(0x20)	/* USB Cotrol Register 1*/
+#define USB_CLKONOFF_CTRL       USBOTHER_REG(0x24)      /* USB Clock on/off Control Register */
+
+/*
+ * register bits
+ */
+
+/* x_PORTSCx */
+#define PORTSC_PTS_MASK			(3 << 30)	/* parallel xcvr select mask */
+#define PORTSC_PTS_UTMI			(0 << 30)	/* UTMI/UTMI+ */
+#define PORTSC_PTS_PHILIPS		(1 << 30)	/* Philips classic */
+#define PORTSC_PTS_ULPI			(2 << 30)	/* ULPI */
+#define PORTSC_PTS_SERIAL		(3 << 30)	/* serial */
+#define PORTSC_STS			(1 << 29)	/* serial xcvr select */
+#define PORTSC_PTW                      (1 << 28)       /* UTMI width */
+#define PORTSC_PHCD                     (1 << 23)       /* Low Power Suspend */
+#define PORTSC_PORT_POWER		(1 << 12)	/* port power */
+#define PORTSC_LS_MASK			(3 << 10)	/* Line State mask */
+#define PORTSC_LS_SE0			(0 << 10)	/* SE0     */
+#define PORTSC_LS_K_STATE		(1 << 10)	/* K-state */
+#define PORTSC_LS_J_STATE		(2 << 10)	/* J-state */
+#define PORTSC_PORT_RESET		(1 <<  8)	/* Port reset */
+#define PORTSC_PORT_SUSPEND		(1 <<  7)	/* Suspend */
+#define PORTSC_PORT_FORCE_RESUME	(1 <<  6)	/* Force port resume */
+#define PORTSC_OVER_CURRENT_CHG		(1 <<  5)	/* over current change */
+#define PORTSC_OVER_CURRENT_ACT		(1 <<  4)	/* over currrent active */
+#define PORTSC_PORT_EN_DIS_CHANGE	(1 <<  3)	/* port {en,dis}able change */
+#define PORTSC_PORT_ENABLE		(1 <<  2)	/* port enabled */
+#define PORTSC_CONNECT_STATUS_CHANGE	(1 <<  1)	/* connect status change */
+#define PORTSC_CURRENT_CONNECT_STATUS	(1 <<  0)	/* current connect status */
+
+#define PORTSC_W1C_BITS                     \
+	(PORTSC_CONNECT_STATUS_CHANGE | \
+	PORTSC_PORT_EN_DIS_CHANGE | \
+	PORTSC_OVER_CURRENT_CHG)
+
+/* UOG_OTGSC Register Bits */
+/* control bits: */
+#define  OTGSC_CTRL_VBUS_DISCHARGE	(1 <<  0)
+#define  OTGSC_CTRL_VBUS_CHARGE		(1 <<  1)
+#define  OTGSC_CTRL_OTG_TERM		(1 <<  3)	/* controls DM pulldown */
+#define  OTGSC_CTRL_DATA_PULSING	(1 <<  4)
+#define  OTGSC_CTRL_USB_ID_PU		(1 <<  5)	/* enable ID pullup */
+/* current status: (R/O) */
+#define  OTGSC_STS_USB_ID		(1 <<  8)	/* 0=A-device  1=B-device */
+#define  OTGSC_STS_A_VBUS_VALID		(1 <<  9)
+#define  OTGSC_STS_A_SESSION_VALID	(1 << 10)
+#define  OTGSC_STS_B_SESSION_VALID	(1 << 11)
+#define  OTGSC_STS_B_SESSION_END	(1 << 12)
+#define  OTGSC_STS_1ms_TIMER		(1 << 13)
+#define  OTGSC_STS_DATA_PULSE		(1 << 14)
+/* interrupt status: (write to clear) */
+#define  OTGSC_IS_MASK			(0x7f << 16)
+#define  OTGSC_IS_USB_ID		(1 << 16)
+#define  OTGSC_IS_A_VBUS_VALID		(1 << 17)
+#define  OTGSC_IS_A_SESSION_VALID	(1 << 18)
+#define  OTGSC_IS_B_SESSION_VALID	(1 << 19)
+#define  OTGSC_IS_B_SESSION_END		(1 << 20)
+#define  OTGSC_IS_1ms_TIMER		(1 << 21)
+#define  OTGSC_IS_DATA_PULSE		(1 << 22)
+/* interrupt enables: */
+#define  OTGSC_IE_MASK			(0x7f << 24)
+#define  OTGSC_IE_USB_ID		(1 << 24)
+#define  OTGSC_IE_A_VBUS_VALID		(1 << 25)
+#define  OTGSC_IE_A_SESSION_VALID	(1 << 26)
+#define  OTGSC_IE_B_SESSION_VALID	(1 << 27)
+#define  OTGSC_IE_B_SESSION_END		(1 << 28)
+#define  OTGSC_IE_1ms_TIMER		(1 << 29)
+#define  OTGSC_IE_DATA_PULSE		(1 << 30)
+
+#if 1				/* FIXME these here for compatibility between my names and Leo's */
+/* OTG interrupt enable bit masks */
+#define  OTGSC_INTERRUPT_ENABLE_BITS_MASK	OTGSC_IE_MASK
+#define  OTGSC_INTSTS_MASK			OTGSC_IS_MASK
+
+/* OTG interrupt status bit masks */
+#define  OTGSC_INTERRUPT_STATUS_BITS_MASK	OTGSC_IS_MASK
+#endif
+
+/* x_USBMODE */
+#define USBMODE_SLOM		(1 << 3)	/* setup lockout mode */
+#define USBMODE_ES		(1 << 2)	/* (big) endian select */
+#define USBMODE_CM_MASK		(3 << 0)	/* controller mode mask */
+#define USBMODE_CM_HOST		(3 << 0)	/* host */
+#define USBMODE_CM_DEVICE	(2 << 0)	/* device */
+#define USBMODE_CM_reserved	(1 << 0)	/* reserved */
+
+/* USBCTRL */
+#define UCTRL_OWIR		(1 << 31)	/* OTG wakeup intr request received */
+#define UCTRL_OSIC_MASK		(3 << 29)	/* OTG  Serial Interface Config: */
+#define UCTRL_OSIC_DU6		(0 << 29)	/* Differential/unidirectional 6 wire */
+#define UCTRL_OSIC_DB4		(1 << 29)	/* Differential/bidirectional  4 wire */
+#define UCTRL_OSIC_SU6		(2 << 29)	/* single-ended/unidirectional 6 wire */
+#define UCTRL_OSIC_SB3		(3 << 29)	/* single-ended/bidirectional  3 wire */
+
+#define UCTRL_OUIE		(1 << 28)	/* OTG ULPI intr enable */
+#define UCTRL_OWIE		(1 << 27)	/* OTG wakeup intr enable */
+#define UCTRL_OBPVAL_RXDP	(1 << 26)	/* OTG RxDp status in bypass mode */
+#define UCTRL_OBPVAL_RXDM	(1 << 25)	/* OTG RxDm status in bypass mode */
+#define UCTRL_OPM		(1 << 24)	/* OTG power mask */
+#define UCTRL_O_PWR_POL	(1 << 24)	/* OTG power pin polarity */
+#ifdef CONFIG_ARCH_MX5
+#define UCTRL_H2WIR		(1 << 17)	/* HOST2 wakeup intr request received */
+#else
+#define UCTRL_H2WIR		(1 << 23)	/* HOST2 wakeup intr request received */
+#endif
+#define UCTRL_H2SIC_MASK	(3 << 21)	/* HOST2 Serial Interface Config: */
+#define UCTRL_H2SIC_DU6		(0 << 21)	/* Differential/unidirectional 6 wire */
+#define UCTRL_H2SIC_DB4		(1 << 21)	/* Differential/bidirectional  4 wire */
+#define UCTRL_H2SIC_SU6		(2 << 21)	/* single-ended/unidirectional 6 wire */
+#define UCTRL_H2SIC_SB3		(3 << 21)	/* single-ended/bidirectional  3 wire */
+
+#ifdef CONFIG_ARCH_MX5
+#define UCTRL_H2UIE		(1 << 8)	/* HOST2 ULPI intr enable */
+#define UCTRL_H2WIE		(1 << 7)	/* HOST2 wakeup intr enable */
+#define UCTRL_H2PP		0	/* Power Polarity for uh2 */
+#define UCTRL_H2PM		(1 << 4)	/* HOST2 power mask */
+#else
+#define UCTRL_H2UIE		(1 << 20)	/* HOST2 ULPI intr enable */
+#define UCTRL_H2WIE		(1 << 19)	/* HOST2 wakeup intr enable */
+#define UCTRL_H2PP		(1 << 18)	/* Power Polarity for uh2 */
+#define UCTRL_H2PM		(1 << 16)	/* HOST2 power mask */
+#endif
+#define UCTRL_H2OVBWK_EN	(1 << 6) /* OTG VBUS Wakeup Enable */
+#define UCTRL_H2OIDWK_EN	(1 << 5) /* OTG ID Wakeup Enable */
+
+#define UCTRL_H1WIR		(1 << 15)	/* HOST1 wakeup intr request received */
+#define UCTRL_H1SIC_MASK	(3 << 13)	/* HOST1 Serial Interface Config: */
+#define UCTRL_H1SIC_DU6		(0 << 13)	/* Differential/unidirectional 6 wire */
+#define UCTRL_H1SIC_DB4		(1 << 13)	/* Differential/bidirectional  4 wire */
+#define UCTRL_H1SIC_SU6		(2 << 13)	/* single-ended/unidirectional 6 wire */
+#define UCTRL_H1SIC_SB3		(3 << 13)	/* single-ended/bidirectional  3 wire */
+#define UCTRL_OLOCKD		(1 << 13)	/* otg lock disable */
+#define UCTRL_H2LOCKD		(1 << 12)	/* HOST2 lock disable */
+#define UCTRL_H1UIE		(1 << 12)	/* Host1 ULPI interrupt enable */
+
+#if defined(CONFIG_ARCH_MX37)
+/* VBUS wakeup enable, UTMI only */
+#define UCTRL_VBUS_WKUP_EN	(1 << 12)
+#elif defined(CONFIG_ARCH_MX25) || defined(CONFIG_ARCH_MX35)
+#define UCTRL_VBUS_WKUP_EN      (1 << 15)
+#endif
+
+#define UCTRL_PP                (1 << 11)       /* power polarity bit */
+#define UCTRL_H1WIE		(1 << 11)	/* HOST1 wakeup intr enable */
+#define UCTRL_H1BPVAL_RXDP	(1 << 10)	/* HOST1 RxDp status in bypass mode */
+#define UCTRL_XCSO              (1 << 10)       /* Xcvr Clock Select for OTG port */
+#define UCTRL_H1BPVAL_RXDM	(1 <<  9)	/* HOST1 RxDm status in bypass mode */
+#define UCTRL_XCSH2             (1 <<  9)       /* Xcvr Clock Select for Host port */
+#define UCTRL_H1PM		(1 <<  8)	/* HOST1 power mask */
+#define UCTRL_IP_PULIDP         (1 <<  8)       /* Ipp_Puimpel_Pullup_Dp */
+
+#define UCTRL_IP_PUE_UP         (1 <<  7)       /* ipp_pue_pullup_dp */
+#define UCTRL_IP_PUE_DOWN       (1 <<  6)       /* ipp_pue_pulldwn_dpdm */
+#define UCTRL_H2DT		(1 <<  5)	/* HOST2 TLL disabled */
+#define UCTRL_H1DT		(1 <<  4)	/* HOST1 TLL disabled */
+#define UCTRL_USBTE             (1 <<  4)       /* USBT Transceiver enable */
+#define UCTRL_OCPOL             (1 <<  3)       /* OverCurrent Polarity */
+#define UCTRL_OCE               (1 <<  2)       /* OverCurrent Enable */
+#define UCTRL_H2OCPOL		(1 <<  2)       /* OverCurrent Polarity of Host2 */
+#define UCTRL_H2OCS             (1 <<  1)       /* Host OverCurrent State */
+#define UCTRL_BPE		(1 <<  0)	/* bypass mode enable */
+#define UCTRL_OTD		(1 <<  0)	/* OTG TLL Disable */
+#define UCTRL_OOCS              (1 <<  0)       /* OTG OverCurrent State */
+
+/* USBCMD */
+#define UCMD_RUN_STOP           (1 << 0)        /* controller run/stop */
+#define UCMD_RESET		(1 << 1)	/* controller reset */
+#define UCMD_ITC_NO_THRESHOLD	 (~(0xff << 16))	/* Interrupt Threshold Control */
+
+/* OTG_MIRROR */
+#define OTGM_SESEND		(1 << 4)	/* B device session end */
+#define OTGM_VBUSVAL		(1 << 3)	/* Vbus valid */
+#define OTGM_BSESVLD		(1 << 2)	/* B session Valid */
+#define OTGM_ASESVLD		(1 << 1)	/* A session Valid */
+#define OTGM_IDIDG		(1 << 0)	/* OTG ID pin status */
+				/* 1=high: Operate as B-device */
+				/* 0=low : Operate as A-device */
+
+/* USB_PHY_CTRL_FUNC */
+/* PHY control0 Register Bit Masks */
+#define USB_UTMI_PHYCTRL_CONF2	(1 << 26)
+
+#define USB_UTMI_PHYCTRL_UTMI_ENABLE (1 << 24)
+#define USB_UTMI_PHYCTRL_CHGRDETEN (1 << 24)    /* Enable Charger Detector */
+#define USB_UTMI_PHYCTRL_CHGRDETON (1 << 23)    /* Charger Detector Power On Control */
+#define USB_UTMI_PHYCTRL_OC_POL	(1 << 9)	/* OTG Polarity of Overcurrent */
+#define USB_UTMI_PHYCTRL_OC_DIS	(1 << 8)	/* OTG Disable Overcurrent Event */
+#define USB_UH1_OC_DIS	(1 << 5)		/* UH1 Disable Overcurrent Event */
+#define USB_UH1_OC_POL	(1 << 6)		/* UH1 Polarity of OC,Low active */
+/* USB_PHY_CTRL_FUNC2*/
+#define USB_UTMI_PHYCTRL2_PLLDIV_MASK		0x3
+#define USB_UTMI_PHYCTRL2_PLLDIV_SHIFT		0
+#define USB_UTMI_PHYCTRL2_HSDEVSEL_MASK		0x3
+#define USB_UTMI_PHYCTRL2_HSDEVSEL_SHIFT	19
+
+/* USB_CTRL_1 */
+#define USB_CTRL_UH1_EXT_CLK_EN			(1 << 25)
+#define USB_CTRL_UH2_EXT_CLK_EN			(1 << 26)
+#define USB_CTRL_UH2_CLK_FROM_ULPI_PHY  	(1 << 2)
+/* ULPIVIEW register bits */
+#define ULPIVW_OFF		(0x170)
+#define ULPIVW_WU		(1 << 31)	/* Wakeup */
+#define ULPIVW_RUN		(1 << 30)	/* read/write run */
+#define ULPIVW_WRITE		(1 << 29)	/* 0=read  1=write */
+#define ULPIVW_SS		(1 << 27)	/* SyncState */
+#define ULPIVW_PORT_MASK	0x07	/* Port field */
+#define ULPIVW_PORT_SHIFT	24
+#define ULPIVW_ADDR_MASK	0xFF	/* data address field */
+#define ULPIVW_ADDR_SHIFT	16
+#define ULPIVW_RDATA_MASK	0xFF	/* read data field */
+#define ULPIVW_RDATA_SHIFT	8
+#define ULPIVW_WDATA_MASK	0xFF	/* write data field */
+#define ULPIVW_WDATA_SHIFT	0
+
+#define HCSPARAMS_PPC           (0x1<<4)        /* Port Power Control */
+/* USB Clock on/off Control Register */
+#define OTG_AHBCLK_OFF          (0x1<<17)      /* 1: OFF */
+#define H1_AHBCLK_OFF           (0x1<<18)      /* 1: OFF */
+extern enum fsl_usb2_modes get_usb_mode(struct fsl_usb2_platform_data *pdata);
+#endif
diff --git a/arch/arm/plat-mxc/include/mach/clock.h b/arch/arm/plat-mxc/include/mach/clock.h
old mode 100644
new mode 100755
index 753a598..5da6d23
--- a/arch/arm/plat-mxc/include/mach/clock.h
+++ b/arch/arm/plat-mxc/include/mach/clock.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2005-2011 Freescale Semiconductor, Inc. All Rights Reserved.
  * Copyright 2008 Juergen Beisert, kernel@pengutronix.de
  *
  * This program is free software; you can redistribute it and/or
@@ -57,8 +57,15 @@ struct clk {
 	int (*set_parent) (struct clk *, struct clk *);
 };
 
-int clk_register(struct clk *clk);
-void clk_unregister(struct clk *clk);
+int clk_get_usecount(struct clk *clk);
+
+/* Clock flags */
+#define RATE_PROPAGATES		(1 << 0)	/* Program children too */
+#define ALWAYS_ENABLED		(1 << 1)	/* Clock cannot be disabled */
+#define RATE_FIXED		(1 << 2)	/* Fixed clock rate */
+#define CPU_FREQ_TRIG_UPDATE	(1 << 3)	/* CPUFREQ trig update */
+#define AHB_HIGH_SET_POINT	(1 << 4)	/* Requires max AHB clock */
+#define AHB_MED_SET_POINT	(1 << 5)	/* Requires med AHB clock */
 
 unsigned long mxc_decode_pll(unsigned int pll, u32 f_ref);
 
diff --git a/arch/arm/plat-mxc/include/mach/common.h b/arch/arm/plat-mxc/include/mach/common.h
old mode 100644
new mode 100755
index da79918..5bb8792
--- a/arch/arm/plat-mxc/include/mach/common.h
+++ b/arch/arm/plat-mxc/include/mach/common.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2011 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -23,6 +23,7 @@ extern void mx35_map_io(void);
 extern void mx50_map_io(void);
 extern void mx51_map_io(void);
 extern void mx53_map_io(void);
+extern void mxc91231_map_io(void);
 extern void imx1_init_early(void);
 extern void imx21_init_early(void);
 extern void imx25_init_early(void);
@@ -32,6 +33,7 @@ extern void imx35_init_early(void);
 extern void imx50_init_early(void);
 extern void imx51_init_early(void);
 extern void imx53_init_early(void);
+extern void mxc91231_init_early(void);
 extern void mxc_init_irq(void __iomem *);
 extern void tzic_init_irq(void __iomem *);
 extern void mx1_init_irq(void);
@@ -43,6 +45,7 @@ extern void mx35_init_irq(void);
 extern void mx50_init_irq(void);
 extern void mx51_init_irq(void);
 extern void mx53_init_irq(void);
+extern void mxc91231_init_irq(void);
 extern void epit_timer_init(struct clk *timer_clk, void __iomem *base, int irq);
 extern void mxc_timer_init(struct clk *timer_clk, void __iomem *, int);
 extern int mx1_clocks_init(unsigned long fref);
@@ -55,11 +58,16 @@ extern int mx51_clocks_init(unsigned long ckil, unsigned long osc,
 			unsigned long ckih1, unsigned long ckih2);
 extern int mx53_clocks_init(unsigned long ckil, unsigned long osc,
 			unsigned long ckih1, unsigned long ckih2);
+extern int mxc91231_clocks_init(unsigned long fref);
 extern int mxc_register_gpios(void);
 extern int mxc_register_device(struct platform_device *pdev, void *data);
 extern void mxc_set_cpu_type(unsigned int type);
 extern void mxc_arch_reset_init(void __iomem *);
+extern void mxc91231_power_off(void);
+extern void mxc91231_arch_reset(int, const char *);
+extern void mxc91231_prepare_idle(void);
 extern void mx51_efikamx_reset(void);
 extern int mx53_revision(void);
+extern int mx50_revision(void);
 extern int mx53_display_revision(void);
 #endif
diff --git a/arch/arm/plat-mxc/include/mach/devices-common.h b/arch/arm/plat-mxc/include/mach/devices-common.h
old mode 100644
new mode 100755
index fa84773..99cb436
--- a/arch/arm/plat-mxc/include/mach/devices-common.h
+++ b/arch/arm/plat-mxc/include/mach/devices-common.h
@@ -81,6 +81,13 @@ struct imx_imxdi_rtc_data {
 struct platform_device *__init imx_add_imxdi_rtc(
 		const struct imx_imxdi_rtc_data *data);
 
+struct imx_srtc_data {
+	resource_size_t iobase;
+	resource_size_t irq;
+};
+struct platform_device *__init imx_add_srtc(
+		const struct imx_srtc_data *data);
+
 #include <mach/imxfb.h>
 struct imx_imx_fb_data {
 	resource_size_t iobase;
@@ -291,3 +298,77 @@ struct imx_spi_imx_data {
 struct platform_device *__init imx_add_spi_imx(
 		const struct imx_spi_imx_data *data,
 		const struct spi_imx_master *pdata);
+
+#include <mach/ipu-v3.h>
+struct imx_ipuv3_data {
+	resource_size_t iobase;
+	resource_size_t iosize;
+	resource_size_t irq_err;
+	resource_size_t irq;
+	int (*init) (void);
+	void (*pg) (int);
+};
+struct platform_device *__init imx_add_ipuv3(
+		const struct imx_ipuv3_data *data,
+		struct imx_ipuv3_platform_data *pdata);
+
+#include <mach/mxc_vpu.h>
+struct imx_vpu_data {
+	resource_size_t iobase;
+	resource_size_t irq;
+	void (*reset) (void);
+	void (*pg) (int);
+};
+struct platform_device *__init imx_add_vpu(
+		const struct imx_vpu_data *data);
+
+#include <mach/mxc_dvfs.h>
+struct imx_dvfs_core_data {
+	resource_size_t iobase;
+	resource_size_t irq;
+};
+struct platform_device *__init imx_add_dvfs_core(
+		const struct imx_dvfs_core_data *data,
+		const struct mxc_dvfs_platform_data *pdata);
+struct platform_device *__init imx_add_busfreq(
+		const struct mxc_bus_freq_platform_data *pdata);
+
+#include <linux/fsl_devices.h>
+struct imx_tve_data {
+	resource_size_t iobase;
+	resource_size_t irq;
+};
+struct platform_device *__init imx_add_tve(
+		const struct imx_tve_data *data,
+		const struct fsl_mxc_tve_platform_data *pdata);
+
+#include <linux/ahci_platform.h>
+struct imx_ahci_imx_data {
+	int id;
+	resource_size_t iobase;
+	resource_size_t irq;
+};
+struct platform_device *__init imx_add_ahci_imx(
+		const struct imx_ahci_imx_data *data,
+		const struct ahci_platform_data *pdata);
+
+struct imx_iim_data {
+	resource_size_t iobase;
+	resource_size_t irq;
+};
+struct platform_device *__init imx_add_iim(
+		const struct imx_iim_data *data,
+		const struct mxc_iim_platform_data *pdata);
+
+struct imx_mxc_gpu_data {
+	resource_size_t irq_2d;
+	resource_size_t irq_3d;
+	resource_size_t iobase_2d;
+	resource_size_t iobase_3d;
+	resource_size_t gmem_base;
+	resource_size_t gmem_size;
+};
+
+struct platform_device *__init imx_add_mxc_gpu(
+		const struct imx_mxc_gpu_data *data,
+		const int *pdata);
diff --git a/arch/arm/plat-mxc/include/mach/dvfs_dptc_struct.h b/arch/arm/plat-mxc/include/mach/dvfs_dptc_struct.h
new file mode 100755
index 0000000..560b056
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/dvfs_dptc_struct.h
@@ -0,0 +1,169 @@
+/*
+ * Copyright 2004-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file arch-mxc/dvfs_dptc_struct.h
+ *
+ * @brief MXC dvfs & dptc structure definitions file.
+ *
+ * @ingroup PM_MX27 PM_MX31 PM_MXC91321 PM_MXC91311
+ */
+#ifndef __ASM_ARCH_MXC_DVFS_DPTC_STRUCT_H__
+#define __ASM_ARCH_MXC_DVFS_DPTC_STRUCT_H__
+
+#include <linux/semaphore.h>
+#include <mach/pm_api.h>
+
+/*!
+ * Number of entries in the DPTC log buffer
+ */
+#define LOG_ENTRIES 1024
+
+/*!
+ * Log buffer Structure.\n
+ * This structure records the DPTC changes. \n
+ * This structure can be read by the user using the proc file system DPTC read entry.
+ */
+typedef struct {
+	/*!
+	 * Index to the head of the log buffer
+	 */
+	int head;
+
+	/*!
+	 * Index to the tail of the log buffer
+	 */
+	int tail;
+
+	/*!
+	 * Mutex to allow access to the log buffer
+	 */
+	struct semaphore mutex;
+
+	/*!
+	 * Array of log buffer entries
+	 */
+	dptc_log_entry_s entries[LOG_ENTRIES];
+} dptc_log_s;
+
+/*!
+ * DPTC driver data structure.\n
+ * Holds all driver parameters and data structures.
+ */
+typedef struct {
+	/*!
+	 * This variable holds the current frequency index
+	 */
+	int current_freq_index;
+
+	/*!
+	 * Boolean variable, if TRUE the DPTC module is enabled
+	 * if FALSE the DPTC module is disabled
+	 */
+	int dptc_is_active;
+
+	/*!
+	 * Boolean variable, if TRUE turbo mode enable
+	 * if FALSE turbo mode disabled
+	 */
+	int turbo_mode_active;
+
+	/*!
+	 * Boolean variable, if TRUE the DVFS module is enabled
+	 * if FALSE the DPTC module is disabled
+	 */
+	int dvfs_is_active;
+
+	/*!
+	 * Boolean variable, if TRUE the DPTC module is suspended
+	 */
+	int suspended;
+
+	unsigned char rc_state;
+
+	/*!
+	 * Pointer to the DVFS & DPTC translation table
+	 */
+	dvfs_dptc_tables_s *dvfs_dptc_tables_ptr;
+
+	/*!
+	 * The DPTC log buffer
+	 */
+	dptc_log_s dptc_log_buffer;
+
+	/*!
+	 * The DVFS log buffer
+	 */
+	unsigned char *dvfs_log_buffer;
+
+	/*!
+	 * The DVFS log buffer physical address (for SDMA)
+	 */
+	dma_addr_t dvfs_log_buffer_phys;
+
+#ifdef CONFIG_MXC_DVFS_SDMA
+	/*!
+	 * SDMA channel number
+	 */
+	int sdma_channel;
+
+	/*!
+	 * This holds the previous working point
+	 */
+	int prev_wp;
+
+	/*!
+	 * Wait entry for predictive DVFS
+	 */
+	wait_queue_head_t dvfs_pred_wait;
+#endif
+
+	/*!
+	 * This holds the current DVFS mode
+	 */
+	unsigned int dvfs_mode;
+
+	/*!
+	 * Log buffer read pointer
+	 */
+	unsigned char *read_ptr;
+
+	/*
+	 * Number of characters in log buffer
+	 */
+	int chars_in_buffer;
+} dvfs_dptc_params_s;
+
+/*!
+ * This struct contains the array with values of supported frequencies in Hz
+ */
+typedef struct {
+	/*
+	 * Number of supported states
+	 */
+	unsigned int num_of_states;
+	/*!
+	 * Array of frequencies
+	 */
+	unsigned int *freqs;
+} dvfs_states_table;
+
+/*
+ * if not defined define TREU and FALSE values.
+ */
+#ifndef TRUE
+#define TRUE  1
+#define FALSE 0
+#endif				/* TRUE */
+
+#endif
diff --git a/arch/arm/plat-mxc/include/mach/fsl_usb.h b/arch/arm/plat-mxc/include/mach/fsl_usb.h
new file mode 100755
index 0000000..e358c39
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/fsl_usb.h
@@ -0,0 +1,100 @@
+/*
+ * Copyright 2005-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*
+ * USB Host side, platform-specific functionality.
+ */
+
+#include <linux/usb/fsl_xcvr.h>
+#include <mach/arc_otg.h>
+
+static void fsl_setup_phy(struct ehci_hcd *ehci,
+			  enum fsl_usb2_phy_modes phy_mode,
+			  int port_offset);
+
+static inline void fsl_platform_usb_setup(struct ehci_hcd *ehci)
+{
+	struct fsl_usb2_platform_data *pdata;
+
+	pdata = ehci_to_hcd(ehci)->self.controller->platform_data;
+	fsl_setup_phy(ehci, pdata->phy_mode, 0);
+}
+
+static inline void fsl_platform_set_host_mode(struct usb_hcd *hcd)
+{
+	unsigned int temp;
+	struct fsl_usb2_platform_data *pdata;
+
+	pdata = hcd->self.controller->platform_data;
+
+	if (pdata->xcvr_ops && pdata->xcvr_ops->set_host)
+		pdata->xcvr_ops->set_host();
+
+	/* set host mode */
+	temp = readl(hcd->regs + 0x1a8);
+	writel(temp | USBMODE_CM_HOST, hcd->regs + 0x1a8);
+}
+
+/* Needed for enable PP and i2c/serial transceivers */
+static inline void
+fsl_platform_set_vbus_power(struct fsl_usb2_platform_data *pdata, int on)
+{
+	u32 temp;
+
+	/* HCSPARAMS */
+	temp = readl(pdata->regs + 0x104);
+	/* Port Power Control */
+	if (temp & HCSPARAMS_PPC) {
+		temp = readl(pdata->regs + FSL_SOC_USB_PORTSC1);
+		if (on)
+			temp |= PORT_POWER;
+		else
+			temp &= ~PORT_POWER;
+
+		writel(temp, pdata->regs + FSL_SOC_USB_PORTSC1);
+	}
+
+	if (pdata->xcvr_ops && pdata->xcvr_ops->set_vbus_power)
+		pdata->xcvr_ops->set_vbus_power(pdata->xcvr_ops, pdata, on);
+}
+
+/* Set USB AHB burst length for host */
+static inline void fsl_platform_set_ahb_burst(struct usb_hcd *hcd)
+{
+	struct fsl_usb2_platform_data *pdata;
+	unsigned int temp;
+
+	pdata = hcd->self.controller->platform_data;
+	if (pdata->change_ahb_burst) {
+		temp = readl(hcd->regs + FSL_SOC_USB_SBUSCFG);
+		writel((temp & (~(0x7))) | pdata->ahb_burst_mode,
+			hcd->regs + FSL_SOC_USB_SBUSCFG);
+	}
+
+	/* Increase TX fifo threshold for USB+ATA for i.mx35 2.0 */
+	if (cpu_is_mx35() && (imx_cpu_ver() >= IMX_CHIP_REVISION_2_0)) {
+		temp = readl(hcd->regs + FSL_SOC_USB_TXFILLTUNING);
+		/* Change TX FIFO threshold to be 0x20 */
+		writel((temp & (~(0x3f << 16))) | (0x20 << 16),
+			hcd->regs + FSL_SOC_USB_TXFILLTUNING);
+	}
+
+	/* Increase TX fifo threshold for USB+SD in Hostx */
+	if (cpu_is_mx53() && (strcmp("DR", pdata->name))) {
+		temp = readl(hcd->regs + FSL_SOC_USB_TXFILLTUNING);
+		/* Change TX FIFO threshold to be 0x08 */
+		writel((temp & (~(0x3f << 16))) | (0x08 << 16),
+				hcd->regs + FSL_SOC_USB_TXFILLTUNING);
+	}
+
+}
diff --git a/arch/arm/plat-mxc/include/mach/fsl_usb_gadget.h b/arch/arm/plat-mxc/include/mach/fsl_usb_gadget.h
new file mode 100755
index 0000000..53f9b05
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/fsl_usb_gadget.h
@@ -0,0 +1,40 @@
+/*
+ * Copyright 2005-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*
+ * USB Gadget side, platform-specific functionality.
+ */
+
+#include <linux/usb/fsl_xcvr.h>
+
+/* Needed for i2c/serial transceivers */
+static inline void
+fsl_platform_set_device_mode(struct fsl_usb2_platform_data *pdata)
+{
+	if (pdata->xcvr_ops && pdata->xcvr_ops->set_device)
+		pdata->xcvr_ops->set_device();
+}
+
+static inline void
+fsl_platform_pullup_enable(struct fsl_usb2_platform_data *pdata)
+{
+	if (pdata->xcvr_ops && pdata->xcvr_ops->pullup)
+		pdata->xcvr_ops->pullup(1);
+}
+
+static inline void
+fsl_platform_pullup_disable(struct fsl_usb2_platform_data *pdata)
+{
+	if (pdata->xcvr_ops && pdata->xcvr_ops->pullup)
+		pdata->xcvr_ops->pullup(0);
+}
diff --git a/arch/arm/plat-mxc/include/mach/iomux-mx53.h b/arch/arm/plat-mxc/include/mach/iomux-mx53.h
old mode 100644
new mode 100755
index e95d9cb..468674f
--- a/arch/arm/plat-mxc/include/mach/iomux-mx53.h
+++ b/arch/arm/plat-mxc/include/mach/iomux-mx53.h
@@ -30,6 +30,9 @@
 #define MX53_SDHC_PAD_CTRL 	(PAD_CTL_HYS | PAD_CTL_PKE | PAD_CTL_PUE | \
 				PAD_CTL_PUS_47K_UP | PAD_CTL_DSE_HIGH | \
 				PAD_CTL_SRE_FAST)
+#define PAD_CTRL_I2C	(PAD_CTL_SRE_FAST | PAD_CTL_ODE | PAD_CTL_PKE | \
+			PAD_CTL_PUE | PAD_CTL_DSE_HIGH | PAD_CTL_PUS_100K_UP \
+			| PAD_CTL_HYS)
 
 #define _MX53_PAD_GPIO_19__KPP_COL_5		IOMUX_PAD(0x348, 0x20, 0, 0x840, 0, 0)
 #define _MX53_PAD_GPIO_19__GPIO4_5		IOMUX_PAD(0x348, 0x20, 1, 0x0, 0, 0)
@@ -1256,7 +1259,7 @@
 #define MX53_PAD_KEY_COL3__GPIO4_12		(_MX53_PAD_KEY_COL3__GPIO4_12 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define MX53_PAD_KEY_COL3__USBOH3_H2_DP		(_MX53_PAD_KEY_COL3__USBOH3_H2_DP | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define MX53_PAD_KEY_COL3__SPDIF_IN1		(_MX53_PAD_KEY_COL3__SPDIF_IN1 | MUX_PAD_CTRL(NO_PAD_CTRL))
-#define MX53_PAD_KEY_COL3__I2C2_SCL		(_MX53_PAD_KEY_COL3__I2C2_SCL | MUX_PAD_CTRL(NO_PAD_CTRL))
+#define MX53_PAD_KEY_COL3__I2C2_SCL		(_MX53_PAD_KEY_COL3__I2C2_SCL | MUX_PAD_CTRL(PAD_CTRL_I2C))
 #define MX53_PAD_KEY_COL3__ECSPI1_SS3		(_MX53_PAD_KEY_COL3__ECSPI1_SS3 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define MX53_PAD_KEY_COL3__FEC_CRS		(_MX53_PAD_KEY_COL3__FEC_CRS | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define MX53_PAD_KEY_COL3__USBPHY1_SIECLOCK		(_MX53_PAD_KEY_COL3__USBPHY1_SIECLOCK | MUX_PAD_CTRL(NO_PAD_CTRL))
@@ -1264,7 +1267,7 @@
 #define MX53_PAD_KEY_ROW3__GPIO4_13		(_MX53_PAD_KEY_ROW3__GPIO4_13 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define MX53_PAD_KEY_ROW3__USBOH3_H2_DM		(_MX53_PAD_KEY_ROW3__USBOH3_H2_DM | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define MX53_PAD_KEY_ROW3__CCM_ASRC_EXT_CLK		(_MX53_PAD_KEY_ROW3__CCM_ASRC_EXT_CLK | MUX_PAD_CTRL(NO_PAD_CTRL))
-#define MX53_PAD_KEY_ROW3__I2C2_SDA		(_MX53_PAD_KEY_ROW3__I2C2_SDA | MUX_PAD_CTRL(NO_PAD_CTRL))
+#define MX53_PAD_KEY_ROW3__I2C2_SDA		(_MX53_PAD_KEY_ROW3__I2C2_SDA | MUX_PAD_CTRL(PAD_CTRL_I2C))
 #define MX53_PAD_KEY_ROW3__OSC32K_32K_OUT		(_MX53_PAD_KEY_ROW3__OSC32K_32K_OUT | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define MX53_PAD_KEY_ROW3__CCM_PLL4_BYP		(_MX53_PAD_KEY_ROW3__CCM_PLL4_BYP | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define MX53_PAD_KEY_ROW3__USBPHY1_LINESTATE_0		(_MX53_PAD_KEY_ROW3__USBPHY1_LINESTATE_0 | MUX_PAD_CTRL(NO_PAD_CTRL))
@@ -1536,7 +1539,7 @@
 #define MX53_PAD_CSI0_DAT8__KPP_COL_7		(_MX53_PAD_CSI0_DAT8__KPP_COL_7 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define MX53_PAD_CSI0_DAT8__ECSPI2_SCLK		(_MX53_PAD_CSI0_DAT8__ECSPI2_SCLK | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define MX53_PAD_CSI0_DAT8__USBOH3_USBH3_OC		(_MX53_PAD_CSI0_DAT8__USBOH3_USBH3_OC | MUX_PAD_CTRL(NO_PAD_CTRL))
-#define MX53_PAD_CSI0_DAT8__I2C1_SDA		(_MX53_PAD_CSI0_DAT8__I2C1_SDA | MUX_PAD_CTRL(NO_PAD_CTRL))
+#define MX53_PAD_CSI0_DAT8__I2C1_SDA		(_MX53_PAD_CSI0_DAT8__I2C1_SDA | MUX_PAD_CTRL(PAD_CTRL_I2C))
 #define MX53_PAD_CSI0_DAT8__EMI_EMI_DEBUG_37		(_MX53_PAD_CSI0_DAT8__EMI_EMI_DEBUG_37 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define MX53_PAD_CSI0_DAT8__TPIU_TRACE_5		(_MX53_PAD_CSI0_DAT8__TPIU_TRACE_5 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define MX53_PAD_CSI0_DAT9__IPU_CSI0_D_9		(_MX53_PAD_CSI0_DAT9__IPU_CSI0_D_9 | MUX_PAD_CTRL(NO_PAD_CTRL))
@@ -1544,7 +1547,7 @@
 #define MX53_PAD_CSI0_DAT9__KPP_ROW_7		(_MX53_PAD_CSI0_DAT9__KPP_ROW_7 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define MX53_PAD_CSI0_DAT9__ECSPI2_MOSI		(_MX53_PAD_CSI0_DAT9__ECSPI2_MOSI | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define MX53_PAD_CSI0_DAT9__USBOH3_USBH3_PWR		(_MX53_PAD_CSI0_DAT9__USBOH3_USBH3_PWR | MUX_PAD_CTRL(NO_PAD_CTRL))
-#define MX53_PAD_CSI0_DAT9__I2C1_SCL		(_MX53_PAD_CSI0_DAT9__I2C1_SCL | MUX_PAD_CTRL(NO_PAD_CTRL))
+#define MX53_PAD_CSI0_DAT9__I2C1_SCL		(_MX53_PAD_CSI0_DAT9__I2C1_SCL | MUX_PAD_CTRL(PAD_CTRL_I2C))
 #define MX53_PAD_CSI0_DAT9__EMI_EMI_DEBUG_38		(_MX53_PAD_CSI0_DAT9__EMI_EMI_DEBUG_38 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define MX53_PAD_CSI0_DAT9__TPIU_TRACE_6		(_MX53_PAD_CSI0_DAT9__TPIU_TRACE_6 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define MX53_PAD_CSI0_DAT10__IPU_CSI0_D_10		(_MX53_PAD_CSI0_DAT10__IPU_CSI0_D_10 | MUX_PAD_CTRL(NO_PAD_CTRL))
@@ -1631,25 +1634,25 @@
 #define MX53_PAD_EIM_EB2__CCM_DI1_EXT_CLK		(_MX53_PAD_EIM_EB2__CCM_DI1_EXT_CLK | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define MX53_PAD_EIM_EB2__IPU_SER_DISP1_CS		(_MX53_PAD_EIM_EB2__IPU_SER_DISP1_CS | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define MX53_PAD_EIM_EB2__ECSPI1_SS0		(_MX53_PAD_EIM_EB2__ECSPI1_SS0 | MUX_PAD_CTRL(NO_PAD_CTRL))
-#define MX53_PAD_EIM_EB2__I2C2_SCL		(_MX53_PAD_EIM_EB2__I2C2_SCL | MUX_PAD_CTRL(NO_PAD_CTRL))
+#define MX53_PAD_EIM_EB2__I2C2_SCL		(_MX53_PAD_EIM_EB2__I2C2_SCL | MUX_PAD_CTRL(PAD_CTRL_I2C))
 #define MX53_PAD_EIM_D16__EMI_WEIM_D_16		(_MX53_PAD_EIM_D16__EMI_WEIM_D_16 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define MX53_PAD_EIM_D16__GPIO3_16		(_MX53_PAD_EIM_D16__GPIO3_16 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define MX53_PAD_EIM_D16__IPU_DI0_PIN5		(_MX53_PAD_EIM_D16__IPU_DI0_PIN5 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define MX53_PAD_EIM_D16__IPU_DISPB1_SER_CLK		(_MX53_PAD_EIM_D16__IPU_DISPB1_SER_CLK | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define MX53_PAD_EIM_D16__ECSPI1_SCLK		(_MX53_PAD_EIM_D16__ECSPI1_SCLK | MUX_PAD_CTRL(NO_PAD_CTRL))
-#define MX53_PAD_EIM_D16__I2C2_SDA		(_MX53_PAD_EIM_D16__I2C2_SDA | MUX_PAD_CTRL(NO_PAD_CTRL))
+#define MX53_PAD_EIM_D16__I2C2_SDA		(_MX53_PAD_EIM_D16__I2C2_SDA | MUX_PAD_CTRL(PAD_CTRL_I2C))
 #define MX53_PAD_EIM_D17__EMI_WEIM_D_17		(_MX53_PAD_EIM_D17__EMI_WEIM_D_17 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define MX53_PAD_EIM_D17__GPIO3_17		(_MX53_PAD_EIM_D17__GPIO3_17 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define MX53_PAD_EIM_D17__IPU_DI0_PIN6		(_MX53_PAD_EIM_D17__IPU_DI0_PIN6 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define MX53_PAD_EIM_D17__IPU_DISPB1_SER_DIN		(_MX53_PAD_EIM_D17__IPU_DISPB1_SER_DIN | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define MX53_PAD_EIM_D17__ECSPI1_MISO		(_MX53_PAD_EIM_D17__ECSPI1_MISO | MUX_PAD_CTRL(NO_PAD_CTRL))
-#define MX53_PAD_EIM_D17__I2C3_SCL		(_MX53_PAD_EIM_D17__I2C3_SCL | MUX_PAD_CTRL(NO_PAD_CTRL))
+#define MX53_PAD_EIM_D17__I2C3_SCL		(_MX53_PAD_EIM_D17__I2C3_SCL | MUX_PAD_CTRL(PAD_CTRL_I2C))
 #define MX53_PAD_EIM_D18__EMI_WEIM_D_18		(_MX53_PAD_EIM_D18__EMI_WEIM_D_18 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define MX53_PAD_EIM_D18__GPIO3_18		(_MX53_PAD_EIM_D18__GPIO3_18 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define MX53_PAD_EIM_D18__IPU_DI0_PIN7		(_MX53_PAD_EIM_D18__IPU_DI0_PIN7 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define MX53_PAD_EIM_D18__IPU_DISPB1_SER_DIO		(_MX53_PAD_EIM_D18__IPU_DISPB1_SER_DIO | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define MX53_PAD_EIM_D18__ECSPI1_MOSI		(_MX53_PAD_EIM_D18__ECSPI1_MOSI | MUX_PAD_CTRL(NO_PAD_CTRL))
-#define MX53_PAD_EIM_D18__I2C3_SDA		(_MX53_PAD_EIM_D18__I2C3_SDA | MUX_PAD_CTRL(NO_PAD_CTRL))
+#define MX53_PAD_EIM_D18__I2C3_SDA		(_MX53_PAD_EIM_D18__I2C3_SDA | MUX_PAD_CTRL(PAD_CTRL_I2C))
 #define MX53_PAD_EIM_D18__IPU_DI1_D0_CS		(_MX53_PAD_EIM_D18__IPU_DI1_D0_CS | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define MX53_PAD_EIM_D19__EMI_WEIM_D_19		(_MX53_PAD_EIM_D19__EMI_WEIM_D_19 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define MX53_PAD_EIM_D19__GPIO3_19		(_MX53_PAD_EIM_D19__GPIO3_19 | MUX_PAD_CTRL(NO_PAD_CTRL))
@@ -1672,7 +1675,7 @@
 #define MX53_PAD_EIM_D21__IPU_DI0_PIN17		(_MX53_PAD_EIM_D21__IPU_DI0_PIN17 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define MX53_PAD_EIM_D21__IPU_DISPB0_SER_CLK		(_MX53_PAD_EIM_D21__IPU_DISPB0_SER_CLK | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define MX53_PAD_EIM_D21__CSPI_SCLK		(_MX53_PAD_EIM_D21__CSPI_SCLK | MUX_PAD_CTRL(NO_PAD_CTRL))
-#define MX53_PAD_EIM_D21__I2C1_SCL		(_MX53_PAD_EIM_D21__I2C1_SCL | MUX_PAD_CTRL(NO_PAD_CTRL))
+#define MX53_PAD_EIM_D21__I2C1_SCL		(_MX53_PAD_EIM_D21__I2C1_SCL | MUX_PAD_CTRL(PAD_CTRL_I2C))
 #define MX53_PAD_EIM_D21__USBOH3_USBOTG_OC		(_MX53_PAD_EIM_D21__USBOH3_USBOTG_OC | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define MX53_PAD_EIM_D22__EMI_WEIM_D_22		(_MX53_PAD_EIM_D22__EMI_WEIM_D_22 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define MX53_PAD_EIM_D22__GPIO3_22		(_MX53_PAD_EIM_D22__GPIO3_22 | MUX_PAD_CTRL(NO_PAD_CTRL))
@@ -1732,7 +1735,7 @@
 #define MX53_PAD_EIM_D28__UART2_CTS		(_MX53_PAD_EIM_D28__UART2_CTS | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define MX53_PAD_EIM_D28__IPU_DISPB0_SER_DIO		(_MX53_PAD_EIM_D28__IPU_DISPB0_SER_DIO | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define MX53_PAD_EIM_D28__CSPI_MOSI		(_MX53_PAD_EIM_D28__CSPI_MOSI | MUX_PAD_CTRL(NO_PAD_CTRL))
-#define MX53_PAD_EIM_D28__I2C1_SDA		(_MX53_PAD_EIM_D28__I2C1_SDA | MUX_PAD_CTRL(NO_PAD_CTRL))
+#define MX53_PAD_EIM_D28__I2C1_SDA		(_MX53_PAD_EIM_D28__I2C1_SDA | MUX_PAD_CTRL(PAD_CTRL_I2C))
 #define MX53_PAD_EIM_D28__IPU_EXT_TRIG		(_MX53_PAD_EIM_D28__IPU_EXT_TRIG | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define MX53_PAD_EIM_D28__IPU_DI0_PIN13		(_MX53_PAD_EIM_D28__IPU_DI0_PIN13 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define MX53_PAD_EIM_D29__EMI_WEIM_D_29		(_MX53_PAD_EIM_D29__EMI_WEIM_D_29 | MUX_PAD_CTRL(NO_PAD_CTRL))
@@ -2297,7 +2300,7 @@
 #define MX53_PAD_GPIO_9__SCC_FAIL_STATE		(_MX53_PAD_GPIO_9__SCC_FAIL_STATE | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define MX53_PAD_GPIO_3__ESAI1_HCKR		(_MX53_PAD_GPIO_3__ESAI1_HCKR | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define MX53_PAD_GPIO_3__GPIO1_3		(_MX53_PAD_GPIO_3__GPIO1_3 | MUX_PAD_CTRL(NO_PAD_CTRL))
-#define MX53_PAD_GPIO_3__I2C3_SCL		(_MX53_PAD_GPIO_3__I2C3_SCL | MUX_PAD_CTRL(NO_PAD_CTRL))
+#define MX53_PAD_GPIO_3__I2C3_SCL		(_MX53_PAD_GPIO_3__I2C3_SCL | MUX_PAD_CTRL(PAD_CTRL_I2C))
 #define MX53_PAD_GPIO_3__DPLLIP1_TOG_EN		(_MX53_PAD_GPIO_3__DPLLIP1_TOG_EN | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define MX53_PAD_GPIO_3__CCM_CLKO2		(_MX53_PAD_GPIO_3__CCM_CLKO2 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define MX53_PAD_GPIO_3__OBSERVE_MUX_OBSRV_INT_OUT0		(_MX53_PAD_GPIO_3__OBSERVE_MUX_OBSRV_INT_OUT0 | MUX_PAD_CTRL(NO_PAD_CTRL))
@@ -2305,7 +2308,7 @@
 #define MX53_PAD_GPIO_3__MLB_MLBCLK		(_MX53_PAD_GPIO_3__MLB_MLBCLK | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define MX53_PAD_GPIO_6__ESAI1_SCKT		(_MX53_PAD_GPIO_6__ESAI1_SCKT | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define MX53_PAD_GPIO_6__GPIO1_6		(_MX53_PAD_GPIO_6__GPIO1_6 | MUX_PAD_CTRL(NO_PAD_CTRL))
-#define MX53_PAD_GPIO_6__I2C3_SDA		(_MX53_PAD_GPIO_6__I2C3_SDA | MUX_PAD_CTRL(NO_PAD_CTRL))
+#define MX53_PAD_GPIO_6__I2C3_SDA		(_MX53_PAD_GPIO_6__I2C3_SDA | MUX_PAD_CTRL(PAD_CTRL_I2C))
 #define MX53_PAD_GPIO_6__CCM_CCM_OUT_0		(_MX53_PAD_GPIO_6__CCM_CCM_OUT_0 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define MX53_PAD_GPIO_6__CSU_CSU_INT_DEB		(_MX53_PAD_GPIO_6__CSU_CSU_INT_DEB | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define MX53_PAD_GPIO_6__OBSERVE_MUX_OBSRV_INT_OUT1		(_MX53_PAD_GPIO_6__OBSERVE_MUX_OBSRV_INT_OUT1 | MUX_PAD_CTRL(NO_PAD_CTRL))
@@ -2333,7 +2336,7 @@
 #define MX53_PAD_GPIO_5__CCM_CLKO		(_MX53_PAD_GPIO_5__CCM_CLKO | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define MX53_PAD_GPIO_5__CSU_CSU_ALARM_AUT_2		(_MX53_PAD_GPIO_5__CSU_CSU_ALARM_AUT_2 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define MX53_PAD_GPIO_5__OBSERVE_MUX_OBSRV_INT_OUT4		(_MX53_PAD_GPIO_5__OBSERVE_MUX_OBSRV_INT_OUT4 | MUX_PAD_CTRL(NO_PAD_CTRL))
-#define MX53_PAD_GPIO_5__I2C3_SCL		(_MX53_PAD_GPIO_5__I2C3_SCL | MUX_PAD_CTRL(NO_PAD_CTRL))
+#define MX53_PAD_GPIO_5__I2C3_SCL		(_MX53_PAD_GPIO_5__I2C3_SCL | MUX_PAD_CTRL(PAD_CTRL_I2C))
 #define MX53_PAD_GPIO_5__CCM_PLL1_BYP		(_MX53_PAD_GPIO_5__CCM_PLL1_BYP | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define MX53_PAD_GPIO_7__ESAI1_TX4_RX1		(_MX53_PAD_GPIO_7__ESAI1_TX4_RX1 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define MX53_PAD_GPIO_7__GPIO1_7		(_MX53_PAD_GPIO_7__GPIO1_7 | MUX_PAD_CTRL(NO_PAD_CTRL))
@@ -2356,7 +2359,7 @@
 #define MX53_PAD_GPIO_16__TZIC_PWRFAIL_INT		(_MX53_PAD_GPIO_16__TZIC_PWRFAIL_INT | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define MX53_PAD_GPIO_16__RTC_CE_RTC_EXT_TRIG1		(_MX53_PAD_GPIO_16__RTC_CE_RTC_EXT_TRIG1 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define MX53_PAD_GPIO_16__SPDIF_IN1		(_MX53_PAD_GPIO_16__SPDIF_IN1 | MUX_PAD_CTRL(NO_PAD_CTRL))
-#define MX53_PAD_GPIO_16__I2C3_SDA		(_MX53_PAD_GPIO_16__I2C3_SDA | MUX_PAD_CTRL(NO_PAD_CTRL))
+#define MX53_PAD_GPIO_16__I2C3_SDA		(_MX53_PAD_GPIO_16__I2C3_SDA | MUX_PAD_CTRL(PAD_CTRL_I2C))
 #define MX53_PAD_GPIO_16__SJC_DE_B		(_MX53_PAD_GPIO_16__SJC_DE_B | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define MX53_PAD_GPIO_17__ESAI1_TX0		(_MX53_PAD_GPIO_17__ESAI1_TX0 | MUX_PAD_CTRL(NO_PAD_CTRL))
 #define MX53_PAD_GPIO_17__GPIO7_12		(_MX53_PAD_GPIO_17__GPIO7_12 | MUX_PAD_CTRL(NO_PAD_CTRL))
diff --git a/arch/arm/plat-mxc/include/mach/ipu-v3.h b/arch/arm/plat-mxc/include/mach/ipu-v3.h
new file mode 100755
index 0000000..431befd
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/ipu-v3.h
@@ -0,0 +1,38 @@
+/*
+ * Copyright (c) 2010 Sascha Hauer <s.hauer@pengutronix.de>
+ * Copyright (C) 2011 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ */
+
+#ifndef __MACH_IPU_V3_H_
+#define __MACH_IPU_V3_H_
+
+struct ipuv3_fb_platform_data {
+	const struct fb_videomode	*modes;
+	int				num_modes;
+	char				*mode_str;
+	u32				interface_pix_fmt;
+
+	/* reserved mem */
+	resource_size_t 		res_base;
+	resource_size_t 		res_size;
+};
+
+struct imx_ipuv3_platform_data {
+	int rev;
+	int (*init) (void);
+	void (*pg) (int);
+	struct ipuv3_fb_platform_data	*fb_head0_platform_data;
+	struct ipuv3_fb_platform_data	*fb_head1_platform_data;
+};
+
+#endif /* __MACH_IPU_V3_H_ */
diff --git a/arch/arm/plat-mxc/include/mach/memory.h b/arch/arm/plat-mxc/include/mach/memory.h
old mode 100644
new mode 100755
index 11be5cd..c638288
--- a/arch/arm/plat-mxc/include/mach/memory.h
+++ b/arch/arm/plat-mxc/include/mach/memory.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2011 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -11,6 +11,9 @@
 #ifndef __ASM_ARCH_MXC_MEMORY_H__
 #define __ASM_ARCH_MXC_MEMORY_H__
 
+#include <asm/sizes.h>
+#include <asm/page.h>
+
 #define MX1_PHYS_OFFSET		UL(0x08000000)
 #define MX21_PHYS_OFFSET	UL(0xc0000000)
 #define MX25_PHYS_OFFSET	UL(0x80000000)
@@ -53,6 +56,37 @@
  * This is required for i.MX camera driver to capture at least four VGA frames.
  */
 #define CONSISTENT_DMA_SIZE SZ_4M
+#else
+
+#ifdef CONFIG_ARCH_MX5
+#define CONSISTENT_DMA_SIZE     (96 * SZ_1M)
+#else
+#define CONSISTENT_DMA_SIZE     (32 * SZ_1M)
+#endif
+
 #endif /* CONFIG_MX1_VIDEO || CONFIG_VIDEO_MX2_HOSTSUPPORT */
 
+#ifndef __ASSEMBLY__
+
+#ifdef CONFIG_DMA_ZONE_SIZE
+#define MXC_DMA_ZONE_SIZE       ((CONFIG_DMA_ZONE_SIZE * SZ_1M) >> PAGE_SHIFT)
+#else
+#define MXC_DMA_ZONE_SIZE       ((12 * SZ_1M) >> PAGE_SHIFT)
+#endif
+
+static inline void __arch_adjust_zones(unsigned long *zone_size,
+		unsigned long *zhole_size)
+{
+	/* Create separate zone to reserve memory for DMA */
+	zone_size[1] = zone_size[0] - MXC_DMA_ZONE_SIZE;
+	zone_size[0] = MXC_DMA_ZONE_SIZE;
+	zhole_size[1] = zhole_size[0];
+	zhole_size[0] = 0;
+}
+
+#define arch_adjust_zones(size, holes) \
+	__arch_adjust_zones(size, holes)
+
+#endif
+
 #endif /* __ASM_ARCH_MXC_MEMORY_H__ */
diff --git a/arch/arm/plat-mxc/include/mach/mx51.h b/arch/arm/plat-mxc/include/mach/mx51.h
old mode 100644
new mode 100755
index dede19a..8bf246e
--- a/arch/arm/plat-mxc/include/mach/mx51.h
+++ b/arch/arm/plat-mxc/include/mach/mx51.h
@@ -14,8 +14,9 @@
 #define MX51_IRAM_PARTITIONS		16
 #define MX51_IRAM_SIZE		(MX51_IRAM_PARTITIONS * SZ_8K)	/* 128KB */
 
-#define MX51_GPU_BASE_ADDR		0x20000000
-#define MX51_GPU_CTRL_BASE_ADDR		0x30000000
+#define MX51_GPU_GMEM_BASE_ADDR		0x20000000
+#define MX51_GPU_GMEM_SIZE		SZ_128K
+#define MX51_GPU_BASE_ADDR		0x30000000
 #define MX51_IPU_CTRL_BASE_ADDR		0x40000000
 
 #define MX51_DEBUG_BASE_ADDR		0x60000000
@@ -75,6 +76,7 @@
 #define MX51_SRC_BASE_ADDR		(MX51_AIPS1_BASE_ADDR + 0xd0000)
 #define MX51_CCM_BASE_ADDR		(MX51_AIPS1_BASE_ADDR + 0xd4000)
 #define MX51_GPC_BASE_ADDR		(MX51_AIPS1_BASE_ADDR + 0xd8000)
+#define MX51_DVFSCORE_BASE_ADDR 	(MX51_GPC_BASE_ADDR + 0x180)
 
 /*
  * AIPS 2
@@ -136,6 +138,18 @@
 #define MX51_IO_P2V(x)			IMX_IO_P2V(x)
 #define MX51_IO_ADDRESS(x)		IOMEM(MX51_IO_P2V(x))
 
+/* PGC */
+#define MX51_GPC_BASE		(MX51_IO_ADDRESS(MX51_GPC_BASE_ADDR))
+#define MX51_PGC_IPU_BASE	(MX51_GPC_BASE + 0x220)
+#define MX51_PGC_VPU_BASE	(MX51_GPC_BASE + 0x240)
+#define MX51_PGC_GPU_BASE	(MX51_GPC_BASE + 0x260)
+#define MX51_PGC_IPU_PGCR	(MX51_PGC_IPU_BASE + 0x0)
+#define MX51_PGC_IPU_PGSR	(MX51_PGC_IPU_BASE + 0xC)
+#define MX51_PGC_VPU_PGCR	(MX51_PGC_VPU_BASE + 0x0)
+#define MX51_PGC_VPU_PGSR	(MX51_PGC_VPU_BASE + 0xC)
+#define MX51_PGC_GPU_PGCR	(MX51_PGC_GPU_BASE + 0x0)
+#define MX51_PGC_GPU_PGSR	(MX51_PGC_GPU_BASE + 0xC)
+
 /*
  * defines for SPBA modules
  */
@@ -250,10 +264,10 @@
 #define MX51_INT_SDMA			6
 #define MX51_MXC_INT_IOMUX		7
 #define MX51_INT_NFC			8
-#define MX51_MXC_INT_VPU		9
+#define MX51_INT_VPU			9
 #define MX51_INT_IPU_ERR		10
 #define MX51_INT_IPU_SYN		11
-#define MX51_MXC_INT_GPU		12
+#define MX51_INT_GPU			12
 #define MX51_MXC_INT_RESV13		13
 #define MX51_MXC_INT_USB_H1		14
 #define MX51_MXC_INT_EMI		15
@@ -310,12 +324,12 @@
 #define MX51_MXC_INT_RESV66		66
 #define MX51_MXC_INT_SIM_IPB		67
 #define MX51_MXC_INT_SIM_DAT		68
-#define MX51_MXC_INT_IIM		69
+#define MX51_INT_IIM			69
 #define MX51_MXC_INT_ATA		70
 #define MX51_MXC_INT_CCM1		71
 #define MX51_MXC_INT_CCM2		72
-#define MX51_MXC_INT_GPC1		73
-#define MX51_MXC_INT_GPC2		74
+#define MX51_INT_GPC1			73
+#define MX51_INT_GPC2			74
 #define MX51_MXC_INT_SRC		75
 #define MX51_MXC_INT_NM			76
 #define MX51_MXC_INT_PMU		77
@@ -325,7 +339,7 @@
 #define MX51_MXC_INT_MCG_ERR		81
 #define MX51_MXC_INT_MCG_TMR		82
 #define MX51_MXC_INT_MCG_FUNC		83
-#define MX51_MXC_INT_GPU2_IRQ		84
+#define MX51_INT_GPU2_IRQ		84
 #define MX51_MXC_INT_GPU2_BUSY		85
 #define MX51_MXC_INT_RESV86		86
 #define MX51_INT_FEC			87
@@ -333,7 +347,7 @@
 #define MX51_MXC_INT_CTI1_TG2		89
 #define MX51_MXC_INT_SJC		90
 #define MX51_MXC_INT_SPDIF		91
-#define MX51_MXC_INT_TVE		92
+#define MX51_INT_TVE			92
 #define MX51_MXC_INT_FIRI		93
 #define MX51_INT_PWM2			94
 #define MX51_MXC_INT_SLIM_EXP		95
diff --git a/arch/arm/plat-mxc/include/mach/mx53.h b/arch/arm/plat-mxc/include/mach/mx53.h
old mode 100644
new mode 100755
index 9d2a1ef..b26b8dd
--- a/arch/arm/plat-mxc/include/mach/mx53.h
+++ b/arch/arm/plat-mxc/include/mach/mx53.h
@@ -28,6 +28,12 @@
 #define MX53_IRAM_PARTITIONS	16
 #define MX53_IRAM_SIZE		(MX53_IRAM_PARTITIONS * SZ_8K)	/* 128KB */
 
+#ifdef CONFIG_MXC_VPU_IRAM
+#define VPU_IRAM_SIZE  0x14000
+#else
+#define VPU_IRAM_SIZE 0
+#endif
+
 /*
  * Graphics Memory of GPU
  */
@@ -35,6 +41,7 @@
 #define MX53_GPU2D_BASE_ADDR		0x20000000
 #define MX53_GPU_BASE_ADDR		0x30000000
 #define MX53_GPU_GMEM_BASE_ADDR	0xF8020000
+#define MX53_GPU_GMEM_SIZE	SZ_256K
 
 #define MX53_DEBUG_BASE_ADDR		0x40000000
 #define MX53_DEBUG_SIZE		SZ_1M
@@ -99,6 +106,7 @@
 #define MX53_ATA_BASE_ADDR	(MX53_AIPS1_BASE_ADDR + 0x000E8000)
 #define MX53_I2C3_BASE_ADDR	(MX53_AIPS1_BASE_ADDR + 0x000EC000)
 #define MX53_UART4_BASE_ADDR	(MX53_AIPS1_BASE_ADDR + 0x000F0000)
+#define MX53_DVFSCORE_BASE_ADDR (MX53_GPC_BASE_ADDR + 0x180)
 
 /*
  * AIPS 2
@@ -157,6 +165,18 @@
 #define MX53_IO_P2V(x)			IMX_IO_P2V(x)
 #define MX53_IO_ADDRESS(x)		IOMEM(MX53_IO_P2V(x))
 
+/* PGC */
+#define MX53_GPC_BASE		(MX53_IO_ADDRESS(MX53_GPC_BASE_ADDR))
+#define MX53_PGC_IPU_BASE	(MX53_GPC_BASE + 0x220)
+#define MX53_PGC_VPU_BASE	(MX53_GPC_BASE + 0x240)
+#define MX53_PGC_GPU_BASE	(MX53_GPC_BASE + 0x260)
+#define MX53_PGC_IPU_PGCR	(MX53_PGC_IPU_BASE + 0x0)
+#define MX53_PGC_IPU_PGSR	(MX53_PGC_IPU_BASE + 0xC)
+#define MX53_PGC_VPU_PGCR	(MX53_PGC_VPU_BASE + 0x0)
+#define MX53_PGC_VPU_PGSR	(MX53_PGC_VPU_BASE + 0xC)
+#define MX53_PGC_GPU_PGCR	(MX53_PGC_GPU_BASE + 0x0)
+#define MX53_PGC_GPU_PGSR	(MX53_PGC_GPU_BASE + 0xC)
+
 /*
  * defines for SPBA modules
  */
@@ -176,10 +196,10 @@
 /*
  * DMA request assignments
  */
-#define MX53_DMA_REQ_SSI3_TX1		47
-#define MX53_DMA_REQ_SSI3_RX1		46
-#define MX53_DMA_REQ_SSI3_TX2		45
-#define MX53_DMA_REQ_SSI3_RX2		44
+#define MX53_DMA_REQ_SSI3_TX0		47
+#define MX53_DMA_REQ_SSI3_RX0		46
+#define MX53_DMA_REQ_SSI3_TX1		45
+#define MX53_DMA_REQ_SSI3_RX1		44
 #define MX53_DMA_REQ_UART3_TX	43
 #define MX53_DMA_REQ_UART3_RX	42
 #define MX53_DMA_REQ_ESAI_TX		41
@@ -194,14 +214,14 @@
 #define MX53_DMA_REQ_ASRC_DMA1	32
 #define MX53_DMA_REQ_EMI_WR		31
 #define MX53_DMA_REQ_EMI_RD		30
-#define MX53_DMA_REQ_SSI1_TX1		29
-#define MX53_DMA_REQ_SSI1_RX1		28
-#define MX53_DMA_REQ_SSI1_TX2		27
-#define MX53_DMA_REQ_SSI1_RX2		26
-#define MX53_DMA_REQ_SSI2_TX1		25
-#define MX53_DMA_REQ_SSI2_RX1		24
-#define MX53_DMA_REQ_SSI2_TX2		23
-#define MX53_DMA_REQ_SSI2_RX2		22
+#define MX53_DMA_REQ_SSI1_TX0		29
+#define MX53_DMA_REQ_SSI1_RX0		28
+#define MX53_DMA_REQ_SSI1_TX1		27
+#define MX53_DMA_REQ_SSI1_RX1		26
+#define MX53_DMA_REQ_SSI2_TX0		25
+#define MX53_DMA_REQ_SSI2_RX0		24
+#define MX53_DMA_REQ_SSI2_TX1		23
+#define MX53_DMA_REQ_SSI2_RX1		22
 #define MX53_DMA_REQ_I2C2_SDHC2	21
 #define MX53_DMA_REQ_I2C1_SDHC1	20
 #define MX53_DMA_REQ_UART1_TX	19
@@ -337,4 +357,27 @@
 #define MX53_INT_GPIO7_LOW	107
 #define MX53_INT_GPIO7_HIGH	108
 
+/* silicon revisions specific to i.MX53 */
+#define MX53_CHIP_REV_1_0		0x10
+#define MX53_CHIP_REV_1_1		0x11
+#define MX53_CHIP_REV_1_2		0x12
+#define MX53_CHIP_REV_1_3		0x13
+#define MX53_CHIP_REV_2_0		0x20
+#define MX53_CHIP_REV_2_1		0x21
+#define MX53_CHIP_REV_2_2		0x22
+#define MX53_CHIP_REV_2_3		0x23
+#define MX53_CHIP_REV_3_0		0x30
+#define MX53_CHIP_REV_3_1		0x31
+#define MX53_CHIP_REV_3_2		0x32
+
+/*!
+ * IIM bank info
+ */
+#define MXC_IIM_MX51_BANK_START_ADDR 0x0800
+#define MXC_IIM_MX51_BANK_END_ADDR   0x147c
+#define MXC_IIM_MX53_BANK_START_ADDR 0x0800
+#define MXC_IIM_MX53_BANK_END_ADDR   0x183c
+#define MXC_IIM_MX53_BANK_AREA_1_OFFSET 0xc00
+#define MXC_IIM_MX53_MAC_ADDR_OFFSET    0x24
+
 #endif /* ifndef __MACH_MX53_H__ */
diff --git a/arch/arm/plat-mxc/include/mach/mxc.h b/arch/arm/plat-mxc/include/mach/mxc.h
old mode 100644
new mode 100755
index 4ac53ce..145b440
--- a/arch/arm/plat-mxc/include/mach/mxc.h
+++ b/arch/arm/plat-mxc/include/mach/mxc.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2007, 2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2007, 2011 Freescale Semiconductor, Inc. All Rights Reserved.
  * Copyright (C) 2008 Juergen Beisert (kernel@pengutronix.de)
  *
  * This program is free software; you can redistribute it and/or
@@ -32,6 +32,7 @@
 #define MXC_CPU_MX27		27
 #define MXC_CPU_MX31		31
 #define MXC_CPU_MX35		35
+#define MXC_CPU_MX37            37
 #define MXC_CPU_MX50		50
 #define MXC_CPU_MX51		51
 #define MXC_CPU_MX53		53
@@ -63,6 +64,21 @@
 #define IMX_CHIP_REVISION_3_2_STRING		"3.2"
 #define IMX_CHIP_REVISION_3_3_STRING		"3.3"
 #define IMX_CHIP_REVISION_UNKNOWN_STRING	"unknown"
+#define IMX_BOARD_REV_1		0x000
+#define IMX_BOARD_REV_2		0x100
+#define IMX_BOARD_REV_3		0x200
+
+#ifndef __ASSEMBLY__
+extern unsigned int system_rev;
+#define board_is_rev(rev)	(((system_rev & 0x0F00) == rev) ? 1 : 0)
+#define imx_cpu_ver()		(system_rev & 0xFF)
+#endif
+
+#ifdef CONFIG_ARCH_MX5
+#define board_is_mx53_arm2() (cpu_is_mx53() && board_is_rev(IMX_BOARD_REV_2))
+#define board_is_mx53_evk_a()    (cpu_is_mx53() && board_is_rev(IMX_BOARD_REV_1))
+#define board_is_mx53_evk_b()    (cpu_is_mx53() && board_is_rev(IMX_BOARD_REV_3))
+#endif
 
 #ifndef __ASSEMBLY__
 extern unsigned int __mxc_cpu_type;
@@ -128,6 +144,8 @@ extern unsigned int __mxc_cpu_type;
 # define cpu_is_mx31()		(0)
 #endif
 
+# define cpu_is_mx32()		(0)
+
 #ifdef CONFIG_SOC_IMX35
 # ifdef mxc_cpu_type
 #  undef mxc_cpu_type
@@ -140,6 +158,18 @@ extern unsigned int __mxc_cpu_type;
 # define cpu_is_mx35()		(0)
 #endif
 
+#ifdef CONFIG_SOC_IMX37
+# ifdef mxc_cpu_type
+#  undef mxc_cpu_type
+#  define mxc_cpu_type __mxc_cpu_type
+# else
+#  define mxc_cpu_type MXC_CPU_MX37
+# endif
+# define cpu_is_mx37()          (mxc_cpu_type == MXC_CPU_MX37)
+#else
+# define cpu_is_mx37()          (0)
+#endif
+
 #ifdef CONFIG_SOC_IMX50
 # ifdef mxc_cpu_type
 #  undef mxc_cpu_type
@@ -179,10 +209,18 @@ extern unsigned int __mxc_cpu_type;
 #ifndef __ASSEMBLY__
 
 struct cpu_op {
+	u32 pll_reg;
+	u32 pll_rate;
 	u32 cpu_rate;
+	u32 pdr0_reg;
+	u32 pdf;
+	u32 mfi;
+	u32 mfd;
+	u32 mfn;
+	u32 cpu_voltage;
+	u32 cpu_podf;
 };
 
-int tzic_enable_wake(int is_idle);
 enum mxc_cpu_pwr_mode {
 	WAIT_CLOCKED,		/* wfi only */
 	WAIT_UNCLOCKED,		/* WAIT */
@@ -191,10 +229,26 @@ enum mxc_cpu_pwr_mode {
 	STOP_POWER_OFF,		/* STOP + SRPG */
 };
 
+int tzic_enable_wake(int is_idle);
+
+extern void mxc_cpu_lp_set(enum mxc_cpu_pwr_mode mode);
+extern int tzic_enable_wake(int is_idle);
 extern struct cpu_op *(*get_cpu_op)(int *op);
 #endif
 
+#if defined(CONFIG_ARCH_MX3) || defined(CONFIG_ARCH_MX2)
+/* These are deprecated, use mx[23][157]_setup_weimcs instead. */
+#define CSCR_U(n) (IO_ADDRESS(WEIM_BASE_ADDR + n * 0x10))
+#define CSCR_L(n) (IO_ADDRESS(WEIM_BASE_ADDR + n * 0x10 + 0x4))
+#define CSCR_A(n) (IO_ADDRESS(WEIM_BASE_ADDR + n * 0x10 + 0x8))
+#endif
+
+#define cpu_is_mx5()    (cpu_is_mx51() || cpu_is_mx53() || cpu_is_mx50())
 #define cpu_is_mx3()	(cpu_is_mx31() || cpu_is_mx35())
 #define cpu_is_mx2()	(cpu_is_mx21() || cpu_is_mx27())
 
+#define MXC_PGCR_PCR		1
+#define MXC_SRPGCR_PCR		1
+#define MXC_EMPGCR_PCR		1
+#define MXC_PGSR_PSR		1
 #endif /*  __ASM_ARCH_MXC_H__ */
diff --git a/arch/arm/plat-mxc/include/mach/mxc91231.h b/arch/arm/plat-mxc/include/mach/mxc91231.h
new file mode 100755
index 0000000..765190f
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/mxc91231.h
@@ -0,0 +1,256 @@
+/*
+ *  Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ *    - Platform specific register memory map
+ *
+ *  Copyright 2005-2007 Motorola, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#ifndef __MACH_MXC91231_H__
+#define __MACH_MXC91231_H__
+
+/*
+ * L2CC
+ */
+#define MXC91231_L2CC_BASE_ADDR		0x30000000
+#define MXC91231_L2CC_SIZE		SZ_64K
+
+/*
+ * AIPS 1
+ */
+#define MXC91231_AIPS1_BASE_ADDR	0x43F00000
+#define MXC91231_AIPS1_SIZE		SZ_1M
+
+#define MXC91231_AIPS1_CTRL_BASE_ADDR	MXC91231_AIPS1_BASE_ADDR
+#define MXC91231_MAX_BASE_ADDR		(MXC91231_AIPS1_BASE_ADDR + 0x04000)
+#define MXC91231_EVTMON_BASE_ADDR	(MXC91231_AIPS1_BASE_ADDR + 0x08000)
+#define MXC91231_CLKCTL_BASE_ADDR	(MXC91231_AIPS1_BASE_ADDR + 0x0C000)
+#define MXC91231_ETB_SLOT4_BASE_ADDR	(MXC91231_AIPS1_BASE_ADDR + 0x10000)
+#define MXC91231_ETB_SLOT5_BASE_ADDR	(MXC91231_AIPS1_BASE_ADDR + 0x14000)
+#define MXC91231_ECT_CTIO_BASE_ADDR	(MXC91231_AIPS1_BASE_ADDR + 0x18000)
+#define MXC91231_I2C_BASE_ADDR		(MXC91231_AIPS1_BASE_ADDR + 0x80000)
+#define MXC91231_MU_BASE_ADDR		(MXC91231_AIPS1_BASE_ADDR + 0x88000)
+#define MXC91231_UART1_BASE_ADDR	(MXC91231_AIPS1_BASE_ADDR + 0x90000)
+#define MXC91231_UART2_BASE_ADDR	(MXC91231_AIPS1_BASE_ADDR + 0x94000)
+#define MXC91231_DSM_BASE_ADDR		(MXC91231_AIPS1_BASE_ADDR + 0x98000)
+#define MXC91231_OWIRE_BASE_ADDR	(MXC91231_AIPS1_BASE_ADDR + 0x9C000)
+#define MXC91231_SSI1_BASE_ADDR		(MXC91231_AIPS1_BASE_ADDR + 0xA0000)
+#define MXC91231_KPP_BASE_ADDR		(MXC91231_AIPS1_BASE_ADDR + 0xA8000)
+#define MXC91231_IOMUX_AP_BASE_ADDR	(MXC91231_AIPS1_BASE_ADDR + 0xAC000)
+#define MXC91231_CTI_AP_BASE_ADDR	(MXC91231_AIPS1_BASE_ADDR + 0xB8000)
+
+/*
+ * AIPS 2
+ */
+#define MXC91231_AIPS2_BASE_ADDR	0x53F00000
+#define MXC91231_AIPS2_SIZE		SZ_1M
+
+#define MXC91231_GEMK_BASE_ADDR		(MXC91231_AIPS2_BASE_ADDR + 0x8C000)
+#define MXC91231_GPT1_BASE_ADDR		(MXC91231_AIPS2_BASE_ADDR + 0x90000)
+#define MXC91231_EPIT1_AP_BASE_ADDR	(MXC91231_AIPS2_BASE_ADDR + 0x94000)
+#define MXC91231_SCC_BASE_ADDR		(MXC91231_AIPS2_BASE_ADDR + 0xAC000)
+#define MXC91231_RNGA_BASE_ADDR		(MXC91231_AIPS2_BASE_ADDR + 0xB0000)
+#define MXC91231_IPU_CTRL_BASE_ADDR	(MXC91231_AIPS2_BASE_ADDR + 0xC0000)
+#define MXC91231_AUDMUX_BASE_ADDR	(MXC91231_AIPS2_BASE_ADDR + 0xC4000)
+#define MXC91231_EDIO_BASE_ADDR		(MXC91231_AIPS2_BASE_ADDR + 0xC8000)
+#define MXC91231_GPIO1_AP_BASE_ADDR	(MXC91231_AIPS2_BASE_ADDR + 0xCC000)
+#define MXC91231_GPIO2_AP_BASE_ADDR	(MXC91231_AIPS2_BASE_ADDR + 0xD0000)
+#define MXC91231_SDMA_BASE_ADDR		(MXC91231_AIPS2_BASE_ADDR + 0xD4000)
+#define MXC91231_RTC_BASE_ADDR		(MXC91231_AIPS2_BASE_ADDR + 0xD8000)
+#define MXC91231_WDOG1_BASE_ADDR	(MXC91231_AIPS2_BASE_ADDR + 0xDC000)
+#define MXC91231_PWM_BASE_ADDR		(MXC91231_AIPS2_BASE_ADDR + 0xE0000)
+#define MXC91231_GPIO3_AP_BASE_ADDR	(MXC91231_AIPS2_BASE_ADDR + 0xE4000)
+#define MXC91231_WDOG2_BASE_ADDR	(MXC91231_AIPS2_BASE_ADDR + 0xE8000)
+#define MXC91231_RTIC_BASE_ADDR		(MXC91231_AIPS2_BASE_ADDR + 0xEC000)
+#define MXC91231_LPMC_BASE_ADDR		(MXC91231_AIPS2_BASE_ADDR + 0xF0000)
+
+/*
+ * SPBA global module 0
+ */
+#define MXC91231_SPBA0_BASE_ADDR	0x50000000
+#define MXC91231_SPBA0_SIZE		SZ_1M
+
+#define MXC91231_MMC_SDHC1_BASE_ADDR	(MXC91231_SPBA0_BASE_ADDR + 0x04000)
+#define MXC91231_MMC_SDHC2_BASE_ADDR	(MXC91231_SPBA0_BASE_ADDR + 0x08000)
+#define MXC91231_UART3_BASE_ADDR	(MXC91231_SPBA0_BASE_ADDR + 0x0C000)
+#define MXC91231_CSPI2_BASE_ADDR	(MXC91231_SPBA0_BASE_ADDR + 0x10000)
+#define MXC91231_SSI2_BASE_ADDR		(MXC91231_SPBA0_BASE_ADDR + 0x14000)
+#define MXC91231_SIM_BASE_ADDR		(MXC91231_SPBA0_BASE_ADDR + 0x18000)
+#define MXC91231_IIM_BASE_ADDR		(MXC91231_SPBA0_BASE_ADDR + 0x1C000)
+#define MXC91231_CTI_SDMA_BASE_ADDR	(MXC91231_SPBA0_BASE_ADDR + 0x20000)
+#define MXC91231_USBOTG_CTRL_BASE_ADDR	(MXC91231_SPBA0_BASE_ADDR + 0x24000)
+#define MXC91231_USBOTG_DATA_BASE_ADDR	(MXC91231_SPBA0_BASE_ADDR + 0x28000)
+#define MXC91231_CSPI1_BASE_ADDR	(MXC91231_SPBA0_BASE_ADDR + 0x30000)
+#define MXC91231_SPBA_CTRL_BASE_ADDR	(MXC91231_SPBA0_BASE_ADDR + 0x3C000)
+#define MXC91231_IOMUX_COM_BASE_ADDR	(MXC91231_SPBA0_BASE_ADDR + 0x40000)
+#define MXC91231_CRM_COM_BASE_ADDR	(MXC91231_SPBA0_BASE_ADDR + 0x44000)
+#define MXC91231_CRM_AP_BASE_ADDR	(MXC91231_SPBA0_BASE_ADDR + 0x48000)
+#define MXC91231_PLL0_BASE_ADDR		(MXC91231_SPBA0_BASE_ADDR + 0x4C000)
+#define MXC91231_PLL1_BASE_ADDR		(MXC91231_SPBA0_BASE_ADDR + 0x50000)
+#define MXC91231_PLL2_BASE_ADDR		(MXC91231_SPBA0_BASE_ADDR + 0x54000)
+#define MXC91231_GPIO4_SH_BASE_ADDR	(MXC91231_SPBA0_BASE_ADDR + 0x58000)
+#define MXC91231_HAC_BASE_ADDR		(MXC91231_SPBA0_BASE_ADDR + 0x5C000)
+#define MXC91231_SAHARA_BASE_ADDR	(MXC91231_SPBA0_BASE_ADDR + 0x5C000)
+#define MXC91231_PLL3_BASE_ADDR		(MXC91231_SPBA0_BASE_ADDR + 0x60000)
+
+/*
+ * SPBA global module 1
+ */
+#define MXC91231_SPBA1_BASE_ADDR	0x52000000
+#define MXC91231_SPBA1_SIZE		SZ_1M
+
+#define MXC91231_MQSPI_BASE_ADDR	(MXC91231_SPBA1_BASE_ADDR + 0x34000)
+#define MXC91231_EL1T_BASE_ADDR		(MXC91231_SPBA1_BASE_ADDR + 0x38000)
+
+/*!
+ * Defines for SPBA modules
+ */
+#define MXC91231_SPBA_SDHC1		0x04
+#define MXC91231_SPBA_SDHC2		0x08
+#define MXC91231_SPBA_UART3		0x0C
+#define MXC91231_SPBA_CSPI2		0x10
+#define MXC91231_SPBA_SSI2		0x14
+#define MXC91231_SPBA_SIM		0x18
+#define MXC91231_SPBA_IIM		0x1C
+#define MXC91231_SPBA_CTI_SDMA		0x20
+#define MXC91231_SPBA_USBOTG_CTRL_REGS	0x24
+#define MXC91231_SPBA_USBOTG_DATA_REGS	0x28
+#define MXC91231_SPBA_CSPI1		0x30
+#define MXC91231_SPBA_MQSPI		0x34
+#define MXC91231_SPBA_EL1T		0x38
+#define MXC91231_SPBA_IOMUX		0x40
+#define MXC91231_SPBA_CRM_COM		0x44
+#define MXC91231_SPBA_CRM_AP		0x48
+#define MXC91231_SPBA_PLL0		0x4C
+#define MXC91231_SPBA_PLL1		0x50
+#define MXC91231_SPBA_PLL2		0x54
+#define MXC91231_SPBA_GPIO4		0x58
+#define MXC91231_SPBA_SAHARA		0x5C
+
+/*
+ * ROMP and AVIC
+ */
+#define MXC91231_ROMP_BASE_ADDR		0x60000000
+#define MXC91231_ROMP_SIZE		SZ_64K
+
+#define MXC91231_AVIC_BASE_ADDR		0x68000000
+#define MXC91231_AVIC_SIZE		SZ_64K
+
+/*
+ * NAND, SDRAM, WEIM, M3IF, EMI controllers
+ */
+#define MXC91231_X_MEMC_BASE_ADDR	0xB8000000
+#define MXC91231_X_MEMC_SIZE		SZ_64K
+
+#define MXC91231_NFC_BASE_ADDR		(MXC91231_X_MEMC_BASE_ADDR + 0x0000)
+#define MXC91231_ESDCTL_BASE_ADDR	(MXC91231_X_MEMC_BASE_ADDR + 0x1000)
+#define MXC91231_WEIM_BASE_ADDR		(MXC91231_X_MEMC_BASE_ADDR + 0x2000)
+#define MXC91231_M3IF_BASE_ADDR		(MXC91231_X_MEMC_BASE_ADDR + 0x3000)
+#define MXC91231_EMI_CTL_BASE_ADDR	(MXC91231_X_MEMC_BASE_ADDR + 0x4000)
+
+/*
+ * Memory regions and CS
+ * CPLD is connected on CS4
+ * CS5 is TP1021 or it is not connected
+ * */
+#define MXC91231_FB_RAM_BASE_ADDR	0x78000000
+#define MXC91231_FB_RAM_SIZE		SZ_256K
+#define MXC91231_CSD0_BASE_ADDR		0x80000000
+#define MXC91231_CSD1_BASE_ADDR		0x90000000
+#define MXC91231_CS0_BASE_ADDR		0xA0000000
+#define MXC91231_CS1_BASE_ADDR		0xA8000000
+#define MXC91231_CS2_BASE_ADDR		0xB0000000
+#define MXC91231_CS3_BASE_ADDR		0xB2000000
+#define MXC91231_CS4_BASE_ADDR		0xB4000000
+#define MXC91231_CS5_BASE_ADDR		0xB6000000
+
+/*
+ * This macro defines the physical to virtual address mapping for all the
+ * peripheral modules. It is used by passing in the physical address as x
+ * and returning the virtual address.
+ */
+#define MXC91231_IO_P2V(x)		IMX_IO_P2V(x)
+#define MXC91231_IO_ADDRESS(x)		IOMEM(MXC91231_IO_P2V(x))
+
+/*
+ * Interrupt numbers
+ */
+#define MXC91231_INT_GPIO3		0
+#define MXC91231_INT_EL1T_CI		1
+#define MXC91231_INT_EL1T_RFCI		2
+#define MXC91231_INT_EL1T_RFI		3
+#define MXC91231_INT_EL1T_MCU		4
+#define MXC91231_INT_EL1T_IPI		5
+#define MXC91231_INT_MU_GEN		6
+#define MXC91231_INT_GPIO4		7
+#define MXC91231_INT_MMC_SDHC2		8
+#define MXC91231_INT_MMC_SDHC1		9
+#define MXC91231_INT_I2C		10
+#define MXC91231_INT_SSI2		11
+#define MXC91231_INT_SSI1		12
+#define MXC91231_INT_CSPI2		13
+#define MXC91231_INT_CSPI1		14
+#define MXC91231_INT_RTIC		15
+#define MXC91231_INT_SAHARA		15
+#define MXC91231_INT_HAC		15
+#define MXC91231_INT_UART3_RX		16
+#define MXC91231_INT_UART3_TX		17
+#define MXC91231_INT_UART3_MINT		18
+#define MXC91231_INT_ECT		19
+#define MXC91231_INT_SIM_IPB		20
+#define MXC91231_INT_SIM_DATA		21
+#define MXC91231_INT_RNGA		22
+#define MXC91231_INT_DSM_AP		23
+#define MXC91231_INT_KPP		24
+#define MXC91231_INT_RTC		25
+#define MXC91231_INT_PWM		26
+#define MXC91231_INT_GEMK_AP		27
+#define MXC91231_INT_EPIT		28
+#define MXC91231_INT_GPT		29
+#define MXC91231_INT_UART2_RX		30
+#define MXC91231_INT_UART2_TX		31
+#define MXC91231_INT_UART2_MINT		32
+#define MXC91231_INT_NANDFC		33
+#define MXC91231_INT_SDMA		34
+#define MXC91231_INT_USB_WAKEUP		35
+#define MXC91231_INT_USB_SOF		36
+#define MXC91231_INT_PMU_EVTMON		37
+#define MXC91231_INT_USB_FUNC		38
+#define MXC91231_INT_USB_DMA		39
+#define MXC91231_INT_USB_CTRL		40
+#define MXC91231_INT_IPU_ERR		41
+#define MXC91231_INT_IPU_SYN		42
+#define MXC91231_INT_UART1_RX		43
+#define MXC91231_INT_UART1_TX		44
+#define MXC91231_INT_UART1_MINT		45
+#define MXC91231_INT_IIM		46
+#define MXC91231_INT_MU_RX_OR		47
+#define MXC91231_INT_MU_TX_OR		48
+#define MXC91231_INT_SCC_SCM		49
+#define MXC91231_INT_SCC_SMN		50
+#define MXC91231_INT_GPIO2		51
+#define MXC91231_INT_GPIO1		52
+#define MXC91231_INT_MQSPI1		53
+#define MXC91231_INT_MQSPI2		54
+#define MXC91231_INT_WDOG2		55
+#define MXC91231_INT_EXT_INT7		56
+#define MXC91231_INT_EXT_INT6		57
+#define MXC91231_INT_EXT_INT5		58
+#define MXC91231_INT_EXT_INT4		59
+#define MXC91231_INT_EXT_INT3		60
+#define MXC91231_INT_EXT_INT2		61
+#define MXC91231_INT_EXT_INT1		62
+#define MXC91231_INT_EXT_INT0		63
+
+#define MXC91231_MAX_INT_LINES		63
+#define MXC91231_MAX_EXT_LINES		8
+
+#endif /* __MACH_MXC91231_H__ */
diff --git a/arch/arm/plat-mxc/include/mach/mxc_dvfs.h b/arch/arm/plat-mxc/include/mach/mxc_dvfs.h
new file mode 100755
index 0000000..35aefaa
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/mxc_dvfs.h
@@ -0,0 +1,276 @@
+/*
+ * Copyright (C) 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @defgroup DVFS Dynamic Voltage and Frequency Scaling (DVFS) Driver
+ */
+
+/*!
+ * @file arch-mxc/mxc_dvfs.h
+ *
+ * @brief This file contains the DVFS configuration structure definition.
+ *
+ *
+ * @ingroup DVFS
+ */
+
+#ifndef __ASM_ARCH_MXC_DVFS_H__
+#define __ASM_ARCH_MXC_DVFS_H__
+
+#ifdef __KERNEL__
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/workqueue.h>
+#include <linux/device.h>
+
+extern void __iomem *gpc_base;
+extern void __iomem *ccm_base;
+
+#define MXC_GPCCNTR_GPCIRQ2M		(1 << 25)
+#define MXC_GPCCNTR_GPCIRQ2		(1 << 24)
+#define MXC_GPCCNTR_GPCIRQM		(1 << 21)
+#define MXC_GPCCNTR_GPCIRQ_ARM	(1 << 20)
+#define MXC_GPCCNTR_GPCIRQ_SDMA	(0 << 20)
+#define MXC_GPCCNTR_DVFS0CR		(1 << 16)
+#define MXC_GPCCNTR_DVFS1CR		(1 << 17)
+#define MXC_GPCCNTR_ADU_MASK		0x8000
+#define MXC_GPCCNTR_ADU			(1 << 15)
+#define MXC_GPCCNTR_STRT			(1 << 14)
+#define MXC_GPCCNTR_FUPD_MASK	0x2000
+#define MXC_GPCCNTR_FUPD			(1 << 13)
+#define MXC_GPCCNTR_HTRI_MASK		0x0000000F
+#define MXC_GPCCNTR_HTRI_OFFSET	0
+
+#define MXC_GPCVCR_VINC_MASK		0x00020000
+#define MXC_GPCVCR_VINC_OFFSET	17
+#define MXC_GPCVCR_VCNTU_MASK	0x00010000
+#define MXC_GPCVCR_VCNTU_OFFSET	16
+#define MXC_GPCVCR_VCNT_MASK		0x00007FFF
+#define MXC_GPCVCR_VCNT_OFFSET	0
+
+/* DVFS-PER */
+#define MXC_DVFSPER_PMCR0_UDCS			(1 << 27)
+#define MXC_DVFSPER_PMCR0_UDCS_MASK		0x8000000
+#define MXC_DVFSPER_PMCR0_ENABLE_MASK	0x10
+#define MXC_DVFSPER_PMCR0_ENABLE			(1 << 4)
+
+#define MXC_DVFSLTR0_UPTHR_MASK		0x0FC00000
+#define MXC_DVFSLTR0_UPTHR_OFFSET	22
+#define MXC_DVFSLTR0_DNTHR_MASK		0x003F0000
+#define MXC_DVFSLTR0_DNTHR_OFFSET	16
+
+#define MXC_DVFSLTR1_PNCTHR_MASK	0x0000003F
+#define MXC_DVFSLTR1_PNCTHR_OFFSET	0
+#define MXC_DVFSLTR1_DNCNT_MASK		0x003FC000
+#define MXC_DVFSLTR1_DNCNT_OFFSET	14
+#define MXC_DVFSLTR1_UPCNT_MASK		0x00003FC0
+#define MXC_DVFSLTR1_UPCNT_OFFSET	6
+#define MXC_DVFSLTR1_LTBRSR		0x800000
+#define MXC_DVFSLTR1_LTBRSH		0x400000
+
+#define MXC_DVFSLTR2_EMAC_MASK		0x000001FF
+#define MXC_DVFSLTR2_EMAC_OFFSET	0
+
+#define MXC_DVFSPMCR0_UDCS		0x8000000
+#define MXC_DVFSPMCR0_DVFEV		0x800000
+#define MXC_DVFSPMCR0_DVFIS		0x400000
+#define MXC_DVFSPMCR0_LBMI		0x200000
+#define MXC_DVFSPMCR0_LBFL		0x100000
+#define MXC_DVFSPMCR0_LBFC_MASK		0xC0000
+#define MXC_DVFSPMCR0_LBFC_OFFSET	18
+#define MXC_DVFSPMCR0_FSVAIM		0x00008000
+#define MXC_DVFSPMCR0_FSVAI_MASK	0x00006000
+#define MXC_DVFSPMCR0_FSVAI_OFFSET	13
+#define MXC_DVFSPMCR0_WFIM		0x00000400
+#define MXC_DVFSPMCR0_WFIM_OFFSET	10
+#define MXC_DVFSPMCR0_DVFEN		0x00000010
+
+#define MXC_DVFSPMCR1_P1INM		0x00100000
+#define MXC_DVFSPMCR1_P1ISM		0x00080000
+#define MXC_DVFSPMCR1_P1IFM		0x00040000
+#define MXC_DVFSPMCR1_P4PM		0x00020000
+#define MXC_DVFSPMCR1_P2PM		0x00010000
+
+/* DVFS CORE register offsets*/
+#define MXC_DVFSCORE_THRS		0x00
+#define MXC_DVFSCORE_COUN		0x04
+#define MXC_DVFSCORE_SIG1		0x08
+#define MXC_DVFSCORE_SIG0		0x0C
+#define MXC_DVFSCORE_GPC0		0x10
+#define MXC_DVFSCORE_GPC1		0x14
+#define MXC_DVFSCORE_GPBT		0x18
+#define MXC_DVFSCORE_EMAC		0x1C
+#define MXC_DVFSCORE_CNTR		0x20
+#define MXC_DVFSCORE_LTR0_0		0x24
+#define MXC_DVFSCORE_LTR0_1		0x28
+#define MXC_DVFSCORE_LTR1_0		0x2C
+#define MXC_DVFSCORE_LTR1_1		0x30
+#define MXC_DVFSCORE_PT0 		0x34
+#define MXC_DVFSCORE_PT1 		0x38
+#define MXC_DVFSCORE_PT2 		0x3C
+#define MXC_DVFSCORE_PT3 		0x40
+
+/*
+ * DVFS structure
+ */
+struct dvfs_wp {
+	int upthr;
+	int downthr;
+	int panicthr;
+	int upcnt;
+	int downcnt;
+	int emac;
+};
+
+struct mxc_dvfs_platform_data {
+	/** Supply voltage regulator name string */
+	char *reg_id;
+	/* CPU clock name string */
+	char *clk1_id;
+	/* DVFS clock name string */
+	char *clk2_id;
+	/* The base address of the DVFS core */
+	void __iomem *membase;
+	/* The interrupt number used by the DVFS core */
+	int irq;
+	/* GPC control reg offset */
+	int gpc_cntr_offset;
+	/* GPC voltage counter reg offset */
+	int gpc_vcr_offset;
+	/* CCM DVFS control reg offset */
+	int ccm_cdcr_offset;
+	/* CCM ARM clock root reg offset */
+	int ccm_cacrr_offset;
+	/* CCM divider handshake in-progress reg offset */
+	int ccm_cdhipr_offset;
+	/* PREDIV mask */
+	u32 prediv_mask;
+	/* PREDIV offset */
+	int prediv_offset;
+	/* PREDIV value */
+	int prediv_val;
+	/* DIV3CK mask */
+	u32 div3ck_mask;
+	/* DIV3CK offset */
+	int div3ck_offset;
+	/* DIV3CK value */
+	int div3ck_val;
+	/* EMAC value */
+	int emac_val;
+	/* Frequency increase threshold. Increase frequency change request
+	   will be sent if DVFS counter value will be more than this value */
+	int upthr_val;
+	/* Frequency decrease threshold. Decrease frequency change request
+	   will be sent if DVFS counter value will be less than this value */
+	int dnthr_val;
+	/* Panic threshold. Panic frequency change request
+	   will be sent if DVFS counter value will be more than this value */
+	int pncthr_val;
+	/* The amount of times the up threshold should be exceeded
+	   before DVFS will trigger frequency increase request */
+	int upcnt_val;
+	/* The amount of times the down threshold should be exceeded
+	   before DVFS will trigger frequency decrease request */
+	int dncnt_val;
+	/* Delay time in us */
+	int delay_time;
+	/* Number of woking points supported */
+	int num_wp;
+};
+
+/*!
+ * This structure is used to define the dvfs controller's platform
+ * data. It includes the regulator name string and DVFS clock name string.
+ */
+struct mxc_dvfsper_data {
+	/** Regulator name string */
+	char *reg_id;
+	/* DVFS clock name string */
+	char *clk_id;
+	/* The base address of the DVFS per */
+	void __iomem *membase;
+	/* GPC control reg address */
+	void __iomem *gpc_cntr_reg_addr;
+	/* GPC VCR reg address */
+	void __iomem *gpc_vcr_reg_addr;
+	/* DVFS enable bit */
+	u32 dvfs_enable_bit;
+	/* DVFS ADU bit */
+	int gpc_adu;
+	/* VAI mask */
+	u32 vai_mask;
+	/* VAI offset */
+	int vai_offset;
+	/* Mask DVFS interrupt */
+	u32 irq_mask;
+	/* Div3 clock offset. */
+	u32 div3_offset;
+	/*div3 clock mask. */
+	u32 div3_mask;
+	/*div3 clock divider */
+	u32 div3_div;
+	/* LP voltage - high setpoint*/
+	u32 lp_high;
+	/* LP voltage - low setpoint*/
+	u32 lp_low;
+};
+
+/*!
+ * This structure is used to define the platform data of bus freq
+ * driver. It includes the regulator name strings.
+ */
+
+struct mxc_bus_freq_platform_data {
+	/* VDDGP regulator name */
+	char *gp_reg_id;
+	/* VCC regulator name */
+	char *lp_reg_id;
+};
+
+#if defined(CONFIG_MXC_DVFS_PER)
+extern int start_dvfs_per(void);
+extern void stop_dvfs_per(void);
+extern int dvfs_per_active(void);
+extern int dvfs_per_divider_active(void);
+extern int dvfs_per_pixel_clk_limit(void);
+#else
+static inline int start_dvfs_per(void)
+{
+	return 0;
+}
+
+static inline void stop_dvfs_per(void)
+{
+}
+
+static inline int dvfs_per_active(void)
+{
+	return 0;
+}
+
+static inline int dvfs_per_divider_active(void)
+{
+	return 0;
+}
+
+static inline int dvfs_per_pixel_clk_limit(void)
+{
+	return 0;
+}
+
+#endif
+
+#endif				/* __KERNEL__ */
+
+#endif				/* __ASM_ARCH_MXC_DVFS_H__ */
diff --git a/arch/arm/plat-mxc/include/mach/mxc_edid.h b/arch/arm/plat-mxc/include/mach/mxc_edid.h
new file mode 100755
index 0000000..f354461
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/mxc_edid.h
@@ -0,0 +1,40 @@
+/*
+ * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @defgroup Framebuffer Framebuffer Driver for SDC and ADC.
+ */
+
+/*!
+ * @file mxc_edid.h
+ *
+ * @brief MXC EDID tools
+ *
+ * @ingroup Framebuffer
+ */
+
+#ifndef MXC_EDID_H
+#define MXC_EDID_H
+
+struct mxc_edid_cfg {
+	bool cea_underscan;
+	bool cea_basicaudio;
+	bool cea_ycbcr444;
+	bool cea_ycbcr422;
+	bool hdmi_cap;
+};
+
+int mxc_edid_read(struct i2c_adapter *adp, unsigned short addr,
+	unsigned char *edid, struct mxc_edid_cfg *cfg, struct fb_info *fbi);
+
+#endif
diff --git a/arch/arm/plat-mxc/include/mach/mxc_vpu.h b/arch/arm/plat-mxc/include/mach/mxc_vpu.h
new file mode 100755
index 0000000..f123113
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/mxc_vpu.h
@@ -0,0 +1,99 @@
+/*
+ * Copyright 2004-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU Lesser General
+ * Public License.  You may obtain a copy of the GNU Lesser General
+ * Public License Version 2.1 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/lgpl-license.html
+ * http://www.gnu.org/copyleft/lgpl.html
+ */
+
+/*!
+ * @defgroup VPU Video Processor Unit Driver
+ */
+
+/*!
+ * @file arch-mxc/mxc_vpu.h
+ *
+ * @brief VPU system initialization and file operation definition
+ *
+ * @ingroup VPU
+ */
+
+#ifndef __ASM_ARCH_MXC_VPU_H__
+#define __ASM_ARCH_MXC_VPU_H__
+
+#include <linux/fs.h>
+
+struct mxc_vpu_platform_data {
+	void (*reset) (void);
+	void (*pg) (int);
+};
+
+struct vpu_mem_desc {
+	u32 size;
+	dma_addr_t phy_addr;
+	u32 cpu_addr;		/* cpu address to free the dma mem */
+	u32 virt_uaddr;		/* virtual user space address */
+};
+
+#define VPU_IOC_MAGIC  'V'
+
+#define VPU_IOC_PHYMEM_ALLOC	_IO(VPU_IOC_MAGIC, 0)
+#define VPU_IOC_PHYMEM_FREE	_IO(VPU_IOC_MAGIC, 1)
+#define VPU_IOC_WAIT4INT	_IO(VPU_IOC_MAGIC, 2)
+#define VPU_IOC_PHYMEM_DUMP	_IO(VPU_IOC_MAGIC, 3)
+#define VPU_IOC_REG_DUMP	_IO(VPU_IOC_MAGIC, 4)
+#define VPU_IOC_VL2CC_FLUSH	_IO(VPU_IOC_MAGIC, 5)
+#define VPU_IOC_IRAM_SETTING	_IO(VPU_IOC_MAGIC, 6)
+#define VPU_IOC_CLKGATE_SETTING	_IO(VPU_IOC_MAGIC, 7)
+#define VPU_IOC_GET_WORK_ADDR   _IO(VPU_IOC_MAGIC, 8)
+#define VPU_IOC_GET_PIC_PARA_ADDR   _IO(VPU_IOC_MAGIC, 9)
+#define VPU_IOC_GET_USER_DATA_ADDR   _IO(VPU_IOC_MAGIC, 10)
+#define VPU_IOC_SYS_SW_RESET	_IO(VPU_IOC_MAGIC, 11)
+#define VPU_IOC_GET_SHARE_MEM   _IO(VPU_IOC_MAGIC, 12)
+
+#define BIT_CODE_RUN			0x000
+#define BIT_CODE_DOWN			0x004
+#define	BIT_INT_CLEAR			0x00C
+#define	BIT_INT_STATUS			0x010
+
+#define BIT_WORK_CTRL_BUF_BASE		0x100
+#define BIT_WORK_CTRL_BUF_REG(i)	(BIT_WORK_CTRL_BUF_BASE + i * 4)
+#define BIT_CODE_BUF_ADDR		BIT_WORK_CTRL_BUF_REG(0)
+#define BIT_WORK_BUF_ADDR		BIT_WORK_CTRL_BUF_REG(1)
+#define BIT_PARA_BUF_ADDR		BIT_WORK_CTRL_BUF_REG(2)
+#define BIT_BIT_STREAM_CTRL		BIT_WORK_CTRL_BUF_REG(3)
+#define BIT_FRAME_MEM_CTRL		BIT_WORK_CTRL_BUF_REG(4)
+#define BIT_BIT_STREAM_PARAM		BIT_WORK_CTRL_BUF_REG(5)
+
+#define BIT_RESET_CTRL			0x11C
+
+/* i could be 0, 1, 2, 3 */
+#define	BIT_RD_PTR_BASE			0x120
+#define BIT_RD_PTR_REG(i)		(BIT_RD_PTR_BASE + i * 8)
+#define BIT_WR_PTR_REG(i)		(BIT_RD_PTR_BASE + i * 8 + 4)
+
+/* i could be 0, 1, 2, 3 */
+#define BIT_FRM_DIS_FLG_BASE		(cpu_is_mx51() ? 0x150 : 0x140)
+#define	BIT_FRM_DIS_FLG_REG(i)		(BIT_FRM_DIS_FLG_BASE + i * 4)
+
+#define BIT_BUSY_FLAG			0x160
+#define BIT_RUN_COMMAND			0x164
+#define BIT_INT_ENABLE			0x170
+
+#define	BITVAL_PIC_RUN			8
+
+#define	VPU_SLEEP_REG_VALUE		10
+#define	VPU_WAKE_REG_VALUE		11
+
+int vl2cc_init(u32 vl2cc_hw_base);
+void vl2cc_enable(void);
+void vl2cc_flush(void);
+void vl2cc_disable(void);
+void vl2cc_cleanup(void);
+
+#endif
diff --git a/arch/arm/plat-mxc/include/mach/sdram_autogating.h b/arch/arm/plat-mxc/include/mach/sdram_autogating.h
new file mode 100755
index 0000000..e102add
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/sdram_autogating.h
@@ -0,0 +1,56 @@
+/*
+ * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @defgroup DVFS Dynamic Voltage and Frequency Scaling (DVFS) Driver
+ */
+
+/*!
+ * @file arch-mxc/sdram_autogating.h
+ *
+ * @brief This file contains the SDRAM autogating function prototypes
+ *
+ *
+ * @ingroup PM
+ */
+
+#ifndef __ASM_ARCH_SDRAM_AUTOGATING_H__
+#define __ASM_ARCH_SDRAM_AUTOGATING_H__
+
+#ifdef __KERNEL__
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/workqueue.h>
+#include <linux/device.h>
+
+
+#ifdef CONFIG_ARCH_MX5
+extern void start_sdram_autogating(void);
+extern void stop_sdram_autogating(void);
+extern int sdram_autogating_active(void);
+#else
+static inline void start_sdram_autogating(void)
+{}
+
+static inline void stop_sdram_autogating(void)
+{}
+
+static inline int sdram_autogating_active(void)
+{
+	return 0;
+}
+#endif
+
+#endif				/*__KERNEL__ */
+#endif				/* __ASM_ARCH_MXC_DVFS_H__ */
diff --git a/arch/arm/plat-mxc/include/mach/system.h b/arch/arm/plat-mxc/include/mach/system.h
old mode 100644
new mode 100755
index 51f02a9..b3c09ca
--- a/arch/arm/plat-mxc/include/mach/system.h
+++ b/arch/arm/plat-mxc/include/mach/system.h
@@ -1,7 +1,7 @@
 /*
  *  Copyright (C) 1999 ARM Limited
  *  Copyright (C) 2000 Deep Blue Solutions Ltd
- *  Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ *  Copyright 2004-2011 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -22,39 +22,7 @@
 
 extern void mx5_cpu_lp_set(enum mxc_cpu_pwr_mode mode);
 
-static inline void arch_idle(void)
-{
-	/* fix i.MX31 errata TLSbo65953 and i.MX35 errata ENGcm09472 */
-	if (cpu_is_mx31() || cpu_is_mx35()) {
-		unsigned long reg = 0;
-		__asm__ __volatile__(
-			/* disable I and D cache */
-			"mrc p15, 0, %0, c1, c0, 0\n"
-			"bic %0, %0, #0x00001000\n"
-			"bic %0, %0, #0x00000004\n"
-			"mcr p15, 0, %0, c1, c0, 0\n"
-			/* invalidate I cache */
-			"mov %0, #0\n"
-			"mcr p15, 0, %0, c7, c5, 0\n"
-			/* clear and invalidate D cache */
-			"mov %0, #0\n"
-			"mcr p15, 0, %0, c7, c14, 0\n"
-			/* WFI */
-			"mov %0, #0\n"
-			"mcr p15, 0, %0, c7, c0, 4\n"
-			"nop\n" "nop\n" "nop\n" "nop\n"
-			"nop\n" "nop\n" "nop\n"
-			/* enable I and D cache */
-			"mrc p15, 0, %0, c1, c0, 0\n"
-			"orr %0, %0, #0x00001000\n"
-			"orr %0, %0, #0x00000004\n"
-			"mcr p15, 0, %0, c1, c0, 0\n"
-			: "=r" (reg));
-	} else if (cpu_is_mx51())
-		mx5_cpu_lp_set(WAIT_UNCLOCKED_POWER_OFF);
-	else
-		cpu_do_idle();
-}
+void arch_idle(void);
 
 void arch_reset(char mode, const char *cmd);
 
diff --git a/arch/arm/plat-mxc/isp1504xc.c b/arch/arm/plat-mxc/isp1504xc.c
new file mode 100755
index 0000000..8fd7bf2
--- /dev/null
+++ b/arch/arm/plat-mxc/isp1504xc.c
@@ -0,0 +1,275 @@
+/*
+ * Copyright (C) 2005-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/fsl_devices.h>
+#include <linux/delay.h>
+#include <linux/usb/fsl_xcvr.h>
+
+#include <mach/hardware.h>
+#include <mach/arc_otg.h>
+#include <asm/mach-types.h>
+
+/* ISP 1504 register addresses */
+#define ISP1504_VID_LOW		0x00	/* Vendor ID low */
+#define ISP1504_VID_HIGH	0x01	/* Vendor ID high */
+#define ISP1504_PID_LOW		0x02	/* Product ID low */
+#define ISP1504_PID_HIGH	0x03	/* Product ID high */
+#define ISP1504_FUNC		0x04	/* Function Control */
+#define ISP1504_ITFCTL		0x07	/* Interface Control */
+#define ISP1504_OTGCTL		0x0A	/* OTG Control */
+
+/* add to above register address to access Set/Clear functions */
+#define ISP1504_REG_SET		0x01
+#define ISP1504_REG_CLEAR	0x02
+
+/* 1504 OTG Control Register bits */
+#define USE_EXT_VBUS_IND	(1 << 7)	/* Use ext. Vbus indicator */
+#define DRV_VBUS_EXT		(1 << 6)	/* Drive Vbus external */
+#define DRV_VBUS		(1 << 5)	/* Drive Vbus */
+#define CHRG_VBUS		(1 << 4)	/* Charge Vbus */
+#define DISCHRG_VBUS		(1 << 3)	/* Discharge Vbus */
+#define DM_PULL_DOWN		(1 << 2)	/* enable DM Pull Down */
+#define DP_PULL_DOWN		(1 << 1)	/* enable DP Pull Down */
+#define ID_PULL_UP		(1 << 0)	/* enable ID Pull Up */
+
+/* 1504 OTG Function Control Register bits */
+#define SUSPENDM		(1 << 6)	/* places the PHY into
+						   low-power mode      */
+#define DRV_RESET		(1 << 5)	/* Active HIGH transceiver
+						   reset                  */
+
+/*!
+ * read ULPI register 'reg' thru VIEWPORT register 'view'
+ *
+ * @param       reg   register to read
+ * @param       view  the ULPI VIEWPORT register address
+ * @return	return isp1504 register value
+ */
+static u8 isp1504_read(int reg, volatile u32 *view)
+{
+	u32 data;
+
+	/* make sure interface is running */
+	if (!(__raw_readl(view) && ULPIVW_SS)) {
+		__raw_writel(ULPIVW_WU, view);
+		do {		/* wait for wakeup */
+			data = __raw_readl(view);
+		} while (data & ULPIVW_WU);
+	}
+
+	/* read the register */
+	__raw_writel((ULPIVW_RUN | (reg << ULPIVW_ADDR_SHIFT)), view);
+
+	do {			/* wait for completion */
+		data = __raw_readl(view);
+	} while (data & ULPIVW_RUN);
+
+	return (u8) (data >> ULPIVW_RDATA_SHIFT) & ULPIVW_RDATA_MASK;
+}
+
+/*!
+ * set bits into OTG ISP1504 register 'reg' thru VIEWPORT register 'view'
+ *
+ * @param       bits  set value
+ * @param	reg   which register
+ * @param       view  the ULPI VIEWPORT register address
+ */
+static void isp1504_set(u8 bits, int reg, volatile u32 *view)
+{
+	u32 data;
+
+	/* make sure interface is running */
+	if (!(__raw_readl(view) && ULPIVW_SS)) {
+		__raw_writel(ULPIVW_WU, view);
+		do {		/* wait for wakeup */
+			data = __raw_readl(view);
+		} while (data & ULPIVW_WU);
+	}
+
+	__raw_writel((ULPIVW_RUN | ULPIVW_WRITE |
+		      ((reg + ISP1504_REG_SET) << ULPIVW_ADDR_SHIFT) |
+		      ((bits & ULPIVW_WDATA_MASK) << ULPIVW_WDATA_SHIFT)),
+		     view);
+
+	while (__raw_readl(view) & ULPIVW_RUN)	/* wait for completion */
+		continue;
+}
+
+/*!
+ * clear bits in OTG ISP1504 register 'reg' thru VIEWPORT register 'view'
+ *
+ * @param       bits  bits to clear
+ * @param	reg   in this register
+ * @param       view  the ULPI VIEWPORT register address
+ */
+static void isp1504_clear(u8 bits, int reg, volatile u32 *view)
+{
+	__raw_writel((ULPIVW_RUN | ULPIVW_WRITE |
+		      ((reg + ISP1504_REG_CLEAR) << ULPIVW_ADDR_SHIFT) |
+		      ((bits & ULPIVW_WDATA_MASK) << ULPIVW_WDATA_SHIFT)),
+		     view);
+
+	while (__raw_readl(view) & ULPIVW_RUN)	/* wait for completion */
+		continue;
+}
+
+
+static void isp1508_fix(u32 *view)
+{
+	/* Set bits IND_PASS_THRU and IND_COMPL */
+	isp1504_set(0x60, ISP1504_ITFCTL, view);
+
+	/* Set bit USE_EXT_VBUS_IND */
+	isp1504_set(USE_EXT_VBUS_IND, ISP1504_OTGCTL, view);
+}
+
+/*!
+ * set vbus power
+ *
+ * @param       view  viewport register
+ * @param       on    power on or off
+ */
+static void isp1504_set_vbus_power(struct fsl_xcvr_ops *this,
+				   struct fsl_usb2_platform_data *pdata, int on)
+{
+	u32 *view = pdata->regs + ULPIVW_OFF;
+
+	pr_debug("real %s(on=%d) view=0x%p\n", __FUNCTION__, on, view);
+
+	pr_debug("ULPI Vendor ID 0x%x    Product ID 0x%x\n",
+		 (isp1504_read(ISP1504_VID_HIGH, view) << 8) |
+		 isp1504_read(ISP1504_VID_LOW, view),
+		 (isp1504_read(ISP1504_PID_HIGH, view) << 8) |
+		 isp1504_read(ISP1504_PID_LOW, view));
+
+	pr_debug("OTG Control before=0x%x\n",
+		 isp1504_read(ISP1504_OTGCTL, view));
+
+	if (on) {
+		isp1504_set(DRV_VBUS_EXT |	/* enable external Vbus */
+			    DRV_VBUS |	/* enable internal Vbus */
+			    USE_EXT_VBUS_IND |	/* use external indicator */
+			    CHRG_VBUS,	/* charge Vbus */
+			    ISP1504_OTGCTL, view);
+
+	} else {
+		isp1508_fix(view);
+
+		isp1504_clear(DRV_VBUS_EXT |	/* disable external Vbus */
+			      DRV_VBUS,	/* disable internal Vbus */
+			      ISP1504_OTGCTL, view);
+
+		isp1504_set(USE_EXT_VBUS_IND |	/* use external indicator */
+			    DISCHRG_VBUS,	/* discharge Vbus */
+			    ISP1504_OTGCTL, view);
+	}
+
+	pr_debug("OTG Control after = 0x%x\n",
+		 isp1504_read(ISP1504_OTGCTL, view));
+}
+
+/*!
+ * set remote wakeup
+ *
+ * @param       view  viewport register
+ */
+static void isp1504_set_remote_wakeup(u32 *view)
+{
+	__raw_writel(~ULPIVW_WRITE & __raw_readl(view), view);
+	__raw_writel((1 << ULPIVW_PORT_SHIFT) | __raw_readl(view), view);
+	__raw_writel(ULPIVW_RUN | __raw_readl(view), view);
+
+	while (__raw_readl(view) & ULPIVW_RUN)	/* wait for completion */
+		continue;
+}
+
+static void isp1504_init(struct fsl_xcvr_ops *this)
+{
+	pr_debug("%s:\n", __FUNCTION__);
+}
+
+static void isp1504_uninit(struct fsl_xcvr_ops *this)
+{
+	pr_debug("%s:\n", __FUNCTION__);
+}
+
+static void isp1504_suspend(struct fsl_xcvr_ops *this)
+{
+	pr_debug("%s\n", __func__);
+
+	/* send suspend command */
+	isp1504_clear(SUSPENDM, ISP1504_FUNC, &UOG_ULPIVIEW);
+	pr_debug("%s.\n", __func__);
+}
+
+/*!
+ * Set the 1504 transceiver to the proper mode for testing purposes.
+ *
+ * @param       view  the ULPI VIEWPORT register address
+ * @param       test_mode Set the 1504 transceiver to disable bit stuffing and NRZI
+ */
+ static void isp1504_set_test_mode(u32 *view, enum usb_test_mode test_mode)
+{
+	if (test_mode == USB_TEST_J || test_mode == USB_TEST_K) {
+		printk(KERN_INFO "udc: disable bit stuffing and NRZI\n");
+		/* Disable bit-stuffing and NRZI encoding. */
+		isp1504_set(0x10, 0x04, view);
+	}
+}
+
+static struct fsl_xcvr_ops isp1504_ops = {
+	.name = "isp1504",
+	.xcvr_type = PORTSC_PTS_ULPI,
+	.init = isp1504_init,
+	.uninit = isp1504_uninit,
+	.suspend = isp1504_suspend,
+	.set_vbus_power = isp1504_set_vbus_power,
+	.set_remote_wakeup = isp1504_set_remote_wakeup,
+	.set_test_mode = isp1504_set_test_mode,
+};
+
+extern void fsl_usb_xcvr_register(struct fsl_xcvr_ops *xcvr_ops);
+extern int fsl_usb_xcvr_suspend(struct fsl_xcvr_ops *xcvr_ops);
+
+static int __init isp1504xc_init(void)
+{
+	pr_debug("%s\n", __FUNCTION__);
+
+	fsl_usb_xcvr_register(&isp1504_ops);
+
+	/* suspend isp1504 */
+	if (fsl_usb_xcvr_suspend(&isp1504_ops))
+		pr_debug("%s: failed to suspend isp1504\n", __func__);
+
+	return 0;
+}
+
+extern void fsl_usb_xcvr_unregister(struct fsl_xcvr_ops *xcvr_ops);
+
+static void __exit isp1504xc_exit(void)
+{
+	fsl_usb_xcvr_unregister(&isp1504_ops);
+}
+
+subsys_initcall(isp1504xc_init);
+module_exit(isp1504xc_exit);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("isp1504 xcvr driver");
+MODULE_LICENSE("GPL");
diff --git a/arch/arm/plat-mxc/pwm.c b/arch/arm/plat-mxc/pwm.c
old mode 100644
new mode 100755
index f4b68be..5db4823
--- a/arch/arm/plat-mxc/pwm.c
+++ b/arch/arm/plat-mxc/pwm.c
@@ -60,7 +60,8 @@ int pwm_config(struct pwm_device *pwm, int duty_ns, int period_ns)
 	if (pwm == NULL || period_ns == 0 || duty_ns > period_ns)
 		return -EINVAL;
 
-	if (cpu_is_mx27() || cpu_is_mx3() || cpu_is_mx25() || cpu_is_mx51()) {
+	if (cpu_is_mx27() || cpu_is_mx3() || cpu_is_mx25() || cpu_is_mx51() ||
+		cpu_is_mx53()) {
 		unsigned long long c;
 		unsigned long period_cycles, duty_cycles, prescale;
 		u32 cr;
diff --git a/arch/arm/plat-mxc/serialxc.c b/arch/arm/plat-mxc/serialxc.c
new file mode 100755
index 0000000..a3eeef9
--- /dev/null
+++ b/arch/arm/plat-mxc/serialxc.c
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2005-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/err.h>
+#include <linux/platform_device.h>
+#include <linux/usb/fsl_xcvr.h>
+
+#include <mach/hardware.h>
+#include <mach/arc_otg.h>
+
+static void usb_serial_init(struct fsl_xcvr_ops *this)
+{
+}
+
+static void usb_serial_uninit(struct fsl_xcvr_ops *this)
+{
+}
+
+static struct fsl_xcvr_ops serial_ops = {
+	.name = "serial",
+	.xcvr_type = PORTSC_PTS_SERIAL,
+	.init = usb_serial_init,
+	.uninit = usb_serial_uninit,
+};
+
+extern void fsl_usb_xcvr_register(struct fsl_xcvr_ops *xcvr_ops);
+
+static int __init serialxc_init(void)
+{
+	pr_debug("%s\n", __FUNCTION__);
+
+	fsl_usb_xcvr_register(&serial_ops);
+
+	return 0;
+}
+
+extern void fsl_usb_xcvr_unregister(struct fsl_xcvr_ops *xcvr_ops);
+
+static void __exit serialxc_exit(void)
+{
+	fsl_usb_xcvr_unregister(&serial_ops);
+}
+
+subsys_initcall(serialxc_init);
+module_exit(serialxc_exit);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("serial xcvr driver");
+MODULE_LICENSE("GPL");
diff --git a/arch/arm/plat-mxc/usb_common.c b/arch/arm/plat-mxc/usb_common.c
new file mode 100755
index 0000000..300d275
--- /dev/null
+++ b/arch/arm/plat-mxc/usb_common.c
@@ -0,0 +1,908 @@
+/*
+ * Copyright (C) 2004-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ *@defgroup USB ARC OTG USB Driver
+ */
+
+/*!
+ * @file usb_common.c
+ *
+ * @brief platform related part of usb driver.
+ * @ingroup USB
+ */
+
+/*!
+ *Include files
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/fsl_devices.h>
+#include <linux/usb/otg.h>
+#include <linux/usb/fsl_xcvr.h>
+#include <linux/regulator/consumer.h>
+#include <mach/arc_otg.h>
+#include <mach/hardware.h>
+#include <asm/mach-types.h>
+
+void __iomem *imx_otg_base;
+
+#define MXC_NUMBER_USB_TRANSCEIVER 6
+struct fsl_xcvr_ops *g_xc_ops[MXC_NUMBER_USB_TRANSCEIVER] = { NULL };
+
+enum fsl_usb2_modes get_usb_mode(struct fsl_usb2_platform_data *pdata)
+{
+	enum fsl_usb2_modes mode;
+	mode = FSL_USB_UNKNOWN;
+
+	if (!strcmp("DR", pdata->name)) {
+		if ((UOG_USBMODE & 0x3) == 0x2)
+			mode = FSL_USB_DR_DEVICE;
+		else if ((UOG_USBMODE & 0x3) == 0x3)
+			mode = FSL_USB_DR_HOST;
+	} else if (!strcmp("Host 1", pdata->name))
+		mode = FSL_USB_MPH_HOST1;
+	else if (!strcmp("Host 2", pdata->name))
+		mode = FSL_USB_MPH_HOST2;
+
+	if (mode == FSL_USB_UNKNOWN)
+		printk(KERN_ERR "unknow usb mode,name is %s\n", pdata->name);
+	return mode;
+}
+
+static struct clk *usb_clk;
+static struct clk *usb_ahb_clk;
+
+
+/*
+ * make sure USB_CLK is running at 60 MHz +/- 1000 Hz
+ */
+static int fsl_check_usbclk(void)
+{
+	unsigned long freq;
+
+	usb_ahb_clk = clk_get(NULL, "usb_ahb_clk");
+	if (clk_enable(usb_ahb_clk)) {
+		printk(KERN_ERR "clk_enable(usb_ahb_clk) failed\n");
+		return -EINVAL;
+	}
+	clk_put(usb_ahb_clk);
+
+	usb_clk = clk_get(NULL, "usb_clk");
+	freq = clk_get_rate(usb_clk);
+	clk_put(usb_clk);
+	if ((freq < 59999000) || (freq > 60001000)) {
+		printk(KERN_ERR "USB_CLK=%lu, should be 60MHz\n", freq);
+		return -1;
+	}
+
+	return 0;
+}
+
+void fsl_usb_xcvr_register(struct fsl_xcvr_ops *xcvr_ops)
+{
+	int i;
+
+	pr_debug("%s\n", __func__);
+	for (i = 0; i < MXC_NUMBER_USB_TRANSCEIVER; i++) {
+		if (g_xc_ops[i] == NULL) {
+			g_xc_ops[i] = xcvr_ops;
+			return;
+		}
+	}
+
+	pr_debug("Failed %s\n", __func__);
+}
+EXPORT_SYMBOL(fsl_usb_xcvr_register);
+
+void fsl_platform_set_test_mode (struct fsl_usb2_platform_data *pdata, enum usb_test_mode mode)
+{
+	if (pdata->xcvr_ops && pdata->xcvr_ops->set_test_mode)
+		pdata->xcvr_ops->set_test_mode((u32 *)(pdata->regs + ULPIVW_OFF), mode);
+}
+EXPORT_SYMBOL(fsl_platform_set_test_mode);
+
+void fsl_usb_xcvr_unregister(struct fsl_xcvr_ops *xcvr_ops)
+{
+	int i;
+
+	pr_debug("%s\n", __func__);
+	for (i = 0; i < MXC_NUMBER_USB_TRANSCEIVER; i++) {
+		if (g_xc_ops[i] == xcvr_ops) {
+			g_xc_ops[i] = NULL;
+			return;
+		}
+	}
+
+	pr_debug("Failed %s\n", __func__);
+}
+EXPORT_SYMBOL(fsl_usb_xcvr_unregister);
+
+static struct fsl_xcvr_ops *fsl_usb_get_xcvr(char *name)
+{
+	int i;
+
+	pr_debug("%s\n", __func__);
+	if (name == NULL) {
+		printk(KERN_ERR "get_xcvr(): No tranceiver name\n");
+		return NULL;
+	}
+
+	for (i = 0; i < MXC_NUMBER_USB_TRANSCEIVER; i++) {
+		if (strcmp(g_xc_ops[i]->name, name) == 0) {
+			return g_xc_ops[i];
+		}
+	}
+	pr_debug("Failed %s\n", __func__);
+	return NULL;
+}
+
+/* The dmamask must be set for EHCI to work */
+static u64 ehci_dmamask = ~(u32) 0;
+
+/*!
+ * Register an instance of a USB host platform device.
+ *
+ * @param	res:	resource pointer
+ * @param       n_res:	number of resources
+ * @param       config: config pointer
+ *
+ * @return      newly-registered platform_device
+ *
+ * The USB controller supports 3 host interfaces, and the
+ * kernel can be configured to support some number of them.
+ * Each supported host interface is registered as an instance
+ * of the "fsl-ehci" device.  Call this function multiple times
+ * to register each host interface.
+ */
+static int usb_mxc_instance_id;
+__init struct platform_device *host_pdev_register(struct resource *res, int n_res,
+					   struct fsl_usb2_platform_data *config)
+{
+	struct platform_device *pdev;
+	int rc;
+
+	pr_debug("register host res=0x%p, size=%d\n", res, n_res);
+
+	pdev = platform_device_register_simple("fsl-ehci",
+			 usb_mxc_instance_id, res, n_res);
+	if (IS_ERR(pdev)) {
+		pr_debug("can't register %s Host, %ld\n",
+			 config->name, PTR_ERR(pdev));
+		return NULL;
+	}
+
+	pdev->dev.coherent_dma_mask = 0xffffffff;
+	pdev->dev.dma_mask = &ehci_dmamask;
+
+	/*
+	 * platform_device_add_data() makes a copy of
+	 * the platform_data passed in.  That makes it
+	 * impossible to share the same config struct for
+	 * all OTG devices (host,gadget,otg).  So, just
+	 * set the platorm_data pointer ourselves.
+	 */
+	rc = platform_device_add_data(pdev, config,
+				      sizeof(struct fsl_usb2_platform_data));
+	if (rc) {
+		platform_device_unregister(pdev);
+		return NULL;
+	}
+
+	printk(KERN_INFO "usb: %s host (%s) registered\n", config->name,
+	       config->transceiver);
+	pr_debug("pdev=0x%p  dev=0x%p  resources=0x%p  pdata=0x%p\n",
+		 pdev, &pdev->dev, pdev->resource, pdev->dev.platform_data);
+
+	usb_mxc_instance_id++;
+
+	return pdev;
+}
+
+static void usbh1_set_serial_xcvr(void)
+{
+	pr_debug("%s: \n", __func__);
+	USBCTRL &= ~(UCTRL_H1SIC_MASK | UCTRL_BPE); /* disable bypass mode */
+	USBCTRL |= UCTRL_H1SIC_SU6 |		/* single-ended / unidir. */
+		   UCTRL_H1WIE | UCTRL_H1DT |	/* disable H1 TLL */
+		   UCTRL_H1PM;			/* power mask */
+}
+
+static void usbh1_set_ulpi_xcvr(void)
+{
+	pr_debug("%s: \n", __func__);
+
+	/* Stop then Reset */
+	UH1_USBCMD &= ~UCMD_RUN_STOP;
+	while (UH1_USBCMD & UCMD_RUN_STOP)
+		;
+
+	UH1_USBCMD |= UCMD_RESET;
+	while (UH1_USBCMD & UCMD_RESET)
+		;
+
+	/* Select the clock from external PHY */
+	USB_CTRL_1 |= USB_CTRL_UH1_EXT_CLK_EN;
+
+	/* select ULPI PHY PTS=2 */
+	UH1_PORTSC1 = (UH1_PORTSC1 & ~PORTSC_PTS_MASK) | PORTSC_PTS_ULPI;
+
+	USBCTRL &= ~UCTRL_H1WIE; /* HOST1 wakeup intr disable */
+	USBCTRL &= ~UCTRL_H1UIE; /* Host1 ULPI interrupt disable */
+	USBCTRL |= UCTRL_H1PM; /* HOST1 power mask */
+	USB_PHY_CTR_FUNC |= USB_UH1_OC_DIS; /* OC is not used */
+
+	/* Interrupt Threshold Control:Immediate (no threshold) */
+	UH1_USBCMD &= UCMD_ITC_NO_THRESHOLD;
+
+	UH1_USBCMD |= UCMD_RESET;       /* reset the controller */
+
+	/* allow controller to reset, and leave time for
+	* the ULPI transceiver to reset too.
+	*/
+	msleep(100);
+
+	/* Turn off the usbpll for ulpi tranceivers */
+	clk_disable(usb_clk);
+}
+
+static void usbh1_set_utmi_xcvr(void)
+{
+	u32 tmp;
+
+	/* Stop then Reset */
+	UH1_USBCMD &= ~UCMD_RUN_STOP;
+	while (UH1_USBCMD & UCMD_RUN_STOP)
+		;
+
+	UH1_USBCMD |= UCMD_RESET;
+	while ((UH1_USBCMD) & (UCMD_RESET))
+		;
+
+	/* For OC and PWR, it is board level setting
+	 * The default setting is for mx53 evk
+	 */
+	USBCTRL &= ~UCTRL_H1PM;	/* Host1 Power Mask */
+	USBCTRL &= ~UCTRL_H1WIE; /* Host1 Wakeup Intr Disable */
+	USB_PHY_CTR_FUNC |= USB_UH1_OC_DIS; /* Over current disable */
+
+	if (cpu_is_mx50()) {
+		USBCTRL |= UCTRL_H1PM; /* Host1 Power Mask */
+		USB_PHY_CTR_FUNC &= ~USB_UH1_OC_DIS; /* Over current enable */
+		/* Over current polarity low active */
+		USB_PHY_CTR_FUNC |= USB_UH1_OC_POL;
+	}
+	/* set UTMI xcvr */
+	tmp = UH1_PORTSC1 & ~PORTSC_PTS_MASK;
+	tmp |= PORTSC_PTS_UTMI;
+	UH1_PORTSC1 = tmp;
+
+	/* Set the PHY clock to 24MHz */
+	USBH1_PHY_CTRL1 &= ~USB_UTMI_PHYCTRL2_PLLDIV_MASK;
+	USBH1_PHY_CTRL1 |= 0x01;
+
+	/* Workaround an IC issue for ehci driver:
+	 * when turn off root hub port power, EHCI set
+	 * PORTSC reserved bits to be 0, but PTW with 0
+	 * means 8 bits tranceiver width, here change
+	 * it back to be 16 bits and do PHY diable and
+	 * then enable.
+	 */
+	UH1_PORTSC1 |= PORTSC_PTW;
+
+	/* need to reset the controller here so that the ID pin
+	 * is correctly detected.
+	 */
+	/* Stop then Reset */
+	UH1_USBCMD &= ~UCMD_RUN_STOP;
+	while (UH1_USBCMD & UCMD_RUN_STOP)
+		;
+
+	UH1_USBCMD |= UCMD_RESET;
+	while ((UH1_USBCMD) & (UCMD_RESET))
+		;
+
+	/* allow controller to reset, and leave time for
+	 * the ULPI transceiver to reset too.
+	 */
+	msleep(100);
+
+	/* Turn off the usbpll for UTMI tranceivers */
+	clk_disable(usb_clk);
+}
+
+static void usbh2_set_ulpi_xcvr(void)
+{
+	u32 tmp;
+
+	pr_debug("%s\n", __func__);
+
+	UH2_USBCMD &= ~UCMD_RUN_STOP;
+	while (UH2_USBCMD & UCMD_RUN_STOP)
+		;
+
+	UH2_USBCMD |= UCMD_RESET;
+	while (UH2_USBCMD & UCMD_RESET)
+
+	USBCTRL_HOST2 &= ~(UCTRL_H2SIC_MASK | UCTRL_BPE);
+	USBCTRL_HOST2 &= ~UCTRL_H2WIE;	/* wakeup intr enable */
+	USBCTRL_HOST2 &= ~UCTRL_H2UIE;	/* ULPI intr enable */
+	USB_CTRL_1 |= USB_CTRL_UH2_EXT_CLK_EN;
+	if (cpu_is_mx53())
+		USB_CTRL_1 |= USB_CTRL_UH2_CLK_FROM_ULPI_PHY;
+	if (cpu_is_mx51())/* not tested */
+		USBCTRL_HOST2 |= (1 << 12);
+	/* must set ULPI phy before turning off clock */
+	tmp = UH2_PORTSC1 & ~PORTSC_PTS_MASK;
+	tmp |= PORTSC_PTS_ULPI;
+	UH2_PORTSC1 = tmp;
+	if (cpu_is_mx53()) {
+		/* turn off the internal 60MHZ clk  */
+		USB_CLKONOFF_CTRL |= (1 << 21);
+	}
+	UH2_USBCMD |= UCMD_RESET;	/* reset the controller */
+
+	/* allow controller to reset, and leave time for
+	 * the ULPI transceiver to reset too.
+	 */
+	msleep(100);
+
+	/* Turn off the usbpll for ulpi tranceivers */
+	clk_disable(usb_clk);
+}
+
+static void usbh2_set_serial_xcvr(void)
+{
+	pr_debug("%s: \n", __func__);
+
+	/* Stop then Reset */
+	UH2_USBCMD &= ~UCMD_RUN_STOP;
+	while (UH2_USBCMD & UCMD_RUN_STOP)
+		;
+
+	UH2_USBCMD |= UCMD_RESET;
+	while (UH2_USBCMD & UCMD_RESET)
+		;
+
+	USBCTRL &= ~(UCTRL_H2SIC_MASK);	/* Disable bypass mode */
+	USBCTRL &= ~(UCTRL_H2PM);	/* Power Mask */
+	USBCTRL &= ~UCTRL_H2OCPOL;	/* OverCurrent Polarity is Low Active */
+	USBCTRL &= ~UCTRL_H2WIE;	/* Wakeup intr disable */
+	USBCTRL |= UCTRL_IP_PUE_DOWN |	/* ipp_pue_pulldwn_dpdm */
+	    UCTRL_USBTE |	/* USBT is enabled */
+	    UCTRL_H2DT;		/* Disable H2 TLL */
+
+	if (cpu_is_mx35() && (imx_cpu_ver() < IMX_CHIP_REVISION_2_0)) {
+		/* Disable Host2 bus Lock for i.MX35 1.0 */
+		USBCTRL |= UCTRL_H2LOCKD;
+		/* USBOTG_PWR low active */
+		USBCTRL &= ~UCTRL_PP;
+		/* OverCurrent Polarity is Low Active */
+		USBCTRL &= ~UCTRL_OCPOL;
+	} else if (cpu_is_mx35() && (imx_cpu_ver() >= IMX_CHIP_REVISION_2_0)) {
+		/* i.MX35 2.0 OTG and Host2 have seperate OC/PWR polarity */
+		USBCTRL &= ~UCTRL_H2PP;
+		USBCTRL &= ~UCTRL_H2OCPOL;
+	} else if (cpu_is_mx25()) {
+		/*
+		 * USBH2_PWR and USBH2_OC are active high.
+		 * Must force xcvr clock to "internal" so that
+		 * we can write to PTS field after it's been
+		 * cleared by ehci_turn_off_all_ports().
+		 */
+		USBCTRL |= UCTRL_H2PP | UCTRL_H2OCPOL | UCTRL_XCSH2;
+		/* Disable Host2 bus Lock */
+		USBCTRL |= UCTRL_H2LOCKD;
+	}
+
+	USBCTRL &= ~(UCTRL_PP);
+	UH2_PORTSC1 = (UH2_PORTSC1 & (~PORTSC_PTS_MASK)) | PORTSC_PTS_SERIAL;
+
+	if (UH2_HCSPARAMS & HCSPARAMS_PPC)
+		UH2_PORTSC1 |= PORTSC_PORT_POWER;
+
+	/* Reset controller before set host mode */
+	UH2_USBCMD |= UCMD_RESET;
+	while (UH2_USBCMD & UCMD_RESET)
+		;
+
+	msleep(100);
+}
+
+/*!
+ * Register remote wakeup by this usb controller
+ *
+ * @param pdev: platform_device for this usb controller
+ *
+ * @return 0 or negative error code in case not supportted.
+ */
+static int usb_register_remote_wakeup(struct platform_device *pdev)
+{
+	struct fsl_usb2_platform_data *pdata = pdev->dev.platform_data;
+	struct resource *res;
+	int irq;
+
+	pr_debug("%s: pdev=0x%p \n", __func__, pdev);
+	if (!(pdata->wake_up_enable))
+		return -ECANCELED;
+
+	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (!res) {
+		dev_err(&pdev->dev,
+		"Found HC with no IRQ. Check %s setup!\n",
+		dev_name(&pdev->dev));
+		return -ENODEV;
+	}
+	irq = res->start;
+	pdev->dev.power.can_wakeup = 1;
+	enable_irq_wake(irq);
+
+	return 0;
+}
+
+int fsl_usb_host_init(struct platform_device *pdev)
+{
+	struct fsl_usb2_platform_data *pdata = pdev->dev.platform_data;
+	struct fsl_xcvr_ops *xops;
+
+	pr_debug("%s: pdev=0x%p  pdata=0x%p\n", __func__, pdev, pdata);
+
+	xops = fsl_usb_get_xcvr(pdata->transceiver);
+	if (!xops) {
+		printk(KERN_ERR "%s transceiver ops missing\n", pdata->name);
+		return -EINVAL;
+	}
+	pdata->xcvr_ops = xops;
+	pdata->xcvr_type = xops->xcvr_type;
+	pdata->pdev = pdev;
+
+	if (fsl_check_usbclk() != 0)
+		return -EINVAL;
+
+	pr_debug("%s: grab pins\n", __func__);
+	if (pdata->gpio_usb_active && pdata->gpio_usb_active())
+		return -EINVAL;
+
+	if (clk_enable(usb_clk)) {
+		printk(KERN_ERR "clk_enable(usb_clk) failed\n");
+		return -EINVAL;
+	}
+
+	if (cpu_is_mx50())
+		/* Turn on AHB CLK for H1*/
+		USB_CLKONOFF_CTRL &= ~H1_AHBCLK_OFF;
+
+	/* enable board power supply for xcvr */
+	if (pdata->xcvr_pwr) {
+		if (pdata->xcvr_pwr->regu1)
+			regulator_enable(pdata->xcvr_pwr->regu1);
+		if (pdata->xcvr_pwr->regu2)
+			regulator_enable(pdata->xcvr_pwr->regu2);
+	}
+
+	if (xops->init)
+		xops->init(xops);
+
+	if (usb_register_remote_wakeup(pdev))
+		pr_debug("%s port is not a wakeup source.\n", pdata->name);
+
+	if (xops->xcvr_type == PORTSC_PTS_SERIAL) {
+		if (cpu_is_mx35()) {
+			usbh2_set_serial_xcvr();
+			/* Close the internal 60Mhz */
+			USBCTRL &= ~UCTRL_XCSH2;
+		} else if (cpu_is_mx25())
+			usbh2_set_serial_xcvr();
+		else
+			usbh1_set_serial_xcvr();
+	} else if (xops->xcvr_type == PORTSC_PTS_ULPI) {
+		if (!strcmp("Host 1", pdata->name))
+			usbh1_set_ulpi_xcvr();
+		if (!strcmp("Host 2", pdata->name))
+			usbh2_set_ulpi_xcvr();
+	} else if (xops->xcvr_type == PORTSC_PTS_UTMI) {
+		usbh1_set_utmi_xcvr();
+	}
+
+	pr_debug("%s: %s success\n", __func__, pdata->name);
+	return 0;
+}
+EXPORT_SYMBOL(fsl_usb_host_init);
+
+void fsl_usb_host_uninit(struct fsl_usb2_platform_data *pdata)
+{
+	pr_debug("%s\n", __func__);
+
+	if (pdata->xcvr_ops && pdata->xcvr_ops->uninit)
+		pdata->xcvr_ops->uninit(pdata->xcvr_ops);
+
+	pdata->regs = NULL;
+
+	if (pdata->gpio_usb_inactive)
+		pdata->gpio_usb_inactive();
+	if (pdata->xcvr_type == PORTSC_PTS_SERIAL) {
+		/* Workaround an IC issue for ehci driver.
+		 * when turn off root hub port power, EHCI set
+		 * PORTSC reserved bits to be 0, but PTS with 0
+		 * means UTMI interface, so here force the Host2
+		 * port use the internal 60Mhz.
+		 */
+		if (cpu_is_mx35())
+			USBCTRL |= UCTRL_XCSH2;
+		clk_disable(usb_clk);
+	}
+
+	/* disable board power supply for xcvr */
+	if (pdata->xcvr_pwr) {
+		if (pdata->xcvr_pwr->regu1)
+			regulator_disable(pdata->xcvr_pwr->regu1);
+		if (pdata->xcvr_pwr->regu2)
+			regulator_disable(pdata->xcvr_pwr->regu2);
+	}
+
+	clk_disable(usb_ahb_clk);
+}
+EXPORT_SYMBOL(fsl_usb_host_uninit);
+
+static void otg_set_serial_xcvr(void)
+{
+	pr_debug("%s\n", __func__);
+}
+
+void otg_set_serial_host(void)
+{
+	pr_debug("%s\n", __func__);
+	/* set USBCTRL for host operation
+	 * disable: bypass mode,
+	 * set: single-ended/unidir/6 wire, OTG wakeup intr enable,
+	 *      power mask
+	 */
+	USBCTRL &= ~UCTRL_OSIC_MASK;
+#if defined(CONFIG_ARCH_MX27) || defined(CONFIG_ARCH_MX3)
+	USBCTRL &= ~UCTRL_BPE;
+#endif
+
+#if defined(CONFIG_MXC_USB_SB3)
+	USBCTRL |= UCTRL_OSIC_SB3 | UCTRL_OWIE | UCTRL_OPM;
+#elif defined(CONFIG_MXC_USB_SU6)
+	USBCTRL |= UCTRL_OSIC_SU6 | UCTRL_OWIE | UCTRL_OPM;
+#elif defined(CONFIG_MXC_USB_DB4)
+	USBCTRL |= UCTRL_OSIC_DB4 | UCTRL_OWIE | UCTRL_OPM;
+#else
+	USBCTRL |= UCTRL_OSIC_DU6 | UCTRL_OWIE | UCTRL_OPM;
+#endif
+
+	USB_OTG_MIRROR = OTGM_VBUSVAL | OTGM_ASESVLD;	/* 0xa */
+}
+EXPORT_SYMBOL(otg_set_serial_host);
+
+void otg_set_serial_peripheral(void)
+{
+	/* set USBCTRL for device operation
+	 * disable: bypass mode
+	 * set: differential/unidir/6 wire, OTG wakeup intr enable,
+	 *      power mask
+	 */
+	USBCTRL &= ~UCTRL_OSIC_MASK;
+#if defined(CONFIG_ARCH_MX27) || defined(CONFIG_ARCH_MX3)
+	USBCTRL &= ~UCTRL_BPE;
+#endif
+
+#if defined(CONFIG_MXC_USB_SB3)
+	USBCTRL |= UCTRL_OSIC_SB3 | UCTRL_OWIE | UCTRL_OPM;
+#elif defined(CONFIG_MXC_USB_SU6)
+	USBCTRL |= UCTRL_OSIC_SU6 | UCTRL_OWIE | UCTRL_OPM;
+#elif defined(CONFIG_MXC_USB_DB4)
+	USBCTRL |= UCTRL_OSIC_DB4 | UCTRL_OWIE | UCTRL_OPM;
+#else
+	USBCTRL |= UCTRL_OSIC_DU6 | UCTRL_OWIE | UCTRL_OPM;
+#endif
+
+	USB_OTG_MIRROR = OTGM_VBUSVAL | OTGM_BSESVLD | OTGM_IDIDG;	/* oxd */
+}
+EXPORT_SYMBOL(otg_set_serial_peripheral);
+
+static void otg_set_ulpi_xcvr(void)
+{
+	u32 tmp;
+
+	pr_debug("%s\n", __func__);
+	USBCTRL &= ~UCTRL_OSIC_MASK;
+#if defined(CONFIG_ARCH_MX27) || defined(CONFIG_ARCH_MX3)
+	USBCTRL &= ~UCTRL_BPE;
+#endif
+	USBCTRL |= UCTRL_OUIE |	/* ULPI intr enable */
+	    UCTRL_OWIE |	/* OTG wakeup intr enable */
+	    UCTRL_OPM;		/* power mask */
+
+	/* must set ULPI phy before turning off clock */
+	tmp = UOG_PORTSC1 & ~PORTSC_PTS_MASK;
+	tmp |= PORTSC_PTS_ULPI;
+	UOG_PORTSC1 = tmp;
+
+	/* need to reset the controller here so that the ID pin
+	 * is correctly detected.
+	 */
+	UOG_USBCMD |= UCMD_RESET;
+
+	/* allow controller to reset, and leave time for
+	 * the ULPI transceiver to reset too.
+	 */
+	msleep(100);
+
+	/* Turn off the usbpll for ulpi tranceivers */
+	clk_disable(usb_clk);
+}
+
+int fsl_usb_xcvr_suspend(struct fsl_xcvr_ops *xcvr_ops)
+{
+	if (!machine_is_mx31_3ds())
+		return -ECANCELED;
+
+	if (xcvr_ops->xcvr_type == PORTSC_PTS_ULPI) {
+		if (fsl_check_usbclk() != 0)
+			return -EINVAL;
+		clk_enable(usb_clk);
+
+		otg_set_ulpi_xcvr();
+
+		if (xcvr_ops->suspend)
+			/* suspend transceiver */
+			xcvr_ops->suspend(xcvr_ops);
+
+		clk_disable(usb_clk);
+	}
+	return 0;
+}
+EXPORT_SYMBOL(fsl_usb_xcvr_suspend);
+
+static void otg_set_utmi_xcvr(void)
+{
+	u32 tmp;
+
+	/* Stop then Reset */
+	UOG_USBCMD &= ~UCMD_RUN_STOP;
+	while (UOG_USBCMD & UCMD_RUN_STOP)
+		;
+
+	UOG_USBCMD |= UCMD_RESET;
+	while ((UOG_USBCMD) & (UCMD_RESET))
+		;
+
+	if (cpu_is_mx53())
+		USB_PHY_CTR_FUNC |= USB_UTMI_PHYCTRL_OC_DIS;
+
+	if (cpu_is_mx51()) {
+		if (machine_is_mx51_3ds()) {
+			/* OTG Polarity of Overcurrent is Low active */
+			USB_PHY_CTR_FUNC |= USB_UTMI_PHYCTRL_OC_POL;
+			/* Enable OTG Overcurrent Event */
+			USB_PHY_CTR_FUNC &= ~USB_UTMI_PHYCTRL_OC_DIS;
+		} else {
+			/* BBG is not using OC */
+			USB_PHY_CTR_FUNC |= USB_UTMI_PHYCTRL_OC_DIS;
+		}
+	} else if (cpu_is_mx25()) {
+		USBCTRL |= UCTRL_OCPOL;
+		USBCTRL &= ~UCTRL_PP;
+	} else if (cpu_is_mx50()) {
+		USB_PHY_CTR_FUNC |= USB_UTMI_PHYCTRL_OC_DIS;
+	} else {
+		/* USBOTG_PWR low active */
+		USBCTRL &= ~UCTRL_PP;
+		/* OverCurrent Polarity is Low Active */
+		USBCTRL &= ~UCTRL_OCPOL;
+
+		if (cpu_is_mx35() && (imx_cpu_ver() < IMX_CHIP_REVISION_2_0))
+			/* OTG Lock Disable */
+			USBCTRL |= UCTRL_OLOCKD;
+	}
+
+	if (cpu_is_mx51())
+		USBCTRL &= ~UCTRL_OPM;	/* OTG Power Mask */
+
+	USBCTRL &= ~UCTRL_OWIE;	/* OTG Wakeup Intr Disable */
+
+	/* set UTMI xcvr */
+	tmp = UOG_PORTSC1 & ~PORTSC_PTS_MASK;
+	tmp |= PORTSC_PTS_UTMI;
+	UOG_PORTSC1 = tmp;
+
+	if (cpu_is_mx51()) {
+		/* Set the PHY clock to 19.2MHz */
+		USB_PHY_CTR_FUNC2 &= ~USB_UTMI_PHYCTRL2_PLLDIV_MASK;
+		USB_PHY_CTR_FUNC2 |= 0x01;
+	}
+
+	/* Workaround an IC issue for ehci driver:
+	 * when turn off root hub port power, EHCI set
+	 * PORTSC reserved bits to be 0, but PTW with 0
+	 * means 8 bits tranceiver width, here change
+	 * it back to be 16 bits and do PHY diable and
+	 * then enable.
+	 */
+	UOG_PORTSC1 |= PORTSC_PTW;
+
+	if (cpu_is_mx35() || cpu_is_mx25()) {
+		/* Enable UTMI interface in PHY control Reg */
+		USB_PHY_CTR_FUNC &= ~USB_UTMI_PHYCTRL_UTMI_ENABLE;
+		USB_PHY_CTR_FUNC |= USB_UTMI_PHYCTRL_UTMI_ENABLE;
+	}
+
+	/* need to reset the controller here so that the ID pin
+	 * is correctly detected.
+	 */
+	/* Stop then Reset */
+	UOG_USBCMD &= ~UCMD_RUN_STOP;
+	while (UOG_USBCMD & UCMD_RUN_STOP)
+		;
+
+	UOG_USBCMD |= UCMD_RESET;
+	while ((UOG_USBCMD) & (UCMD_RESET))
+		;
+
+	/* allow controller to reset, and leave time for
+	 * the ULPI transceiver to reset too.
+	 */
+	msleep(100);
+
+	/* Turn off the usbpll for UTMI tranceivers */
+	clk_disable(usb_clk);
+}
+
+static int mxc_otg_used;
+
+int usbotg_init(struct platform_device *pdev)
+{
+	struct fsl_usb2_platform_data *pdata = pdev->dev.platform_data;
+	struct fsl_xcvr_ops *xops;
+
+	pr_debug("%s: pdev=0x%p  pdata=0x%p\n", __func__, pdev, pdata);
+
+	xops = fsl_usb_get_xcvr(pdata->transceiver);
+	if (!xops) {
+		printk(KERN_ERR "DR transceiver ops missing\n");
+		return -EINVAL;
+	}
+	pdata->xcvr_ops = xops;
+	pdata->xcvr_type = xops->xcvr_type;
+	pdata->pdev = pdev;
+
+	if (fsl_check_usbclk() != 0)
+		return -EINVAL;
+	if (!mxc_otg_used) {
+		if (cpu_is_mx50())
+			/* Turn on AHB CLK for OTG*/
+			USB_CLKONOFF_CTRL &= ~OTG_AHBCLK_OFF;
+
+		pr_debug("%s: grab pins\n", __func__);
+		if (pdata->gpio_usb_active && pdata->gpio_usb_active())
+			return -EINVAL;
+
+		if (clk_enable(usb_clk)) {
+			printk(KERN_ERR "clk_enable(usb_clk) failed\n");
+			return -EINVAL;
+		}
+
+		if (xops->init)
+			xops->init(xops);
+
+		UOG_PORTSC1 = UOG_PORTSC1 & ~PORTSC_PHCD;
+		if (xops->xcvr_type == PORTSC_PTS_SERIAL) {
+			if (pdata->operating_mode == FSL_USB2_DR_HOST) {
+				otg_set_serial_host();
+				/* need reset */
+				UOG_USBCMD |= UCMD_RESET;
+				msleep(100);
+			} else if (pdata->operating_mode == FSL_USB2_DR_DEVICE)
+				otg_set_serial_peripheral();
+			otg_set_serial_xcvr();
+		} else if (xops->xcvr_type == PORTSC_PTS_ULPI) {
+			otg_set_ulpi_xcvr();
+		} else if (xops->xcvr_type == PORTSC_PTS_UTMI) {
+			otg_set_utmi_xcvr();
+		}
+	}
+
+	if (usb_register_remote_wakeup(pdev))
+		pr_debug("DR is not a wakeup source.\n");
+
+	mxc_otg_used++;
+	pr_debug("%s: success\n", __func__);
+	return 0;
+}
+EXPORT_SYMBOL(usbotg_init);
+
+void usbotg_uninit(struct fsl_usb2_platform_data *pdata)
+{
+	pr_debug("%s\n", __func__);
+
+	mxc_otg_used--;
+	if (!mxc_otg_used) {
+		if (pdata->xcvr_ops && pdata->xcvr_ops->uninit)
+			pdata->xcvr_ops->uninit(pdata->xcvr_ops);
+
+		pdata->regs = NULL;
+
+		if (machine_is_mx31_3ds()) {
+			if (pdata->xcvr_ops && pdata->xcvr_ops->suspend)
+				pdata->xcvr_ops->suspend(pdata->xcvr_ops);
+			clk_disable(usb_clk);
+		}
+		msleep(1);
+		UOG_PORTSC1 = UOG_PORTSC1 | PORTSC_PHCD;
+		if (pdata->gpio_usb_inactive)
+			pdata->gpio_usb_inactive();
+		if (pdata->xcvr_type == PORTSC_PTS_SERIAL)
+			clk_disable(usb_clk);
+		clk_disable(usb_ahb_clk);
+	}
+}
+EXPORT_SYMBOL(usbotg_uninit);
+
+/*
+ * This function is used to debounce the reading value for id/vbus at
+ * the register of otgsc
+ */
+void usb_debounce_id_vbus(void)
+{
+	mdelay(3);
+}
+EXPORT_SYMBOL(usb_debounce_id_vbus);
+
+int usb_host_wakeup_irq(struct device *wkup_dev)
+{
+	int wakeup_req = 0;
+	struct fsl_usb2_platform_data *pdata = wkup_dev->platform_data;
+
+	if (!strcmp("Host 1", pdata->name)) {
+		wakeup_req = USBCTRL & UCTRL_H1WIR;
+	} else if (!strcmp("Host 2", pdata->name)) {
+		wakeup_req = USBCTRL_HOST2 & UCTRL_H2WIR;
+	} else if (!strcmp("DR", pdata->name)) {
+		wakeup_req = USBCTRL & UCTRL_OWIR;
+		/*if only host mode is enabled, the wakeup event
+		 * must be host wakeup event */
+#ifdef CONFIG_USB_OTG
+		/* if ID change status, it is host wakeup event */
+		if (wakeup_req && (UOG_OTGSC & OTGSC_IS_USB_ID))
+			wakeup_req = 0;
+#endif
+	}
+
+	return wakeup_req;
+}
+EXPORT_SYMBOL(usb_host_wakeup_irq);
+
+int usb_event_is_otg_wakeup(void)
+{
+	int ret = (USBCTRL & UCTRL_OWIR) ? 1 : 0;
+	return ret;
+}
+EXPORT_SYMBOL(usb_event_is_otg_wakeup);
+
+void usb_host_set_wakeup(struct device *wkup_dev, bool para)
+{
+	struct fsl_usb2_platform_data *pdata = wkup_dev->platform_data;
+	if (pdata->wake_up_enable)
+		pdata->wake_up_enable(pdata, para);
+}
+EXPORT_SYMBOL(usb_host_set_wakeup);
diff --git a/arch/arm/plat-mxc/usb_wakeup.c b/arch/arm/plat-mxc/usb_wakeup.c
new file mode 100755
index 0000000..80bc6c98
--- /dev/null
+++ b/arch/arm/plat-mxc/usb_wakeup.c
@@ -0,0 +1,224 @@
+/*
+ * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ *  The code contained herein is licensed under the GNU General Public
+ *  License. You may obtain a copy of the GNU General Public License
+ *  Version 2 or later at the following locations:
+ *  *
+ *  http://www.opensource.org/licenses/gpl-license.html
+ *  http://www.gnu.org/copyleft/gpl.html
+*/
+
+#include <linux/sched.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/slab.h>
+#include <linux/kthread.h>
+#include <linux/platform_device.h>
+#include <linux/mutex.h>
+#include <linux/fsl_devices.h>
+#include <linux/suspend.h>
+
+struct wakeup_ctrl {
+	int wakeup_irq;
+	int usb_irq;
+	struct fsl_usb2_wakeup_platform_data *pdata;
+	struct task_struct *thread;
+	struct completion  event;
+};
+static struct wakeup_ctrl *g_ctrl;
+
+extern int usb_event_is_otg_wakeup(void);
+extern void usb_debounce_id_vbus(void);
+
+static void wakeup_clk_gate(struct fsl_usb2_wakeup_platform_data *pdata, bool on)
+{
+	if (pdata->usb_clock_for_pm)
+		pdata->usb_clock_for_pm(on);
+}
+
+static bool usb2_is_in_lowpower(struct wakeup_ctrl *ctrl)
+{
+	int i;
+	struct fsl_usb2_wakeup_platform_data *pdata = ctrl->pdata;
+	/* all the usb module related the wakeup is in lowpower mode */
+	for (i = 0; i < 3; i++) {
+		if (pdata->usb_pdata[i]) {
+			if (pdata->usb_pdata[i]->phy_lowpower_suspend && !pdata->usb_pdata[i]->lowpower)
+				return false;
+		}
+	}
+	return true;
+}
+
+static void delay_process_wakeup(struct wakeup_ctrl *ctrl)
+{
+	int i;
+	struct fsl_usb2_wakeup_platform_data *pdata = ctrl->pdata;
+	disable_irq_nosync(ctrl->wakeup_irq);
+	if ((ctrl->usb_irq > 0) && (ctrl->wakeup_irq != ctrl->usb_irq))
+		disable_irq_nosync(ctrl->usb_irq);
+
+	for (i = 0; i < 3; i++) {
+		if (pdata->usb_pdata[i]) {
+			pdata->usb_pdata[i]->irq_delay = 1;
+		}
+	}
+	pdata->usb_wakeup_is_pending = true;
+	complete(&ctrl->event);
+}
+
+static irqreturn_t usb_wakeup_handler(int irq, void *_dev)
+{
+	struct wakeup_ctrl *ctrl = (struct wakeup_ctrl *)_dev;
+	irqreturn_t ret = IRQ_NONE;
+
+	if (usb2_is_in_lowpower(ctrl)) {
+		printk(KERN_INFO "usb wakeup is here\n");
+		delay_process_wakeup(ctrl);
+		ret = IRQ_HANDLED;
+	}
+	return ret;
+}
+
+static enum usb_wakeup_event is_wakeup(struct fsl_usb2_platform_data *pdata)
+{
+	if (pdata->is_wakeup_event)
+		return pdata->is_wakeup_event(pdata);
+	else
+		return WAKEUP_EVENT_INVALID;
+}
+
+static void wakeup_event_handler(struct wakeup_ctrl *ctrl)
+{
+	struct fsl_usb2_wakeup_platform_data *pdata = ctrl->pdata;
+	int already_waked = 0;
+	enum usb_wakeup_event wakeup_evt;
+	int i, cnt = 0;
+
+	wakeup_clk_gate(ctrl->pdata, true);
+
+recheck:
+	/* In order to get the real id/vbus value */
+	if (usb_event_is_otg_wakeup())
+		msleep(10);	/* usb_debounce_id_vbus(); */
+
+	for (i = 0; i < 3; i++) {
+		struct fsl_usb2_platform_data *usb_pdata = pdata->usb_pdata[i];
+		if (usb_pdata) {
+			usb_pdata->irq_delay = 0;
+			wakeup_evt = is_wakeup(usb_pdata);
+			if (wakeup_evt != WAKEUP_EVENT_INVALID) {
+				if (usb_pdata->usb_clock_for_pm)
+					usb_pdata->usb_clock_for_pm(true);
+				usb_pdata->lowpower = 0;
+				already_waked = 1;
+				if (usb_pdata->wakeup_handler) {
+					usb_pdata->wakeup_handler(usb_pdata);
+				}
+			}
+		}
+	}
+	/* for IC: ID/VBUS status change after wakeup interrupt */
+	if ((cnt++ < 5) && (already_waked == 0))
+		goto recheck;
+	/* If nothing to wakeup, clear wakeup event */
+	if ((already_waked == 0) && pdata->usb_wakeup_exhandle)
+		pdata->usb_wakeup_exhandle();
+
+	wakeup_clk_gate(ctrl->pdata, false);
+	pdata->usb_wakeup_is_pending = false;
+	wake_up(&pdata->wq);
+}
+
+static int wakeup_event_thread(void *param)
+{
+	struct wakeup_ctrl *ctrl = (struct wakeup_ctrl *)param;
+	struct sched_param sch_param = {.sched_priority = 1};
+
+	sched_setscheduler(current, SCHED_RR, &sch_param);
+	while (1) {
+		wait_for_completion_interruptible(&ctrl->event);
+		if (kthread_should_stop())
+			break;
+		wakeup_event_handler(ctrl);
+		enable_irq(ctrl->wakeup_irq);
+		if ((ctrl->usb_irq > 0) && (ctrl->wakeup_irq != ctrl->usb_irq))
+			enable_irq(ctrl->usb_irq);
+	}
+	return 0;
+}
+
+static int wakeup_dev_probe(struct platform_device *pdev)
+{
+	struct fsl_usb2_wakeup_platform_data *pdata;
+	struct wakeup_ctrl *ctrl = NULL;
+	int status;
+
+	printk(KERN_INFO "IMX usb wakeup probe\n");
+
+	if (!pdev || !pdev->dev.platform_data)
+		return -ENODEV;
+	ctrl = kzalloc(sizeof(*ctrl), GFP_KERNEL);
+	if (!ctrl)
+		return -ENOMEM;
+	pdata = pdev->dev.platform_data;
+	init_waitqueue_head(&pdata->wq);
+	pdata->usb_wakeup_is_pending = false;
+
+	ctrl->pdata = pdata;
+	init_completion(&ctrl->event);
+	ctrl->wakeup_irq = platform_get_irq(pdev, 0);
+	status = request_irq(ctrl->wakeup_irq, usb_wakeup_handler, IRQF_SHARED, "usb_wakeup", (void *)ctrl);
+	if (status)
+		goto error1;
+	ctrl->usb_irq = platform_get_irq(pdev, 1);
+
+	ctrl->thread = kthread_run(wakeup_event_thread, (void *)ctrl, "usb_wakeup thread");
+	status = IS_ERR(ctrl->thread) ? -1 : 0;
+	if (status)
+		goto error2;
+	g_ctrl = ctrl;
+	printk(KERN_DEBUG "the wakeup pdata is 0x%p\n", pdata);
+
+	return 0;
+error2:
+	free_irq(ctrl->wakeup_irq, (void *)ctrl);
+error1:
+	kfree(ctrl);
+	return status;
+}
+
+static int  wakeup_dev_exit(struct platform_device *pdev)
+{
+	if (g_ctrl->thread) {
+		complete(&g_ctrl->event);
+		kthread_stop(g_ctrl->thread);
+	}
+	free_irq(g_ctrl->wakeup_irq, (void *)g_ctrl);
+	kfree(g_ctrl);
+	return 0;
+}
+static struct platform_driver wakeup_d = {
+	.probe   = wakeup_dev_probe,
+	.remove  = wakeup_dev_exit,
+	.driver = {
+		.name = "usb_wakeup",
+	},
+};
+
+static int __init wakeup_dev_init(void)
+{
+	return platform_driver_register(&wakeup_d);
+}
+static void __exit wakeup_dev_uninit(void)
+{
+	platform_driver_unregister(&wakeup_d);
+}
+
+subsys_initcall(wakeup_dev_init);
+module_exit(wakeup_dev_uninit);
+
diff --git a/arch/arm/plat-mxc/utmixc.c b/arch/arm/plat-mxc/utmixc.c
new file mode 100755
index 0000000..ad935fd
--- /dev/null
+++ b/arch/arm/plat-mxc/utmixc.c
@@ -0,0 +1,108 @@
+/*
+ * Copyright (C) 2005-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/device.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/err.h>
+#include <linux/platform_device.h>
+#include <linux/fsl_devices.h>
+#include <linux/pmic_external.h>
+#include <linux/usb/fsl_xcvr.h>
+
+#include <mach/hardware.h>
+#include <mach/arc_otg.h>
+#include <asm/mach-types.h>
+
+static struct regulator *usbotg_regux;
+
+static void usb_utmi_init(struct fsl_xcvr_ops *this)
+{
+#if defined(CONFIG_MXC_PMIC_MC13892_MODULE) || defined(CONFIG_MXC_PMIC_MC13892)
+	if (machine_is_mx51_3ds()) {
+		unsigned int value;
+
+		/* VUSBIN */
+		pmic_read_reg(REG_USB1, &value, 0xffffff);
+		value |= 0x1;
+		value |= (0x1 << 3);
+		pmic_write_reg(REG_USB1, value, 0xffffff);
+	}
+#endif
+}
+
+static void usb_utmi_uninit(struct fsl_xcvr_ops *this)
+{
+}
+
+/*!
+ * set vbus power
+ *
+ * @param       view  viewport register
+ * @param       on    power on or off
+ */
+static void set_power(struct fsl_xcvr_ops *this,
+		      struct fsl_usb2_platform_data *pdata, int on)
+{
+	struct device *dev = &pdata->pdev->dev;
+
+	pr_debug("real %s(on=%d) pdata=0x%p\n", __func__, on, pdata);
+	if (machine_is_mx37_3ds()) {
+		if (on) {
+			if (!board_is_rev(IMX_BOARD_REV_2))
+				usbotg_regux = regulator_get(dev, "DCDC2");
+			else
+				usbotg_regux = regulator_get(dev, "SWBST");
+
+			regulator_enable(usbotg_regux);
+		} else {
+			regulator_disable(usbotg_regux);
+			regulator_put(usbotg_regux);
+		}
+	}
+	if (pdata && pdata->platform_driver_vbus)
+		pdata->platform_driver_vbus(on);
+}
+
+static struct fsl_xcvr_ops utmi_ops = {
+	.name = "utmi",
+	.xcvr_type = PORTSC_PTS_UTMI,
+	.init = usb_utmi_init,
+	.uninit = usb_utmi_uninit,
+	.set_vbus_power = set_power,
+};
+
+extern void fsl_usb_xcvr_register(struct fsl_xcvr_ops *xcvr_ops);
+
+static int __init utmixc_init(void)
+{
+	fsl_usb_xcvr_register(&utmi_ops);
+	return 0;
+}
+
+extern void fsl_usb_xcvr_unregister(struct fsl_xcvr_ops *xcvr_ops);
+
+static void __exit utmixc_exit(void)
+{
+	fsl_usb_xcvr_unregister(&utmi_ops);
+}
+
+subsys_initcall(utmixc_init);
+module_exit(utmixc_exit);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("utmi xcvr driver");
+MODULE_LICENSE("GPL");
-- 
1.7.9.5

