From 75e6b66b5b26a91837d64d3e0c76f047dcd0722e Mon Sep 17 00:00:00 2001
From: Jason Liu <r64343@freescale.com>
Date: Tue, 7 Feb 2012 14:26:23 +0800
Subject: ENGR00173869-8: i.mx6: ARM2: add i.mx6dl support

i.mx6dl and i.mx6q share the same ARM2 board due to the pin-pin
compatible between them.

Signed-off-by: Jason Liu <r64343@freescale.com>
---
 arch/arm/mach-mx6/board-mx6dl_arm2.h         |  313 ++++++
 arch/arm/mach-mx6/board-mx6q_arm2.c          | 1307 ++++++++++++--------------
 arch/arm/mach-mx6/board-mx6q_arm2.h          |  314 +++++++
 arch/arm/plat-mxc/audmux-v2.c                |    2 +-
 arch/arm/plat-mxc/devices/platform-viv_gpu.c |   12 +-
 arch/arm/plat-mxc/dvfs_core.c                |   10 +-
 arch/arm/plat-mxc/include/mach/fsl_usb.h     |    4 +-
 arch/arm/plat-mxc/usb_common.c               |    8 +-
 8 files changed, 1241 insertions(+), 729 deletions(-)
 create mode 100644 arch/arm/mach-mx6/board-mx6dl_arm2.h
 create mode 100644 arch/arm/mach-mx6/board-mx6q_arm2.h

diff --git a/arch/arm/mach-mx6/board-mx6dl_arm2.h b/arch/arm/mach-mx6/board-mx6dl_arm2.h
new file mode 100644
index 0000000..1ba2e57
--- /dev/null
+++ b/arch/arm/mach-mx6/board-mx6dl_arm2.h
@@ -0,0 +1,313 @@
+/*
+ * Copyright (C) 2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <mach/iomux-mx6dl.h>
+
+static iomux_v3_cfg_t mx6dl_arm2_pads[] = {
+
+	/* UART4 for debug */
+	MX6DL_PAD_KEY_COL0__UART4_TXD,
+	MX6DL_PAD_KEY_ROW0__UART4_RXD,
+	/* USB HSIC ports use the same pin with ENET */
+#ifdef CONFIG_USB_EHCI_ARC_HSIC
+	/* USB H2 strobe/data pin */
+	MX6DL_PAD_RGMII_TX_CTL__USBOH3_H2_STROBE,
+	MX6DL_PAD_RGMII_TXC__USBOH3_H2_DATA,
+
+	/* USB H3 strobe/data pin */
+	MX6DL_PAD_RGMII_RXC__USBOH3_H3_STROBE,
+	MX6DL_PAD_RGMII_RX_CTL__USBOH3_H3_DATA,
+	/* ENET */
+#else
+	MX6DL_PAD_KEY_COL1__ENET_MDIO,
+	MX6DL_PAD_KEY_COL2__ENET_MDC,
+	MX6DL_PAD_RGMII_TXC__ENET_RGMII_TXC,
+	MX6DL_PAD_RGMII_TD0__ENET_RGMII_TD0,
+	MX6DL_PAD_RGMII_TD1__ENET_RGMII_TD1,
+	MX6DL_PAD_RGMII_TD2__ENET_RGMII_TD2,
+	MX6DL_PAD_RGMII_TD3__ENET_RGMII_TD3,
+	MX6DL_PAD_RGMII_TX_CTL__ENET_RGMII_TX_CTL,
+	MX6DL_PAD_ENET_REF_CLK__ENET_TX_CLK,
+	MX6DL_PAD_RGMII_RXC__ENET_RGMII_RXC,
+	MX6DL_PAD_RGMII_RD0__ENET_RGMII_RD0,
+	MX6DL_PAD_RGMII_RD1__ENET_RGMII_RD1,
+	MX6DL_PAD_RGMII_RD2__ENET_RGMII_RD2,
+	MX6DL_PAD_RGMII_RD3__ENET_RGMII_RD3,
+	MX6DL_PAD_RGMII_RX_CTL__ENET_RGMII_RX_CTL,
+#endif
+	/* MCLK for csi0 */
+	MX6DL_PAD_GPIO_0__CCM_CLKO,
+	MX6DL_PAD_GPIO_3__CCM_CLKO2,
+
+	/* SD1 */
+	MX6DL_PAD_SD1_CLK__USDHC1_CLK,
+	MX6DL_PAD_SD1_CMD__USDHC1_CMD,
+	MX6DL_PAD_SD1_DAT0__USDHC1_DAT0,
+	MX6DL_PAD_SD1_DAT1__USDHC1_DAT1,
+	MX6DL_PAD_SD1_DAT2__USDHC1_DAT2,
+	MX6DL_PAD_SD1_DAT3__USDHC1_DAT3,
+	/* SD2 */
+	MX6DL_PAD_SD2_CLK__USDHC2_CLK,
+	MX6DL_PAD_SD2_CMD__USDHC2_CMD,
+	MX6DL_PAD_SD2_DAT0__USDHC2_DAT0,
+	MX6DL_PAD_SD2_DAT1__USDHC2_DAT1,
+	MX6DL_PAD_SD2_DAT2__USDHC2_DAT2,
+	MX6DL_PAD_SD2_DAT3__USDHC2_DAT3,
+	/* SD3 */
+	MX6DL_PAD_SD3_CLK__USDHC3_CLK_50MHZ,
+	MX6DL_PAD_SD3_CMD__USDHC3_CMD_50MHZ,
+	MX6DL_PAD_SD3_DAT0__USDHC3_DAT0_50MHZ,
+	MX6DL_PAD_SD3_DAT1__USDHC3_DAT1_50MHZ,
+	MX6DL_PAD_SD3_DAT2__USDHC3_DAT2_50MHZ,
+	MX6DL_PAD_SD3_DAT3__USDHC3_DAT3_50MHZ,
+	MX6DL_PAD_SD3_DAT4__USDHC3_DAT4_50MHZ,
+	MX6DL_PAD_SD3_DAT5__USDHC3_DAT5_50MHZ,
+	MX6DL_PAD_SD3_DAT6__USDHC3_DAT6_50MHZ,
+	MX6DL_PAD_SD3_DAT7__USDHC3_DAT7_50MHZ,
+	MX6DL_PAD_SD3_RST__USDHC3_RST,
+	/* SD3 VSelect */
+	MX6DL_PAD_GPIO_18__USDHC3_VSELECT,
+	/* SD3_CD and SD3_WP */
+	MX6DL_PAD_NANDF_CS0__GPIO_6_11,
+	MX6DL_PAD_NANDF_CS1__GPIO_6_14,
+	/* SD4 */
+	MX6DL_PAD_SD4_CLK__USDHC4_CLK_50MHZ,
+	MX6DL_PAD_SD4_CMD__USDHC4_CMD_50MHZ,
+	MX6DL_PAD_SD4_DAT0__USDHC4_DAT0_50MHZ,
+	MX6DL_PAD_SD4_DAT1__USDHC4_DAT1_50MHZ,
+	MX6DL_PAD_SD4_DAT2__USDHC4_DAT2_50MHZ,
+	MX6DL_PAD_SD4_DAT3__USDHC4_DAT3_50MHZ,
+	MX6DL_PAD_SD4_DAT4__USDHC4_DAT4_50MHZ,
+	MX6DL_PAD_SD4_DAT5__USDHC4_DAT5_50MHZ,
+	MX6DL_PAD_SD4_DAT6__USDHC4_DAT6_50MHZ,
+	MX6DL_PAD_SD4_DAT7__USDHC4_DAT7_50MHZ,
+	MX6DL_PAD_NANDF_ALE__USDHC4_RST,
+	/* eCSPI1 */
+	MX6DL_PAD_EIM_EB2__ECSPI1_SS0,
+	MX6DL_PAD_EIM_D16__ECSPI1_SCLK,
+	MX6DL_PAD_EIM_D17__ECSPI1_MISO,
+	MX6DL_PAD_EIM_D18__ECSPI1_MOSI,
+	MX6DL_PAD_EIM_D19__ECSPI1_SS1,
+	MX6DL_PAD_EIM_EB2__GPIO_2_30,	/*SS0*/
+	MX6DL_PAD_EIM_D19__GPIO_3_19,	/*SS1*/
+
+	/* ESAI */
+	MX6DL_PAD_ENET_RXD0__ESAI1_HCKT,
+	MX6DL_PAD_ENET_CRS_DV__ESAI1_SCKT,
+	MX6DL_PAD_ENET_RXD1__ESAI1_FST,
+	MX6DL_PAD_ENET_TX_EN__ESAI1_TX3_RX2,
+	MX6DL_PAD_ENET_TXD1__ESAI1_TX2_RX3,
+	MX6DL_PAD_ENET_TXD0__ESAI1_TX4_RX1,
+	MX6DL_PAD_ENET_MDC__ESAI1_TX5_RX0,
+	MX6DL_PAD_NANDF_CS2__ESAI1_TX0,
+	MX6DL_PAD_NANDF_CS3__ESAI1_TX1,
+
+	/* I2C1 */
+	MX6DL_PAD_CSI0_DAT8__I2C1_SDA,
+	MX6DL_PAD_CSI0_DAT9__I2C1_SCL,
+
+	/* I2C2 */
+	MX6DL_PAD_KEY_COL3__I2C2_SCL,
+	MX6DL_PAD_KEY_ROW3__I2C2_SDA,
+
+	/* DISPLAY */
+	MX6DL_PAD_DI0_DISP_CLK__IPU1_DI0_DISP_CLK,
+	MX6DL_PAD_DI0_PIN15__IPU1_DI0_PIN15,
+	MX6DL_PAD_DI0_PIN2__IPU1_DI0_PIN2,
+	MX6DL_PAD_DI0_PIN3__IPU1_DI0_PIN3,
+	MX6DL_PAD_DISP0_DAT0__IPU1_DISP0_DAT_0,
+	MX6DL_PAD_DISP0_DAT1__IPU1_DISP0_DAT_1,
+	MX6DL_PAD_DISP0_DAT2__IPU1_DISP0_DAT_2,
+	MX6DL_PAD_DISP0_DAT3__IPU1_DISP0_DAT_3,
+	MX6DL_PAD_DISP0_DAT4__IPU1_DISP0_DAT_4,
+	MX6DL_PAD_DISP0_DAT5__IPU1_DISP0_DAT_5,
+	MX6DL_PAD_DISP0_DAT6__IPU1_DISP0_DAT_6,
+	MX6DL_PAD_DISP0_DAT7__IPU1_DISP0_DAT_7,
+	MX6DL_PAD_DISP0_DAT8__IPU1_DISP0_DAT_8,
+	MX6DL_PAD_DISP0_DAT9__IPU1_DISP0_DAT_9,
+	MX6DL_PAD_DISP0_DAT10__IPU1_DISP0_DAT_10,
+	MX6DL_PAD_DISP0_DAT11__IPU1_DISP0_DAT_11,
+	MX6DL_PAD_DISP0_DAT12__IPU1_DISP0_DAT_12,
+	MX6DL_PAD_DISP0_DAT13__IPU1_DISP0_DAT_13,
+	MX6DL_PAD_DISP0_DAT14__IPU1_DISP0_DAT_14,
+	MX6DL_PAD_DISP0_DAT15__IPU1_DISP0_DAT_15,
+	MX6DL_PAD_DISP0_DAT16__IPU1_DISP0_DAT_16,
+	MX6DL_PAD_DISP0_DAT17__IPU1_DISP0_DAT_17,
+	MX6DL_PAD_DISP0_DAT18__IPU1_DISP0_DAT_18,
+	MX6DL_PAD_DISP0_DAT19__IPU1_DISP0_DAT_19,
+	MX6DL_PAD_DISP0_DAT20__IPU1_DISP0_DAT_20,
+	MX6DL_PAD_DISP0_DAT21__IPU1_DISP0_DAT_21,
+	MX6DL_PAD_DISP0_DAT22__IPU1_DISP0_DAT_22,
+	MX6DL_PAD_DISP0_DAT23__IPU1_DISP0_DAT_23,
+
+	MX6DL_PAD_EIM_D24__GPIO_3_24,
+
+	/* UART2 */
+	MX6DL_PAD_EIM_D26__UART2_RXD,
+	MX6DL_PAD_EIM_D27__UART2_TXD,
+	MX6DL_PAD_EIM_D28__UART2_RTS,
+	MX6DL_PAD_EIM_D29__UART2_CTS,
+
+	/* PWM1 */
+	MX6DL_PAD_GPIO_9__PWM1_PWMO,
+
+	/* DISP0 DET */
+	MX6DL_PAD_EIM_D31__GPIO_3_31,
+
+	/* DISP0 RESET */
+	MX6DL_PAD_EIM_WAIT__GPIO_5_0,
+
+	/* HDMI */
+	MX6DL_PAD_EIM_A25__HDMI_TX_CEC_LINE,
+	MX6DL_PAD_SD1_DAT1__HDMI_TX_OPHYDTB_0,
+	MX6DL_PAD_SD1_DAT0__HDMI_TX_OPHYDTB_1,
+
+	/* USBOTG ID pin */
+	MX6DL_PAD_GPIO_1__USBOTG_ID,
+
+	/* MLB150 */
+	MX6DL_PAD_GPIO_3__MLB_MLBCLK,
+	MX6DL_PAD_GPIO_6__MLB_MLBSIG,
+	MX6DL_PAD_GPIO_2__MLB_MLBDAT,
+};
+
+static iomux_v3_cfg_t mx6dl_arm2_i2c3_pads[] = {
+	MX6DL_PAD_GPIO_5__I2C3_SCL,
+	MX6DL_PAD_GPIO_16__I2C3_SDA,
+};
+
+static iomux_v3_cfg_t mx6dl_arm2_spdif_pads[] = {
+	/* SPDIF */
+	MX6DL_PAD_GPIO_16__SPDIF_IN1,
+	MX6DL_PAD_GPIO_17__SPDIF_OUT1,
+};
+
+static iomux_v3_cfg_t mx6dl_arm2_can_pads[] = {
+	/* CAN1 */
+	MX6DL_PAD_GPIO_7__CAN1_TXCAN,
+	MX6DL_PAD_KEY_ROW2__CAN1_RXCAN,
+	MX6DL_PAD_GPIO_17__GPIO_7_12,	/* CAN1 STBY */
+	MX6DL_PAD_GPIO_18__GPIO_7_13,	/* CAN1 EN */
+
+	/* CAN2 */
+	MX6DL_PAD_KEY_COL4__CAN2_TXCAN,
+	MX6DL_PAD_KEY_ROW4__CAN2_RXCAN,
+	MX6DL_PAD_CSI0_DAT6__GPIO_5_24,	/* CAN2 EN */
+};
+
+static iomux_v3_cfg_t mx6dl_arm2_esai_record_pads[] = {
+	MX6DL_PAD_ENET_RX_ER__ESAI1_HCKR,
+	MX6DL_PAD_ENET_MDIO__ESAI1_SCKR,
+	MX6DL_PAD_ENET_REF_CLK__ESAI1_FSR,
+};
+
+static iomux_v3_cfg_t mx6dl_arm2_csi0_sensor_pads[] = {
+	MX6DL_PAD_GPIO_0__CCM_CLKO,
+	/* ipu1 csi0 */
+	MX6DL_PAD_CSI0_DAT12__IPU1_CSI0_D_12,
+	MX6DL_PAD_CSI0_DAT13__IPU1_CSI0_D_13,
+	MX6DL_PAD_CSI0_DAT14__IPU1_CSI0_D_14,
+	MX6DL_PAD_CSI0_DAT15__IPU1_CSI0_D_15,
+	MX6DL_PAD_CSI0_DAT16__IPU1_CSI0_D_16,
+	MX6DL_PAD_CSI0_DAT17__IPU1_CSI0_D_17,
+	MX6DL_PAD_CSI0_DAT18__IPU1_CSI0_D_18,
+	MX6DL_PAD_CSI0_DAT19__IPU1_CSI0_D_19,
+	MX6DL_PAD_CSI0_VSYNC__IPU1_CSI0_VSYNC,
+	MX6DL_PAD_CSI0_MCLK__IPU1_CSI0_HSYNC,
+	MX6DL_PAD_CSI0_PIXCLK__IPU1_CSI0_PIXCLK,
+	/* camera reset */
+	MX6DL_PAD_GPIO_19__GPIO_4_5,
+	/* camera powerdown */
+	MX6DL_PAD_CSI0_DAT5__GPIO_5_23,
+};
+
+static iomux_v3_cfg_t mx6dl_arm2_csi0_tvin_pads[] = {
+	/* ipu1 csi0 */
+	MX6DL_PAD_CSI0_DAT12__IPU1_CSI0_D_12,
+	MX6DL_PAD_CSI0_DAT13__IPU1_CSI0_D_13,
+	MX6DL_PAD_CSI0_DAT14__IPU1_CSI0_D_14,
+	MX6DL_PAD_CSI0_DAT15__IPU1_CSI0_D_15,
+	MX6DL_PAD_CSI0_DAT16__IPU1_CSI0_D_16,
+	MX6DL_PAD_CSI0_DAT17__IPU1_CSI0_D_17,
+	MX6DL_PAD_CSI0_DAT18__IPU1_CSI0_D_18,
+	MX6DL_PAD_CSI0_DAT19__IPU1_CSI0_D_19,
+	MX6DL_PAD_CSI0_VSYNC__IPU1_CSI0_VSYNC,
+	MX6DL_PAD_CSI0_MCLK__IPU1_CSI0_HSYNC,
+	MX6DL_PAD_CSI0_PIXCLK__IPU1_CSI0_PIXCLK,
+	/* camera reset */
+	MX6DL_PAD_CSI0_DAT7__GPIO_5_25,
+	/* camera powerdown */
+	MX6DL_PAD_CSI0_DAT5__GPIO_5_23,
+};
+
+static iomux_v3_cfg_t mx6dl_arm2_mipi_sensor_pads[] = {
+	MX6DL_PAD_CSI0_MCLK__CCM_CLKO,
+};
+
+static iomux_v3_cfg_t mx6dl_arm2_audmux_pads[] = {
+
+	/* AUDMUX */
+	MX6DL_PAD_CSI0_DAT4__AUDMUX_AUD3_TXC,
+	MX6DL_PAD_CSI0_DAT5__AUDMUX_AUD3_TXD,
+	MX6DL_PAD_CSI0_DAT6__AUDMUX_AUD3_TXFS,
+	MX6DL_PAD_CSI0_DAT7__AUDMUX_AUD3_RXD,
+};
+
+#define MX6DL_USDHC_PAD_SETTING(id, speed)	\
+mx6dl_sd##id##_##speed##mhz[] = {		\
+	MX6DL_PAD_SD##id##_CLK__USDHC##id##_CLK_##speed##MHZ,	\
+	MX6DL_PAD_SD##id##_CMD__USDHC##id##_CMD_##speed##MHZ,	\
+	MX6DL_PAD_SD##id##_DAT0__USDHC##id##_DAT0_##speed##MHZ,	\
+	MX6DL_PAD_SD##id##_DAT1__USDHC##id##_DAT1_##speed##MHZ,	\
+	MX6DL_PAD_SD##id##_DAT2__USDHC##id##_DAT2_##speed##MHZ,	\
+	MX6DL_PAD_SD##id##_DAT3__USDHC##id##_DAT3_##speed##MHZ,	\
+	MX6DL_PAD_SD##id##_DAT4__USDHC##id##_DAT4_##speed##MHZ,	\
+	MX6DL_PAD_SD##id##_DAT5__USDHC##id##_DAT5_##speed##MHZ,	\
+	MX6DL_PAD_SD##id##_DAT6__USDHC##id##_DAT6_##speed##MHZ,	\
+	MX6DL_PAD_SD##id##_DAT7__USDHC##id##_DAT7_##speed##MHZ,	\
+}
+
+static iomux_v3_cfg_t MX6DL_USDHC_PAD_SETTING(3, 50);
+static iomux_v3_cfg_t MX6DL_USDHC_PAD_SETTING(3, 100);
+static iomux_v3_cfg_t MX6DL_USDHC_PAD_SETTING(3, 200);
+static iomux_v3_cfg_t MX6DL_USDHC_PAD_SETTING(4, 50);
+static iomux_v3_cfg_t MX6DL_USDHC_PAD_SETTING(4, 100);
+static iomux_v3_cfg_t MX6DL_USDHC_PAD_SETTING(4, 200);
+
+/* The GPMI is conflicted with SD3, so init this in the driver. */
+static iomux_v3_cfg_t mx6dl_gpmi_nand[] __initdata = {
+	MX6DL_PAD_NANDF_CLE__RAWNAND_CLE,
+	MX6DL_PAD_NANDF_ALE__RAWNAND_ALE,
+	MX6DL_PAD_NANDF_CS0__RAWNAND_CE0N,
+	MX6DL_PAD_NANDF_CS1__RAWNAND_CE1N,
+	MX6DL_PAD_NANDF_CS2__RAWNAND_CE2N,
+	MX6DL_PAD_NANDF_CS3__RAWNAND_CE3N,
+	MX6DL_PAD_NANDF_RB0__RAWNAND_READY0,
+	MX6DL_PAD_SD4_DAT0__RAWNAND_DQS,
+	MX6DL_PAD_NANDF_D0__RAWNAND_D0,
+	MX6DL_PAD_NANDF_D1__RAWNAND_D1,
+	MX6DL_PAD_NANDF_D2__RAWNAND_D2,
+	MX6DL_PAD_NANDF_D3__RAWNAND_D3,
+	MX6DL_PAD_NANDF_D4__RAWNAND_D4,
+	MX6DL_PAD_NANDF_D5__RAWNAND_D5,
+	MX6DL_PAD_NANDF_D6__RAWNAND_D6,
+	MX6DL_PAD_NANDF_D7__RAWNAND_D7,
+	MX6DL_PAD_SD4_CMD__RAWNAND_RDN,
+	MX6DL_PAD_SD4_CLK__RAWNAND_WRN,
+	MX6DL_PAD_NANDF_WP_B__RAWNAND_RESETN,
+};
diff --git a/arch/arm/mach-mx6/board-mx6q_arm2.c b/arch/arm/mach-mx6/board-mx6q_arm2.c
index 09268f0..04025bc 100644
--- a/arch/arm/mach-mx6/board-mx6q_arm2.c
+++ b/arch/arm/mach-mx6/board-mx6q_arm2.c
@@ -55,7 +55,6 @@
 #include <mach/hardware.h>
 #include <mach/mxc_dvfs.h>
 #include <mach/memory.h>
-#include <mach/iomux-mx6q.h>
 #include <mach/imx-uart.h>
 #include <mach/viv_gpu.h>
 #include <mach/ahci_sata.h>
@@ -75,36 +74,37 @@
 #include "devices-imx6q.h"
 #include "crm_regs.h"
 #include "cpu_op-mx6.h"
-
-#define MX6Q_ARM2_LDB_BACKLIGHT	IMX_GPIO_NR(1, 9)
-#define MX6Q_ARM2_ECSPI1_CS0	IMX_GPIO_NR(2, 30)
-#define MX6Q_ARM2_ECSPI1_CS1	IMX_GPIO_NR(3, 19)
-#define MX6Q_ARM2_DISP0_PWR	IMX_GPIO_NR(3, 24)
-#define MX6Q_ARM2_DISP0_I2C_EN	IMX_GPIO_NR(3, 28)
-#define MX6Q_ARM2_DISP0_DET_INT	IMX_GPIO_NR(3, 31)
-#define MX6Q_ARM2_DISP0_RESET	IMX_GPIO_NR(5, 0)
-#define MX6Q_ARM2_SD3_CD	IMX_GPIO_NR(6, 11)
-#define MX6Q_ARM2_SD3_WP	IMX_GPIO_NR(6, 14)
-#define MX6Q_ARM2_USB_OTG_PWR	IMX_GPIO_NR(3, 22)
-#define MX6Q_ARM2_MAX7310_1_BASE_ADDR	IMX_GPIO_NR(8, 0)
-#define MX6Q_ARM2_MAX7310_2_BASE_ADDR	IMX_GPIO_NR(8, 8)
-#define MX6Q_ARM2_CAP_TCH_INT	IMX_GPIO_NR(3, 31)
-
-#define MX6Q_ARM2_IO_EXP_GPIO1(x) \
-		(MX6Q_ARM2_MAX7310_1_BASE_ADDR + (x))
-#define MX6Q_ARM2_IO_EXP_GPIO2(x) \
-		(MX6Q_ARM2_MAX7310_2_BASE_ADDR + (x))
-
-#define MX6Q_ARM2_CAN1_STBY       IMX_GPIO_NR(7, 12)
-#define MX6Q_ARM2_CAN1_EN         IMX_GPIO_NR(7, 13)
-#define MX6Q_ARM2_CAN2_STBY       MX6Q_ARM2_IO_EXP_GPIO2(1)
-#define MX6Q_ARM2_CAN2_EN         IMX_GPIO_NR(5, 24)
-
-#define MX6Q_ARM2_CSI0_RST		IMX_GPIO_NR(4, 5)
-#define MX6Q_ARM2_CSI0_PWN		IMX_GPIO_NR(5, 23)
-#define MX6Q_ARM2_CSI0_RST_TVIN		IMX_GPIO_NR(5, 25)
-
-#define BMCR_PDOWN      	0x0800 /* PHY Powerdown */
+#include "board-mx6q_arm2.h"
+#include "board-mx6dl_arm2.h"
+
+/* GPIO PIN, sort by PORT/BIT */
+#define MX6_ARM2_LDB_BACKLIGHT		IMX_GPIO_NR(1, 9)
+#define MX6_ARM2_ECSPI1_CS0		IMX_GPIO_NR(2, 30)
+#define MX6_ARM2_ECSPI1_CS1		IMX_GPIO_NR(3, 19)
+#define MX6_ARM2_USB_OTG_PWR		IMX_GPIO_NR(3, 22)
+#define MX6_ARM2_DISP0_PWR		IMX_GPIO_NR(3, 24)
+#define MX6_ARM2_DISP0_I2C_EN		IMX_GPIO_NR(3, 28)
+#define MX6_ARM2_CAP_TCH_INT		IMX_GPIO_NR(3, 31)
+#define MX6_ARM2_DISP0_DET_INT		IMX_GPIO_NR(3, 31)
+#define MX6_ARM2_CSI0_RST		IMX_GPIO_NR(4, 5)
+#define MX6_ARM2_DISP0_RESET		IMX_GPIO_NR(5, 0)
+#define MX6_ARM2_CSI0_PWN		IMX_GPIO_NR(5, 23)
+#define MX6_ARM2_CAN2_EN		IMX_GPIO_NR(5, 24)
+#define MX6_ARM2_CSI0_RST_TVIN		IMX_GPIO_NR(5, 25)
+#define MX6_ARM2_SD3_CD			IMX_GPIO_NR(6, 11)
+#define MX6_ARM2_SD3_WP			IMX_GPIO_NR(6, 14)
+#define MX6_ARM2_CAN1_STBY		IMX_GPIO_NR(7, 12)
+#define MX6_ARM2_CAN1_EN		IMX_GPIO_NR(7, 13)
+#define MX6_ARM2_MAX7310_1_BASE_ADDR	IMX_GPIO_NR(8, 0)
+#define MX6_ARM2_MAX7310_2_BASE_ADDR	IMX_GPIO_NR(8, 8)
+
+#define MX6_ARM2_IO_EXP_GPIO1(x)	(MX6_ARM2_MAX7310_1_BASE_ADDR + (x))
+#define MX6_ARM2_IO_EXP_GPIO2(x)	(MX6_ARM2_MAX7310_2_BASE_ADDR + (x))
+
+#define MX6_ARM2_CAN2_STBY		MX6_ARM2_IO_EXP_GPIO2(1)
+
+
+#define BMCR_PDOWN			0x0800 /* PHY Powerdown */
 
 void __init early_console_setup(unsigned long base, struct clk *clk);
 static struct clk *sata_clk;
@@ -118,277 +118,6 @@ extern void (*put_cpu_regulator)(void);
 extern char *gp_reg_id;
 extern void mx6_cpu_regulator_init(void);
 
-static iomux_v3_cfg_t mx6q_arm2_pads[] = {
-
-	/* UART4 for debug */
-	MX6Q_PAD_KEY_COL0__UART4_TXD,
-	MX6Q_PAD_KEY_ROW0__UART4_RXD,
-	/* USB HSIC ports use the same pin with ENET */
-#ifdef CONFIG_USB_EHCI_ARC_HSIC
-	/* USB H2 strobe/data pin */
-	MX6Q_PAD_RGMII_TX_CTL__USBOH3_H2_STROBE,
-	MX6Q_PAD_RGMII_TXC__USBOH3_H2_DATA,
-
-	/* USB H3 strobe/data pin */
-	MX6Q_PAD_RGMII_RXC__USBOH3_H3_STROBE,
-	MX6Q_PAD_RGMII_RX_CTL__USBOH3_H3_DATA,
-	/* ENET */
-#else
-	MX6Q_PAD_KEY_COL1__ENET_MDIO,
-	MX6Q_PAD_KEY_COL2__ENET_MDC,
-	MX6Q_PAD_RGMII_TXC__ENET_RGMII_TXC,
-	MX6Q_PAD_RGMII_TD0__ENET_RGMII_TD0,
-	MX6Q_PAD_RGMII_TD1__ENET_RGMII_TD1,
-	MX6Q_PAD_RGMII_TD2__ENET_RGMII_TD2,
-	MX6Q_PAD_RGMII_TD3__ENET_RGMII_TD3,
-	MX6Q_PAD_RGMII_TX_CTL__ENET_RGMII_TX_CTL,
-	MX6Q_PAD_ENET_REF_CLK__ENET_TX_CLK,
-	MX6Q_PAD_RGMII_RXC__ENET_RGMII_RXC,
-	MX6Q_PAD_RGMII_RD0__ENET_RGMII_RD0,
-	MX6Q_PAD_RGMII_RD1__ENET_RGMII_RD1,
-	MX6Q_PAD_RGMII_RD2__ENET_RGMII_RD2,
-	MX6Q_PAD_RGMII_RD3__ENET_RGMII_RD3,
-	MX6Q_PAD_RGMII_RX_CTL__ENET_RGMII_RX_CTL,
-#endif
-	/* MCLK for csi0 */
-	MX6Q_PAD_GPIO_0__CCM_CLKO,
-	MX6Q_PAD_GPIO_3__CCM_CLKO2,
-
-	/* SD1 */
-	MX6Q_PAD_SD1_CLK__USDHC1_CLK,
-	MX6Q_PAD_SD1_CMD__USDHC1_CMD,
-	MX6Q_PAD_SD1_DAT0__USDHC1_DAT0,
-	MX6Q_PAD_SD1_DAT1__USDHC1_DAT1,
-	MX6Q_PAD_SD1_DAT2__USDHC1_DAT2,
-	MX6Q_PAD_SD1_DAT3__USDHC1_DAT3,
-	/* SD2 */
-	MX6Q_PAD_SD2_CLK__USDHC2_CLK,
-	MX6Q_PAD_SD2_CMD__USDHC2_CMD,
-	MX6Q_PAD_SD2_DAT0__USDHC2_DAT0,
-	MX6Q_PAD_SD2_DAT1__USDHC2_DAT1,
-	MX6Q_PAD_SD2_DAT2__USDHC2_DAT2,
-	MX6Q_PAD_SD2_DAT3__USDHC2_DAT3,
-	/* SD3 */
-	MX6Q_PAD_SD3_CLK__USDHC3_CLK_50MHZ,
-	MX6Q_PAD_SD3_CMD__USDHC3_CMD_50MHZ,
-	MX6Q_PAD_SD3_DAT0__USDHC3_DAT0_50MHZ,
-	MX6Q_PAD_SD3_DAT1__USDHC3_DAT1_50MHZ,
-	MX6Q_PAD_SD3_DAT2__USDHC3_DAT2_50MHZ,
-	MX6Q_PAD_SD3_DAT3__USDHC3_DAT3_50MHZ,
-	MX6Q_PAD_SD3_DAT4__USDHC3_DAT4_50MHZ,
-	MX6Q_PAD_SD3_DAT5__USDHC3_DAT5_50MHZ,
-	MX6Q_PAD_SD3_DAT6__USDHC3_DAT6_50MHZ,
-	MX6Q_PAD_SD3_DAT7__USDHC3_DAT7_50MHZ,
-	MX6Q_PAD_SD3_RST__USDHC3_RST,
-	/* SD3 VSelect */
-	MX6Q_PAD_GPIO_18__USDHC3_VSELECT,
-	/* SD3_CD and SD3_WP */
-	MX6Q_PAD_NANDF_CS0__GPIO_6_11,
-	MX6Q_PAD_NANDF_CS1__GPIO_6_14,
-	/* SD4 */
-	MX6Q_PAD_SD4_CLK__USDHC4_CLK_50MHZ,
-	MX6Q_PAD_SD4_CMD__USDHC4_CMD_50MHZ,
-	MX6Q_PAD_SD4_DAT0__USDHC4_DAT0_50MHZ,
-	MX6Q_PAD_SD4_DAT1__USDHC4_DAT1_50MHZ,
-	MX6Q_PAD_SD4_DAT2__USDHC4_DAT2_50MHZ,
-	MX6Q_PAD_SD4_DAT3__USDHC4_DAT3_50MHZ,
-	MX6Q_PAD_SD4_DAT4__USDHC4_DAT4_50MHZ,
-	MX6Q_PAD_SD4_DAT5__USDHC4_DAT5_50MHZ,
-	MX6Q_PAD_SD4_DAT6__USDHC4_DAT6_50MHZ,
-	MX6Q_PAD_SD4_DAT7__USDHC4_DAT7_50MHZ,
-	MX6Q_PAD_NANDF_ALE__USDHC4_RST,
-	/* eCSPI1 */
-	MX6Q_PAD_EIM_EB2__ECSPI1_SS0,
-	MX6Q_PAD_EIM_D16__ECSPI1_SCLK,
-	MX6Q_PAD_EIM_D17__ECSPI1_MISO,
-	MX6Q_PAD_EIM_D18__ECSPI1_MOSI,
-	MX6Q_PAD_EIM_D19__ECSPI1_SS1,
-	MX6Q_PAD_EIM_EB2__GPIO_2_30,	/*SS0*/
-	MX6Q_PAD_EIM_D19__GPIO_3_19,	/*SS1*/
-
-	/* ESAI */
-	MX6Q_PAD_ENET_RXD0__ESAI1_HCKT,
-	MX6Q_PAD_ENET_CRS_DV__ESAI1_SCKT,
-	MX6Q_PAD_ENET_RXD1__ESAI1_FST,
-	MX6Q_PAD_ENET_TX_EN__ESAI1_TX3_RX2,
-	MX6Q_PAD_ENET_TXD1__ESAI1_TX2_RX3,
-	MX6Q_PAD_ENET_TXD0__ESAI1_TX4_RX1,
-	MX6Q_PAD_ENET_MDC__ESAI1_TX5_RX0,
-	MX6Q_PAD_NANDF_CS2__ESAI1_TX0,
-	MX6Q_PAD_NANDF_CS3__ESAI1_TX1,
-
-	/* I2C1 */
-	MX6Q_PAD_CSI0_DAT8__I2C1_SDA,
-	MX6Q_PAD_CSI0_DAT9__I2C1_SCL,
-
-	/* I2C2 */
-	MX6Q_PAD_KEY_COL3__I2C2_SCL,
-	MX6Q_PAD_KEY_ROW3__I2C2_SDA,
-
-	/* DISPLAY */
-	MX6Q_PAD_DI0_DISP_CLK__IPU1_DI0_DISP_CLK,
-	MX6Q_PAD_DI0_PIN15__IPU1_DI0_PIN15,
-	MX6Q_PAD_DI0_PIN2__IPU1_DI0_PIN2,
-	MX6Q_PAD_DI0_PIN3__IPU1_DI0_PIN3,
-	MX6Q_PAD_DISP0_DAT0__IPU1_DISP0_DAT_0,
-	MX6Q_PAD_DISP0_DAT1__IPU1_DISP0_DAT_1,
-	MX6Q_PAD_DISP0_DAT2__IPU1_DISP0_DAT_2,
-	MX6Q_PAD_DISP0_DAT3__IPU1_DISP0_DAT_3,
-	MX6Q_PAD_DISP0_DAT4__IPU1_DISP0_DAT_4,
-	MX6Q_PAD_DISP0_DAT5__IPU1_DISP0_DAT_5,
-	MX6Q_PAD_DISP0_DAT6__IPU1_DISP0_DAT_6,
-	MX6Q_PAD_DISP0_DAT7__IPU1_DISP0_DAT_7,
-	MX6Q_PAD_DISP0_DAT8__IPU1_DISP0_DAT_8,
-	MX6Q_PAD_DISP0_DAT9__IPU1_DISP0_DAT_9,
-	MX6Q_PAD_DISP0_DAT10__IPU1_DISP0_DAT_10,
-	MX6Q_PAD_DISP0_DAT11__IPU1_DISP0_DAT_11,
-	MX6Q_PAD_DISP0_DAT12__IPU1_DISP0_DAT_12,
-	MX6Q_PAD_DISP0_DAT13__IPU1_DISP0_DAT_13,
-	MX6Q_PAD_DISP0_DAT14__IPU1_DISP0_DAT_14,
-	MX6Q_PAD_DISP0_DAT15__IPU1_DISP0_DAT_15,
-	MX6Q_PAD_DISP0_DAT16__IPU1_DISP0_DAT_16,
-	MX6Q_PAD_DISP0_DAT17__IPU1_DISP0_DAT_17,
-	MX6Q_PAD_DISP0_DAT18__IPU1_DISP0_DAT_18,
-	MX6Q_PAD_DISP0_DAT19__IPU1_DISP0_DAT_19,
-	MX6Q_PAD_DISP0_DAT20__IPU1_DISP0_DAT_20,
-	MX6Q_PAD_DISP0_DAT21__IPU1_DISP0_DAT_21,
-	MX6Q_PAD_DISP0_DAT22__IPU1_DISP0_DAT_22,
-	MX6Q_PAD_DISP0_DAT23__IPU1_DISP0_DAT_23,
-
-	MX6Q_PAD_EIM_D24__GPIO_3_24,
-
-	/* UART2 */
-	MX6Q_PAD_EIM_D26__UART2_RXD,
-	MX6Q_PAD_EIM_D27__UART2_TXD,
-	MX6Q_PAD_EIM_D28__UART2_RTS,
-	MX6Q_PAD_EIM_D29__UART2_CTS,
-
-	/* PWM1 */
-	MX6Q_PAD_GPIO_9__PWM1_PWMO,
-
-	/* DISP0 DET */
-	MX6Q_PAD_EIM_D31__GPIO_3_31,
-
-	/* DISP0 RESET */
-	MX6Q_PAD_EIM_WAIT__GPIO_5_0,
-
-	/* HDMI */
-	MX6Q_PAD_EIM_A25__HDMI_TX_CEC_LINE,
-	MX6Q_PAD_SD1_DAT1__HDMI_TX_OPHYDTB_0,
-	MX6Q_PAD_SD1_DAT0__HDMI_TX_OPHYDTB_1,
-
-	/* USBOTG ID pin */
-	MX6Q_PAD_GPIO_1__USBOTG_ID,
-
-	/* MLB150 */
-	MX6Q_PAD_GPIO_3__MLB_MLBCLK,
-	MX6Q_PAD_GPIO_6__MLB_MLBSIG,
-	MX6Q_PAD_GPIO_2__MLB_MLBDAT,
-};
-
-static iomux_v3_cfg_t mx6q_arm2_i2c3_pads[] = {
-	MX6Q_PAD_GPIO_5__I2C3_SCL,
-	MX6Q_PAD_GPIO_16__I2C3_SDA,
-};
-
-static iomux_v3_cfg_t mx6q_arm2_spdif_pads[] = {
-	/* SPDIF */
-	MX6Q_PAD_GPIO_16__SPDIF_IN1,
-	MX6Q_PAD_GPIO_17__SPDIF_OUT1,
-};
-
-static iomux_v3_cfg_t mx6q_arm2_can_pads[] = {
-	/* CAN1 */
-	MX6Q_PAD_GPIO_7__CAN1_TXCAN,
-	MX6Q_PAD_KEY_ROW2__CAN1_RXCAN,
-	MX6Q_PAD_GPIO_17__GPIO_7_12,	/* CAN1 STBY */
-	MX6Q_PAD_GPIO_18__GPIO_7_13,	/* CAN1 EN */
-
-	/* CAN2 */
-	MX6Q_PAD_KEY_COL4__CAN2_TXCAN,
-	MX6Q_PAD_KEY_ROW4__CAN2_RXCAN,
-	MX6Q_PAD_CSI0_DAT6__GPIO_5_24,	/* CAN2 EN */
-};
-
-static iomux_v3_cfg_t mx6q_arm2_esai_record_pads[] = {
-	MX6Q_PAD_ENET_RX_ER__ESAI1_HCKR,
-	MX6Q_PAD_ENET_MDIO__ESAI1_SCKR,
-	MX6Q_PAD_ENET_REF_CLK__ESAI1_FSR,
-};
-
-static iomux_v3_cfg_t mx6q_arm2_csi0_sensor_pads[] = {
-	MX6Q_PAD_GPIO_0__CCM_CLKO,
-	/* ipu1 csi0 */
-	MX6Q_PAD_CSI0_DAT12__IPU1_CSI0_D_12,
-	MX6Q_PAD_CSI0_DAT13__IPU1_CSI0_D_13,
-	MX6Q_PAD_CSI0_DAT14__IPU1_CSI0_D_14,
-	MX6Q_PAD_CSI0_DAT15__IPU1_CSI0_D_15,
-	MX6Q_PAD_CSI0_DAT16__IPU1_CSI0_D_16,
-	MX6Q_PAD_CSI0_DAT17__IPU1_CSI0_D_17,
-	MX6Q_PAD_CSI0_DAT18__IPU1_CSI0_D_18,
-	MX6Q_PAD_CSI0_DAT19__IPU1_CSI0_D_19,
-	MX6Q_PAD_CSI0_VSYNC__IPU1_CSI0_VSYNC,
-	MX6Q_PAD_CSI0_MCLK__IPU1_CSI0_HSYNC,
-	MX6Q_PAD_CSI0_PIXCLK__IPU1_CSI0_PIXCLK,
-	/* camera reset */
-	MX6Q_PAD_GPIO_19__GPIO_4_5,
-	/* camera powerdown */
-	MX6Q_PAD_CSI0_DAT5__GPIO_5_23,
-};
-
-static iomux_v3_cfg_t mx6q_arm2_csi0_tvin_pads[] = {
-	/* ipu1 csi0 */
-	MX6Q_PAD_CSI0_DAT12__IPU1_CSI0_D_12,
-	MX6Q_PAD_CSI0_DAT13__IPU1_CSI0_D_13,
-	MX6Q_PAD_CSI0_DAT14__IPU1_CSI0_D_14,
-	MX6Q_PAD_CSI0_DAT15__IPU1_CSI0_D_15,
-	MX6Q_PAD_CSI0_DAT16__IPU1_CSI0_D_16,
-	MX6Q_PAD_CSI0_DAT17__IPU1_CSI0_D_17,
-	MX6Q_PAD_CSI0_DAT18__IPU1_CSI0_D_18,
-	MX6Q_PAD_CSI0_DAT19__IPU1_CSI0_D_19,
-	MX6Q_PAD_CSI0_VSYNC__IPU1_CSI0_VSYNC,
-	MX6Q_PAD_CSI0_MCLK__IPU1_CSI0_HSYNC,
-	MX6Q_PAD_CSI0_PIXCLK__IPU1_CSI0_PIXCLK,
-	/* camera reset */
-	MX6Q_PAD_CSI0_DAT7__GPIO_5_25,
-	/* camera powerdown */
-	MX6Q_PAD_CSI0_DAT5__GPIO_5_23,
-};
-
-static iomux_v3_cfg_t mx6q_arm2_mipi_sensor_pads[] = {
-	MX6Q_PAD_CSI0_MCLK__CCM_CLKO,
-};
-
-static iomux_v3_cfg_t mx6q_arm2_audmux_pads[] = {
-
-	/* AUDMUX */
-	MX6Q_PAD_CSI0_DAT4__AUDMUX_AUD3_TXC,
-	MX6Q_PAD_CSI0_DAT5__AUDMUX_AUD3_TXD,
-	MX6Q_PAD_CSI0_DAT6__AUDMUX_AUD3_TXFS,
-	MX6Q_PAD_CSI0_DAT7__AUDMUX_AUD3_RXD,
-};
-
-#define MX6Q_USDHC_PAD_SETTING(id, speed)	\
-mx6q_sd##id##_##speed##mhz[] = {		\
-	MX6Q_PAD_SD##id##_CLK__USDHC##id##_CLK_##speed##MHZ,	\
-	MX6Q_PAD_SD##id##_CMD__USDHC##id##_CMD_##speed##MHZ,	\
-	MX6Q_PAD_SD##id##_DAT0__USDHC##id##_DAT0_##speed##MHZ,	\
-	MX6Q_PAD_SD##id##_DAT1__USDHC##id##_DAT1_##speed##MHZ,	\
-	MX6Q_PAD_SD##id##_DAT2__USDHC##id##_DAT2_##speed##MHZ,	\
-	MX6Q_PAD_SD##id##_DAT3__USDHC##id##_DAT3_##speed##MHZ,	\
-	MX6Q_PAD_SD##id##_DAT4__USDHC##id##_DAT4_##speed##MHZ,	\
-	MX6Q_PAD_SD##id##_DAT5__USDHC##id##_DAT5_##speed##MHZ,	\
-	MX6Q_PAD_SD##id##_DAT6__USDHC##id##_DAT6_##speed##MHZ,	\
-	MX6Q_PAD_SD##id##_DAT7__USDHC##id##_DAT7_##speed##MHZ,	\
-}
-
-static iomux_v3_cfg_t MX6Q_USDHC_PAD_SETTING(3, 50);
-static iomux_v3_cfg_t MX6Q_USDHC_PAD_SETTING(3, 100);
-static iomux_v3_cfg_t MX6Q_USDHC_PAD_SETTING(3, 200);
-static iomux_v3_cfg_t MX6Q_USDHC_PAD_SETTING(4, 50);
-static iomux_v3_cfg_t MX6Q_USDHC_PAD_SETTING(4, 100);
-static iomux_v3_cfg_t MX6Q_USDHC_PAD_SETTING(4, 200);
-
 enum sd_pad_mode {
 	SD_PAD_MODE_LOW_SPEED,
 	SD_PAD_MODE_MED_SPEED,
@@ -399,27 +128,53 @@ static int plt_sd3_pad_change(int clock)
 {
 	static enum sd_pad_mode pad_mode = SD_PAD_MODE_LOW_SPEED;
 
+	iomux_v3_cfg_t *sd3_pads_200mhz = NULL;
+	iomux_v3_cfg_t *sd3_pads_100mhz = NULL;
+	iomux_v3_cfg_t *sd3_pads_50mhz = NULL;
+
+	u32 sd3_pads_200mhz_cnt;
+	u32 sd3_pads_100mhz_cnt;
+	u32 sd3_pads_50mhz_cnt;
+
+	if (cpu_is_mx6q()) {
+		sd3_pads_200mhz = mx6q_sd3_200mhz;
+		sd3_pads_100mhz = mx6q_sd3_100mhz;
+		sd3_pads_50mhz = mx6q_sd3_50mhz;
+
+		sd3_pads_200mhz_cnt = ARRAY_SIZE(mx6q_sd3_200mhz);
+		sd3_pads_100mhz_cnt = ARRAY_SIZE(mx6q_sd3_100mhz);
+		sd3_pads_50mhz_cnt = ARRAY_SIZE(mx6q_sd3_50mhz);
+	} else if (cpu_is_mx6dl()) {
+		sd3_pads_200mhz = mx6dl_sd3_200mhz;
+		sd3_pads_100mhz = mx6dl_sd3_100mhz;
+		sd3_pads_50mhz = mx6dl_sd3_50mhz;
+
+		sd3_pads_200mhz_cnt = ARRAY_SIZE(mx6dl_sd3_200mhz);
+		sd3_pads_100mhz_cnt = ARRAY_SIZE(mx6dl_sd3_100mhz);
+		sd3_pads_50mhz_cnt = ARRAY_SIZE(mx6dl_sd3_50mhz);
+	}
+
 	if (clock > 100000000) {
 		if (pad_mode == SD_PAD_MODE_HIGH_SPEED)
 			return 0;
-
+		BUG_ON(!sd3_pads_200mhz);
 		pad_mode = SD_PAD_MODE_HIGH_SPEED;
-		return mxc_iomux_v3_setup_multiple_pads(mx6q_sd3_200mhz,
-					ARRAY_SIZE(mx6q_sd3_200mhz));
+		return mxc_iomux_v3_setup_multiple_pads(sd3_pads_200mhz,
+							sd3_pads_200mhz_cnt);
 	} else if (clock > 52000000) {
 		if (pad_mode == SD_PAD_MODE_MED_SPEED)
 			return 0;
-
+		BUG_ON(!sd3_pads_100mhz);
 		pad_mode = SD_PAD_MODE_MED_SPEED;
-		return mxc_iomux_v3_setup_multiple_pads(mx6q_sd3_100mhz,
-					ARRAY_SIZE(mx6q_sd3_100mhz));
+		return mxc_iomux_v3_setup_multiple_pads(sd3_pads_100mhz,
+							sd3_pads_100mhz_cnt);
 	} else {
 		if (pad_mode == SD_PAD_MODE_LOW_SPEED)
 			return 0;
-
+		BUG_ON(!sd3_pads_50mhz);
 		pad_mode = SD_PAD_MODE_LOW_SPEED;
-		return mxc_iomux_v3_setup_multiple_pads(mx6q_sd3_50mhz,
-					ARRAY_SIZE(mx6q_sd3_50mhz));
+		return mxc_iomux_v3_setup_multiple_pads(sd3_pads_50mhz,
+							sd3_pads_50mhz_cnt);
 	}
 }
 
@@ -427,79 +182,93 @@ static int plt_sd4_pad_change(int clock)
 {
 	static enum sd_pad_mode pad_mode = SD_PAD_MODE_LOW_SPEED;
 
+	iomux_v3_cfg_t *sd4_pads_200mhz = NULL;
+	iomux_v3_cfg_t *sd4_pads_100mhz = NULL;
+	iomux_v3_cfg_t *sd4_pads_50mhz = NULL;
+
+	u32 sd4_pads_200mhz_cnt;
+	u32 sd4_pads_100mhz_cnt;
+	u32 sd4_pads_50mhz_cnt;
+
+	if (cpu_is_mx6q()) {
+		sd4_pads_200mhz = mx6q_sd4_200mhz;
+		sd4_pads_100mhz = mx6q_sd4_100mhz;
+		sd4_pads_50mhz = mx6q_sd4_50mhz;
+
+		sd4_pads_200mhz_cnt = ARRAY_SIZE(mx6q_sd4_200mhz);
+		sd4_pads_100mhz_cnt = ARRAY_SIZE(mx6q_sd4_100mhz);
+		sd4_pads_50mhz_cnt = ARRAY_SIZE(mx6q_sd4_50mhz);
+	} else if (cpu_is_mx6dl()) {
+		sd4_pads_200mhz = mx6dl_sd4_200mhz;
+		sd4_pads_100mhz = mx6dl_sd4_100mhz;
+		sd4_pads_50mhz = mx6dl_sd4_50mhz;
+
+		sd4_pads_200mhz_cnt = ARRAY_SIZE(mx6dl_sd4_200mhz);
+		sd4_pads_100mhz_cnt = ARRAY_SIZE(mx6dl_sd4_100mhz);
+		sd4_pads_50mhz_cnt = ARRAY_SIZE(mx6dl_sd4_50mhz);
+	}
+
 	if (clock > 100000000) {
 		if (pad_mode == SD_PAD_MODE_HIGH_SPEED)
 			return 0;
 
 		pad_mode = SD_PAD_MODE_HIGH_SPEED;
-		return mxc_iomux_v3_setup_multiple_pads(mx6q_sd4_200mhz,
-					ARRAY_SIZE(mx6q_sd4_200mhz));
+		return mxc_iomux_v3_setup_multiple_pads(sd4_pads_200mhz,
+							sd4_pads_200mhz_cnt);
 	} else if (clock > 52000000) {
 		if (pad_mode == SD_PAD_MODE_MED_SPEED)
 			return 0;
 
 		pad_mode = SD_PAD_MODE_MED_SPEED;
-		return mxc_iomux_v3_setup_multiple_pads(mx6q_sd4_100mhz,
-					ARRAY_SIZE(mx6q_sd4_100mhz));
+		return mxc_iomux_v3_setup_multiple_pads(sd4_pads_100mhz,
+							sd4_pads_100mhz_cnt);
 	} else {
 		if (pad_mode == SD_PAD_MODE_LOW_SPEED)
 			return 0;
 
 		pad_mode = SD_PAD_MODE_LOW_SPEED;
-		return mxc_iomux_v3_setup_multiple_pads(mx6q_sd4_50mhz,
-					ARRAY_SIZE(mx6q_sd4_50mhz));
+		return mxc_iomux_v3_setup_multiple_pads(sd4_pads_50mhz,
+							sd4_pads_50mhz_cnt);
 	}
 }
 
-static const struct esdhc_platform_data mx6q_arm2_sd3_data __initconst = {
-	.cd_gpio = MX6Q_ARM2_SD3_CD,
-	.wp_gpio = MX6Q_ARM2_SD3_WP,
-	.support_18v = 1,
-	.support_8bit = 1,
-	.keep_power_at_suspend = 1,
-	.delay_line = 0,
-	.platform_pad_change = plt_sd3_pad_change,
-};
-
-/* No card detect signal for SD4 */
-static const struct esdhc_platform_data mx6q_arm2_sd4_data __initconst = {
-	.always_present = 1,
-	.support_8bit = 1,
-	.keep_power_at_suspend = 1,
-	.platform_pad_change = plt_sd4_pad_change,
-};
-
-/* The GPMI is conflicted with SD3, so init this in the driver. */
-static iomux_v3_cfg_t mx6q_gpmi_nand[] __initdata = {
-	MX6Q_PAD_NANDF_CLE__RAWNAND_CLE,
-	MX6Q_PAD_NANDF_ALE__RAWNAND_ALE,
-	MX6Q_PAD_NANDF_CS0__RAWNAND_CE0N,
-	MX6Q_PAD_NANDF_CS1__RAWNAND_CE1N,
-	MX6Q_PAD_NANDF_CS2__RAWNAND_CE2N,
-	MX6Q_PAD_NANDF_CS3__RAWNAND_CE3N,
-	MX6Q_PAD_NANDF_RB0__RAWNAND_READY0,
-	MX6Q_PAD_SD4_DAT0__RAWNAND_DQS,
-	MX6Q_PAD_NANDF_D0__RAWNAND_D0,
-	MX6Q_PAD_NANDF_D1__RAWNAND_D1,
-	MX6Q_PAD_NANDF_D2__RAWNAND_D2,
-	MX6Q_PAD_NANDF_D3__RAWNAND_D3,
-	MX6Q_PAD_NANDF_D4__RAWNAND_D4,
-	MX6Q_PAD_NANDF_D5__RAWNAND_D5,
-	MX6Q_PAD_NANDF_D6__RAWNAND_D6,
-	MX6Q_PAD_NANDF_D7__RAWNAND_D7,
-	MX6Q_PAD_SD4_CMD__RAWNAND_RDN,
-	MX6Q_PAD_SD4_CLK__RAWNAND_WRN,
-	MX6Q_PAD_NANDF_WP_B__RAWNAND_RESETN,
+static const struct esdhc_platform_data mx6_arm2_sd3_data __initconst = {
+	.cd_gpio		= MX6_ARM2_SD3_CD,
+	.wp_gpio		= MX6_ARM2_SD3_WP,
+	.support_18v		= 1,
+	.support_8bit		= 1,
+	.keep_power_at_suspend	= 1,
+	.delay_line		= 0,
+	.platform_pad_change	= plt_sd3_pad_change,
+};
+
+/* No card detect signal for SD4 on ARM2 board*/
+static const struct esdhc_platform_data mx6_arm2_sd4_data __initconst = {
+	.always_present		= 1,
+	.support_8bit		= 1,
+	.keep_power_at_suspend	= 1,
+	.platform_pad_change	= plt_sd4_pad_change,
 };
 
 static int gpmi_nand_platform_init(void)
 {
-	return mxc_iomux_v3_setup_multiple_pads(mx6q_gpmi_nand,
-					ARRAY_SIZE(mx6q_gpmi_nand));
+	iomux_v3_cfg_t *nand_pads = NULL;
+	u32 nand_pads_cnt;
+
+	if (cpu_is_mx6q()) {
+		nand_pads = mx6q_gpmi_nand;
+		nand_pads_cnt = ARRAY_SIZE(mx6dl_gpmi_nand);
+	} else if (cpu_is_mx6dl()) {
+		nand_pads = mx6dl_gpmi_nand;
+		nand_pads_cnt = ARRAY_SIZE(mx6dl_gpmi_nand);
+
+	}
+	BUG_ON(!nand_pads);
+	return mxc_iomux_v3_setup_multiple_pads(nand_pads, nand_pads_cnt);
 }
 
 static const struct gpmi_nand_platform_data
-mx6q_gpmi_nand_platform_data __initconst = {
+mx6_gpmi_nand_platform_data __initconst = {
 	.platform_init           = gpmi_nand_platform_init,
 	.min_prop_delay_in_ns    = 5,
 	.max_prop_delay_in_ns    = 9,
@@ -507,23 +276,23 @@ mx6q_gpmi_nand_platform_data __initconst = {
 };
 
 static const struct anatop_thermal_platform_data
-	mx6q_arm2_anatop_thermal_data __initconst = {
+	mx6_arm2_anatop_thermal_data __initconst = {
 	.name = "anatop_thermal",
 };
 
-static const struct imxuart_platform_data mx6q_uart1_data __initconst = {
-	.flags = IMXUART_HAVE_RTSCTS | IMXUART_USE_DCEDTE | IMXUART_SDMA,
+static const struct imxuart_platform_data mx6_arm2_uart1_data __initconst = {
+	.flags      = IMXUART_HAVE_RTSCTS | IMXUART_USE_DCEDTE | IMXUART_SDMA,
 	.dma_req_rx = MX6Q_DMA_REQ_UART2_RX,
 	.dma_req_tx = MX6Q_DMA_REQ_UART2_TX,
 };
 
-static inline void mx6q_arm2_init_uart(void)
+static inline void mx6_arm2_init_uart(void)
 {
 	imx6q_add_imx_uart(3, NULL);
-	imx6q_add_imx_uart(1, &mx6q_uart1_data);
+	imx6q_add_imx_uart(1, &mx6_arm2_uart1_data);
 }
 
-static int mx6q_arm2_fec_phy_init(struct phy_device *phydev)
+static int mx6_arm2_fec_phy_init(struct phy_device *phydev)
 {
 	unsigned short val;
 
@@ -550,7 +319,7 @@ static int mx6q_arm2_fec_phy_init(struct phy_device *phydev)
 	return 0;
 }
 
-static int mx6q_arm2_fec_power_hibernate(struct phy_device *phydev)
+static int mx6_arm2_fec_power_hibernate(struct phy_device *phydev)
 {
 	unsigned short val;
 
@@ -565,52 +334,51 @@ static int mx6q_arm2_fec_power_hibernate(struct phy_device *phydev)
 }
 
 static struct fec_platform_data fec_data __initdata = {
-	.init = mx6q_arm2_fec_phy_init,
-	.power_hibernate = mx6q_arm2_fec_power_hibernate,
-	.phy = PHY_INTERFACE_MODE_RGMII,
+	.init			= mx6_arm2_fec_phy_init,
+	.power_hibernate	= mx6_arm2_fec_power_hibernate,
+	.phy			= PHY_INTERFACE_MODE_RGMII,
 };
 
-static int mx6q_arm2_spi_cs[] = {
-	MX6Q_ARM2_ECSPI1_CS0,
-	MX6Q_ARM2_ECSPI1_CS1,
+static int mx6_arm2_spi_cs[] = {
+	MX6_ARM2_ECSPI1_CS0,
+	MX6_ARM2_ECSPI1_CS1,
 };
 
-static const struct spi_imx_master mx6q_arm2_spi_data __initconst = {
-	.chipselect     = mx6q_arm2_spi_cs,
-	.num_chipselect = ARRAY_SIZE(mx6q_arm2_spi_cs),
+static const struct spi_imx_master mx6_arm2_spi_data __initconst = {
+	.chipselect     = mx6_arm2_spi_cs,
+	.num_chipselect = ARRAY_SIZE(mx6_arm2_spi_cs),
 };
 
 #if defined(CONFIG_MTD_M25P80) || defined(CONFIG_MTD_M25P80_MODULE)
 static struct mtd_partition m25p32_partitions[] = {
 	{
-		.name = "bootloader",
-		.offset = 0,
-		.size = 0x00040000,
-	},
-	{
-		.name = "kernel",
-		.offset = MTDPART_OFS_APPEND,
-		.size = MTDPART_SIZ_FULL,
+		.name	= "bootloader",
+		.offset	= 0,
+		.size	= 0x00040000,
+	}, {
+		.name	= "kernel",
+		.offset	= MTDPART_OFS_APPEND,
+		.size	= MTDPART_SIZ_FULL,
 	},
 };
 
 static struct flash_platform_data m25p32_spi_flash_data = {
-	.name = "m25p32",
-	.parts = m25p32_partitions,
-	.nr_parts = ARRAY_SIZE(m25p32_partitions),
-	.type = "m25p32",
+	.name		= "m25p32",
+	.parts		= m25p32_partitions,
+	.nr_parts	= ARRAY_SIZE(m25p32_partitions),
+	.type		= "m25p32",
 };
 #endif
 
 static struct spi_board_info m25p32_spi0_board_info[] __initdata = {
 #if defined(CONFIG_MTD_M25P80)
 	{
-		/* The modalias must be the same as spi device driver name */
-		.modalias = "m25p80",
-		.max_speed_hz = 20000000,
-		.bus_num = 0,
-		.chip_select = 1,
-		.platform_data = &m25p32_spi_flash_data,
+	/* The modalias must be the same as spi device driver name */
+	.modalias	= "m25p80",
+	.max_speed_hz	= 20000000,
+	.bus_num	= 0,
+	.chip_select	= 1,
+	.platform_data	= &m25p32_spi_flash_data,
 	},
 #endif
 };
@@ -625,9 +393,7 @@ static int max7310_1_setup(struct i2c_client *client,
 	unsigned gpio_base, unsigned ngpio,
 	void *context)
 {
-	int max7310_gpio_value[] = {
-		0, 1, 0, 1, 0, 0, 0, 0,
-	};
+	int max7310_gpio_value[] = { 0, 1, 0, 1, 0, 0, 0, 0 };
 
 	int n;
 
@@ -645,7 +411,7 @@ static int max7310_1_setup(struct i2c_client *client,
 }
 
 static struct pca953x_platform_data max7310_platdata = {
-	.gpio_base	= MX6Q_ARM2_MAX7310_1_BASE_ADDR,
+	.gpio_base	= MX6_ARM2_MAX7310_1_BASE_ADDR,
 	.invert		= 0,
 	.setup		= max7310_1_setup,
 };
@@ -654,9 +420,7 @@ static int max7310_u48_setup(struct i2c_client *client,
 	unsigned gpio_base, unsigned ngpio,
 	void *context)
 {
-	int max7310_gpio_value[] = {
-		1, 1, 1, 1, 0, 1, 0, 0,
-	};
+	int max7310_gpio_value[] = { 1, 1, 1, 1, 0, 1, 0, 0 };
 
 	int n;
 
@@ -674,7 +438,7 @@ static int max7310_u48_setup(struct i2c_client *client,
 }
 
 static struct pca953x_platform_data max7310_u48_platdata = {
-	.gpio_base	= MX6Q_ARM2_MAX7310_2_BASE_ADDR,
+	.gpio_base	= MX6_ARM2_MAX7310_2_BASE_ADDR,
 	.invert		= 0,
 	.setup		= max7310_u48_setup,
 };
@@ -682,46 +446,59 @@ static struct pca953x_platform_data max7310_u48_platdata = {
 static void ddc_dvi_init(void)
 {
 	/* enable DVI I2C */
-	gpio_set_value(MX6Q_ARM2_DISP0_I2C_EN, 1);
+	gpio_set_value(MX6_ARM2_DISP0_I2C_EN, 1);
 
 	/* DISP0 Detect */
-	gpio_request(MX6Q_ARM2_DISP0_DET_INT, "disp0-detect");
-	gpio_direction_input(MX6Q_ARM2_DISP0_DET_INT);
+	gpio_request(MX6_ARM2_DISP0_DET_INT, "disp0-detect");
+	gpio_direction_input(MX6_ARM2_DISP0_DET_INT);
 }
 
 static int ddc_dvi_update(void)
 {
 	/* DVI cable state */
-	if (gpio_get_value(MX6Q_ARM2_DISP0_DET_INT) == 1)
+	if (gpio_get_value(MX6_ARM2_DISP0_DET_INT) == 1)
 		return 1;
-	else
-		return 0;
+	return 0;
 }
 
 static struct fsl_mxc_dvi_platform_data sabr_ddc_dvi_data = {
-	.ipu_id = 0,
-	.disp_id = 0,
-	.init = ddc_dvi_init,
-	.update = ddc_dvi_update,
+	.ipu_id		= 0,
+	.disp_id	= 0,
+	.init		= ddc_dvi_init,
+	.update		= ddc_dvi_update,
 };
 
-static void mx6q_csi0_io_init(void)
+static void mx6_csi0_io_init(void)
 {
 	if (0 == sgtl5000_en) {
-		mxc_iomux_v3_setup_multiple_pads(mx6q_arm2_csi0_sensor_pads,
-			ARRAY_SIZE(mx6q_arm2_csi0_sensor_pads));
+		iomux_v3_cfg_t *sensor_pads = NULL;
+		u32 sensor_pads_cnt;
+
+		if (cpu_is_mx6q()) {
+			sensor_pads = mx6q_arm2_csi0_sensor_pads;
+			sensor_pads_cnt = \
+				ARRAY_SIZE(mx6q_arm2_csi0_sensor_pads);
+		} else if (cpu_is_mx6dl()) {
+			sensor_pads = mx6dl_arm2_csi0_sensor_pads;
+			sensor_pads_cnt = \
+				ARRAY_SIZE(mx6dl_arm2_csi0_sensor_pads);
+		}
+
+		BUG_ON(!sensor_pads);
+		mxc_iomux_v3_setup_multiple_pads(sensor_pads, sensor_pads_cnt);
 	}
 	/* Camera reset */
-	gpio_request(MX6Q_ARM2_CSI0_RST, "cam-reset");
-	gpio_direction_output(MX6Q_ARM2_CSI0_RST, 1);
+	gpio_request(MX6_ARM2_CSI0_RST, "cam-reset");
+	gpio_direction_output(MX6_ARM2_CSI0_RST, 1);
 
 	/* Camera power down */
-	gpio_request(MX6Q_ARM2_CSI0_PWN, "cam-pwdn");
-	gpio_direction_output(MX6Q_ARM2_CSI0_PWN, 1);
+	gpio_request(MX6_ARM2_CSI0_PWN, "cam-pwdn");
+	gpio_direction_output(MX6_ARM2_CSI0_PWN, 1);
 	msleep(1);
-	gpio_set_value(MX6Q_ARM2_CSI0_PWN, 0);
+	gpio_set_value(MX6_ARM2_CSI0_PWN, 0);
 
-	/* For MX6Q GPR1 bit19 and bit20 meaning:
+	/* For MX6Q:
+	 * GPR1 bit19 and bit20 meaning:
 	 * Bit19:       0 - Enable mipi to IPU1 CSI0
 	 *                      virtual channel is fixed to 0
 	 *              1 - Enable parallel interface to IPU1 CSI0
@@ -732,79 +509,114 @@ static void mx6q_csi0_io_init(void)
 	 *      virtual channel is fixed to 1
 	 * IPU2 CSI0 directly connect to mipi csi2,
 	 *      virtual channel is fixed to 2
+	 *
+	 * For MX6DL:
+	 * GPR1 bit 21 and GPR13 bit 0-5, RM has detail information
 	 */
-	mxc_iomux_set_gpr_register(1, 19, 1, 1);
+	if (cpu_is_mx6q())
+		mxc_iomux_set_gpr_register(1, 19, 1, 1);
+	else if (cpu_is_mx6dl())
+		mxc_iomux_set_gpr_register(13, 0, 3, 4);
 }
 
 static struct fsl_mxc_camera_platform_data camera_data = {
-	.analog_regulator = "DA9052_LDO7",
-	.core_regulator = "DA9052_LDO9",
-	.mclk = 24000000,
-	.csi = 0,
-	.io_init = mx6q_csi0_io_init,
+	.analog_regulator	= "DA9052_LDO7",
+	.core_regulator		= "DA9052_LDO9",
+	.mclk			= 24000000,
+	.csi			= 0,
+	.io_init		= mx6_csi0_io_init,
 };
 
-static void mx6q_csi0_tvin_io_init(void)
+static void mx6_csi0_tvin_io_init(void)
 {
 	if (0 == sgtl5000_en) {
-		mxc_iomux_v3_setup_multiple_pads(mx6q_arm2_csi0_tvin_pads,
-			ARRAY_SIZE(mx6q_arm2_csi0_tvin_pads));
+		iomux_v3_cfg_t *tvin_pads = NULL;
+		u32 tvin_pads_cnt;
+
+		if (cpu_is_mx6q()) {
+			tvin_pads = mx6q_arm2_csi0_tvin_pads;
+			tvin_pads_cnt = \
+				ARRAY_SIZE(mx6q_arm2_csi0_tvin_pads);
+		} else if (cpu_is_mx6dl()) {
+			tvin_pads = mx6dl_arm2_csi0_tvin_pads;
+			tvin_pads_cnt = \
+				ARRAY_SIZE(mx6dl_arm2_csi0_tvin_pads);
+		}
+
+		BUG_ON(!tvin_pads);
+		mxc_iomux_v3_setup_multiple_pads(tvin_pads, tvin_pads_cnt);
 	}
 	/* Tvin reset */
-	gpio_request(MX6Q_ARM2_CSI0_RST_TVIN, "tvin-reset");
-	gpio_direction_output(MX6Q_ARM2_CSI0_RST_TVIN, 1);
+	gpio_request(MX6_ARM2_CSI0_RST_TVIN, "tvin-reset");
+	gpio_direction_output(MX6_ARM2_CSI0_RST_TVIN, 1);
 
 	/* Tvin power down */
-	gpio_request(MX6Q_ARM2_CSI0_PWN, "cam-pwdn");
-	gpio_direction_output(MX6Q_ARM2_CSI0_PWN, 0);
+	gpio_request(MX6_ARM2_CSI0_PWN, "cam-pwdn");
+	gpio_direction_output(MX6_ARM2_CSI0_PWN, 0);
 	msleep(1);
-	gpio_set_value(MX6Q_ARM2_CSI0_PWN, 1);
+	gpio_set_value(MX6_ARM2_CSI0_PWN, 1);
 
-	mxc_iomux_set_gpr_register(1, 19, 1, 1);
+	if (cpu_is_mx6q())
+		mxc_iomux_set_gpr_register(1, 19, 1, 1);
+	else if (cpu_is_mx6dl())
+		mxc_iomux_set_gpr_register(13, 0, 3, 4);
 }
 
 static struct fsl_mxc_tvin_platform_data tvin_data = {
-	.io_init = mx6q_csi0_tvin_io_init,
+	.io_init = mx6_csi0_tvin_io_init,
 	.cvbs = false,
 };
 
-static void mx6q_mipi_sensor_io_init(void)
+static void mx6_mipi_sensor_io_init(void)
 {
-	mxc_iomux_v3_setup_multiple_pads(mx6q_arm2_mipi_sensor_pads,
-			ARRAY_SIZE(mx6q_arm2_mipi_sensor_pads));
+	iomux_v3_cfg_t *mipi_sensor_pads = NULL;
+	u32 mipi_sensor_pads_cnt;
+
+	if (cpu_is_mx6q()) {
+		mipi_sensor_pads = mx6q_arm2_mipi_sensor_pads;
+		mipi_sensor_pads_cnt = ARRAY_SIZE(mx6dl_gpmi_nand);
+	} else if (cpu_is_mx6dl()) {
+		mipi_sensor_pads = mx6dl_arm2_mipi_sensor_pads;
+		mipi_sensor_pads_cnt = ARRAY_SIZE(mx6dl_arm2_mipi_sensor_pads);
 
-	mxc_iomux_set_gpr_register(1, 19, 1, 0);
+	}
+	BUG_ON(!mipi_sensor_pads);
+	mxc_iomux_v3_setup_multiple_pads(mipi_sensor_pads,
+					mipi_sensor_pads_cnt);
+
+	if (cpu_is_mx6q())
+		mxc_iomux_set_gpr_register(1, 19, 1, 0);
+	if (cpu_is_mx6dl())
+		mxc_iomux_set_gpr_register(13, 0, 3, 0);
 }
 
 static struct fsl_mxc_camera_platform_data ov5640_mipi_data = {
-	.mclk = 24000000,
-	.csi = 0,
-	.io_init = mx6q_mipi_sensor_io_init,
+	.mclk		= 24000000,
+	.csi		= 0,
+	.io_init	= mx6_mipi_sensor_io_init,
 };
 
 static struct i2c_board_info mxc_i2c0_board_info[] __initdata = {
 	{
 		I2C_BOARD_INFO("cs42888", 0x48),
-	},
-	{
+	}, {
 		I2C_BOARD_INFO("ov5640", 0x3c),
 		.platform_data = (void *)&camera_data,
-	},
-	{
+	}, {
 		I2C_BOARD_INFO("adv7180", 0x21),
 		.platform_data = (void *)&tvin_data,
 	},
 };
 
-static struct imxi2c_platform_data mx6q_arm2_i2c0_data = {
+static struct imxi2c_platform_data mx6_arm2_i2c0_data = {
 	.bitrate = 100000,
 };
 
-static struct imxi2c_platform_data mx6q_arm2_i2c1_data = {
+static struct imxi2c_platform_data mx6_arm2_i2c1_data = {
 	.bitrate = 100000,
 };
 
-static struct imxi2c_platform_data mx6q_arm2_i2c2_data = {
+static struct imxi2c_platform_data mx6_arm2_i2c2_data = {
 	.bitrate = 400000,
 };
 
@@ -812,19 +624,16 @@ static struct i2c_board_info mxc_i2c2_board_info[] __initdata = {
 	{
 		I2C_BOARD_INFO("max7310", 0x1F),
 		.platform_data = &max7310_platdata,
-	},
-	{
+	}, {
 		I2C_BOARD_INFO("max7310", 0x1B),
 		.platform_data = &max7310_u48_platdata,
-	},
-	{
+	}, {
 		I2C_BOARD_INFO("mxc_dvi", 0x50),
 		.platform_data = &sabr_ddc_dvi_data,
-		.irq = gpio_to_irq(MX6Q_ARM2_DISP0_DET_INT),
-	},
-	{
+		.irq = gpio_to_irq(MX6_ARM2_DISP0_DET_INT),
+	}, {
 		I2C_BOARD_INFO("egalax_ts", 0x4),
-		.irq = gpio_to_irq(MX6Q_ARM2_CAP_TCH_INT),
+		.irq = gpio_to_irq(MX6_ARM2_CAP_TCH_INT),
 	},
 
 };
@@ -832,47 +641,44 @@ static struct i2c_board_info mxc_i2c2_board_info[] __initdata = {
 static struct i2c_board_info mxc_i2c1_board_info[] __initdata = {
 	{
 		I2C_BOARD_INFO("egalax_ts", 0x4),
-		.irq = gpio_to_irq(MX6Q_ARM2_CAP_TCH_INT),
-	},
-	{
+		.irq = gpio_to_irq(MX6_ARM2_CAP_TCH_INT),
+	}, {
 		I2C_BOARD_INFO("mxc_hdmi_i2c", 0x50),
-	},
-	{
+	}, {
 		I2C_BOARD_INFO("ov5640_mipi", 0x3c),
 		.platform_data = (void *)&ov5640_mipi_data,
-	},
-	{
+	}, {
 		I2C_BOARD_INFO("sgtl5000", 0x0a),
 	},
 };
 
-static void imx6q_arm2_usbotg_vbus(bool on)
+static void imx6_arm2_usbotg_vbus(bool on)
 {
 	if (on)
-		gpio_set_value(MX6Q_ARM2_USB_OTG_PWR, 1);
+		gpio_set_value(MX6_ARM2_USB_OTG_PWR, 1);
 	else
-		gpio_set_value(MX6Q_ARM2_USB_OTG_PWR, 0);
+		gpio_set_value(MX6_ARM2_USB_OTG_PWR, 0);
 }
 
-static void __init imx6q_arm2_init_usb(void)
+static void __init mx6_arm2_init_usb(void)
 {
 	int ret = 0;
 
 	imx_otg_base = MX6_IO_ADDRESS(MX6Q_USB_OTG_BASE_ADDR);
+
 	/* disable external charger detect,
 	 * or it will affect signal quality at dp.
 	 */
 
-	ret = gpio_request(MX6Q_ARM2_USB_OTG_PWR, "usb-pwr");
+	ret = gpio_request(MX6_ARM2_USB_OTG_PWR, "usb-pwr");
 	if (ret) {
-		printk(KERN_ERR"failed to get GPIO MX6Q_ARM2_USB_OTG_PWR:"
-			" %d\n", ret);
+		pr_err("failed to get GPIO MX6_ARM2_USB_OTG_PWR:%d\n", ret);
 		return;
 	}
-	gpio_direction_output(MX6Q_ARM2_USB_OTG_PWR, 0);
+	gpio_direction_output(MX6_ARM2_USB_OTG_PWR, 0);
 	mxc_iomux_set_gpr_register(1, 13, 1, 1);
 
-	mx6_set_otghost_vbus_func(imx6q_arm2_usbotg_vbus);
+	mx6_set_otghost_vbus_func(imx6_arm2_usbotg_vbus);
 	mx6_usb_dr_init();
 	mx6_usb_h1_init();
 #ifdef CONFIG_USB_EHCI_ARC_HSIC
@@ -881,20 +687,20 @@ static void __init imx6q_arm2_init_usb(void)
 #endif
 }
 
-static struct viv_gpu_platform_data imx6q_gpu_pdata __initdata = {
+static struct viv_gpu_platform_data imx6_gpu_pdata __initdata = {
 	.reserved_mem_size = SZ_128M,
 };
 
 /* HW Initialization, if return 0, initialization is successful. */
-static int mx6q_arm2_sata_init(struct device *dev, void __iomem *addr)
+static int mx6_arm2_sata_init(struct device *dev, void __iomem *addr)
 {
 	u32 tmpdata;
 	int ret = 0;
 	struct clk *clk;
 
 	/* Enable SATA PWR CTRL_0 of MAX7310 */
-	gpio_request(MX6Q_ARM2_MAX7310_1_BASE_ADDR, "SATA_PWR_EN");
-	gpio_direction_output(MX6Q_ARM2_MAX7310_1_BASE_ADDR, 1);
+	gpio_request(MX6_ARM2_MAX7310_1_BASE_ADDR, "SATA_PWR_EN");
+	gpio_direction_output(MX6_ARM2_MAX7310_1_BASE_ADDR, 1);
 
 	sata_clk = clk_get(dev, "imx_sata_clk");
 	if (IS_ERR(sata_clk)) {
@@ -947,41 +753,41 @@ release_sata_clk:
 put_sata_clk:
 	clk_put(sata_clk);
 	/* Disable SATA PWR CTRL_0 of MAX7310 */
-	gpio_request(MX6Q_ARM2_MAX7310_1_BASE_ADDR, "SATA_PWR_EN");
-	gpio_direction_output(MX6Q_ARM2_MAX7310_1_BASE_ADDR, 0);
+	gpio_request(MX6_ARM2_MAX7310_1_BASE_ADDR, "SATA_PWR_EN");
+	gpio_direction_output(MX6_ARM2_MAX7310_1_BASE_ADDR, 0);
 
 	return ret;
 }
 
-static void mx6q_arm2_sata_exit(struct device *dev)
+static void mx6_arm2_sata_exit(struct device *dev)
 {
 	clk_disable(sata_clk);
 	clk_put(sata_clk);
 
 	/* Disable SATA PWR CTRL_0 of MAX7310 */
-	gpio_request(MX6Q_ARM2_MAX7310_1_BASE_ADDR, "SATA_PWR_EN");
-	gpio_direction_output(MX6Q_ARM2_MAX7310_1_BASE_ADDR, 0);
+	gpio_request(MX6_ARM2_MAX7310_1_BASE_ADDR, "SATA_PWR_EN");
+	gpio_direction_output(MX6_ARM2_MAX7310_1_BASE_ADDR, 0);
 
 }
 
-static struct ahci_platform_data mx6q_arm2_sata_data = {
-	.init = mx6q_arm2_sata_init,
-	.exit = mx6q_arm2_sata_exit,
+static struct ahci_platform_data mx6_arm2_sata_data = {
+	.init	= mx6_arm2_sata_init,
+	.exit	= mx6_arm2_sata_exit,
 };
 
 static struct imx_asrc_platform_data imx_asrc_data = {
-	.channel_bits = 4,
-	.clk_map_ver = 2,
+	.channel_bits	= 4,
+	.clk_map_ver	= 2,
 };
 
-static void mx6q_sabreauto_reset_mipi_dsi(void)
+static void mx6_arm2_reset_mipi_dsi(void)
 {
-	gpio_set_value(MX6Q_ARM2_DISP0_PWR, 1);
-	gpio_set_value(MX6Q_ARM2_DISP0_RESET, 1);
+	gpio_set_value(MX6_ARM2_DISP0_PWR, 1);
+	gpio_set_value(MX6_ARM2_DISP0_RESET, 1);
 	udelay(10);
-	gpio_set_value(MX6Q_ARM2_DISP0_RESET, 0);
+	gpio_set_value(MX6_ARM2_DISP0_RESET, 0);
 	udelay(50);
-	gpio_set_value(MX6Q_ARM2_DISP0_RESET, 1);
+	gpio_set_value(MX6_ARM2_DISP0_RESET, 1);
 
 	/*
 	 * it needs to delay 120ms minimum for reset complete
@@ -990,148 +796,147 @@ static void mx6q_sabreauto_reset_mipi_dsi(void)
 }
 
 static struct mipi_dsi_platform_data mipi_dsi_pdata = {
-	.ipu_id	 = 1,
-	.disp_id = 1,
-	.lcd_panel = "TRULY-WVGA",
-	.reset   = mx6q_sabreauto_reset_mipi_dsi,
+	.ipu_id		= 1,
+	.disp_id	= 1,
+	.lcd_panel	= "TRULY-WVGA",
+	.reset		= mx6_arm2_reset_mipi_dsi,
 };
 
 static struct ipuv3_fb_platform_data sabr_fb_data[] = {
 	{ /*fb0*/
-	.disp_dev = "ldb",
-	.interface_pix_fmt = IPU_PIX_FMT_RGB666,
-	.mode_str = "LDB-XGA",
-	.default_bpp = 16,
-	.int_clk = false,
+	.disp_dev		= "ldb",
+	.interface_pix_fmt	= IPU_PIX_FMT_RGB666,
+	.mode_str		= "LDB-XGA",
+	.default_bpp		= 16,
+	.int_clk		= false,
 	}, {
-	.disp_dev = "mipi_dsi",
-	.interface_pix_fmt = IPU_PIX_FMT_RGB24,
-	.mode_str = "TRULY-WVGA",
-	.default_bpp = 24,
-	.int_clk = false,
+	.disp_dev		= "mipi_dsi",
+	.interface_pix_fmt	= IPU_PIX_FMT_RGB24,
+	.mode_str		= "TRULY-WVGA",
+	.default_bpp		= 24,
+	.int_clk		= false,
 	}, {
-	.disp_dev = "ldb",
-	.interface_pix_fmt = IPU_PIX_FMT_RGB666,
-	.mode_str = "LDB-XGA",
-	.default_bpp = 16,
-	.int_clk = false,
+	.disp_dev		= "ldb",
+	.interface_pix_fmt	= IPU_PIX_FMT_RGB666,
+	.mode_str		= "LDB-XGA",
+	.default_bpp		= 16,
+	.int_clk		= false,
 	}, {
-	.disp_dev = "lcd",
-	.interface_pix_fmt = IPU_PIX_FMT_RGB565,
-	.mode_str = "CLAA-WVGA",
-	.default_bpp = 16,
-	.int_clk = false,
+	.disp_dev		= "lcd",
+	.interface_pix_fmt	= IPU_PIX_FMT_RGB565,
+	.mode_str		= "CLAA-WVGA",
+	.default_bpp		= 16,
+	.int_clk		= false,
 	}
 };
 
 static void hdmi_init(int ipu_id, int disp_id)
 {
 	int hdmi_mux_setting;
+	int max_ipu_id = cpu_is_mx6q() ? 1 : 0;
 
-	if ((ipu_id > 1) || (ipu_id < 0)) {
-		printk(KERN_ERR"Invalid IPU select for HDMI: %d. Set to 0\n",
-			ipu_id);
+	if ((ipu_id > max_ipu_id) || (ipu_id < 0)) {
+		pr_err("Invalid IPU select for HDMI: %d. Set to 0\n", ipu_id);
 		ipu_id = 0;
 	}
 
 	if ((disp_id > 1) || (disp_id < 0)) {
-		printk(KERN_ERR"Invalid DI select for HDMI: %d. Set to 0\n",
-			disp_id);
+		pr_err("Invalid DI select for HDMI: %d. Set to 0\n", disp_id);
 		disp_id = 0;
 	}
 
 	/* Configure the connection between IPU1/2 and HDMI */
-	hdmi_mux_setting = 2*ipu_id + disp_id;
+	hdmi_mux_setting = 2 * ipu_id + disp_id;
 
 	/* GPR3, bits 2-3 = HDMI_MUX_CTL */
 	mxc_iomux_set_gpr_register(3, 2, 2, hdmi_mux_setting);
 }
 
 static struct fsl_mxc_hdmi_platform_data hdmi_data = {
-	.init = hdmi_init,
+	.init		= hdmi_init,
 };
 
 static struct fsl_mxc_hdmi_core_platform_data hdmi_core_data = {
-	.ipu_id = 0,
-	.disp_id = 0,
+	.ipu_id		= 0,
+	.disp_id	= 0,
 };
 
 static struct fsl_mxc_lcd_platform_data lcdif_data = {
-	.ipu_id = 0,
-	.disp_id = 0,
-	.default_ifmt = IPU_PIX_FMT_RGB565,
+	.ipu_id		= 0,
+	.disp_id	= 0,
+	.default_ifmt	= IPU_PIX_FMT_RGB565,
 };
 
 static struct fsl_mxc_ldb_platform_data ldb_data = {
-	.ipu_id = 0,
-	.disp_id = 1,
-	.ext_ref = 1,
-	.mode = LDB_SEP0,
-	.sec_ipu_id = 1,
-	.sec_disp_id = 0,
+	.ipu_id		= 0,
+	.disp_id	= 1,
+	.ext_ref	= 1,
+	.mode		= LDB_SEP0,
+	.sec_ipu_id	= 1,
+	.sec_disp_id	= 0,
 };
 
 static struct imx_ipuv3_platform_data ipu_data[] = {
 	{
-	.rev = 4,
-	.csi_clk[0] = "ccm_clk0",
+	.rev		= 4,
+	.csi_clk[0]	= "ccm_clk0",
 	}, {
-	.rev = 4,
-	.csi_clk[0] = "ccm_clk0",
+	.rev		= 4,
+	.csi_clk[0]	= "ccm_clk0",
 	},
 };
 
 static struct platform_pwm_backlight_data mx6_arm2_pwm_backlight_data = {
-	.pwm_id = 0,
-	.max_brightness = 255,
-	.dft_brightness = 128,
-	.pwm_period_ns = 50000,
+	.pwm_id		= 0,
+	.max_brightness	= 255,
+	.dft_brightness	= 128,
+	.pwm_period_ns	= 50000,
 };
 
-static struct gpio mx6q_flexcan_gpios[] = {
-	{ MX6Q_ARM2_CAN1_EN, GPIOF_OUT_INIT_LOW, "flexcan1-en" },
-	{ MX6Q_ARM2_CAN1_STBY, GPIOF_OUT_INIT_LOW, "flexcan1-stby" },
-	{ MX6Q_ARM2_CAN2_EN, GPIOF_OUT_INIT_LOW, "flexcan2-en" },
+static struct gpio mx6_flexcan_gpios[] = {
+	{ MX6_ARM2_CAN1_EN, GPIOF_OUT_INIT_LOW, "flexcan1-en" },
+	{ MX6_ARM2_CAN1_STBY, GPIOF_OUT_INIT_LOW, "flexcan1-stby" },
+	{ MX6_ARM2_CAN2_EN, GPIOF_OUT_INIT_LOW, "flexcan2-en" },
 };
 
-static void mx6q_flexcan0_switch(int enable)
+static void mx6_flexcan0_switch(int enable)
 {
 	if (enable) {
-		gpio_set_value(MX6Q_ARM2_CAN1_EN, 1);
-		gpio_set_value(MX6Q_ARM2_CAN1_STBY, 1);
+		gpio_set_value(MX6_ARM2_CAN1_EN, 1);
+		gpio_set_value(MX6_ARM2_CAN1_STBY, 1);
 	} else {
-		gpio_set_value(MX6Q_ARM2_CAN1_EN, 0);
-		gpio_set_value(MX6Q_ARM2_CAN1_STBY, 0);
+		gpio_set_value(MX6_ARM2_CAN1_EN, 0);
+		gpio_set_value(MX6_ARM2_CAN1_STBY, 0);
 	}
 }
 
-static void mx6q_flexcan1_switch(int enable)
+static void mx6_flexcan1_switch(int enable)
 {
 	if (enable) {
-		gpio_set_value(MX6Q_ARM2_CAN2_EN, 1);
-		gpio_set_value_cansleep(MX6Q_ARM2_CAN2_STBY, 1);
+		gpio_set_value(MX6_ARM2_CAN2_EN, 1);
+		gpio_set_value_cansleep(MX6_ARM2_CAN2_STBY, 1);
 	} else {
-		gpio_set_value(MX6Q_ARM2_CAN2_EN, 0);
-		gpio_set_value_cansleep(MX6Q_ARM2_CAN2_STBY, 0);
+		gpio_set_value(MX6_ARM2_CAN2_EN, 0);
+		gpio_set_value_cansleep(MX6_ARM2_CAN2_STBY, 0);
 	}
 }
 
 static const struct flexcan_platform_data
-		mx6q_arm2_flexcan_pdata[] __initconst = {
+		mx6_arm2_flexcan_pdata[] __initconst = {
 	{
-		.transceiver_switch = mx6q_flexcan0_switch,
+		.transceiver_switch = mx6_flexcan0_switch,
 	}, {
-		.transceiver_switch = mx6q_flexcan1_switch,
+		.transceiver_switch = mx6_flexcan1_switch,
 	}
 };
 
 static struct mipi_csi2_platform_data mipi_csi2_pdata = {
-	.ipu_id	 = 0,
-	.csi_id = 0,
-	.v_channel = 0,
-	.lanes = 2,
-	.dphy_clk = "mipi_pllref_clk",
-	.pixel_clk = "emi_clk",
+	.ipu_id		= 0,
+	.csi_id		= 0,
+	.v_channel	= 0,
+	.lanes		= 2,
+	.dphy_clk	= "mipi_pllref_clk",
+	.pixel_clk	= "emi_clk",
 };
 
 static void arm2_suspend_enter(void)
@@ -1143,22 +948,22 @@ static void arm2_suspend_exit(void)
 {
 	/* resmue resore */
 }
-static const struct pm_platform_data mx6q_arm2_pm_data __initconst = {
-	.name = "imx_pm",
-	.suspend_enter = arm2_suspend_enter,
-	.suspend_exit = arm2_suspend_exit,
+static const struct pm_platform_data mx6_arm2_pm_data __initconst = {
+	.name		= "imx_pm",
+	.suspend_enter	= arm2_suspend_enter,
+	.suspend_exit	= arm2_suspend_exit,
 };
 
 static struct mxc_audio_platform_data sab_audio_data = {
-	.sysclk = 16934400,
+	.sysclk	= 16934400,
 };
 
 static struct platform_device sab_audio_device = {
-	.name = "imx-cs42888",
+	.name	= "imx-cs42888",
 };
 
 static struct imx_esai_platform_data sab_esai_pdata = {
-	.flags = IMX_ESAI_NET,
+	.flags	= IMX_ESAI_NET,
 };
 
 static struct regulator_consumer_supply arm2_vmmc_consumers[] = {
@@ -1173,16 +978,16 @@ static struct regulator_init_data arm2_vmmc_init = {
 };
 
 static struct fixed_voltage_config arm2_vmmc_reg_config = {
-	.supply_name		= "vmmc",
-	.microvolts		= 3300000,
-	.gpio			= -1,
-	.init_data		= &arm2_vmmc_init,
+	.supply_name	= "vmmc",
+	.microvolts	= 3300000,
+	.gpio		= -1,
+	.init_data	= &arm2_vmmc_init,
 };
 
 static struct platform_device arm2_vmmc_reg_devices = {
-	.name	= "reg-fixed-voltage",
-	.id	= 0,
-	.dev	= {
+	.name		= "reg-fixed-voltage",
+	.id		= 0,
+	.dev		= {
 		.platform_data = &arm2_vmmc_reg_config,
 	},
 };
@@ -1190,43 +995,43 @@ static struct platform_device arm2_vmmc_reg_devices = {
 #ifdef CONFIG_SND_SOC_CS42888
 
 static struct regulator_consumer_supply cs42888_arm2_consumer_va = {
-	.supply = "VA",
-	.dev_name = "0-0048",
+	.supply		= "VA",
+	.dev_name	= "0-0048",
 };
 
 static struct regulator_consumer_supply cs42888_arm2_consumer_vd = {
-	.supply = "VD",
-	.dev_name = "0-0048",
+	.supply		= "VD",
+	.dev_name	= "0-0048",
 };
 
 static struct regulator_consumer_supply cs42888_arm2_consumer_vls = {
-	.supply = "VLS",
-	.dev_name = "0-0048",
+	.supply		= "VLS",
+	.dev_name	= "0-0048",
 };
 
 static struct regulator_consumer_supply cs42888_arm2_consumer_vlc = {
-	.supply = "VLC",
-	.dev_name = "0-0048",
+	.supply		= "VLC",
+	.dev_name	= "0-0048",
 };
 
 static struct regulator_init_data cs42888_arm2_va_reg_initdata = {
-	.num_consumer_supplies = 1,
-	.consumer_supplies = &cs42888_arm2_consumer_va,
+	.num_consumer_supplies	= 1,
+	.consumer_supplies	= &cs42888_arm2_consumer_va,
 };
 
 static struct regulator_init_data cs42888_arm2_vd_reg_initdata = {
-	.num_consumer_supplies = 1,
-	.consumer_supplies = &cs42888_arm2_consumer_vd,
+	.num_consumer_supplies	= 1,
+	.consumer_supplies	= &cs42888_arm2_consumer_vd,
 };
 
 static struct regulator_init_data cs42888_arm2_vls_reg_initdata = {
-	.num_consumer_supplies = 1,
-	.consumer_supplies = &cs42888_arm2_consumer_vls,
+	.num_consumer_supplies	= 1,
+	.consumer_supplies	= &cs42888_arm2_consumer_vls,
 };
 
 static struct regulator_init_data cs42888_arm2_vlc_reg_initdata = {
-	.num_consumer_supplies = 1,
-	.consumer_supplies = &cs42888_arm2_consumer_vlc,
+	.num_consumer_supplies	= 1,
+	.consumer_supplies	= &cs42888_arm2_consumer_vlc,
 };
 
 static struct fixed_voltage_config cs42888_arm2_va_reg_config = {
@@ -1294,33 +1099,33 @@ static struct platform_device cs42888_arm2_vlc_reg_devices = {
 #ifdef CONFIG_SND_SOC_SGTL5000
 
 static struct regulator_consumer_supply sgtl5000_arm2_consumer_vdda = {
-	.supply = "VDDA",
-	.dev_name = "1-000a",
+	.supply		= "VDDA",
+	.dev_name	= "1-000a",
 };
 
 static struct regulator_consumer_supply sgtl5000_arm2_consumer_vddio = {
-	.supply = "VDDIO",
-	.dev_name = "1-000a",
+	.supply		= "VDDIO",
+	.dev_name	= "1-000a",
 };
 
 static struct regulator_consumer_supply sgtl5000_arm2_consumer_vddd = {
-	.supply = "VDDD",
-	.dev_name = "1-000a",
+	.supply		= "VDDD",
+	.dev_name	= "1-000a",
 };
 
 static struct regulator_init_data sgtl5000_arm2_vdda_reg_initdata = {
-	.num_consumer_supplies = 1,
-	.consumer_supplies = &sgtl5000_arm2_consumer_vdda,
+	.num_consumer_supplies	= 1,
+	.consumer_supplies	= &sgtl5000_arm2_consumer_vdda,
 };
 
 static struct regulator_init_data sgtl5000_arm2_vddio_reg_initdata = {
-	.num_consumer_supplies = 1,
-	.consumer_supplies = &sgtl5000_arm2_consumer_vddio,
+	.num_consumer_supplies	= 1,
+	.consumer_supplies	= &sgtl5000_arm2_consumer_vddio,
 };
 
 static struct regulator_init_data sgtl5000_arm2_vddd_reg_initdata = {
-	.num_consumer_supplies = 1,
-	.consumer_supplies = &sgtl5000_arm2_consumer_vddd,
+	.num_consumer_supplies	= 1,
+	.consumer_supplies	= &sgtl5000_arm2_consumer_vddd,
 };
 
 static struct fixed_voltage_config sgtl5000_arm2_vdda_reg_config = {
@@ -1396,7 +1201,7 @@ static struct platform_device mx6_arm2_audio_device = {
 	.name = "imx-sgtl5000",
 };
 
-static int __init imx6q_init_audio(void)
+static int __init mx6_arm2_init_audio(void)
 {
 	struct clk *pll3_pfd, *esai_clk;
 	mxc_register_device(&sab_audio_device, &sab_audio_data);
@@ -1414,10 +1219,10 @@ static int __init imx6q_init_audio(void)
 	clk_set_rate(esai_clk, 101647058);
 
 #ifdef CONFIG_SND_SOC_CS42888
-		platform_device_register(&cs42888_arm2_va_reg_devices);
-		platform_device_register(&cs42888_arm2_vd_reg_devices);
-		platform_device_register(&cs42888_arm2_vls_reg_devices);
-		platform_device_register(&cs42888_arm2_vlc_reg_devices);
+	platform_device_register(&cs42888_arm2_va_reg_devices);
+	platform_device_register(&cs42888_arm2_vd_reg_devices);
+	platform_device_register(&cs42888_arm2_vls_reg_devices);
+	platform_device_register(&cs42888_arm2_vlc_reg_devices);
 #endif
 
 	if (sgtl5000_en) {
@@ -1426,8 +1231,17 @@ static int __init imx6q_init_audio(void)
 				&mx6_arm2_audio_data);
 		imx6q_add_imx_ssi(1, &mx6_arm2_ssi_pdata);
 
-		mxc_iomux_v3_setup_multiple_pads(mx6q_arm2_audmux_pads,
-			ARRAY_SIZE(mx6q_arm2_audmux_pads));
+		/*
+		 * AUDMUX3 and CSI0_Camera use the same pin
+		 * MX6x_PAD_CSI0_DAT5
+		 */
+		if (cpu_is_mx6q()) {
+			mxc_iomux_v3_setup_multiple_pads(mx6q_arm2_audmux_pads,
+					ARRAY_SIZE(mx6q_arm2_audmux_pads));
+		} else if (cpu_is_mx6dl()) {
+			mxc_iomux_v3_setup_multiple_pads(mx6dl_arm2_audmux_pads,
+					ARRAY_SIZE(mx6dl_arm2_audmux_pads));
+		}
 
 #ifdef CONFIG_SND_SOC_SGTL5000
 	platform_device_register(&sgtl5000_arm2_vdda_reg_devices);
@@ -1447,36 +1261,36 @@ static int __init early_use_esai_record(char *p)
 
 early_param("esai_record", early_use_esai_record);
 
-static struct mxc_mlb_platform_data mx6q_arm2_mlb150_data = {
-	.reg_nvcc = NULL,
-	.mlb_clk = "mlb150_clk",
-	.mlb_pll_clk = "pll6",
+static struct mxc_mlb_platform_data mx6_arm2_mlb150_data = {
+	.reg_nvcc		= NULL,
+	.mlb_clk		= "mlb150_clk",
+	.mlb_pll_clk		= "pll6",
 };
 
 static struct mxc_dvfs_platform_data arm2_dvfscore_data = {
-	.reg_id = "cpu_vddgp",
-	.clk1_id = "cpu_clk",
-	.clk2_id = "gpc_dvfs_clk",
-	.gpc_cntr_offset = MXC_GPC_CNTR_OFFSET,
-	.ccm_cdcr_offset = MXC_CCM_CDCR_OFFSET,
-	.ccm_cacrr_offset = MXC_CCM_CACRR_OFFSET,
-	.ccm_cdhipr_offset = MXC_CCM_CDHIPR_OFFSET,
-	.prediv_mask = 0x1F800,
-	.prediv_offset = 11,
-	.prediv_val = 3,
-	.div3ck_mask = 0xE0000000,
-	.div3ck_offset = 29,
-	.div3ck_val = 2,
-	.emac_val = 0x08,
-	.upthr_val = 25,
-	.dnthr_val = 9,
-	.pncthr_val = 33,
-	.upcnt_val = 10,
-	.dncnt_val = 10,
-	.delay_time = 80,
-};
-
-static void __init fixup_mxc_board(struct machine_desc *desc, struct tag *tags,
+	.reg_id			= "cpu_vddgp",
+	.clk1_id		= "cpu_clk",
+	.clk2_id		= "gpc_dvfs_clk",
+	.gpc_cntr_offset	= MXC_GPC_CNTR_OFFSET,
+	.ccm_cdcr_offset	= MXC_CCM_CDCR_OFFSET,
+	.ccm_cacrr_offset	= MXC_CCM_CACRR_OFFSET,
+	.ccm_cdhipr_offset	= MXC_CCM_CDHIPR_OFFSET,
+	.prediv_mask		= 0x1F800,
+	.prediv_offset		= 11,
+	.prediv_val		= 3,
+	.div3ck_mask		= 0xE0000000,
+	.div3ck_offset		= 29,
+	.div3ck_val		= 2,
+	.emac_val		= 0x08,
+	.upthr_val		= 25,
+	.dnthr_val		= 9,
+	.pncthr_val		= 33,
+	.upcnt_val		= 10,
+	.dncnt_val		= 10,
+	.delay_time		= 80,
+};
+
+static void __init mx6_arm2_fixup(struct machine_desc *desc, struct tag *tags,
 				   char **cmdline, struct meminfo *mi)
 {
 }
@@ -1514,8 +1328,8 @@ static int spdif_clk_set_rate(struct clk *clk, unsigned long rate)
 }
 
 static struct mxc_spdif_platform_data mxc_spdif_data = {
-	.spdif_tx = 1,		/* enable tx */
-	.spdif_rx = 1,		/* enable rx */
+	.spdif_tx		= 1,		/* enable tx */
+	.spdif_rx		= 1,		/* enable rx */
 	/*
 	 * spdif0_clk will be 454.7MHz divided by ccm dividers.
 	 *
@@ -1523,30 +1337,76 @@ static struct mxc_spdif_platform_data mxc_spdif_data = {
 	 * 48KHz:   454.7MHz / 4 (ccm) / 37 (spdif) = 48,004 Hz ~ 0.01% error
 	 * 32KHz:   454.7MHz / 6 (ccm) / 37 (spdif) = 32,003 Hz ~ 0.01% error
 	 */
-	.spdif_clk_44100 = 1,	/* tx clk from spdif0_clk_root */
-	.spdif_clk_48000 = 1,	/* tx clk from spdif0_clk_root */
-	.spdif_div_44100 = 23,
-	.spdif_div_48000 = 37,
-	.spdif_div_32000 = 37,
-	.spdif_rx_clk = 0,	/* rx clk from spdif stream */
-	.spdif_clk_set_rate = spdif_clk_set_rate,
-	.spdif_clk = NULL,	/* spdif bus clk */
+	.spdif_clk_44100	= 1,    /* tx clk from spdif0_clk_root */
+	.spdif_clk_48000	= 1,    /* tx clk from spdif0_clk_root */
+	.spdif_div_44100	= 23,
+	.spdif_div_48000	= 37,
+	.spdif_div_32000	= 37,
+	.spdif_rx_clk		= 0,    /* rx clk from spdif stream */
+	.spdif_clk_set_rate	= spdif_clk_set_rate,
+	.spdif_clk		= NULL, /* spdif bus clk */
 };
 
 /*!
  * Board specific initialization.
  */
-static void __init mx6_board_init(void)
+static void __init mx6_arm2_init(void)
 {
 	int i;
 	int ret;
 
-	mxc_iomux_v3_setup_multiple_pads(mx6q_arm2_pads,
-					ARRAY_SIZE(mx6q_arm2_pads));
+	iomux_v3_cfg_t *common_pads = NULL;
+	iomux_v3_cfg_t *esai_rec_pads = NULL;
+	iomux_v3_cfg_t *spdif_pads = NULL;
+	iomux_v3_cfg_t *flexcan_pads = NULL;
+	iomux_v3_cfg_t *i2c3_pads = NULL;
+
+	int common_pads_cnt;
+	int esai_rec_pads_cnt;
+	int spdif_pads_cnt;
+	int flexcan_pads_cnt;
+	int i2c3_pads_cnt;
 
-	if (esai_record)
-	    mxc_iomux_v3_setup_multiple_pads(mx6q_arm2_esai_record_pads,
-			ARRAY_SIZE(mx6q_arm2_esai_record_pads));
+
+	/*
+	 * common pads: pads are non-shared with others on this board
+	 * feature_pds: pads are shared with others on this board
+	 */
+
+	if (cpu_is_mx6q()) {
+		common_pads = mx6q_arm2_pads;
+		esai_rec_pads = mx6q_arm2_esai_record_pads;
+		spdif_pads = mx6q_arm2_spdif_pads;
+		flexcan_pads = mx6q_arm2_can_pads;
+		i2c3_pads = mx6q_arm2_i2c3_pads;
+
+		common_pads_cnt = ARRAY_SIZE(mx6q_arm2_pads);
+		esai_rec_pads_cnt = ARRAY_SIZE(mx6q_arm2_esai_record_pads);
+		spdif_pads_cnt =  ARRAY_SIZE(mx6q_arm2_spdif_pads);
+		flexcan_pads_cnt = ARRAY_SIZE(mx6q_arm2_can_pads);
+		i2c3_pads_cnt = ARRAY_SIZE(mx6q_arm2_i2c3_pads);
+	} else if (cpu_is_mx6dl()) {
+		common_pads = mx6dl_arm2_pads;
+		esai_rec_pads = mx6dl_arm2_esai_record_pads;
+		spdif_pads = mx6dl_arm2_spdif_pads;
+		flexcan_pads = mx6dl_arm2_can_pads;
+		i2c3_pads = mx6dl_arm2_i2c3_pads;
+
+		common_pads_cnt = ARRAY_SIZE(mx6dl_arm2_pads);
+		esai_rec_pads_cnt = ARRAY_SIZE(mx6dl_arm2_esai_record_pads);
+		spdif_pads_cnt =  ARRAY_SIZE(mx6dl_arm2_spdif_pads);
+		flexcan_pads_cnt = ARRAY_SIZE(mx6dl_arm2_can_pads);
+		i2c3_pads_cnt = ARRAY_SIZE(mx6dl_arm2_i2c3_pads);
+	}
+
+	BUG_ON(!common_pads);
+	mxc_iomux_v3_setup_multiple_pads(common_pads, common_pads_cnt);
+
+	if (esai_record) {
+		BUG_ON(!esai_rec_pads);
+		mxc_iomux_v3_setup_multiple_pads(esai_rec_pads,
+						esai_rec_pads_cnt);
+	}
 
 	/*
 	 * S/PDIF in and i2c3 are mutually exclusive because both
@@ -1555,26 +1415,46 @@ static void __init mx6_board_init(void)
 	 * use GPIO_17.
 	 */
 	if (spdif_en) {
-		mxc_iomux_v3_setup_multiple_pads(mx6q_arm2_spdif_pads,
-			ARRAY_SIZE(mx6q_arm2_spdif_pads));
+		BUG_ON(!spdif_pads);
+		mxc_iomux_v3_setup_multiple_pads(spdif_pads, spdif_pads_cnt);
 	} else {
-		mxc_iomux_v3_setup_multiple_pads(mx6q_arm2_i2c3_pads,
-			ARRAY_SIZE(mx6q_arm2_i2c3_pads));
-		if (flexcan_en)
-			mxc_iomux_v3_setup_multiple_pads(mx6q_arm2_can_pads,
-				ARRAY_SIZE(mx6q_arm2_can_pads));
+		BUG_ON(!i2c3_pads);
+		mxc_iomux_v3_setup_multiple_pads(i2c3_pads, i2c3_pads_cnt);
+	}
+
+	if (!spdif_en && flexcan_en) {
+		BUG_ON(!flexcan_pads);
+		mxc_iomux_v3_setup_multiple_pads(flexcan_pads,
+						flexcan_pads_cnt);
 	}
 
+	/*
+	 * the following is the common devices support on the shared ARM2 boards
+	 * Since i.MX6DQ/DL share the same memory/Register layout, we don't
+	 * need to diff the i.MX6DQ or i.MX6DL here. We can simply use the
+	 * mx6q_add_features() for the shared devices. For which only exist
+	 * on each indivual SOC, we can use cpu_is_mx6q/6dl() to diff it.
+	 */
+
 	gp_reg_id = arm2_dvfscore_data.reg_id;
-	mx6q_arm2_init_uart();
+	mx6_arm2_init_uart();
 	imx6q_add_mipi_csi2(&mipi_csi2_pdata);
 	imx6q_add_mxc_hdmi_core(&hdmi_core_data);
 
 	imx6q_add_ipuv3(0, &ipu_data[0]);
-	imx6q_add_ipuv3(1, &ipu_data[1]);
-
-	for (i = 0; i < ARRAY_SIZE(sabr_fb_data); i++)
-		imx6q_add_ipuv3fb(i, &sabr_fb_data[i]);
+	if (cpu_is_mx6q())
+		imx6q_add_ipuv3(1, &ipu_data[1]);
+
+	if (cpu_is_mx6dl()) {
+		mipi_dsi_pdata.ipu_id = 0;
+		mipi_dsi_pdata.disp_id = 1;
+		ldb_data.ipu_id = 0;
+		ldb_data.disp_id = 0;
+		for (i = 0; i < ARRAY_SIZE(sabr_fb_data) / 2; i++)
+			imx6q_add_ipuv3fb(i, &sabr_fb_data[i]);
+	} else
+		for (i = 0; i < ARRAY_SIZE(sabr_fb_data); i++)
+			imx6q_add_ipuv3fb(i, &sabr_fb_data[i]);
 
 	imx6q_add_mipi_dsi(&mipi_dsi_pdata);
 	imx6q_add_lcdif(&lcdif_data);
@@ -1584,37 +1464,38 @@ static void __init mx6_board_init(void)
 
 	imx6q_add_imx_snvs_rtc();
 
-	imx6q_add_imx_i2c(0, &mx6q_arm2_i2c0_data);
-	imx6q_add_imx_i2c(1, &mx6q_arm2_i2c1_data);
+	imx6q_add_imx_i2c(0, &mx6_arm2_i2c0_data);
+	imx6q_add_imx_i2c(1, &mx6_arm2_i2c1_data);
 	i2c_register_board_info(0, mxc_i2c0_board_info,
 			ARRAY_SIZE(mxc_i2c0_board_info));
 	i2c_register_board_info(1, mxc_i2c1_board_info,
 			ARRAY_SIZE(mxc_i2c1_board_info));
 	if (!spdif_en) {
-		imx6q_add_imx_i2c(2, &mx6q_arm2_i2c2_data);
+		imx6q_add_imx_i2c(2, &mx6_arm2_i2c2_data);
 		i2c_register_board_info(2, mxc_i2c2_board_info,
 				ARRAY_SIZE(mxc_i2c2_board_info));
 	}
 
 	/* SPI */
-	imx6q_add_ecspi(0, &mx6q_arm2_spi_data);
+	imx6q_add_ecspi(0, &mx6_arm2_spi_data);
 	spi_device_init();
 
 	imx6q_add_mxc_hdmi(&hdmi_data);
 
-	imx6q_add_anatop_thermal_imx(1, &mx6q_arm2_anatop_thermal_data);
+	imx6q_add_anatop_thermal_imx(1, &mx6_arm2_anatop_thermal_data);
 
 	if (!esai_record)
 		imx6_init_fec(fec_data);
 
-	imx6q_add_pm_imx(0, &mx6q_arm2_pm_data);
-	imx6q_add_sdhci_usdhc_imx(3, &mx6q_arm2_sd4_data);
-	imx6q_add_sdhci_usdhc_imx(2, &mx6q_arm2_sd3_data);
-	imx_add_viv_gpu(&imx6_gpu_data, &imx6q_gpu_pdata);
-	imx6q_arm2_init_usb();
-	imx6q_add_ahci(0, &mx6q_arm2_sata_data);
+	imx6q_add_pm_imx(0, &mx6_arm2_pm_data);
+	imx6q_add_sdhci_usdhc_imx(3, &mx6_arm2_sd4_data);
+	imx6q_add_sdhci_usdhc_imx(2, &mx6_arm2_sd3_data);
+	imx_add_viv_gpu(&imx6_gpu_data, &imx6_gpu_pdata);
+	if (cpu_is_mx6q())
+		imx6q_add_ahci(0, &mx6_arm2_sata_data);
 	imx6q_add_vpu();
-	imx6q_init_audio();
+	mx6_arm2_init_usb();
+	mx6_arm2_init_audio();
 	platform_device_register(&arm2_vmmc_reg_devices);
 	mx6_cpu_regulator_init();
 
@@ -1623,23 +1504,23 @@ static void __init mx6_board_init(void)
 	imx6q_add_asrc(&imx_asrc_data);
 
 	/* DISP0 Reset - Assert for i2c disabled mode */
-	gpio_request(MX6Q_ARM2_DISP0_RESET, "disp0-reset");
-	gpio_direction_output(MX6Q_ARM2_DISP0_RESET, 0);
+	gpio_request(MX6_ARM2_DISP0_RESET, "disp0-reset");
+	gpio_direction_output(MX6_ARM2_DISP0_RESET, 0);
 
 	/* DISP0 I2C enable */
-	gpio_request(MX6Q_ARM2_DISP0_I2C_EN, "disp0-i2c");
-	gpio_direction_output(MX6Q_ARM2_DISP0_I2C_EN, 0);
+	gpio_request(MX6_ARM2_DISP0_I2C_EN, "disp0-i2c");
+	gpio_direction_output(MX6_ARM2_DISP0_I2C_EN, 0);
 
-	gpio_request(MX6Q_ARM2_DISP0_PWR, "disp0-pwr");
-	gpio_direction_output(MX6Q_ARM2_DISP0_PWR, 1);
+	gpio_request(MX6_ARM2_DISP0_PWR, "disp0-pwr");
+	gpio_direction_output(MX6_ARM2_DISP0_PWR, 1);
 
-	gpio_request(MX6Q_ARM2_LDB_BACKLIGHT, "ldb-backlight");
-	gpio_direction_output(MX6Q_ARM2_LDB_BACKLIGHT, 1);
+	gpio_request(MX6_ARM2_LDB_BACKLIGHT, "ldb-backlight");
+	gpio_direction_output(MX6_ARM2_LDB_BACKLIGHT, 1);
 	imx6q_add_otp();
 	imx6q_add_viim();
 	imx6q_add_imx2_wdt(0, NULL);
 	imx6q_add_dma();
-	imx6q_add_gpmi(&mx6q_gpmi_nand_platform_data);
+	imx6q_add_gpmi(&mx6_gpmi_nand_platform_data);
 
 	imx6q_add_dvfs_core(&arm2_dvfscore_data);
 
@@ -1653,13 +1534,13 @@ static void __init mx6_board_init(void)
 		imx6q_add_spdif_dai();
 		imx6q_add_spdif_audio_device();
 	} else if (flexcan_en) {
-		ret = gpio_request_array(mx6q_flexcan_gpios,
-				ARRAY_SIZE(mx6q_flexcan_gpios));
+		ret = gpio_request_array(mx6_flexcan_gpios,
+				ARRAY_SIZE(mx6_flexcan_gpios));
 		if (ret) {
 			pr_err("failed to request flexcan-gpios: %d\n", ret);
 		} else {
-			imx6q_add_flexcan0(&mx6q_arm2_flexcan_pdata[0]);
-			imx6q_add_flexcan1(&mx6q_arm2_flexcan_pdata[1]);
+			imx6q_add_flexcan0(&mx6_arm2_flexcan_pdata[0]);
+			imx6q_add_flexcan1(&mx6_arm2_flexcan_pdata[1]);
 		}
 	}
 
@@ -1668,7 +1549,7 @@ static void __init mx6_board_init(void)
 	imx6q_add_perfmon(0);
 	imx6q_add_perfmon(1);
 	imx6q_add_perfmon(2);
-	imx6q_add_mlb150(&mx6q_arm2_mlb150_data);
+	imx6q_add_mlb150(&mx6_arm2_mlb150_data);
 }
 
 extern void __iomem *twd_base;
@@ -1689,29 +1570,25 @@ static struct sys_timer mxc_timer = {
 	.init   = mx6_timer_init,
 };
 
-static void __init mx6q_reserve(void)
+static void __init mx6_arm2_reserve(void)
 {
 	phys_addr_t phys;
 
-	if (imx6q_gpu_pdata.reserved_mem_size) {
-		phys = memblock_alloc_base(imx6q_gpu_pdata.reserved_mem_size,
-			SZ_4K, SZ_2G);
-		memblock_free(phys, imx6q_gpu_pdata.reserved_mem_size);
-		memblock_remove(phys, imx6q_gpu_pdata.reserved_mem_size);
-		imx6q_gpu_pdata.reserved_mem_base = phys;
+	if (imx6_gpu_pdata.reserved_mem_size) {
+		phys = memblock_alloc_base(
+			imx6_gpu_pdata.reserved_mem_size, SZ_4K, SZ_2G);
+		memblock_free(phys, imx6_gpu_pdata.reserved_mem_size);
+		memblock_remove(phys, imx6_gpu_pdata.reserved_mem_size);
+		imx6_gpu_pdata.reserved_mem_base = phys;
 	}
 }
 
-/*
- * initialize __mach_desc_MX6Q_ARM2 data structure.
- */
-MACHINE_START(MX6Q_ARM2, "Freescale i.MX 6Quad Armadillo2 Board")
-	/* Maintainer: Freescale Semiconductor, Inc. */
-	.boot_params = MX6_PHYS_OFFSET + 0x100,
-	.fixup = fixup_mxc_board,
-	.map_io = mx6_map_io,
-	.init_irq = mx6_init_irq,
-	.init_machine = mx6_board_init,
-	.timer = &mxc_timer,
-	.reserve = mx6q_reserve,
+MACHINE_START(MX6Q_ARM2, "Freescale i.MX 6Quad/Solo/DualLite Armadillo2 Board")
+	.boot_params	= MX6_PHYS_OFFSET + 0x100,
+	.fixup		= mx6_arm2_fixup,
+	.map_io		= mx6_map_io,
+	.init_irq	= mx6_init_irq,
+	.init_machine	= mx6_arm2_init,
+	.timer		= &mxc_timer,
+	.reserve	= mx6_arm2_reserve,
 MACHINE_END
diff --git a/arch/arm/mach-mx6/board-mx6q_arm2.h b/arch/arm/mach-mx6/board-mx6q_arm2.h
new file mode 100644
index 0000000..9e3ef81
--- /dev/null
+++ b/arch/arm/mach-mx6/board-mx6q_arm2.h
@@ -0,0 +1,314 @@
+/*
+ * Copyright (C) 2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <mach/iomux-mx6q.h>
+
+static iomux_v3_cfg_t mx6q_arm2_pads[] = {
+
+	/* UART4 for debug */
+	MX6Q_PAD_KEY_COL0__UART4_TXD,
+	MX6Q_PAD_KEY_ROW0__UART4_RXD,
+	/* USB HSIC ports use the same pin with ENET */
+#ifdef CONFIG_USB_EHCI_ARC_HSIC
+	/* USB H2 strobe/data pin */
+	MX6Q_PAD_RGMII_TX_CTL__USBOH3_H2_STROBE,
+	MX6Q_PAD_RGMII_TXC__USBOH3_H2_DATA,
+
+	/* USB H3 strobe/data pin */
+	MX6Q_PAD_RGMII_RXC__USBOH3_H3_STROBE,
+	MX6Q_PAD_RGMII_RX_CTL__USBOH3_H3_DATA,
+	/* ENET */
+#else
+	MX6Q_PAD_KEY_COL1__ENET_MDIO,
+	MX6Q_PAD_KEY_COL2__ENET_MDC,
+	MX6Q_PAD_RGMII_TXC__ENET_RGMII_TXC,
+	MX6Q_PAD_RGMII_TD0__ENET_RGMII_TD0,
+	MX6Q_PAD_RGMII_TD1__ENET_RGMII_TD1,
+	MX6Q_PAD_RGMII_TD2__ENET_RGMII_TD2,
+	MX6Q_PAD_RGMII_TD3__ENET_RGMII_TD3,
+	MX6Q_PAD_RGMII_TX_CTL__ENET_RGMII_TX_CTL,
+	MX6Q_PAD_ENET_REF_CLK__ENET_TX_CLK,
+	MX6Q_PAD_RGMII_RXC__ENET_RGMII_RXC,
+	MX6Q_PAD_RGMII_RD0__ENET_RGMII_RD0,
+	MX6Q_PAD_RGMII_RD1__ENET_RGMII_RD1,
+	MX6Q_PAD_RGMII_RD2__ENET_RGMII_RD2,
+	MX6Q_PAD_RGMII_RD3__ENET_RGMII_RD3,
+	MX6Q_PAD_RGMII_RX_CTL__ENET_RGMII_RX_CTL,
+#endif
+	/* MCLK for csi0 */
+	MX6Q_PAD_GPIO_0__CCM_CLKO,
+	MX6Q_PAD_GPIO_3__CCM_CLKO2,
+
+	/* SD1 */
+	MX6Q_PAD_SD1_CLK__USDHC1_CLK,
+	MX6Q_PAD_SD1_CMD__USDHC1_CMD,
+	MX6Q_PAD_SD1_DAT0__USDHC1_DAT0,
+	MX6Q_PAD_SD1_DAT1__USDHC1_DAT1,
+	MX6Q_PAD_SD1_DAT2__USDHC1_DAT2,
+	MX6Q_PAD_SD1_DAT3__USDHC1_DAT3,
+	/* SD2 */
+	MX6Q_PAD_SD2_CLK__USDHC2_CLK,
+	MX6Q_PAD_SD2_CMD__USDHC2_CMD,
+	MX6Q_PAD_SD2_DAT0__USDHC2_DAT0,
+	MX6Q_PAD_SD2_DAT1__USDHC2_DAT1,
+	MX6Q_PAD_SD2_DAT2__USDHC2_DAT2,
+	MX6Q_PAD_SD2_DAT3__USDHC2_DAT3,
+	/* SD3 */
+	MX6Q_PAD_SD3_CLK__USDHC3_CLK_50MHZ,
+	MX6Q_PAD_SD3_CMD__USDHC3_CMD_50MHZ,
+	MX6Q_PAD_SD3_DAT0__USDHC3_DAT0_50MHZ,
+	MX6Q_PAD_SD3_DAT1__USDHC3_DAT1_50MHZ,
+	MX6Q_PAD_SD3_DAT2__USDHC3_DAT2_50MHZ,
+	MX6Q_PAD_SD3_DAT3__USDHC3_DAT3_50MHZ,
+	MX6Q_PAD_SD3_DAT4__USDHC3_DAT4_50MHZ,
+	MX6Q_PAD_SD3_DAT5__USDHC3_DAT5_50MHZ,
+	MX6Q_PAD_SD3_DAT6__USDHC3_DAT6_50MHZ,
+	MX6Q_PAD_SD3_DAT7__USDHC3_DAT7_50MHZ,
+	MX6Q_PAD_SD3_RST__USDHC3_RST,
+	/* SD3 VSelect */
+	MX6Q_PAD_GPIO_18__USDHC3_VSELECT,
+	/* SD3_CD and SD3_WP */
+	MX6Q_PAD_NANDF_CS0__GPIO_6_11,
+	MX6Q_PAD_NANDF_CS1__GPIO_6_14,
+	/* SD4 */
+	MX6Q_PAD_SD4_CLK__USDHC4_CLK_50MHZ,
+	MX6Q_PAD_SD4_CMD__USDHC4_CMD_50MHZ,
+	MX6Q_PAD_SD4_DAT0__USDHC4_DAT0_50MHZ,
+	MX6Q_PAD_SD4_DAT1__USDHC4_DAT1_50MHZ,
+	MX6Q_PAD_SD4_DAT2__USDHC4_DAT2_50MHZ,
+	MX6Q_PAD_SD4_DAT3__USDHC4_DAT3_50MHZ,
+	MX6Q_PAD_SD4_DAT4__USDHC4_DAT4_50MHZ,
+	MX6Q_PAD_SD4_DAT5__USDHC4_DAT5_50MHZ,
+	MX6Q_PAD_SD4_DAT6__USDHC4_DAT6_50MHZ,
+	MX6Q_PAD_SD4_DAT7__USDHC4_DAT7_50MHZ,
+	MX6Q_PAD_NANDF_ALE__USDHC4_RST,
+	/* eCSPI1 */
+	MX6Q_PAD_EIM_EB2__ECSPI1_SS0,
+	MX6Q_PAD_EIM_D16__ECSPI1_SCLK,
+	MX6Q_PAD_EIM_D17__ECSPI1_MISO,
+	MX6Q_PAD_EIM_D18__ECSPI1_MOSI,
+	MX6Q_PAD_EIM_D19__ECSPI1_SS1,
+	MX6Q_PAD_EIM_EB2__GPIO_2_30,	/*SS0*/
+	MX6Q_PAD_EIM_D19__GPIO_3_19,	/*SS1*/
+
+	/* ESAI */
+	MX6Q_PAD_ENET_RXD0__ESAI1_HCKT,
+	MX6Q_PAD_ENET_CRS_DV__ESAI1_SCKT,
+	MX6Q_PAD_ENET_RXD1__ESAI1_FST,
+	MX6Q_PAD_ENET_TX_EN__ESAI1_TX3_RX2,
+	MX6Q_PAD_ENET_TXD1__ESAI1_TX2_RX3,
+	MX6Q_PAD_ENET_TXD0__ESAI1_TX4_RX1,
+	MX6Q_PAD_ENET_MDC__ESAI1_TX5_RX0,
+	MX6Q_PAD_NANDF_CS2__ESAI1_TX0,
+	MX6Q_PAD_NANDF_CS3__ESAI1_TX1,
+
+	/* I2C1 */
+	MX6Q_PAD_CSI0_DAT8__I2C1_SDA,
+	MX6Q_PAD_CSI0_DAT9__I2C1_SCL,
+
+	/* I2C2 */
+	MX6Q_PAD_KEY_COL3__I2C2_SCL,
+	MX6Q_PAD_KEY_ROW3__I2C2_SDA,
+
+	/* DISPLAY */
+	MX6Q_PAD_DI0_DISP_CLK__IPU1_DI0_DISP_CLK,
+	MX6Q_PAD_DI0_PIN15__IPU1_DI0_PIN15,
+	MX6Q_PAD_DI0_PIN2__IPU1_DI0_PIN2,
+	MX6Q_PAD_DI0_PIN3__IPU1_DI0_PIN3,
+	MX6Q_PAD_DISP0_DAT0__IPU1_DISP0_DAT_0,
+	MX6Q_PAD_DISP0_DAT1__IPU1_DISP0_DAT_1,
+	MX6Q_PAD_DISP0_DAT2__IPU1_DISP0_DAT_2,
+	MX6Q_PAD_DISP0_DAT3__IPU1_DISP0_DAT_3,
+	MX6Q_PAD_DISP0_DAT4__IPU1_DISP0_DAT_4,
+	MX6Q_PAD_DISP0_DAT5__IPU1_DISP0_DAT_5,
+	MX6Q_PAD_DISP0_DAT6__IPU1_DISP0_DAT_6,
+	MX6Q_PAD_DISP0_DAT7__IPU1_DISP0_DAT_7,
+	MX6Q_PAD_DISP0_DAT8__IPU1_DISP0_DAT_8,
+	MX6Q_PAD_DISP0_DAT9__IPU1_DISP0_DAT_9,
+	MX6Q_PAD_DISP0_DAT10__IPU1_DISP0_DAT_10,
+	MX6Q_PAD_DISP0_DAT11__IPU1_DISP0_DAT_11,
+	MX6Q_PAD_DISP0_DAT12__IPU1_DISP0_DAT_12,
+	MX6Q_PAD_DISP0_DAT13__IPU1_DISP0_DAT_13,
+	MX6Q_PAD_DISP0_DAT14__IPU1_DISP0_DAT_14,
+	MX6Q_PAD_DISP0_DAT15__IPU1_DISP0_DAT_15,
+	MX6Q_PAD_DISP0_DAT16__IPU1_DISP0_DAT_16,
+	MX6Q_PAD_DISP0_DAT17__IPU1_DISP0_DAT_17,
+	MX6Q_PAD_DISP0_DAT18__IPU1_DISP0_DAT_18,
+	MX6Q_PAD_DISP0_DAT19__IPU1_DISP0_DAT_19,
+	MX6Q_PAD_DISP0_DAT20__IPU1_DISP0_DAT_20,
+	MX6Q_PAD_DISP0_DAT21__IPU1_DISP0_DAT_21,
+	MX6Q_PAD_DISP0_DAT22__IPU1_DISP0_DAT_22,
+	MX6Q_PAD_DISP0_DAT23__IPU1_DISP0_DAT_23,
+
+	MX6Q_PAD_EIM_D24__GPIO_3_24,
+
+	/* UART2 */
+	MX6Q_PAD_EIM_D26__UART2_RXD,
+	MX6Q_PAD_EIM_D27__UART2_TXD,
+	MX6Q_PAD_EIM_D28__UART2_RTS,
+	MX6Q_PAD_EIM_D29__UART2_CTS,
+
+	/* PWM1 */
+	MX6Q_PAD_GPIO_9__PWM1_PWMO,
+
+	/* DISP0 DET */
+	MX6Q_PAD_EIM_D31__GPIO_3_31,
+
+	/* DISP0 RESET */
+	MX6Q_PAD_EIM_WAIT__GPIO_5_0,
+
+	/* HDMI */
+	MX6Q_PAD_EIM_A25__HDMI_TX_CEC_LINE,
+	MX6Q_PAD_SD1_DAT1__HDMI_TX_OPHYDTB_0,
+	MX6Q_PAD_SD1_DAT0__HDMI_TX_OPHYDTB_1,
+
+	/* USBOTG ID pin */
+	MX6Q_PAD_GPIO_1__USBOTG_ID,
+
+	/* MLB150 */
+	MX6Q_PAD_GPIO_3__MLB_MLBCLK,
+	MX6Q_PAD_GPIO_6__MLB_MLBSIG,
+	MX6Q_PAD_GPIO_2__MLB_MLBDAT,
+};
+
+static iomux_v3_cfg_t mx6q_arm2_i2c3_pads[] = {
+	MX6Q_PAD_GPIO_5__I2C3_SCL,
+	MX6Q_PAD_GPIO_16__I2C3_SDA,
+};
+
+static iomux_v3_cfg_t mx6q_arm2_spdif_pads[] = {
+	/* SPDIF */
+	MX6Q_PAD_GPIO_16__SPDIF_IN1,
+	MX6Q_PAD_GPIO_17__SPDIF_OUT1,
+};
+
+static iomux_v3_cfg_t mx6q_arm2_can_pads[] = {
+	/* CAN1 */
+	MX6Q_PAD_GPIO_7__CAN1_TXCAN,
+	MX6Q_PAD_KEY_ROW2__CAN1_RXCAN,
+	MX6Q_PAD_GPIO_17__GPIO_7_12,	/* CAN1 STBY */
+	MX6Q_PAD_GPIO_18__GPIO_7_13,	/* CAN1 EN */
+
+	/* CAN2 */
+	MX6Q_PAD_KEY_COL4__CAN2_TXCAN,
+	MX6Q_PAD_KEY_ROW4__CAN2_RXCAN,
+	MX6Q_PAD_CSI0_DAT6__GPIO_5_24,	/* CAN2 EN */
+};
+
+static iomux_v3_cfg_t mx6q_arm2_esai_record_pads[] = {
+	MX6Q_PAD_ENET_RX_ER__ESAI1_HCKR,
+	MX6Q_PAD_ENET_MDIO__ESAI1_SCKR,
+	MX6Q_PAD_ENET_REF_CLK__ESAI1_FSR,
+};
+
+static iomux_v3_cfg_t mx6q_arm2_csi0_sensor_pads[] = {
+	MX6Q_PAD_GPIO_0__CCM_CLKO,
+	/* ipu1 csi0 */
+	MX6Q_PAD_CSI0_DAT12__IPU1_CSI0_D_12,
+	MX6Q_PAD_CSI0_DAT13__IPU1_CSI0_D_13,
+	MX6Q_PAD_CSI0_DAT14__IPU1_CSI0_D_14,
+	MX6Q_PAD_CSI0_DAT15__IPU1_CSI0_D_15,
+	MX6Q_PAD_CSI0_DAT16__IPU1_CSI0_D_16,
+	MX6Q_PAD_CSI0_DAT17__IPU1_CSI0_D_17,
+	MX6Q_PAD_CSI0_DAT18__IPU1_CSI0_D_18,
+	MX6Q_PAD_CSI0_DAT19__IPU1_CSI0_D_19,
+	MX6Q_PAD_CSI0_VSYNC__IPU1_CSI0_VSYNC,
+	MX6Q_PAD_CSI0_MCLK__IPU1_CSI0_HSYNC,
+	MX6Q_PAD_CSI0_PIXCLK__IPU1_CSI0_PIXCLK,
+	/* camera reset */
+	MX6Q_PAD_GPIO_19__GPIO_4_5,
+	/* camera powerdown */
+	MX6Q_PAD_CSI0_DAT5__GPIO_5_23,
+};
+
+static iomux_v3_cfg_t mx6q_arm2_csi0_tvin_pads[] = {
+	/* ipu1 csi0 */
+	MX6Q_PAD_CSI0_DAT12__IPU1_CSI0_D_12,
+	MX6Q_PAD_CSI0_DAT13__IPU1_CSI0_D_13,
+	MX6Q_PAD_CSI0_DAT14__IPU1_CSI0_D_14,
+	MX6Q_PAD_CSI0_DAT15__IPU1_CSI0_D_15,
+	MX6Q_PAD_CSI0_DAT16__IPU1_CSI0_D_16,
+	MX6Q_PAD_CSI0_DAT17__IPU1_CSI0_D_17,
+	MX6Q_PAD_CSI0_DAT18__IPU1_CSI0_D_18,
+	MX6Q_PAD_CSI0_DAT19__IPU1_CSI0_D_19,
+	MX6Q_PAD_CSI0_VSYNC__IPU1_CSI0_VSYNC,
+	MX6Q_PAD_CSI0_MCLK__IPU1_CSI0_HSYNC,
+	MX6Q_PAD_CSI0_PIXCLK__IPU1_CSI0_PIXCLK,
+	/* camera reset */
+	MX6Q_PAD_CSI0_DAT7__GPIO_5_25,
+	/* camera powerdown */
+	MX6Q_PAD_CSI0_DAT5__GPIO_5_23,
+};
+
+static iomux_v3_cfg_t mx6q_arm2_mipi_sensor_pads[] = {
+	MX6Q_PAD_CSI0_MCLK__CCM_CLKO,
+};
+
+static iomux_v3_cfg_t mx6q_arm2_audmux_pads[] = {
+
+	/* AUDMUX */
+	MX6Q_PAD_CSI0_DAT4__AUDMUX_AUD3_TXC,
+	MX6Q_PAD_CSI0_DAT5__AUDMUX_AUD3_TXD,
+	MX6Q_PAD_CSI0_DAT6__AUDMUX_AUD3_TXFS,
+	MX6Q_PAD_CSI0_DAT7__AUDMUX_AUD3_RXD,
+};
+
+#define MX6Q_USDHC_PAD_SETTING(id, speed)	\
+mx6q_sd##id##_##speed##mhz[] = {		\
+	MX6Q_PAD_SD##id##_CLK__USDHC##id##_CLK_##speed##MHZ,	\
+	MX6Q_PAD_SD##id##_CMD__USDHC##id##_CMD_##speed##MHZ,	\
+	MX6Q_PAD_SD##id##_DAT0__USDHC##id##_DAT0_##speed##MHZ,	\
+	MX6Q_PAD_SD##id##_DAT1__USDHC##id##_DAT1_##speed##MHZ,	\
+	MX6Q_PAD_SD##id##_DAT2__USDHC##id##_DAT2_##speed##MHZ,	\
+	MX6Q_PAD_SD##id##_DAT3__USDHC##id##_DAT3_##speed##MHZ,	\
+	MX6Q_PAD_SD##id##_DAT4__USDHC##id##_DAT4_##speed##MHZ,	\
+	MX6Q_PAD_SD##id##_DAT5__USDHC##id##_DAT5_##speed##MHZ,	\
+	MX6Q_PAD_SD##id##_DAT6__USDHC##id##_DAT6_##speed##MHZ,	\
+	MX6Q_PAD_SD##id##_DAT7__USDHC##id##_DAT7_##speed##MHZ,	\
+}
+
+static iomux_v3_cfg_t MX6Q_USDHC_PAD_SETTING(3, 50);
+static iomux_v3_cfg_t MX6Q_USDHC_PAD_SETTING(3, 100);
+static iomux_v3_cfg_t MX6Q_USDHC_PAD_SETTING(3, 200);
+static iomux_v3_cfg_t MX6Q_USDHC_PAD_SETTING(4, 50);
+static iomux_v3_cfg_t MX6Q_USDHC_PAD_SETTING(4, 100);
+static iomux_v3_cfg_t MX6Q_USDHC_PAD_SETTING(4, 200);
+
+
+/* The GPMI is conflicted with SD3, so init this in the driver. */
+static iomux_v3_cfg_t mx6q_gpmi_nand[] __initdata = {
+	MX6Q_PAD_NANDF_CLE__RAWNAND_CLE,
+	MX6Q_PAD_NANDF_ALE__RAWNAND_ALE,
+	MX6Q_PAD_NANDF_CS0__RAWNAND_CE0N,
+	MX6Q_PAD_NANDF_CS1__RAWNAND_CE1N,
+	MX6Q_PAD_NANDF_CS2__RAWNAND_CE2N,
+	MX6Q_PAD_NANDF_CS3__RAWNAND_CE3N,
+	MX6Q_PAD_NANDF_RB0__RAWNAND_READY0,
+	MX6Q_PAD_SD4_DAT0__RAWNAND_DQS,
+	MX6Q_PAD_NANDF_D0__RAWNAND_D0,
+	MX6Q_PAD_NANDF_D1__RAWNAND_D1,
+	MX6Q_PAD_NANDF_D2__RAWNAND_D2,
+	MX6Q_PAD_NANDF_D3__RAWNAND_D3,
+	MX6Q_PAD_NANDF_D4__RAWNAND_D4,
+	MX6Q_PAD_NANDF_D5__RAWNAND_D5,
+	MX6Q_PAD_NANDF_D6__RAWNAND_D6,
+	MX6Q_PAD_NANDF_D7__RAWNAND_D7,
+	MX6Q_PAD_SD4_CMD__RAWNAND_RDN,
+	MX6Q_PAD_SD4_CLK__RAWNAND_WRN,
+	MX6Q_PAD_NANDF_WP_B__RAWNAND_RESETN,
+};
diff --git a/arch/arm/plat-mxc/audmux-v2.c b/arch/arm/plat-mxc/audmux-v2.c
index c727019..8933cac 100644
--- a/arch/arm/plat-mxc/audmux-v2.c
+++ b/arch/arm/plat-mxc/audmux-v2.c
@@ -189,7 +189,7 @@ static int mxc_audmux_v2_init(void)
 	int ret;
 
 #if defined(CONFIG_ARCH_MX6)
-	if (cpu_is_mx6q()) {
+	if (cpu_is_mx6q() || cpu_is_mx6dl()) {
 		audmux_base = MX6_IO_ADDRESS(MX6Q_AUDMUX_BASE_ADDR);
 		ret = 0;
 	}
diff --git a/arch/arm/plat-mxc/devices/platform-viv_gpu.c b/arch/arm/plat-mxc/devices/platform-viv_gpu.c
index b11efe0..dad9d5a 100644
--- a/arch/arm/plat-mxc/devices/platform-viv_gpu.c
+++ b/arch/arm/plat-mxc/devices/platform-viv_gpu.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -36,6 +36,7 @@ struct platform_device *__init imx_add_viv_gpu(
 		const struct imx_viv_gpu_data *data,
 		const struct viv_gpu_platform_data *pdata)
 {
+	u32 res_count = 0;
 	struct resource res[] = {
 		{
 			.name = "iobase_3d",
@@ -70,8 +71,15 @@ struct platform_device *__init imx_add_viv_gpu(
 		},
 	};
 
+	if (cpu_is_mx6q())
+		res_count = ARRAY_SIZE(res);
+	else if (cpu_is_mx6dl())
+		/* No openVG on i.mx6 Solo/DL */
+		res_count = ARRAY_SIZE(res) - 2;
+	BUG_ON(!res_count);
+
 	return imx_add_platform_device_dmamask("galcore", 0,
-			res, ARRAY_SIZE(res),
+			res, res_count,
 			pdata, sizeof(*pdata),
 			DMA_BIT_MASK(32));
 }
diff --git a/arch/arm/plat-mxc/dvfs_core.c b/arch/arm/plat-mxc/dvfs_core.c
index cacd3cc..d52f7b6 100755
--- a/arch/arm/plat-mxc/dvfs_core.c
+++ b/arch/arm/plat-mxc/dvfs_core.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008-2012 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -427,7 +427,7 @@ static int set_cpu_freq(int op)
 {
 	int ret = 0;
 
-	if (cpu_is_mx6q())
+	if (cpu_is_mx6q() || cpu_is_mx6dl())
 		ret = mx6_set_cpu_freq(op);
 	else
 		ret = mx5_set_cpu_freq(op);
@@ -476,7 +476,7 @@ static int start_dvfs(void)
 	/* GPCIRQ=1, select ARM IRQ */
 	reg |= MXC_GPCCNTR_GPCIRQ_ARM;
 	/* ADU=1, select ARM domain */
-	if (!cpu_is_mx6q())
+	if (!(cpu_is_mx6q() || cpu_is_mx6dl()))
 		reg |= MXC_GPCCNTR_ADU;
 	__raw_writel(reg, gpc_base + dvfs_data->gpc_cntr_offset);
 
@@ -509,7 +509,7 @@ static int start_dvfs(void)
 	__raw_writel(reg, dvfs_data->membase + MXC_DVFSCORE_CNTR);
 
 	/* Enable DVFS */
-	if (cpu_is_mx6q()) {
+	if (cpu_is_mx6q() || cpu_is_mx6dl()) {
 		unsigned long cpu_wfi = 0;
 		int num_cpus = num_possible_cpus();
 		reg = __raw_readl(dvfs_data->membase + MXC_DVFSCORE_EMAC);
@@ -947,7 +947,7 @@ static int __devinit mxc_dvfs_core_probe(struct platform_device *pdev)
 		printk(KERN_ERR "%s: failed to get cpu clock\n", __func__);
 		return PTR_ERR(cpu_clk);
 	}
-	if (!cpu_is_mx6q()) {
+	if (!(cpu_is_mx6q() || cpu_is_mx6dl())) {
 		dvfs_clk = clk_get(NULL, dvfs_data->clk2_id);
 		if (IS_ERR(dvfs_clk)) {
 			printk(KERN_ERR "%s: failed to get dvfs clock\n", __func__);
diff --git a/arch/arm/plat-mxc/include/mach/fsl_usb.h b/arch/arm/plat-mxc/include/mach/fsl_usb.h
index c471064..0b47a7d 100755
--- a/arch/arm/plat-mxc/include/mach/fsl_usb.h
+++ b/arch/arm/plat-mxc/include/mach/fsl_usb.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2005-2012 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -98,7 +98,7 @@ static inline void fsl_platform_set_ahb_burst(struct usb_hcd *hcd)
 	}
 
 	/* Increase TX fifo threshold for in Hostx */
-	if (cpu_is_mx6q()) {
+	if (cpu_is_mx6()) {
 		temp = readl(hcd->regs + FSL_SOC_USB_TXFILLTUNING);
 		/* Change TX FIFO threshold to be 0x08 */
 		writel((temp & (~(0x3f << 16))) | (0x08 << 16),
diff --git a/arch/arm/plat-mxc/usb_common.c b/arch/arm/plat-mxc/usb_common.c
index b50963b..bb9c45a 100755
--- a/arch/arm/plat-mxc/usb_common.c
+++ b/arch/arm/plat-mxc/usb_common.c
@@ -88,7 +88,7 @@ static int fsl_check_usbclk(void)
 
 	usb_ahb_clk = clk_get(NULL, "usb_ahb_clk");
 	if (clk_enable(usb_ahb_clk)) {
-		if (cpu_is_mx6q())
+		if (cpu_is_mx6q() || cpu_is_mx6dl())
 			return 0; /* there is no ahb clock at mx6 */
 		printk(KERN_ERR "clk_enable(usb_ahb_clk) failed\n");
 		return -EINVAL;
@@ -97,7 +97,7 @@ static int fsl_check_usbclk(void)
 
 	usb_clk = clk_get(NULL, "usb_clk");
 	if (clk_enable(usb_clk)) {
-		if (cpu_is_mx6q())
+		if (cpu_is_mx6q() || cpu_is_mx6dl())
 			return 0; /* there is usb_clk at mx6 */
 		printk(KERN_ERR "clk_enable(usb_clk) failed\n");
 		return -EINVAL;
@@ -502,7 +502,7 @@ int fsl_usb_host_init(struct platform_device *pdev)
 
 	if (usb_register_remote_wakeup(pdev))
 		pr_debug("%s port is not a wakeup source.\n", pdata->name);
-	if (!cpu_is_mx6q()) {
+	if (!(cpu_is_mx6q() || cpu_is_mx6dl())) {
 		if (xops->xcvr_type == PORTSC_PTS_SERIAL) {
 			if (cpu_is_mx35()) {
 				usbh2_set_serial_xcvr();
@@ -814,7 +814,7 @@ int usbotg_init(struct platform_device *pdev)
 			return -EINVAL;
 		if (xops->init)
 			xops->init(xops);
-		if (!(cpu_is_mx6q())) {
+		if (!((cpu_is_mx6q() || cpu_is_mx6dl()))) {
 			UOG_PORTSC1 = UOG_PORTSC1 & ~PORTSC_PHCD;
 
 
-- 
1.7.9.5

