From 4086d05bf2a3358984626ae90b9d223b898af83a Mon Sep 17 00:00:00 2001
From: Lily Zhang <r58066@freescale.com>
Date: Sun, 1 Nov 2009 11:14:53 +0800
Subject: ENGR00117843 Missing i.MX headers for kernel headers_install

Add i.MX specific files into include/linux/Kbuild
ISL29023:Add device head file to Kbuild

This patch adds device head file to Kbuild to pass

Signed-off-by: Lily Zhang <r58066@freescale.com>
---
 include/linux/Kbuild              |   24 +
 include/linux/imx_adc.h           |  275 ++++++++++
 include/linux/isl29023.h          |   47 ++
 include/linux/mxc_asrc.h          |  210 +++++++
 include/linux/mxc_mlb.h           |   51 ++
 include/linux/mxc_pf.h            |  125 +++++
 include/linux/mxc_scc2_driver.h   |  975 +++++++++++++++++++++++++++++++++
 include/linux/mxc_scc_driver.h    | 1031 +++++++++++++++++++++++++++++++++++
 include/linux/mxc_si4702.h        |   39 ++
 include/linux/mxc_sim_interface.h |  108 ++++
 include/linux/pmic_battery.h      |  419 ++++++++++++++
 include/linux/pmic_light.h        | 1082 +++++++++++++++++++++++++++++++++++++
 include/linux/pmic_rtc.h          |  153 ++++++
 include/linux/pxp_dma.h           |  223 ++++++++
 14 files changed, 4762 insertions(+)
 create mode 100644 include/linux/imx_adc.h
 create mode 100644 include/linux/isl29023.h
 create mode 100644 include/linux/mxc_asrc.h
 create mode 100644 include/linux/mxc_mlb.h
 create mode 100644 include/linux/mxc_pf.h
 create mode 100644 include/linux/mxc_scc2_driver.h
 create mode 100644 include/linux/mxc_scc_driver.h
 create mode 100644 include/linux/mxc_si4702.h
 create mode 100644 include/linux/mxc_sim_interface.h
 create mode 100644 include/linux/pmic_battery.h
 create mode 100644 include/linux/pmic_light.h
 create mode 100644 include/linux/pmic_rtc.h
 create mode 100644 include/linux/pxp_dma.h

diff --git a/include/linux/Kbuild b/include/linux/Kbuild
index ed62710..b03fa4e 100644
--- a/include/linux/Kbuild
+++ b/include/linux/Kbuild
@@ -19,6 +19,30 @@ header-y += netfilter_ipv6/
 header-y += usb/
 header-y += wimax/
 
+## i.MX specific files
+header-y += fsl_devices.h
+header-y += imx_adc.h
+header-y += ipu.h
+header-y += isl29023.h
+header-y += mxc_asrc.h
+header-y += mxc_mlb.h
+header-y += mxc_pf.h
+header-y += mxc_scc2_driver.h
+header-y += mxc_scc_driver.h
+header-y += mxc_srtc.h
+header-y += mxc_si4702.h
+header-y += mxc_sim_interface.h
+header-y += mxc_v4l2.h
+header-y += mxcfb.h
+header-y += pmic_adc.h
+header-y += pmic_battery.h
+header-y += pmic_external.h
+header-y += pmic_light.h
+header-y += pmic_rtc.h
+header-y += pmic_status.h
+header-y += pxp_dma.h
+header-y += soundcard.h
+
 objhdr-y += version.h
 
 ifneq ($(wildcard $(srctree)/arch/$(SRCARCH)/include/asm/a.out.h \
diff --git a/include/linux/imx_adc.h b/include/linux/imx_adc.h
new file mode 100644
index 0000000..6cab35c
--- /dev/null
+++ b/include/linux/imx_adc.h
@@ -0,0 +1,275 @@
+/*
+ * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU Lesser General
+ * Public License.  You may obtain a copy of the GNU Lesser General
+ * Public License Version 2.1 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/lgpl-license.html
+ * http://www.gnu.org/copyleft/lgpl.html
+ */
+
+#ifndef __ASM_ARCH_IMX_ADC_H__
+#define __ASM_ARCH_IMX_ADC_H__
+
+/*!
+ * @defgroup IMX_ADC Digitizer Driver
+ * @ingroup IMX_DRVRS
+ */
+
+/*!
+ * @file arch-mxc/imx_adc.h
+ * @brief This is the header of IMX ADC driver.
+ *
+ * @ingroup IMX_ADC
+ */
+
+#include <linux/ioctl.h>
+
+/*!
+ * @enum IMX_ADC_STATUS
+ * @brief Define return values for all IMX_ADC APIs.
+ *
+ * These return values are used by all of the IMX_ADC APIs.
+ *
+ * @ingroup IMX_ADC
+ */
+enum IMX_ADC_STATUS {
+	/*! The requested operation was successfully completed. */
+	IMX_ADC_SUCCESS = 0,
+	/*! The requested operation could not be completed due to an error. */
+	IMX_ADC_ERROR = -1,
+	/*!
+	 * The requested operation failed because one or more of the
+	 * parameters was invalid.
+	 */
+	IMX_ADC_PARAMETER_ERROR = -2,
+	/*!
+	 * The requested operation could not be completed because the ADC
+	 * hardware does not support it.
+	 */
+	IMX_ADC_NOT_SUPPORTED = -3,
+	/*! Error in malloc function */
+	IMX_ADC_MALLOC_ERROR = -5,
+	/*! Error in un-subscribe event */
+	IMX_ADC_UNSUBSCRIBE_ERROR = -6,
+	/*! Event occur and not subscribed */
+	IMX_ADC_EVENT_NOT_SUBSCRIBED = -7,
+	/*! Error - bad call back */
+	IMX_ADC_EVENT_CALL_BACK = -8,
+	/*!
+	 * The requested operation could not be completed because there
+	 * are too many ADC client requests
+	 */
+	IMX_ADC_CLIENT_NBOVERFLOW = -9,
+};
+
+/*
+ * Macros implementing error handling
+ */
+#define CHECK_ERROR(a)			\
+do {					\
+		int ret = (a); 			\
+		if (ret != IMX_ADC_SUCCESS)	\
+	return ret; 			\
+} while (0)
+
+#define CHECK_ERROR_KFREE(func, freeptrs) \
+do { \
+	int ret = (func); \
+	if (ret != IMX_ADC_SUCCESS) { \
+		freeptrs;	\
+		return ret;	\
+	}	\
+} while (0)
+
+#define MOD_NAME  "mxcadc"
+
+/*!
+ * @name IOCTL user space interface
+ */
+
+/*!
+ * Initialize ADC.
+ * Argument type: none.
+ */
+#define IMX_ADC_INIT                   _IO('p', 0xb0)
+/*!
+ * De-initialize ADC.
+ * Argument type: none.
+ */
+#define IMX_ADC_DEINIT                 _IO('p', 0xb1)
+/*!
+ * Convert one channel.
+ * Argument type: pointer to t_adc_convert_param.
+ */
+#define IMX_ADC_CONVERT                _IOWR('p', 0xb2, int)
+/*!
+ * Convert multiple channels.
+ * Argument type: pointer to t_adc_convert_param.
+ */
+#define IMX_ADC_CONVERT_MULTICHANNEL   _IOWR('p', 0xb4, int)
+
+/*! @{ */
+/*!
+ * @name Touch Screen minimum and maximum values
+ */
+#define IMX_ADC_DEVICE "/dev/imx_adc"
+
+/*
+ * Maximun allowed variation in the three X/Y co-ordinates acquired from
+ * touch screen
+ */
+#define DELTA_Y_MAX             100
+#define DELTA_X_MAX             100
+
+/* Upon clearing the filter, this is the delay in restarting the filter */
+#define FILTER_MIN_DELAY        4
+
+/* Length of X and Y touch screen filters */
+#define FILTLEN                 3
+
+#define TS_X_MAX                1000
+#define TS_Y_MAX                1000
+
+#define TS_X_MIN                80
+#define TS_Y_MIN                80
+
+/*! @} */
+/*!
+ * This enumeration defines input channels for IMX ADC
+ */
+
+enum t_channel {
+	TS_X_POS,
+	TS_Y_POS,
+	GER_PURPOSE_ADC0,
+	GER_PURPOSE_ADC1,
+	GER_PURPOSE_ADC2,
+	GER_PURPOSE_MULTICHNNEL,
+};
+
+/*!
+ * This structure is used to report touch screen value.
+ */
+struct t_touch_screen {
+	/* Touch Screen X position */
+	unsigned int x_position;
+	/* Touch Screen X position1 */
+	unsigned int x_position1;
+	/* Touch Screen X position2 */
+	unsigned int x_position2;
+	/* Touch Screen X position3 */
+	unsigned int x_position3;
+	/* Touch Screen Y position */
+	unsigned int y_position;
+	/* Touch Screen Y position1 */
+	unsigned int y_position1;
+	/* Touch Screen Y position2 */
+	unsigned int y_position2;
+	/* Touch Screen Y position3 */
+	unsigned int y_position3;
+	/* Touch Screen contact value */
+	unsigned int contact_resistance;
+	/* Flag indicate the data usability */
+	unsigned int valid_flag;
+};
+
+/*!
+ * This structure is used with IOCTL code \a IMX_ADC_CONVERT,
+ * \a IMX_ADC_CONVERT_8X and \a IMX_ADC_CONVERT_MULTICHANNEL.
+ */
+
+struct t_adc_convert_param {
+	/* channel or channels to be sampled.  */
+	enum t_channel channel;
+	/* holds up to 16 sampling results */
+	unsigned short result[16];
+};
+
+/* EXPORTED FUNCTIONS */
+
+#ifdef __KERNEL__
+/* Driver data */
+struct imx_adc_data {
+	u32 irq;
+	struct clk *adc_clk;
+};
+
+/*!
+ * This function initializes all ADC registers with default values. This
+ * function also registers the interrupt events.
+ *
+ * @return       This function returns IMX_ADC_SUCCESS if successful.
+ */
+enum IMX_ADC_STATUS imx_adc_init(void);
+
+/*!
+ * This function disables the ADC, de-registers the interrupt events.
+ *
+ * @return       This function returns IMX_ADC_SUCCESS if successful.
+ */
+enum IMX_ADC_STATUS imx_adc_deinit(void);
+
+/*!
+ * This function triggers a conversion and returns one sampling result of one
+ * channel.
+ *
+ * @param        channel   The channel to be sampled
+ * @param        result    The pointer to the conversion result. The memory
+ *                         should be allocated by the caller of this function.
+ *
+ * @return       This function returns IMX_ADC_SUCCESS if successful.
+ */
+
+enum IMX_ADC_STATUS imx_adc_convert(enum t_channel channel,
+				    unsigned short *result);
+
+/*!
+ * This function triggers a conversion and returns sampling results of each
+ * specified channel.
+ *
+ * @param        channels  This input parameter is bitmap to specify channels
+ *                         to be sampled.
+ * @param        result    The pointer to array to store sampling result.
+ *                         The order of the result in the array is from lowest
+ *                         channel number to highest channel number of the
+ *                         sampled channels.
+ *                         The memory should be allocated by the caller of this
+ *                         function.
+ *			   Note that the behavior of this function might differ
+ *			   from one platform to another regarding especially
+ *			   channels order.
+ *
+ * @return       This function returns IMX_ADC_SUCCESS if successful.
+ */
+
+enum IMX_ADC_STATUS imx_adc_convert_multichnnel(enum t_channel channels,
+						unsigned short *result);
+
+/*!
+ * This function retrieves the current touch screen operation mode.
+ *
+ * @param        touch_sample Pointer to touch sample.
+ * @param        wait_tsi     if true, we wait until interrupt occurs
+ * @return       This function returns IMX_ADC_SUCCESS if successful.
+ */
+enum IMX_ADC_STATUS imx_adc_get_touch_sample(struct t_touch_screen *ts_value,
+					     int wait_tsi);
+
+/*!
+ * This function read the touch screen value.
+ *
+ * @param        touch_sample    return value of touch screen
+ * @param        wait_tsi        if true, we need wait until interrupt occurs
+ * @return       This function returns 0.
+ */
+enum IMX_ADC_STATUS imx_adc_read_ts(struct t_touch_screen *touch_sample,
+				    int wait_tsi);
+
+int is_imx_adc_ready(void);
+
+#endif				/* _KERNEL */
+#endif				/* __ASM_ARCH_IMX_ADC_H__ */
diff --git a/include/linux/isl29023.h b/include/linux/isl29023.h
new file mode 100644
index 0000000..c5106ae
--- /dev/null
+++ b/include/linux/isl29023.h
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef __ISL29023_H__
+#define __ISL29023_H__
+
+#include <linux/types.h>
+
+#define ISL29023_PD_MODE	0x0
+#define ISL29023_ALS_ONCE_MODE	0x1
+#define ISL29023_IR_ONCE_MODE	0x2
+#define ISL29023_ALS_CONT_MODE	0x5
+#define ISL29023_IR_CONT_MODE	0x6
+
+#define ISL29023_INT_PERSISTS_1		0x0
+#define ISL29023_INT_PERSISTS_4		0x1
+#define ISL29023_INT_PERSISTS_8		0x2
+#define ISL29023_INT_PERSISTS_16	0x3
+
+#define ISL29023_RES_16		0x0
+#define ISL29023_RES_12		0x1
+#define ISL29023_RES_8		0x2
+#define ISL29023_RES_4		0x3
+
+#define ISL29023_RANGE_1K	0x0
+#define ISL29023_RANGE_4K	0x1
+#define ISL29023_RANGE_16K	0x2
+#define ISL29023_RANGE_64K	0x3
+
+#endif
diff --git a/include/linux/mxc_asrc.h b/include/linux/mxc_asrc.h
new file mode 100644
index 0000000..13a4850
--- /dev/null
+++ b/include/linux/mxc_asrc.h
@@ -0,0 +1,210 @@
+/*
+ * Copyright 2008-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file mx35_asrc.h
+ *
+ * @brief MX35 Asynchronous Sample Rate Converter
+ *
+ * @ingroup ??
+ */
+
+#ifndef __MXC_ASRC_H__
+#define __MXC_ASRC_H__
+
+#define ASRC_IOC_MAGIC	'C'
+
+#define ASRC_REQ_PAIR	_IOWR(ASRC_IOC_MAGIC, 0, struct asrc_req)
+#define ASRC_CONFIG_PAIR	_IOWR(ASRC_IOC_MAGIC, 1, struct asrc_config)
+#define ASRC_RELEASE_PAIR	_IOW(ASRC_IOC_MAGIC, 2, enum asrc_pair_index)
+#define ASRC_QUERYBUF	_IOWR(ASRC_IOC_MAGIC, 3, struct asrc_buffer)
+#define ASRC_Q_INBUF	_IOW(ASRC_IOC_MAGIC, 4, struct asrc_buffer)
+#define ASRC_DQ_INBUF	_IOW(ASRC_IOC_MAGIC, 5, struct asrc_buffer)
+#define ASRC_Q_OUTBUF	_IOW(ASRC_IOC_MAGIC, 6, struct asrc_buffer)
+#define ASRC_DQ_OUTBUF	_IOW(ASRC_IOC_MAGIC, 7, struct asrc_buffer)
+#define ASRC_START_CONV	_IOW(ASRC_IOC_MAGIC, 8, enum asrc_pair_index)
+#define ASRC_STOP_CONV	_IOW(ASRC_IOC_MAGIC, 9, enum asrc_pair_index)
+#define ASRC_STATUS	_IOW(ASRC_IOC_MAGIC, 10, struct asrc_status_flags)
+#define ASRC_FLUSH	_IOW(ASRC_IOC_MAGIC, 11, enum asrc_pair_index)
+
+enum asrc_pair_index {
+	ASRC_PAIR_A,
+	ASRC_PAIR_B,
+	ASRC_PAIR_C
+};
+
+enum asrc_inclk {
+	INCLK_NONE = 0x03,
+	INCLK_ESAI_RX = 0x00,
+	INCLK_SSI1_RX = 0x01,
+	INCLK_SSI2_RX = 0x02,
+	INCLK_SPDIF_RX = 0x04,
+	INCLK_MLB_CLK = 0x05,
+	INCLK_ESAI_TX = 0x08,
+	INCLK_SSI1_TX = 0x09,
+	INCLK_SSI2_TX = 0x0a,
+	INCLK_SPDIF_TX = 0x0c,
+	INCLK_ASRCK1_CLK = 0x0f,
+};
+
+enum asrc_outclk {
+	OUTCLK_NONE = 0x03,
+	OUTCLK_ESAI_TX = 0x00,
+	OUTCLK_SSI1_TX = 0x01,
+	OUTCLK_SSI2_TX = 0x02,
+	OUTCLK_SPDIF_TX = 0x04,
+	OUTCLK_MLB_CLK = 0x05,
+	OUTCLK_ESAI_RX = 0x08,
+	OUTCLK_SSI1_RX = 0x09,
+	OUTCLK_SSI2_RX = 0x0a,
+	OUTCLK_SPDIF_RX = 0x0c,
+	OUTCLK_ASRCK1_CLK = 0x0f,
+};
+
+struct asrc_config {
+	enum asrc_pair_index pair;
+	unsigned int channel_num;
+	unsigned int buffer_num;
+	unsigned int dma_buffer_size;
+	unsigned int input_sample_rate;
+	unsigned int output_sample_rate;
+	unsigned int word_width;
+	enum asrc_inclk inclk;
+	enum asrc_outclk outclk;
+};
+
+struct asrc_pair {
+	unsigned int start_channel;
+	unsigned int chn_num;
+	unsigned int chn_max;
+	unsigned int active;
+	unsigned int overload_error;
+};
+
+struct asrc_req {
+	unsigned int chn_num;
+	enum asrc_pair_index index;
+};
+
+struct asrc_querybuf {
+	unsigned int buffer_index;
+	unsigned int input_length;
+	unsigned int output_length;
+	unsigned long input_offset;
+	unsigned long output_offset;
+};
+
+struct asrc_buffer {
+	unsigned int index;
+	unsigned int length;
+	int buf_valid;
+};
+
+struct asrc_status_flags {
+	enum asrc_pair_index index;
+	unsigned int overload_error;
+};
+
+#define ASRC_BUF_NA	    -35	/* ASRC DQ's buffer is NOT available */
+#define ASRC_BUF_AV	    35	/* ASRC DQ's buffer is available */
+enum asrc_error_status {
+	ASRC_TASK_Q_OVERLOAD = 0x01,
+	ASRC_OUTPUT_TASK_OVERLOAD = 0x02,
+	ASRC_INPUT_TASK_OVERLOAD = 0x04,
+	ASRC_OUTPUT_BUFFER_OVERFLOW = 0x08,
+	ASRC_INPUT_BUFFER_UNDERRUN = 0x10,
+};
+
+#ifdef __KERNEL__
+
+#define ASRC_DMA_BUFFER_NUM 8
+
+#define ASRC_ASRCTR_REG 	0x00
+#define ASRC_ASRIER_REG 	0x04
+#define ASRC_ASRCNCR_REG 	0x0C
+#define ASRC_ASRCFG_REG 	0x10
+#define ASRC_ASRCSR_REG 	0x14
+#define ASRC_ASRCDR1_REG 	0x18
+#define ASRC_ASRCDR2_REG 	0x1C
+#define ASRC_ASRSTR_REG 	0x20
+#define ASRC_ASRRA_REG 		0x24
+#define ASRC_ASRRB_REG 		0x28
+#define ASRC_ASRRC_REG 		0x2C
+#define ASRC_ASRPM1_REG 	0x40
+#define ASRC_ASRPM2_REG 	0x44
+#define ASRC_ASRPM3_REG 	0x48
+#define ASRC_ASRPM4_REG 	0x4C
+#define ASRC_ASRPM5_REG 	0x50
+#define ASRC_ASRTFR1		0x54
+#define ASRC_ASRCCR_REG 	0x5C
+#define ASRC_ASRDIA_REG 	0x60
+#define ASRC_ASRDOA_REG 	0x64
+#define ASRC_ASRDIB_REG 	0x68
+#define ASRC_ASRDOB_REG 	0x6C
+#define ASRC_ASRDIC_REG 	0x70
+#define ASRC_ASRDOC_REG 	0x74
+#define ASRC_ASRIDRHA_REG 	0x80
+#define ASRC_ASRIDRLA_REG 	0x84
+#define ASRC_ASRIDRHB_REG 	0x88
+#define ASRC_ASRIDRLB_REG 	0x8C
+#define ASRC_ASRIDRHC_REG 	0x90
+#define ASRC_ASRIDRLC_REG 	0x94
+#define ASRC_ASR76K_REG 	0x98
+#define ASRC_ASR56K_REG 	0x9C
+
+struct dma_block {
+	unsigned int index;
+	unsigned int length;
+	unsigned char *dma_vaddr;
+	dma_addr_t dma_paddr;
+	struct list_head queue;
+};
+
+struct asrc_pair_params {
+	enum asrc_pair_index index;
+	struct list_head input_queue;
+	struct list_head input_done_queue;
+	struct list_head output_queue;
+	struct list_head output_done_queue;
+	wait_queue_head_t input_wait_queue;
+	wait_queue_head_t output_wait_queue;
+	unsigned int input_counter;
+	unsigned int output_counter;
+	unsigned int input_queue_empty;
+	unsigned int output_queue_empty;
+	unsigned int input_dma_channel;
+	unsigned int output_dma_channel;
+	unsigned int input_buffer_size;
+	unsigned int output_buffer_size;
+	unsigned int buffer_num;
+	unsigned int pair_hold;
+	unsigned int asrc_active;
+	struct dma_block input_dma[ASRC_DMA_BUFFER_NUM];
+	struct dma_block output_dma[ASRC_DMA_BUFFER_NUM];
+	struct semaphore busy_lock;
+};
+
+struct asrc_data {
+	struct asrc_pair asrc_pair[3];
+};
+
+extern int asrc_req_pair(int chn_num, enum asrc_pair_index *index);
+extern void asrc_release_pair(enum asrc_pair_index index);
+extern int asrc_config_pair(struct asrc_config *config);
+extern void asrc_get_status(struct asrc_status_flags *flags);
+extern void asrc_start_conv(enum asrc_pair_index index);
+extern void asrc_stop_conv(enum asrc_pair_index index);
+
+#endif				/* __kERNEL__ */
+
+#endif				/* __MXC_ASRC_H__ */
diff --git a/include/linux/mxc_mlb.h b/include/linux/mxc_mlb.h
new file mode 100644
index 0000000..7c8afea
--- /dev/null
+++ b/include/linux/mxc_mlb.h
@@ -0,0 +1,51 @@
+/*
+ * mxc_mlb.h
+ *
+ * Copyright 2008-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef _MXC_MLB_H
+#define _MXC_MLB_H
+
+/* define IOCTL command */
+#define MLB_SET_FPS		_IOW('S', 0x10, unsigned int)
+#define MLB_GET_VER		_IOR('S', 0x11, unsigned long)
+#define MLB_SET_DEVADDR		_IOR('S', 0x12, unsigned char)
+/*!
+ * set channel address for each logical channel
+ * the MSB 16bits is for tx channel, the left LSB is for rx channel
+ */
+#define MLB_CHAN_SETADDR	_IOW('S', 0x13, unsigned int)
+#define MLB_CHAN_STARTUP	_IO('S', 0x14)
+#define MLB_CHAN_SHUTDOWN	_IO('S', 0x15)
+#define MLB_CHAN_GETEVENT	_IOR('S', 0x16, unsigned long)
+
+/*!
+ * MLB event define
+ */
+enum {
+	MLB_EVT_TX_PROTO_ERR_CUR = 1 << 0,
+	MLB_EVT_TX_BRK_DETECT_CUR = 1 << 1,
+	MLB_EVT_TX_PROTO_ERR_PREV = 1 << 8,
+	MLB_EVT_TX_BRK_DETECT_PREV = 1 << 9,
+	MLB_EVT_RX_PROTO_ERR_CUR = 1 << 16,
+	MLB_EVT_RX_BRK_DETECT_CUR = 1 << 17,
+	MLB_EVT_RX_PROTO_ERR_PREV = 1 << 24,
+	MLB_EVT_RX_BRK_DETECT_PREV = 1 << 25,
+};
+
+#ifdef __KERNEL__
+extern void gpio_mlb_active(void);
+extern void gpio_mlb_inactive(void);
+#endif
+
+#endif				/* _MXC_MLB_H */
diff --git a/include/linux/mxc_pf.h b/include/linux/mxc_pf.h
new file mode 100644
index 0000000..9daf853
--- /dev/null
+++ b/include/linux/mxc_pf.h
@@ -0,0 +1,125 @@
+/*
+ * Copyright 2005-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU Lesser General
+ * Public License.  You may obtain a copy of the GNU Lesser General
+ * Public License Version 2.1 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/lgpl-license.html
+ * http://www.gnu.org/copyleft/lgpl.html
+ */
+
+/*!
+ * @defgroup MXC_PF MPEG4/H.264 Post Filter Driver
+ */
+/*!
+ * @file arch-mxc/mxc_pf.h
+ *
+ * @brief MXC IPU MPEG4/H.264 Post-filtering driver
+ *
+ * User-level API for IPU Hardware MPEG4/H.264 Post-filtering.
+ *
+ * @ingroup MXC_PF
+ */
+#ifndef __INCLUDED_MXC_PF_H__
+#define __INCLUDED_MXC_PF_H__
+
+#define PF_MAX_BUFFER_CNT       17
+
+#define PF_WAIT_Y	0x0001
+#define PF_WAIT_U	0x0002
+#define PF_WAIT_V	0x0004
+#define PF_WAIT_ALL	(PF_WAIT_Y|PF_WAIT_U|PF_WAIT_V)
+
+/*!
+ * Structure for Post Filter initialization parameters.
+ */
+typedef struct {
+	uint16_t pf_mode;	/*!< Post filter operation mode */
+	uint16_t width;		/*!< Width of frame in pixels */
+	uint16_t height;	/*!< Height of frame in pixels */
+	uint16_t stride;	/*!< Stride of Y plane in pixels. Stride for U and V planes is half Y stride */
+	uint32_t qp_size;
+	unsigned long qp_paddr;
+} pf_init_params;
+
+/*!
+ * Structure for Post Filter buffer request parameters.
+ */
+typedef struct {
+	int count;		/*!< Number of buffers requested */
+	__u32 req_size;
+} pf_reqbufs_params;
+
+/*!
+ * Structure for Post Filter buffer request parameters.
+ */
+typedef struct {
+	int index;
+	int size;		/*!< Size of buffer allocated */
+	__u32 offset;		/*!< Buffer offset in driver memory. Set by QUERYBUF */
+	__u32 y_offset;		/*!< Optional starting relative offset of Y data
+				   from beginning of buffer. Set to 0 to use default
+				   calculated based on height and stride */
+	__u32 u_offset;		/*!< Optional starting relative offset of U data
+				   from beginning of buffer. Set to 0 to use default
+				   calculated based on height and stride */
+	__u32 v_offset;		/*!< Optional starting relative offset of V data
+				   from beginning of buffer. Set to 0 to use default
+				   calculated based on height and stride */
+} pf_buf;
+
+/*!
+ * Structure for Post Filter start parameters.
+ */
+typedef struct {
+	pf_buf in;		/*!< Input buffer address and offsets */
+	pf_buf out;		/*!< Output buffer address and offsets */
+	int qp_buf;
+	int wait;
+	uint32_t h264_pause_row;	/*!< Row to pause at for H.264 mode. 0 to disable pause */
+} pf_start_params;
+
+/*! @name User Client Ioctl Interface */
+/*! @{ */
+
+/*!
+ * IOCTL to Initialize the Post Filter.
+ */
+#define PF_IOCTL_INIT           _IOW('F', 0x0, pf_init_params)
+
+/*!
+ * IOCTL to Uninitialize the Post Filter.
+ */
+#define PF_IOCTL_UNINIT         _IO('F', 0x1)
+
+/*!
+ * IOCTL to set the buffer mode and allocate buffers if driver allocated.
+ */
+#define PF_IOCTL_REQBUFS        _IOWR('F', 0x2, pf_reqbufs_params)
+
+/*!
+ * IOCTL to set the buffer mode and allocate buffers if driver allocated.
+ */
+#define PF_IOCTL_QUERYBUF       _IOR('F', 0x2, pf_buf)
+
+/*!
+ * IOCTL to start post filtering on a frame of data. This ioctl may block until
+ * processing is done or return immediately.
+ */
+#define PF_IOCTL_START          _IOWR('F', 0x3, pf_start_params)
+
+/*!
+ * IOCTL to resume post-filtering after an intra frame pause in H.264 mode.
+ */
+#define PF_IOCTL_RESUME         _IOW('F', 0x4, int)
+
+/*!
+ * IOCTL to wait for post-filtering to complete.
+ */
+#define PF_IOCTL_WAIT           _IOW('F', 0x5, int)
+/*! @} */
+
+#endif				/* __INCLUDED_MXC_PF_H__ */
diff --git a/include/linux/mxc_scc2_driver.h b/include/linux/mxc_scc2_driver.h
new file mode 100644
index 0000000..4a32d62
--- /dev/null
+++ b/include/linux/mxc_scc2_driver.h
@@ -0,0 +1,975 @@
+
+/*
+ * Copyright 2004-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef SCC_DRIVER_H
+#define SCC_DRIVER_H
+
+/*
+ * NAMING CONVENTIONS
+ * ==================
+ * (A note to maintainers and other interested parties)
+ *
+ * Use scc_ or SCC_ prefix for 'high-level' interface routines and the types
+ * passed to those routines.  Try to avoid #defines in these interfaces.
+ *
+ * Use SMN_ or SCM_ prefix for the #defines used with scc_read_register() and
+ * scc_write_register, or values passed/retrieved from those routines.
+ */
+
+/*! @file mxc_scc2_driver.h
+ *
+ * @brief (Header file to use the SCC2 driver.)
+ *
+ * The SCC2 driver is available to other kernel modules directly.  Secure
+ * Partition functionality is extended to users through the SHW API.  Other
+ * functionality of the SCC2 is limited to kernel-space users.
+ *
+ * With the exception of #scc_monitor_security_failure(), all routines are
+ * 'synchronous', i.e. they will not return to their caller until the requested
+ * action is complete, or fails to complete.  Some of these functions could
+ * take quite a while to perform, depending upon the request.
+ *
+ * Routines are provided to:
+ * @li trigger a security-violation alarm - #scc_set_sw_alarm()
+ * @li get configuration and version information - #scc_get_configuration()
+ * @li zeroize memory - #scc_zeroize_memories()
+ * @li Work with secure partitions: #scc_allocate_partition()
+ *     #scc_engage_partition() #scc_diminish_permissions()
+ *     #scc_release_partition()
+ * @li Encrypt or decrypt regions of data: #scc_encrypt_region()
+ *     #scc_decrypt_region()
+ * @li monitor the Security Failure alarm - #scc_monitor_security_failure()
+ * @li stop monitoring Security Failure alarm -
+ *     #scc_stop_monitoring_security_failure()
+ * @li write registers of the SCC - #scc_write_register()
+ * @li read registers of the SCC - #scc_read_register()
+ *
+ * The SCC2 encrypts and decrypts using Triple DES with an internally stored
+ * key.  When the SCC2 is in Secure mode, it uses its secret, unique-per-chip
+ * key.  When it is in Non-Secure mode, it uses a default key.  This ensures
+ * that secrets stay secret if the SCC2 is not in Secure mode.
+ *
+ * Not all functions that could be provided in a 'high level' manner have been
+ * implemented.  Among the missing are interfaces to the ASC/AIC components and
+ * the timer functions.  These and other features must be accessed through
+ * #scc_read_register() and #scc_write_register(), using the @c \#define values
+ * provided.
+ *
+ * Here is a glossary of acronyms used in the SCC2 driver documentation:
+ * - CBC - Cipher Block Chaining.  A method of performing a block cipher.
+ *    Each block is encrypted using some part of the result of the previous
+ *    block's encryption.  It needs an 'initialization vector' to seed the
+ *    operation.
+ * - ECB - Electronic Code Book.  A method of performing a block cipher.
+ *    With a given key, a given block will always encrypt to the same value.
+ * - DES - Data Encryption Standard.  (8-byte) Block cipher algorithm which
+ *    uses 56-bit keys.  In SCC2, this key is constant and unique to the device.
+ *    SCC uses the "triple DES" form of this algorithm.
+ * - AIC - Algorithm Integrity Checker.
+ * - ASC - Algorithm Sequence Checker.
+ * - SMN - Security Monitor.  The part of the SCC2 responsible for monitoring
+ *    for security problems and notifying the CPU and other PISA components.
+ * - SCM - Secure Memory.  The part of the SCC2 which handles the cryptography.
+ * - SCC - Security Controller.  Central security mechanism for PISA.
+ * - PISA - Platform-Independent Security Architecture.
+ */
+
+/* Temporarily define compile-time flags to make Doxygen happy. */
+#ifdef DOXYGEN_HACK
+/** @defgroup scccompileflags SCC Driver compile-time flags
+ *
+ * These preprocessor flags should be set, if desired, in a makefile so
+ * that they show up on the compiler command line.
+ */
+/** @addtogroup scccompileflags */
+
+/** @{ */
+/**
+ * Compile-time flag to change @ref smnregs and @ref scmregs
+ * offset values for the SCC's implementation on the MX.21 board.
+ *
+ * This must also be set properly for any code which calls the
+ * scc_read_register() or scc_write_register() functions or references the
+ * register offsets.
+ */
+#define TAHITI
+/** @} */
+#undef TAHITI
+
+#endif				/* DOXYGEN_HACK */
+
+/*! Major Version of the driver.  Used for
+    scc_configuration->driver_major_version */
+#define SCC_DRIVER_MAJOR_VERSION    2
+/*! Old Minor Version of the driver. */
+#define SCC_DRIVER_MINOR_VERSION_0    0
+/*! Minor Version of the driver.  Used for
+    scc_configuration->driver_minor_version */
+#define SCC_DRIVER_MINOR_VERSION_2    2
+
+
+/*!
+ *  Interrupt line number of SCM interrupt.
+ */
+#define INT_SCC_SCM         MXC_INT_SCC_SCM
+
+/*!
+ *  Interrupt line number of the SMN interrupt.
+ */
+#define INT_SCC_SMN         MXC_INT_SCC_SMN
+
+/**
+ * @typedef scc_return_t
+ */
+/** Common status return values from SCC driver functions. */
+	typedef enum scc_return_t {
+		SCC_RET_OK = 0,	 /**< Function succeeded  */
+		SCC_RET_FAIL,	 /**< Non-specific failure */
+		SCC_RET_VERIFICATION_FAILED,
+				 /**< Decrypt validation failed */
+		SCC_RET_TOO_MANY_FUNCTIONS,
+				 /**< At maximum registered functions */
+		SCC_RET_BUSY,	 /**< SCC is busy and cannot handle request */
+		/**< Encryption or decryption failed because@c count_out_bytes
+			says that @c data_out is too small to hold the value. */
+		SCC_RET_INSUFFICIENT_SPACE,
+	} scc_return_t;
+
+/**
+ * @typedef scc_partition_status_t
+ */
+/** Partition status information. */
+	typedef enum scc_partition_status_t {
+		SCC_PART_S_UNUSABLE,
+				  /**< Partition not implemented */
+		SCC_PART_S_UNAVAILABLE,
+				  /**< Partition owned by other host */
+		SCC_PART_S_AVAILABLE,
+				  /**< Partition available */
+		SCC_PART_S_ALLOCATED,
+				  /**< Partition owned by host but not engaged*/
+		SCC_PART_S_ENGAGED,
+				  /**< Partition owned by host and engaged */
+	} scc_partition_status_t;
+
+/**
+ * Configuration information about SCC and the driver.
+ *
+ * This struct/typedef contains information from the SCC and the driver to
+ * allow the user of the driver to determine the size of the SCC's memories and
+ * the version of the SCC and the driver.
+ */
+	typedef struct scc_config_t {
+		int driver_major_version;
+				/**< Major version of the SCC driver code  */
+		int driver_minor_version;
+				/**< Minor version of the SCC driver code  */
+		int scm_version; /**< Version from SCM Configuration register */
+		int smn_version; /**< Version from SMN Status register */
+		/**< Number of bytes per block of RAM; also
+			block size of the crypto algorithm. */
+		int block_size_bytes;
+		int partition_size_bytes;
+				/**< Number of bytes in each partition */
+		int partition_count;
+				/**< Number of partitions on this platform */
+	} scc_config_t;
+
+/**
+ * @typedef scc_enc_dec_t
+ */
+/**
+ * Determine whether SCC will run its cryptographic
+ * function as an encryption or decryption.
+ */
+	typedef enum scc_enc_dec_t {
+		SCC_ENCRYPT,	/**< Encrypt (from Red to Black) */
+		SCC_DECRYPT	/**< Decrypt (from Black to Red) */
+	} scc_enc_dec_t;
+
+/**
+ * @typedef scc_verify_t
+ */
+/**
+ * Tell the driver whether it is responsible for verifying the integrity of a
+ * secret.  During an encryption, using other than #SCC_VERIFY_MODE_NONE will
+ * cause a check value to be generated and appended to the plaintext before
+ * encryption.  During decryption, the check value will be verified after
+ * decryption, and then stripped from the message.
+ */
+	typedef enum scc_verify_t {
+    /** No verification value added or checked.  Input plaintext data must be
+     *  be a multiple of the blocksize (#scc_get_configuration()).  */
+		SCC_VERIFY_MODE_NONE,
+    /** Driver will generate/validate a 2-byte CCITT CRC.  Input plaintext
+		will be padded to a multiple of the blocksize, adding 3-10 bytes
+		to the resulting output ciphertext.  Upon decryption, this padding
+		will be stripped, and the CRC will be verified. */
+		SCC_VERIFY_MODE_CCITT_CRC
+	} scc_verify_t;
+
+/**
+ * @typedef scc_cypher_mode_t
+ */
+/**
+ * Select the cypher mode to use for partition cover/uncover operations.
+ */
+
+	typedef enum scc_cypher_mode_t {
+		SCC_CYPHER_MODE_ECB = 1,
+				   /**< ECB mode */
+		SCC_CYPHER_MODE_CBC = 2,
+				   /**< CBC mode */
+	} scc_cypher_mode_t;
+
+/**
+ * Allocate a partition of secure memory
+ *
+ * @param       smid_value  Value to use for the SMID register.  Must be 0 for
+ *                          kernel mode ownership.
+ * @param[out]  part_no     (If successful) Assigned partition number.
+ * @param[out]  part_base   Kernel virtual address of the partition.
+ * @param[out]  part_phys   Physical address of the partition.
+ *
+ * @return      SCC_RET_OK if successful.
+ */
+	extern scc_return_t
+	    scc_allocate_partition(uint32_t smid_value,
+				   int *part_no,
+				   void **part_base, uint32_t *part_phys);
+
+/* Note: This function has to be run in the same context (userspace or kernel
+ * mode) as the process that will be using the partition.  Because the SCC2 API
+ * is not accessible in user mode, this function is also provided as a macro in
+ * in fsl_shw.h.  Kernel-mode users that include this file are able to use this
+ * version of the function without having to include the whole SHW API.  If the
+ * macro definition was defined before we got here, un-define it so this
+ * version will be used instead.
+ */
+
+#ifdef scc_engage_partition
+#undef scc_engage_partition
+#endif
+
+/**
+ * Engage partition of secure memory
+ *
+ * @param part_base (kernel) Virtual
+ * @param UMID NULL, or 16-byte UMID for partition security
+ * @param permissions ORed values of the type SCM_PERM_* which will be used as
+ *                    initial partition permissions.  SHW API users should use
+ *                    the FSL_PERM_* definitions instead.
+ *
+ * @return SCC_RET_OK if successful.
+ */
+	extern scc_return_t
+	    scc_engage_partition(void *part_base,
+				 const uint8_t *UMID, uint32_t permissions);
+
+/**
+ * Release a partition of secure memory
+ *
+ * @param   part_base   Kernel virtual address of the partition to be released.
+ *
+ * @return  SCC_RET_OK if successful.
+ */
+	extern scc_return_t scc_release_partition(void *part_base);
+
+/**
+ * Diminish the permissions on a partition of secure memory
+ *
+ * @param part_base   Kernel virtual address of the partition.
+ *
+ * @param permissions ORed values of the type SCM_PERM_* which will be used as
+ *                    initial partition permissions.  SHW API users should use
+ *                    the FSL_PERM_* definitions instead.
+ *
+ * @return  SCC_RET_OK if successful.
+ */
+	extern scc_return_t
+	    scc_diminish_permissions(void *part_base, uint32_t permissions);
+
+/**
+ * Query the status of a partition of secure memory
+ *
+ * @param part_base   Kernel virtual address of the partition.
+ *
+ * @return  SCC_RET_OK if successful.
+ */
+	extern scc_partition_status_t scc_partition_status(void *part_base);
+
+/**
+ * Calculate the physical address from the kernel virtual address.
+ */
+	extern uint32_t scc_virt_to_phys(void *address);
+/*scc_return_t
+scc_verify_slot_access(uint64_t owner_id, uint32_t slot, uint32_t access_len);*/
+
+
+/**
+ * Encrypt a region of secure memory.
+ *
+ * @param   part_base    Kernel virtual address of the partition.
+ * @param   offset_bytes Offset from the start of the partition to the plaintext
+ *                       data.
+ * @param   byte_count   Length of the region (octets).
+ * @param   black_data   Physical location to store the encrypted data.
+ * @param   IV           Value to use for the Initialization Vector.
+ * @param   cypher_mode  Cyphering mode to use, specified by type
+ *                       #scc_cypher_mode_t
+ *
+ * @return  SCC_RET_OK if successful.
+ */
+	extern scc_return_t
+	    scc_encrypt_region(uint32_t part_base, uint32_t offset_bytes,
+			       uint32_t byte_count, uint8_t *black_data,
+			       uint32_t *IV, scc_cypher_mode_t cypher_mode);
+
+/**
+ * Decrypt a region into secure memory
+ *
+ * @param   part_base    Kernel virtual address of the partition.
+ * @param   offset_bytes Offset from the start of the partition to store the
+ *                       plaintext data.
+ * @param   byte_count   Length of the region (octets).
+ * @param   black_data   Physical location of the encrypted data.
+ * @param   IV           Value to use for the Initialization Vector.
+ * @param   cypher_mode  Cyphering mode to use, specified by type
+ *                       #scc_cypher_mode_t
+ *
+ * @return  SCC_RET_OK if successful.
+ */
+	extern scc_return_t
+	    scc_decrypt_region(uint32_t part_base, uint32_t offset_bytes,
+			       uint32_t byte_count, uint8_t *black_data,
+			       uint32_t *IV, scc_cypher_mode_t cypher_mode);
+
+/**
+ * Retrieve configuration information from the SCC.
+ *
+ * This function always succeeds.
+ *
+ * @return   A pointer to the configuration information.  This is a pointer to
+ *           static memory and must not be freed.  The values never change, and
+ *           the return value will never be null.
+ */
+	extern scc_config_t *scc_get_configuration(void);
+
+/**
+ * Zeroize Red and Black memories of the SCC.  This will start the Zeroizing
+ * process.  The routine will return when the memories have zeroized or failed
+ * to do so.  The driver will poll waiting for this to occur, so this
+ * routine must not be called from interrupt level.  Some future version of
+ * driver may elect instead to sleep.
+ *
+ * @return 0 or error if initialization fails.
+ */
+	extern scc_return_t scc_zeroize_memories(void);
+
+/**
+ * Signal a software alarm to the SCC.  This will take the SCC and other PISA
+ * parts out of Secure mode and into Security Failure mode.  The SCC will stay
+ * in failed mode until a reboot.
+ *
+ * @internal
+ * If the SCC is not already in fail state, simply write the
+ * #SMN_COMMAND_SET_SOFTWARE_ALARM bit in #SMN_COMMAND_REG.  Since there is no
+ * reason to wait for the interrupt to bounce back, simply act as though
+ * one did.
+ */
+	extern void scc_set_sw_alarm(void);
+
+/**
+ * This routine will register a function to be called should a Security Failure
+ * be signalled by the SCC (Security Monitor).
+ *
+ * The callback function may be called from interrupt level, it may be called
+ * from some process' task.  It should therefore not take a long time to
+ * perform its operation, and it may not sleep.
+ *
+ * @param  callback_func  Function pointer to routine which will receive
+ *                        notification of the security failure.
+ * @return         0 if function was successfully registered, non-zero on
+ *                 failure.  See #scc_return_t.
+ *
+ * @internal
+ *  There is a fixed global static array which keeps track of the requests to
+ *  monitor the failure.
+ *
+ *  Add @c callback_func to the first empty slot in #scc_callbacks[].  If there
+ *  is no room, return #SCC_RET_TOO_MANY_FUNCTIONS.
+ */
+	extern scc_return_t scc_monitor_security_failure(void
+							 callback_func(void));
+
+/**
+ * This routine will deregister a function previously registered with
+ * #scc_monitor_security_failure().
+ *
+ * @param callback_func Function pointer to routine previously registered with
+ *                      #scc_stop_monitoring_security_failure().
+ */
+	extern void scc_stop_monitoring_security_failure(void
+							 callback_func(void));
+
+/**
+ * Read value from an SCC register.
+ * The offset will be checked for validity (range) as well as whether it is
+ * accessible (e.g. not busy, not in failed state) at the time of the call.
+ *
+ * @param[in]   register_offset  The (byte) offset within the SCC block
+ *                               of the register to be queried.  See
+ *                              @ref scmregs and @ref smnregs.
+ * @param[out]  value            Pointer to where value from the register
+ *                               should be placed.
+ * @return      0 if OK, non-zero on error.  See #scc_return_t.
+ *
+ * @internal
+ *  Verify that the register_offset is a) valid, b) refers to a readable
+ *  register, and c) the SCC is in a state which would allow a read of this
+ *  register.
+ */
+	extern scc_return_t scc_read_register(int register_offset,
+					      uint32_t *value);
+
+/**
+ * Write a new value into an SCC register.
+ * The offset will be checked for validity (range) as well as whether it is
+ * accessible (e.g. not busy, not in failed state) at the time of the call.
+ *
+ * @param[in]  register_offset  The (byte) offset within the SCC block
+ *                              of the register to be modified.  See
+ *                              @ref scmregs and @ref smnregs
+ * @param[in]  value            The value to store into the register.
+ * @return     0 if OK, non-zero on error.  See #scc_return_t.
+ *
+ * @internal
+ *  Verify that the register_offset is a) valid, b) refers to a writeable
+ *  register, and c) the SCC is in a state which would allow a write to this
+ *  register.
+ */
+	extern scc_return_t scc_write_register(int register_offset,
+					       uint32_t value);
+
+/**
+ * @defgroup scmregs SCM Registers
+ *
+ * These values are offsets into the SCC for the Secure Memory
+ * (SCM) registers.  They are used in the @c register_offset parameter of
+ * #scc_read_register() and #scc_write_register().
+ */
+/** @addtogroup scmregs */
+/** @{ */
+/** Offset of SCM Version ID Register */
+#define SCM_VERSION_REG		0x000
+/** Offset of SCM Interrupt Control Register */
+#define SCM_INT_CTL_REG		0x008
+/** Offset of SCM Status Register */
+#define SCM_STATUS_REG		0x00c
+/** Offset of SCM Error Status Register */
+#define SCM_ERR_STATUS_REG	0x010
+/** Offset of SCM Fault Address Register */
+#define SCM_FAULT_ADR_REG	0x014
+/** Offset of SCM Partition Owners Register */
+#define SCM_PART_OWNERS_REG	0x018
+/** Offset of SCM Partitions Engaged Register */
+#define SCM_PART_ENGAGED_REG	0x01c
+/** Offset of SCM Unique Number 0 Register */
+#define SCM_UNIQUE_ID0_REG	0x020
+/** Offset of SCM Unique Number 1 Register */
+#define SCM_UNIQUE_ID1_REG	0x024
+/** Offset of SCM Unique Number 2 Register */
+#define SCM_UNIQUE_ID2_REG	0x028
+/** Offset of SCM Unique Number 3 Register */
+#define SCM_UNIQUE_ID3_REG	0x02c
+/** Offset of SCM Zeroize Command Register */
+#define SCM_ZCMD_REG		0x050
+/** Offset of SCM Cipher Command Register */
+#define SCM_CCMD_REG		0x054
+/** Offset of SCM Cipher Black RAM Start Address Register */
+#define SCM_C_BLACK_ST_REG	0x058
+/** Offset of SCM Internal Debug Register */
+#define SCM_DBG_STATUS_REG	0x05c
+/** Offset of SCM Cipher IV 0 Register */
+#define SCM_AES_CBC_IV0_REG	0x060
+/** Offset of SCM Cipher IV 1 Register */
+#define SCM_AES_CBC_IV1_REG	0x064
+/** Offset of SCM Cipher IV 2 Register */
+#define SCM_AES_CBC_IV2_REG	0x068
+/** Offset of SCM Cipher IV 3 Register */
+#define SCM_AES_CBC_IV3_REG	0x06c
+/** Offset of SCM SMID Partition 0 Register */
+#define SCM_SMID0_REG		0x080
+/** Offset of SCM Partition 0 Access Permissions Register */
+#define SCM_ACC0_REG		0x084
+/** Offset of SCM SMID Partition 1 Register */
+#define SCM_SMID1_REG		0x088
+/** Offset of SCM Partition 1 Access Permissions Register */
+#define SCM_ACC1_REG		0x08c
+/** Offset of SCM SMID Partition 2 Register */
+#define SCM_SMID2_REG		0x090
+/** Offset of SCM Partition 2 Access Permissions Register */
+#define SCM_ACC2_REG		0x094
+/** Offset of SCM SMID Partition 3 Register */
+#define SCM_SMID3_REG		0x098
+/** Offset of SCM Partition 3 Access Permissions Register */
+#define SCM_ACC3_REG		0x09c
+/** Offset of SCM SMID Partition 4 Register */
+#define SCM_SMID4_REG		0x0a0
+/** Offset of SCM Partition 4 Access Permissions Register */
+#define SCM_ACC4_REG		0x0a4
+/** Offset of SCM SMID Partition 5 Register */
+#define SCM_SMID5_REG		0x0a8
+/** Offset of SCM Partition 5 Access Permissions Register */
+#define SCM_ACC5_REG		0x0ac
+/** Offset of SCM SMID Partition 6 Register */
+#define SCM_SMID6_REG		0x0b0
+/** Offset of SCM Partition 6 Access Permissions Register */
+#define SCM_ACC6_REG		0x0b4
+/** Offset of SCM SMID Partition 7 Register */
+#define SCM_SMID7_REG		0x0b8
+/** Offset of SCM Partition 7 Access Permissions Register */
+#define SCM_ACC7_REG		0x0bc
+/** Offset of SCM SMID Partition 8 Register */
+#define SCM_SMID8_REG		0x0c0
+/** Offset of SCM Partition 8 Access Permissions Register */
+#define SCM_ACC8_REG		0x0c4
+/** Offset of SCM SMID Partition 9 Register */
+#define SCM_SMID9_REG		0x0c8
+/** Offset of SCM Partition 9 Access Permissions Register */
+#define SCM_ACC9_REG		0x0cc
+/** Offset of SCM SMID Partition 10 Register */
+#define SCM_SMID10_REG		0x0d0
+/** Offset of SCM Partition 10 Access Permissions Register */
+#define SCM_ACC10_REG		0x0d4
+/** Offset of SCM SMID Partition 11 Register */
+#define SCM_SMID11_REG		0x0d8
+/** Offset of SCM Partition 11 Access Permissions Register */
+#define SCM_ACC11_REG		0x0dc
+/** Offset of SCM SMID Partition 12 Register */
+#define SCM_SMID12_REG		0x0e0
+/** Offset of SCM Partition 12 Access Permissions Register */
+#define SCM_ACC12_REG		0x0e4
+/** Offset of SCM SMID Partition 13 Register */
+#define SCM_SMID13_REG		0x0e8
+/** Offset of SCM Partition 13 Access Permissions Register */
+#define SCM_ACC13_REG		0x0ec
+/** Offset of SCM SMID Partition 14 Register */
+#define SCM_SMID14_REG		0x0f0
+/** Offset of SCM Partition 14 Access Permissions Register */
+#define SCM_ACC14_REG		0x0f4
+/** Offset of SCM SMID Partition 15 Register */
+#define SCM_SMID15_REG		0x0f8
+/** Offset of SCM Partition 15 Access Permissions Register */
+#define SCM_ACC15_REG		0x0fc
+/** @} */
+
+/** Number of bytes of register space for the SCM. */
+#define SCM_REG_BANK_SIZE	0x100
+
+/** Number of bytes of register space for the SCM. */
+#define SCM_REG_BANK_SIZE	0x100
+
+/** Offset of the SMN registers */
+#define SMN_ADDR_OFFSET		0x100
+
+/**
+ * @defgroup smnregs SMN Registers
+ *
+ * These values are offsets into the SCC for the Security Monitor
+ * (SMN) registers.  They are used in the @c register_offset parameter of the
+ * #scc_read_register() and #scc_write_register().
+ */
+/** @addtogroup smnregs */
+/** @{ */
+/** Offset of SMN Status Register */
+#define SMN_STATUS_REG		(SMN_ADDR_OFFSET+0x00000000)
+/** Offset of SMH Command Register */
+#define SMN_COMMAND_REG		(SMN_ADDR_OFFSET+0x00000004)
+/** Offset of SMH Sequence Start Register */
+#define SMN_SEQ_START_REG	(SMN_ADDR_OFFSET+0x00000008)
+/** Offset of SMH Sequence End Register */
+#define SMN_SEQ_END_REG		(SMN_ADDR_OFFSET+0x0000000c)
+/** Offset of SMH Sequence Check Register */
+#define SMN_SEQ_CHECK_REG	(SMN_ADDR_OFFSET+0x00000010)
+/** Offset of SMH BitBank Count Register */
+#define SMN_BB_CNT_REG		(SMN_ADDR_OFFSET+0x00000014)
+/** Offset of SMH BitBank Increment Register */
+#define SMN_BB_INC_REG		(SMN_ADDR_OFFSET+0x00000018)
+/** Offset of SMH BitBank Decrement Register */
+#define SMN_BB_DEC_REG		(SMN_ADDR_OFFSET+0x0000001c)
+/** Offset of SMH Compare Register */
+#define SMN_COMPARE_REG		(SMN_ADDR_OFFSET+0x00000020)
+/** Offset of SMH Plaintext Check Register */
+#define SMN_PT_CHK_REG		(SMN_ADDR_OFFSET+0x00000024)
+/** Offset of SMH Ciphertext Check Register */
+#define SMN_CT_CHK_REG		(SMN_ADDR_OFFSET+0x00000028)
+/** Offset of SMH Timer Initial Value Register */
+#define SMN_TIMER_IV_REG	(SMN_ADDR_OFFSET+0x0000002c)
+/** Offset of SMH Timer Control Register */
+#define SMN_TIMER_CTL_REG	(SMN_ADDR_OFFSET+0x00000030)
+/** Offset of SMH Security Violation Register */
+#define SMN_SEC_VIO_REG		(SMN_ADDR_OFFSET+0x00000034)
+/** Offset of SMH Timer Register */
+#define SMN_TIMER_REG		(SMN_ADDR_OFFSET+0x00000038)
+/** Offset of SMH High-Assurance Control Register */
+#define SMN_HAC_REG		(SMN_ADDR_OFFSET+0x0000003c)
+/** Number of bytes allocated to the SMN registers */
+#define SMN_REG_BANK_SIZE	0x40
+/** @} */
+
+/** Number of bytes of total register space for the SCC. */
+#define SCC_ADDRESS_RANGE	(SMN_ADDR_OFFSET + SMN_REG_BANK_SIZE)
+
+/**
+ * @defgroup smnstatusregdefs SMN Status Register definitions (SMN_STATUS)
+ */
+/** @addtogroup smnstatusregdefs */
+/** @{ */
+/** SMN version id. */
+#define SMN_STATUS_VERSION_ID_MASK        0xfc000000
+/**  number of bits to shift #SMN_STATUS_VERSION_ID_MASK to get it to LSB */
+#define SMN_STATUS_VERSION_ID_SHIFT       28
+/** Illegal bus master access attempted. */
+#define SMN_STATUS_ILLEGAL_MASTER         0x01000000
+/** Scan mode entered/exited since last reset. */
+#define SMN_STATUS_SCAN_EXIT              0x00800000
+/** Some security peripheral is initializing */
+#define SMN_STATUS_PERIP_INIT             0x00010000
+/** Internal error detected in SMN. */
+#define SMN_STATUS_SMN_ERROR              0x00004000
+/** SMN has an outstanding interrupt. */
+#define SMN_STATUS_SMN_STATUS_IRQ         0x00004000
+/** Software Alarm was triggered. */
+#define SMN_STATUS_SOFTWARE_ALARM         0x00002000
+/** Timer has expired. */
+#define SMN_STATUS_TIMER_ERROR            0x00001000
+/** Plaintext/Ciphertext compare failed. */
+#define SMN_STATUS_PC_ERROR               0x00000800
+/** Bit Bank detected overflow or underflow */
+#define SMN_STATUS_BITBANK_ERROR          0x00000400
+/** Algorithm Sequence Check failed. */
+#define SMN_STATUS_ASC_ERROR              0x00000200
+/** Security Policy Block detected error. */
+#define SMN_STATUS_SECURITY_POLICY_ERROR  0x00000100
+/** Security Violation Active error. */
+#define SMN_STATUS_SEC_VIO_ACTIVE_ERROR   0x00000080
+/** Processor booted from internal ROM. */
+#define SMN_STATUS_INTERNAL_BOOT          0x00000020
+/** SMN's internal state. */
+#define SMN_STATUS_STATE_MASK             0x0000001F
+/** Number of bits to shift #SMN_STATUS_STATE_MASK to get it to LSB. */
+#define SMN_STATUS_STATE_SHIFT            0
+/** @} */
+
+/**
+ * @defgroup sccscmstates SMN Model Secure State Controller States (SMN_STATE_MASK)
+ */
+/** @addtogroup sccscmstates */
+/** @{ */
+/** This is the first state of the SMN after power-on reset  */
+#define SMN_STATE_START         0x0
+/** The SMN is zeroizing its RAM during reset */
+#define SMN_STATE_ZEROIZE_RAM   0x5
+/** SMN has passed internal checks, and is waiting for Software check-in */
+#define SMN_STATE_HEALTH_CHECK  0x6
+/** Fatal Security Violation.  SMN is locked, SCM is inoperative. */
+#define SMN_STATE_FAIL          0x9
+/** SCC is in secure state.  SCM is using secret key. */
+#define SMN_STATE_SECURE        0xA
+/** Due to non-fatal error, device is not secure.  SCM is using default key. */
+#define SMN_STATE_NON_SECURE    0xC
+/** @} */
+
+/** @{ */
+/** SCM Status bit: Key Status is Default Key in Use */
+#define SCM_STATUS_KST_DEFAULT_KEY	0x80000000
+/** SCM Status bit: Key Status is (reserved) */
+#define SCM_STATUS_KST_RESERVED1	0x40000000
+/** SCM Status bit: Key status is Wrong Key */
+#define SCM_STATUS_KST_WRONG_KEY	0x20000000
+/** SCM Status bit: Bad Key detected */
+#define SCM_STATUS_KST_BAD_KEY	0x10000000
+/** SCM Status bit: Error has occurred */
+#define SCM_STATUS_ERR		0x00008000
+/** SCM Status bit: Monitor State is Failed */
+#define SCM_STATUS_MSS_FAIL	0x00004000
+/** SCM Status bit: Monitor State is Secure */
+#define SCM_STATUS_MSS_SEC	0x00002000
+/** SCM Status bit: Secure Storage is Failed */
+#define SCM_STATUS_RSS_FAIL	0x00000400
+/** SCM Status bit: Secure Storage is Secure */
+#define SCM_STATUS_RSS_SEC	0x00000200
+/** SCM Status bit: Secure Storage is Initializing */
+#define SCM_STATUS_RSS_INIT	0x00000100
+/** SCM Status bit: Unique Number Valid */
+#define SCM_STATUS_UNV		0x00000080
+/** SCM Status bit: Big Endian mode */
+#define SCM_STATUS_BIG		0x00000040
+/** SCM Status bit: Using Secret Key */
+#define SCM_STATUS_USK		0x00000020
+/** SCM Status bit: Ram is being blocked */
+#define SCM_STATUS_BAR		0x00000010
+/** Bit mask of SRS */
+#define SCM_STATUS_SRS_MASK	0x0000000F
+/** Number of bits to shift SRS to/from MSb */
+#define SCM_STATUS_SRS_SHIFT	0
+/** @} */
+
+#define SCM_STATUS_SRS_RESET	0x0	/**< Reset, Zeroise All */
+#define SCM_STATUS_SRS_READY	0x1	/**< All Ready */
+#define SCM_STATUS_SRS_ZBUSY	0x2	/**< Zeroize Busy (Partition Only) */
+#define SCM_STATUS_SRS_CBUSY	0x3	/**< Cipher Busy */
+#define SCM_STATUS_SRS_ABUSY	0x4	/**< All Busy */
+#define SCM_STATUS_SRS_ZDONE	0x5	/**< Zeroize Done, Cipher Ready */
+#define SCM_STATUS_SRS_CDONE	0x6	/**< Cipher Done, Zeroize Ready */
+#define SCM_STATUS_SRS_ZDONE2	0x7	/**< Zeroize Done, Cipher Busy */
+#define SCM_STATUS_SRS_CDONE2	0x8	/**< Cipher Done, Zeroize Busy */
+#define SCM_STATUS_SRS_ADONE	0xD	/**< All Done */
+#define SCM_STATUS_SRS_FAIL	    0xF	/**< Fail State */
+
+
+/* Format of the SCM VERSION ID REGISTER */
+#define SCM_VER_BPP_MASK    0xFF000000	/**< Bytes Per Partition Mask */
+#define SCM_VER_BPP_SHIFT   24		/**< Bytes Per Partition Shift */
+#define SCM_VER_BPCB_MASK   0x001F0000	/**< Bytes Per Cipher Block Mask */
+#define SCM_VER_BPCB_SHIFT  16		/**< Bytes Per Cipher Block Shift */
+#define SCM_VER_NP_MASK     0x0000F000	/**< Number of Partitions Mask */
+#define SCM_VER_NP_SHIFT    12		/**< Number of Partitions Shift */
+#define SCM_VER_MAJ_MASK    0x00000F00	/**< Major Version Mask */
+#define SCM_VER_MAJ_SHIFT   8		/**< Major Version Shift */
+#define SCM_VER_MIN_MASK    0x000000FF	/**< Minor Version Mask */
+#define SCM_VER_MIN_SHIFT   0		/**< Minor Version Shift */
+
+/**< SCC Hardware version supported by this driver */
+#define SCM_MAJOR_VERSION_2 2
+
+/* Format of the SCM ERROR STATUS REGISTER */
+#define SCM_ERRSTAT_MID_MASK    0x00F00000  /**< Master ID Mask */
+#define SCM_ERRSTAT_MID_SHIFT   20	    /**< Master ID Shift */
+#define SCM_ERRSTAT_ILM         0x00080000  /**< Illegal Master */
+#define SCM_ERRSTAT_SUP         0x00008000  /**< Supervisor Access */
+#define SCM_ERRSTAT_ERC_MASK    0x00000F00  /**< Error Code Mask */
+#define SCM_ERRSTAT_ERC_SHIFT   8	    /**< Error Code Shift */
+#define SCM_ERRSTAT_SMS_MASK    0x000000F0  /**< Secure Monitor State Mask */
+#define SCM_ERRSTAT_SMS_SHIFT   4	    /**< Secure Monitor State Shift */
+#define SCM_ERRSTAT_SRS_MASK    0x0000000F  /**< Secure Ram State Mask */
+#define SCM_ERRSTAT_SRS_SHIFT   0	    /**< Secure Ram State Shift */
+
+/* SCM ERROR STATUS REGISTER ERROR CODES */
+#define SCM_ERCD_UNK_ADDR       0x1 /**< Unknown Address */
+#define SCM_ERCD_UNK_CMD        0x2 /**< Unknown Command */
+#define SCM_ERCD_READ_PERM      0x3 /**< Read Permission Error */
+#define SCM_ERCD_WRITE_PERM     0x4 /**< Write Permission Error */
+#define SCM_ERCD_DMA_ERROR      0x5 /**< DMA Error */
+#define SCM_ERCD_BLK_OVFL       0x6 /**< Encryption Block Length Overflow */
+#define SCM_ERCD_NO_KEY         0x7 /**< Key Not Engaged */
+#define SCM_ERCD_ZRZ_OVFL       0x8 /**< Zeroize Command Queue Overflow */
+#define SCM_ERCD_CPHR_OVFL      0x9 /**< Cipher Command Queue Overflow */
+#define SCM_ERCD_PROC_INTR      0xA /**< Process Interrupted */
+#define SCM_ERCD_WRNG_KEY       0xB /**< Wrong Key */
+#define SCM_ERCD_DEVICE_BUSY    0xC /**< Device Busy */
+#define SCM_ERCD_UNALGN_ADDR    0xD /**< DMA Unaligned Address */
+
+/* Format of the CIPHER COMMAND REGISTER */
+#define SCM_CCMD_LENGTH_MASK	0xFFF00000 /**< Cipher Length Mask */
+#define SCM_CCMD_LENGTH_SHIFT	20	   /**< Cipher Length Shift */
+#define SCM_CCMD_OFFSET_MASK	0x000FFF00 /**< Block Offset Mask */
+#define SCM_CCMD_OFFSET_SHIFT	8	   /**< Block Offset Shift */
+#define SCM_CCMD_PART_MASK	0x000000F0     /**< Partition Number Mask */
+#define SCM_CCMD_PART_SHIFT	4	       /**< Partition Number Shift */
+#define SCM_CCMD_CCMD_MASK	0x0000000F     /**< Cipher Command Mask */
+#define SCM_CCMD_CCMD_SHIFT	0	       /**< Cipher Command Shift */
+
+/* Values for SCM_CCMD_CCMD field */
+#define SCM_CCMD_AES_DEC_ECB 1 /**< Decrypt without Chaining (ECB) */
+#define SCM_CCMD_AES_ENC_ECB 3 /**< Encrypt without Chaining (ECB) */
+#define SCM_CCMD_AES_DEC_CBC 5 /**< Decrypt with Chaining (CBC) */
+#define SCM_CCMD_AES_ENC_CBC 7 /**< Encrypt with Chaining (CBC) */
+
+#define SCM_CCMD_AES     1     /**< Use AES Mode */
+#define SCM_CCMD_DEC     0     /**< Decrypt */
+#define SCM_CCMD_ENC     2     /**< Encrypt */
+#define SCM_CCMD_ECB     0     /**< Perform operation without chaining (ECB) */
+#define SCM_CCMD_CBC     4     /**< Perform operation with chaining (CBC) */
+
+/* Format of the ZEROIZE COMMAND REGISTER */
+#define SCM_ZCMD_PART_MASK	0x000000F0  /**< Target Partition Mask */
+#define SCM_ZCMD_PART_SHIFT	4	    /**< Target Partition Shift */
+#define SCM_ZCMD_CCMD_MASK	0x0000000F  /**< Zeroize Command Mask */
+#define SCM_ZCMD_CCMD_SHIFT	0	    /**< Zeroize Command Shift */
+
+/* MASTER ACCESS PERMISSIONS REGISTER */
+/* Note that API users should use the FSL_PERM_ defines instead of these */
+/** SCM Access Permission: Do not zeroize/deallocate partition
+	on SMN Fail state */
+#define SCM_PERM_NO_ZEROIZE	0x10000000
+/** SCM Access Permission: Ignore Supervisor/User mode
+	in permission determination */
+#define SCM_PERM_HD_SUP_DISABLE	0x00000800
+/** SCM Access Permission: Allow Read Access to  Host Domain */
+#define SCM_PERM_HD_READ	0x00000400
+/** SCM Access Permission: Allow Write Access to  Host Domain */
+#define SCM_PERM_HD_WRITE	0x00000200
+/** SCM Access Permission: Allow Execute Access to  Host Domain */
+#define SCM_PERM_HD_EXECUTE	0x00000100
+/** SCM Access Permission: Allow Read Access to Trusted Host Domain */
+#define SCM_PERM_TH_READ	0x00000040
+/** SCM Access Permission: Allow Write Access to Trusted Host Domain */
+#define SCM_PERM_TH_WRITE	0x00000020
+/** SCM Access Permission: Allow Read Access to Other/World Domain */
+#define SCM_PERM_OT_READ	0x00000004
+/** SCM Access Permission: Allow Write Access to Other/World Domain */
+#define SCM_PERM_OT_WRITE	0x00000002
+/** SCM Access Permission: Allow Execute Access to Other/World Domain */
+#define SCM_PERM_OT_EXECUTE	0x00000001
+/**< Valid bits that can be set in the Permissions register */
+#define SCM_PERM_MASK 0xC0000F67
+
+/* Zeroize Command register definitions */
+#define ZCMD_DEALLOC_PART 3	 /**< Deallocate Partition */
+#define Z_INT_EN	0x00000002   /**< Zero Interrupt Enable */
+
+/**
+ * @defgroup scmpartitionownersregdefs SCM Partition Owners Register
+ */
+/** @addtogroup scmpartitionownersregdefs */
+/** @{ */
+/** Number of bits to shift partition number to get to its field. */
+#define SCM_POWN_SHIFT   2
+/** Mask for a field once the register has been shifted. */
+#define SCM_POWN_MASK    3
+/** Partition is free */
+#define SCM_POWN_PART_FREE       0
+/** Partition is unable to be allocated */
+#define SCM_POWN_PART_UNUSABLE   1
+/** Partition is owned by another master */
+#define SCM_POWN_PART_OTHER      2
+/** Partition is owned by this master */
+#define SCM_POWN_PART_OWNED      3
+/** @} */
+
+/**
+ * @defgroup smnpartitionsengagedregdefs SCM Partitions Engaged Register
+ */
+/** @addtogroup smnpartitionsengagedregdefs */
+/** @{ */
+/** Number of bits to shift partition number to get to its field. */
+#define SCM_PENG_SHIFT   1
+/** Engaged value for a field once the register has been shifted. */
+#define SCM_PENG_ENGAGED    1
+/** @} */
+
+/** Number of bytes between each subsequent SMID register */
+#define SCM_SMID_WIDTH      8
+
+/**
+ * @defgroup smncommandregdefs SMN Command Register Definitions (SMN_COMMAND_REG)
+ */
+/** @addtogroup smncommandregdefs */
+/** @{ */
+
+/** These bits are unimplemented or reserved */
+#define SMN_COMMAND_ZEROS_MASK   0xfffffff0
+#define SMN_COMMAND_CLEAR_INTERRUPT     0x8 /**< Clear SMN Interrupt */
+#define SMN_COMMAND_CLEAR_BIT_BANK      0x4 /**< Clear SMN Bit Bank */
+#define SMN_COMMAND_ENABLE_INTERRUPT    0x2 /**< Enable SMN Interrupts */
+#define SMN_COMMAND_SET_SOFTWARE_ALARM  0x1 /**< Set Software Alarm */
+/** @} */
+
+/**
+ * @defgroup smntimercontroldefs SMN Timer Control Register definitions (SMN_TIMER_CONTROL)
+ */
+/** @addtogroup smntimercontroldefs */
+/** @{ */
+/** These bits are reserved or zero */
+#define SMN_TIMER_CTRL_ZEROS_MASK 0xfffffffc
+/** Load the timer from #SMN_TIMER_IV_REG */
+#define SMN_TIMER_LOAD_TIMER             0x2
+/** Setting to zero stops the Timer */
+#define SMN_TIMER_STOP_MASK              0x1
+/** Setting this value starts the timer */
+#define SMN_TIMER_START_TIMER            0x1
+/** @} */
+
+/**
+ * @defgroup scmchainmodedefs SCM_CHAINING_MODE_MASK - Bit definitions
+ */
+/** @addtogroup scmchainmodedefs */
+/** @{ */
+#define SCM_CBC_MODE            0x2 /**< Cipher block chaining */
+#define SCM_ECB_MODE            0x0 /**< Electronic codebook. */
+/** @} */
+
+/* Bit definitions in the SCM_CIPHER_MODE_MASK */
+/**
+ * @defgroup scmciphermodedefs SCM_CIPHER_MODE_MASK - Bit definitions
+ */
+/** @addtogroup scmciphermodedefs */
+/** @{ */
+#define SCM_DECRYPT_MODE        0x1 /**< decrypt from black to red memory */
+#define SCM_ENCRYPT_MODE        0x0 /**< encrypt from red to black memory */
+/** @} */
+
+/**
+ * @defgroup smndbgdetdefs SMN Debug Detector Status Register (SCM_DEBUG_DETECT_STAT)
+ */
+/** @addtogroup smndbgdetdefs */
+/** @{ */
+#define SMN_DBG_ZEROS_MASK  0xfffff000 /**< These bits are zero or reserved */
+#define SMN_DBG_D12             0x0800 /**< Error detected on Debug Port D12 */
+#define SMN_DBG_D11             0x0400 /**< Error detected on Debug Port D11 */
+#define SMN_DBG_D10             0x0200 /**< Error detected on Debug Port D10 */
+#define SMN_DBG_D9              0x0100 /**< Error detected on Debug Port D9 */
+#define SMN_DBG_D8              0x0080 /**< Error detected on Debug Port D8 */
+#define SMN_DBG_D7              0x0040 /**< Error detected on Debug Port D7 */
+#define SMN_DBG_D6              0x0020 /**< Error detected on Debug Port D6 */
+#define SMN_DBG_D5              0x0010 /**< Error detected on Debug Port D5 */
+#define SMN_DBG_D4              0x0008 /**< Error detected on Debug Port D4 */
+#define SMN_DBG_D3              0x0004 /**< Error detected on Debug Port D3 */
+#define SMN_DBG_D2              0x0002 /**< Error detected on Debug Port D2 */
+#define SMN_DBG_D1              0x0001 /**< Error detected on Debug Port D1 */
+/** @} */
+
+/** Mask for the usable bits of the Sequence Start Register
+    (#SMN_SEQ_START_REG) */
+#define SMN_SEQUENCE_START_MASK    0x0000ffff
+
+/** Mask for the usable bits of the Sequence End Register
+    (#SMN_SEQ_END_REG) */
+#define SMN_SEQUENCE_END_MASK      0x0000ffff
+
+/** Mask for the usable bits of the Sequence Check Register
+    (#SMN_SEQ_CHECK_REG) */
+#define SMN_SEQUENCE_CHECK_MASK    0x0000ffff
+
+/** Mask for the usable bits of the Bit Counter Register
+    (#SMN_BB_CNT_REG) */
+#define SMN_BIT_COUNT_MASK         0x000007ff
+
+/** Mask for the usable bits of the Bit Bank Increment Size Register
+    (#SMN_BB_INC_REG) */
+#define SMN_BITBANK_INC_SIZE_MASK  0x000007ff
+
+/** Mask for the usable bits of the Bit Bank Decrement Register
+    (#SMN_BB_DEC_REG) */
+#define SMN_BITBANK_DECREMENT_MASK 0x000007ff
+
+/** Mask for the usable bits of the Compare Size Register
+    (#SMN_COMPARE_REG) */
+#define SMN_COMPARE_SIZE_MASK      0x0000003f
+
+/*! @} */
+
+#endif				/* SCC_DRIVER_H */
diff --git a/include/linux/mxc_scc_driver.h b/include/linux/mxc_scc_driver.h
new file mode 100644
index 0000000..5cb0585
--- /dev/null
+++ b/include/linux/mxc_scc_driver.h
@@ -0,0 +1,1031 @@
+
+/*
+ * Copyright 2004-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef __ASM_ARCH_MXC_SCC_DRIVER_H__
+#define __ASM_ARCH_MXC_SCC_DRIVER_H__
+
+/* Start marker for C++ compilers */
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * NAMING CONVENTIONS
+ * ==================
+ * (A note to maintainers and other interested parties)
+ *
+ * Use scc_ or SCC_ prefix for 'high-level' interface routines and the types
+ * passed to those routines.  Try to avoid #defines in these interfaces.
+ *
+ * Use SMN_ or SCM_ prefix for the #defines used with scc_read_register() and
+ * scc_write_register, or values passed/retrieved from those routines.
+ */
+
+/*!
+ * @defgroup MXCSCC SCC Driver
+ *
+ * @ingroup MXCSECDRVRS
+ */
+
+/*!
+ * @file arch-mxc/mxc_scc_driver.h
+ *
+ * @brief (Header file to use the SCC driver.)
+ *
+ * The SCC driver will only be available to other kernel modules.  That is,
+ * there will be no node file in /dev, no way for a user-mode program to access
+ * the driver, no way for a user program to access the device directly.
+ *
+ * With the exception of #scc_monitor_security_failure(), all routines are
+ * 'synchronous', i.e. they will not return to their caller until the requested
+ * action is complete, or fails to complete.  Some of these functions could
+ * take quite a while to perform, depending upon the request.
+ *
+ * Routines are provided to:
+ * @li encrypt or decrypt secrets - #scc_crypt()
+ * @li trigger a security-violation alarm - #scc_set_sw_alarm()
+ * @li get configuration and version information - #scc_get_configuration()
+ * @li zeroize memory - #scc_zeroize_memories()
+ * @li Work on wrapped and stored secret values: #scc_alloc_slot(),
+ *     #scc_dealloc_slot(), scc_load_slot(), #scc_decrypt_slot(),
+ *     #scc_encrypt_slot(), #scc_get_slot_info()
+
+ * @li monitor the Security Failure alarm - #scc_monitor_security_failure()
+ * @li stop monitoring Security Failure alarm -
+ *     #scc_stop_monitoring_security_failure()
+ * @li write registers of the SCC - #scc_write_register()
+ * @li read registers of the SCC - #scc_read_register()
+ *
+ * The driver does not allow "storage" of data in either the Red or Black
+ * memories.  Any decrypted secret is returned to the user, and if the user
+ * wants to use it at a later point, the encrypted form must again be passed
+ * to the driver, and it must be decrypted again.
+ *
+ * The SCC encrypts and decrypts using Triple DES with an internally stored
+ * key.  When the SCC is in Secure mode, it uses its secret, unique-per-chip
+ * key.  When it is in Non-Secure mode, it uses a default key.  This ensures
+ * that secrets stay secret if the SCC is not in Secure mode.
+ *
+ * Not all functions that could be provided in a 'high level' manner have been
+ * implemented.  Among the missing are interfaces to the ASC/AIC components and
+ * the timer functions.  These and other features must be accessed through
+ * #scc_read_register() and #scc_write_register(), using the @c \#define values
+ * provided.
+ *
+ * Here is a glossary of acronyms used in the SCC driver documentation:
+ * - CBC - Cipher Block Chaining.  A method of performing a block cipher.
+ *    Each block is encrypted using some part of the result of the previous
+ *    block's encryption.  It needs an 'initialization vector' to seed the
+ *    operation.
+ * - ECB - Electronic Code Book.  A method of performing a block cipher.
+ *    With a given key, a given block will always encrypt to the same value.
+ * - DES - Data Encryption Standard.  (8-byte) Block cipher algorithm which
+ *    uses 56-bit keys.  In SCC, this key is constant and unique to the device.
+ *    SCC uses the "triple DES" form of this algorithm.
+ * - AIC - Algorithm Integrity Checker.
+ * - ASC - Algorithm Sequence Checker.
+ * - SMN - Security Monitor.  The part of the SCC responsible for monitoring
+ *    for security problems and notifying the CPU and other PISA components.
+ * - SCM - Secure Memory.  The part of the SCC which handles the cryptography.
+ * - SCC - Security Controller.  Central security mechanism for PISA.
+ * - PISA - Platform-Independent Security Architecture.
+ */
+
+/* Temporarily define compile-time flags to make Doxygen happy. */
+#ifdef DOXYGEN_HACK
+/*! @defgroup scccompileflags SCC Driver compile-time flags
+ *
+ * These preprocessor flags should be set, if desired, in a makefile so
+ * that they show up on the compiler command line.
+ */
+/*! @addtogroup scccompileflags */
+
+/*! @{ */
+/*!
+ * Compile-time flag to change @ref smnregs and @ref scmregs
+ * offset values for the SCC's implementation on the MX.21 board.
+ *
+ * This must also be set properly for any code which calls the
+ * scc_read_register() or scc_write_register() functions or references the
+ * register offsets.
+ */
+#define TAHITI
+/*! @} */
+#undef TAHITI
+
+#endif				/* DOXYGEN_HACK */
+
+/*! Major Version of the driver.  Used for
+    scc_configuration->driver_major_version */
+#define SCC_DRIVER_MAJOR_VERSION_1 1
+/*! Old Minor Version of the driver. */
+#define SCC_DRIVER_MINOR_VERSION_0 0
+/*! Old Minor Version of the driver. */
+#define SCC_DRIVER_MINOR_VERSION_4 4
+/*! Old Minor Version of the driver. */
+#define SCC_DRIVER_MINOR_VERSION_5 5
+/*! Old Minor Version of the driver. */
+#define SCC_DRIVER_MINOR_VERSION_6 6
+/*! Minor Version of the driver.  Used for
+    scc_configuration->driver_minor_version */
+#define SCC_DRIVER_MINOR_VERSION_8 8
+
+
+/*!
+ * @typedef scc_return_t
+ */
+/*! Common status return values from SCC driver functions. */
+	typedef enum scc_return_t {
+		SCC_RET_OK = 0,	/*!< Function succeeded  */
+		SCC_RET_FAIL,	/*!< Non-specific failure */
+		SCC_RET_VERIFICATION_FAILED,	/*!< Decrypt validation failed */
+		SCC_RET_TOO_MANY_FUNCTIONS,	/*!< At maximum registered functions */
+		SCC_RET_BUSY,	/*!< SCC is busy and cannot handle request */
+		SCC_RET_INSUFFICIENT_SPACE,	/*!< Encryption or decryption failed because
+							   @c count_out_bytes says that @c data_out is
+							   too small to hold the value. */
+	} scc_return_t;
+
+/*!
+ * Configuration information about SCC and the driver.
+ *
+ * This struct/typedef contains information from the SCC and the driver to
+ * allow the user of the driver to determine the size of the SCC's memories and
+ * the version of the SCC and the driver.
+ */
+	typedef struct scc_config_t {
+		int driver_major_version;	/*!< Major version of the SCC driver code  */
+		int driver_minor_version;	/*!< Minor version of the SCC driver code  */
+		int scm_version;	/*!< Version from SCM Configuration register */
+		int smn_version;	/*!< Version from SMN Status register */
+		int block_size_bytes;	/*!< Number of bytes per block of RAM; also
+					   block size of the crypto algorithm. */
+		int black_ram_size_blocks;	/*!< Number of blocks of Black RAM */
+		int red_ram_size_blocks;	/*!< Number of blocks of Red RAM */
+	} scc_config_t;
+
+/*!
+ * @typedef scc_enc_dec_t
+ */
+/*!
+ * Determine whether SCC will run its cryptographic
+ * function as an encryption or decryption.  Used as an argument to
+ * #scc_crypt().
+ */
+	typedef enum scc_enc_dec_t {
+		SCC_ENCRYPT,	/*!< Encrypt (from Red to Black) */
+		SCC_DECRYPT	/*!< Decrypt (from Black to Red) */
+	} scc_enc_dec_t;
+
+/*
+ * @typedef scc_crypto_mode_t
+ */
+/*!
+ * Determine whether SCC will run its cryptographic function in ECB (electronic
+ * codebook) or CBC (cipher-block chaining) mode.  Used as an argument to
+ * #scc_crypt().
+ */
+	typedef enum scc_crypto_mode_t {
+		SCC_ECB_MODE,	/*!< Electronic Codebook Mode */
+		SCC_CBC_MODE	/*!< Cipher Block Chaining Mode  */
+	} scc_crypto_mode_t;
+
+/*!
+ * @typedef scc_verify_t
+ */
+/*!
+ * Tell the driver whether it is responsible for verifying the integrity of a
+ * secret.  During an encryption, using other than #SCC_VERIFY_MODE_NONE will
+ * cause a check value to be generated and appended to the plaintext before
+ * encryption.  During decryption, the check value will be verified after
+ * decryption, and then stripped from the message.
+ */
+	typedef enum scc_verify_t {
+		/*! No verification value added or checked.  Input plaintext data must be
+		 *  be a multiple of the blocksize (#scc_get_configuration()).  */
+		SCC_VERIFY_MODE_NONE,
+		/*! Driver will generate/validate a 2-byte CCITT CRC.  Input plaintext will
+		   be padded to a multiple of the blocksize, adding 3-10 bytes to the
+		   resulting output ciphertext.  Upon decryption, this padding will be
+		   stripped, and the CRC will be verified. */
+		SCC_VERIFY_MODE_CCITT_CRC
+	} scc_verify_t;
+
+/*!
+ * Determine if the given credentials match that of the key slot.
+ *
+ * @param[in]  owner_id     A value which will control access to the slot.
+ * @param[in]  slot         Key Slot to query
+ * @param[in]  access_len   Length of the key
+ *
+ * @return     0 on success, non-zero on failure.  See #scc_return_t.
+ */
+	 scc_return_t
+	    scc_verify_slot_access(uint64_t owner_id, uint32_t slot,
+				   uint32_t access_len);
+
+/*!
+ * Retrieve configuration information from the SCC.
+ *
+ * This function always succeeds.
+ *
+ * @return   A pointer to the configuration information.  This is a pointer to
+ *           static memory and must not be freed.  The values never change, and
+ *           the return value will never be null.
+ */
+	extern scc_config_t *scc_get_configuration(void);
+
+/*!
+ * Zeroize Red and Black memories of the SCC.  This will start the Zeroizing
+ * process.  The routine will return when the memories have zeroized or failed
+ * to do so.  The driver will poll waiting for this to occur, so this
+ * routine must not be called from interrupt level.  Some future version of
+ * driver may elect instead to sleep.
+ *
+ * @return 0 or error if initialization fails.
+ */
+	extern scc_return_t scc_zeroize_memories(void);
+
+/*!
+ * Perform a Triple DES encryption or decryption operation.
+ *
+ * This routine will cause the SCM to perform an encryption or decryption with
+ * its internal key.  If the SCC's #SMN_STATUS register shows that the SCC is
+ * in #SMN_STATE_SECURE, then the Secret Key will be used.  If it is
+ * #SMN_STATE_NON_SECURE (or health check), then the Default Key will be used.
+ *
+ * This function will perform in a variety of ways, depending upon the values
+ * of @c direction, @c crypto_mode, and @c check_mode.  If
+ * #SCC_VERIFY_MODE_CCITT_CRC mode is requested, upon successful completion,
+ * the @c count_in_bytes will be different from the returned value of @c
+ * count_out_bytes.  This is because the two-byte CRC and some amount of
+ * padding (at least one byte) will either be added or stripped.
+ *
+ * This function will not return until the SCC has performed the operation (or
+ * reported failure to do so).  It must therefore not be called from interrupt
+ * level.  In the current version, it will poll the SCC for completion.  In
+ * future versions, it may sleep.
+ *
+ * @param[in]    count_in_bytes The number of bytes to move through the crypto
+ *                            function.  Must be greater than zero.
+ *
+ * @param[in]    data_in      Pointer to the array of bytes to be used as input
+ *                            to the crypto function.
+ *
+ * @param[in]    init_vector  Pointer to the block-sized (8 byte) array of
+ *                            bytes which form the initialization vector for
+ *                            this operation.  A non-null value is required
+ *                            when @c crypto_mode has the value #SCC_CBC_MODE;
+ *                            the value is ignored in #SCC_ECB_MODE.
+ *
+ * @param[in]    direction    Direct the driver to perform encryption or
+ *                            decryption.
+ *
+ * @param[in]    crypto_mode  Run the crypto function in ECB or CBC mode.
+ *
+ * @param[in]    check_mode   During encryption, generate and append a check
+ *                            value to the plaintext and pad the resulting
+ *                            data.  During decryption, validate the plaintext
+ *                            with that check value and remove the padding.
+ *
+ * @param[in,out] count_out_bytes On input, the number of bytes available for
+ *                            copying to @c data_out.  On return, the number of
+ *                            bytes copied to @c data_out.
+ *
+ * @param[out] data_out       Pointer to the array of bytes that are where the
+ *                            output of the crypto function are to be placed.
+ *                            For encryption, this must be able to hold a
+ *                            longer ciphertext than the plaintext message at
+ *                            @c data_in.  The driver will append a 'pad' of
+ *                            1-8 bytes to the message, and if @c check_mode is
+ *                            used, additional bytes may be added, the number
+ *                            depending upon the type of check being requested.
+ *
+ * @return     0 on success, non-zero on failure.  See #scc_return_t.
+ *
+ * @internal
+ * This function will verify SCC state and the functions parameters.  It will
+ * acquire the crypto lock, and set up some SCC registers and variables common
+ * to encryption and decryption.  A rough check will be made to verify that
+ * enough space is available in @c count_out_bytes.  Upon success, either the
+ * #scc_encrypt or #scc_decrypt routine will be called to do the actual work.
+ * The crypto lock will then be released.
+ */
+extern scc_return_t scc_crypt(unsigned long count_in_bytes,
+				      const uint8_t *data_in,
+				      const uint8_t *init_vector,
+				      scc_enc_dec_t direction,
+				      scc_crypto_mode_t crypto_mode,
+				      scc_verify_t check_mode,
+				      uint8_t *data_out,
+				      unsigned long *count_out_bytes);
+
+
+/*!
+ * Allocate a key slot for a stored key (or other stored value).
+ *
+ * This feature is to allow decrypted secret values to be kept in RED RAM.
+ * This can all visibility of the data only by Sahara.
+ *
+ * @param   value_size_bytes  Size, in bytes, of RED key/value.  Currently only
+ *                            a size up to 32 bytes is supported.
+ *
+ * @param      owner_id       A value which will control access to the slot.
+ *                            It must be passed into to any subsequent calls to
+ *                            use the assigned slot.
+ *
+ * @param[out] slot           The slot number for the key.
+ *
+ * @return     0 on success, non-zero on failure.  See #scc_return_t.
+ */
+	extern scc_return_t scc_alloc_slot(uint32_t value_size_bytes,
+					   uint64_t owner_id, uint32_t *slot);
+
+/*!
+ * Deallocate the key slot of a stored key or secret value.
+ *
+ * @param      owner_id       The id which owns the @c slot.
+ *
+ * @param      slot           The slot number for the key.
+
+ * @return     0 on success, non-zero on failure.  See #scc_return_t.
+ */
+	extern scc_return_t scc_dealloc_slot(uint64_t owner_id, uint32_t slot);
+
+/*!
+ * Load a value into a slot.
+ *
+ * @param owner_id      Value of owner of slot
+ * @param slot          Handle of slot
+ * @param key_data      Data to load into the slot
+ * @param key_length    Length, in bytes, of @c key_data to copy to SCC.
+ *
+ * @return SCC_RET_OK on success.  SCC_RET_FAIL will be returned if slot
+ * specified cannot be accessed for any reason, or SCC_RET_INSUFFICIENT_SPACE
+ * if @c key_length exceeds the size of the slot.
+ */
+	extern scc_return_t scc_load_slot(uint64_t owner_id, uint32_t slot,
+					  const uint8_t *key_data,
+					  uint32_t key_length);
+/*!
+ * Read a value from a slot.
+ *
+ * @param owner_id      Value of owner of slot
+ * @param slot          Handle of slot
+ * @param key_length    Length, in bytes, of @c key_data to copy from SCC.
+ * @param key_data      Location to write the key
+ *
+ * @return SCC_RET_OK on success.  SCC_RET_FAIL will be returned if slot
+ * specified cannot be accessed for any reason, or SCC_RET_INSUFFICIENT_SPACE
+ * if @c key_length exceeds the size of the slot.
+ */
+	extern scc_return_t scc_read_slot(uint64_t owner_id, uint32_t slot,
+					  uint32_t key_length,
+					  uint8_t *key_data);
+
+/*!
+ * Allocate a key slot to fit the requested size.
+ *
+ * @param owner_id      Value of owner of slot
+ * @param slot          Handle of slot
+ * @param length        Length, in bytes, of @c black_data
+ * @param black_data    Location to store result of encrypting RED data in slot
+ *
+ * @return SCC_RET_OK on success, SCC_RET_FAIL if slot specified cannot be
+ *         accessed for any reason.
+ */
+	extern scc_return_t scc_encrypt_slot(uint64_t owner_id, uint32_t slot,
+					     uint32_t length,
+					     uint8_t *black_data);
+
+/*!
+ * Decrypt some black data and leave result in the slot.
+ *
+ * @param owner_id      Value of owner of slot
+ * @param slot          Handle of slot
+ * @param length        Length, in bytes, of @c black_data
+ * @param black_data    Location of data to dencrypt and store in slot
+ *
+ * @return SCC_RET_OK on success, SCC_RET_FAIL if slot specified cannot be
+ *         accessed for any reason.
+ */
+	extern scc_return_t scc_decrypt_slot(uint64_t owner_id, uint32_t slot,
+					     uint32_t length,
+					     const uint8_t *black_data);
+
+/*!
+ * Get attributes of data in RED slot.
+ *
+ * @param      owner_id         The id which owns the @c slot.
+ *
+ * @param      slot             The slot number for the key.
+ *
+ * @param[out] address          Physical address of RED value.
+ *
+ * @param[out] value_size_bytes Length, in bytes, of RED value,
+ *                              or NULL if unneeded..
+ *
+ * @param[out] slot_size_bytes  Length, in bytes, of slot size,
+ *                              or NULL if unneeded..
+ *
+ * @return     0 on success, non-zero on failure.  See #scc_return_t.
+ */
+	extern scc_return_t scc_get_slot_info(uint64_t owner_id, uint32_t slot,
+					      uint32_t *address,
+					      uint32_t *value_size_bytes,
+					      uint32_t *slot_size_bytes);
+
+/*!
+ * Signal a software alarm to the SCC.  This will take the SCC and other PISA
+ * parts out of Secure mode and into Security Failure mode.  The SCC will stay
+ * in failed mode until a reboot.
+ *
+ * @internal
+ * If the SCC is not already in fail state, simply write the
+ * #SMN_COMMAND_SET_SOFTWARE_ALARM bit in #SMN_COMMAND.  Since there is no
+ * reason to wait for the interrupt to bounce back, simply act as though
+ * one did.
+ */
+	extern void scc_set_sw_alarm(void);
+
+/*!
+ * This routine will register a function to be called should a Security Failure
+ * be signalled by the SCC (Security Monitor).
+ *
+ * The callback function may be called from interrupt level, it may be called
+ * from some process' task.  It should therefore not take a long time to
+ * perform its operation, and it may not sleep.
+ *
+ * @param  callback_func  Function pointer to routine which will receive
+ *                        notification of the security failure.
+ * @return         0 if function was successfully registered, non-zero on
+ *                 failure.  See #scc_return_t.
+ *
+ * @internal
+ *  There is a fixed global static array which keeps track of the requests to
+ *  monitor the failure.
+ *
+ *  Add @c callback_func to the first empty slot in #scc_callbacks[].  If there
+ *  is no room, return #SCC_RET_TOO_MANY_FUNCTIONS.
+ */
+	extern scc_return_t scc_monitor_security_failure(void
+							 callback_func(void));
+
+/*!
+ * This routine will deregister a function previously registered with
+ * #scc_monitor_security_failure().
+ *
+ * @param callback_func Function pointer to routine previously registered with
+ *                      #scc_stop_monitoring_security_failure().
+ */
+	extern void scc_stop_monitoring_security_failure(void
+							 callback_func(void));
+
+/*!
+ * Read value from an SCC register.
+ * The offset will be checked for validity (range) as well as whether it is
+ * accessible (e.g. not busy, not in failed state) at the time of the call.
+ *
+ * @param[in]   register_offset  The (byte) offset within the SCC block
+ *                               of the register to be queried. See
+ *                              @ref scmregs and @ref smnregs.
+ * @param[out]  value            Pointer to where value from the register
+ *                               should be placed.
+ * @return      0 if OK, non-zero on error.  See #scc_return_t.
+ *
+ * @internal
+ *  Verify that the register_offset is a) valid, b) refers to a readable
+ *  register, and c) the SCC is in a state which would allow a read of this
+ *  register.
+ */
+	extern scc_return_t scc_read_register(int register_offset,
+					      uint32_t *value);
+
+/*!
+ * Write a new value into an SCC register.
+ * The offset will be checked for validity (range) as well as whether it is
+ * accessible (e.g. not busy, not in failed state) at the time of the call.
+ *
+ * @param[in]  register_offset  The (byte) offset within the SCC block
+ *                              of the register to be modified. See
+ *                              @ref scmregs and @ref smnregs.
+ * @param[in]  value            The value to store into the register.
+ * @return     0 if OK, non-zero on error.  See #scc_return_t.
+ *
+ * @internal
+ *  Verify that the register_offset is a) valid, b) refers to a writeable
+ *  register, and c) the SCC is in a state which would allow a write to this
+ *  register.
+ */
+	extern scc_return_t scc_write_register(int register_offset,
+					       uint32_t value);
+
+/*
+ * NOTE TO MAINTAINERS
+ *
+ * All of the doxygen comments for the register offset values are in this the
+ * following comment section.  Any changes to register names or definitions
+ * must be reflected in this section and in both the TAHITI and non-TAHITI
+ *version of the memory map.
+ */
+
+/*!
+ * @defgroup scmregs SCM Registers
+ *
+ * These values are offsets into the SCC for the Secure Memory
+ * (SCM) registers.  They are used in the @c register_offset parameter of
+ * #scc_read_register() and #scc_write_register().
+ */
+/*! @addtogroup scmregs */
+/*! @{ */
+/*! @def SCM_RED_START
+ * Starting block offset in red memory for cipher function. */
+
+/*! @def SCM_BLACK_START
+ * Starting block offset in black memory for cipher function. */
+
+/*! @def SCM_LENGTH
+ * Number of blocks to process during cipher function */
+
+/*! @def SCM_CONTROL
+ * SCM Control register.
+ * See @ref scmcontrolregdefs "SCM Control Register definitions" for details.
+ */
+
+/*! @def SCM_STATUS
+ * SCM Status register.
+ * See @ref scmstatusregdefs "SCM Status Register Definitions" for details.
+ */
+
+/*! @def SCM_ERROR_STATUS
+ * SCM Error Status Register.
+ * See @ref scmerrstatdefs "SCM Error Status Register definitions" for
+ * details. */
+
+/*! @def SCM_INTERRUPT_CTRL
+ * SCM Interrupt Control Register.
+ * See @ref scminterruptcontroldefs "SCM Interrupt Control Register definitions"
+ * for details.
+ */
+
+/*! @def SCM_CONFIGURATION
+ * SCM Configuration Register.
+ * See @ref scmconfigdefs "SCM Configuration Register Definitions" for
+ * details.
+ */
+
+/*! @def SCM_INIT_VECTOR_0
+ * Upper Half of the Initialization Vector */
+
+/*! @def SCM_INIT_VECTOR_1
+ * Lower Half of the Initialization Vector */
+
+/*! @def SCM_RED_MEMORY
+ * Starting location of first block of Red memory */
+
+/*! @def SCM_BLACK_MEMORY
+ * Starting location of first block of Black memory */
+
+	/*! @} *//* end of SCM group */
+
+/*!
+ * @defgroup smnregs SMN Registers
+ *
+ * These values are offsets into the SCC for the Security Monitor
+ * (SMN) registers.  They are used in the @c register_offset parameter of the
+ * #scc_read_register() and #scc_write_register().
+ */
+/*! @addtogroup smnregs */
+/*! @{ */
+/*! @def SMN_STATUS
+ * Status register for SMN.
+ * See @ref smnstatusregdefs "SMN Status Register definitions" for further
+ * information.
+ */
+
+/*! @def SMN_COMMAND
+ * Command register for SMN. See
+ * @ref smncommandregdefs "Command Register Definitions" for further
+ * information.
+ */
+
+/*! @def SMN_SEQUENCE_START
+ * Sequence Start register for ASC. See #SMN_SEQUENCE_START_MASK
+ */
+
+/*! @def SMN_SEQUENCE_END
+ * Sequence End register for ASC. See #SMN_SEQUENCE_CHECK_MASK
+ */
+
+/*! @def SMN_SEQUENCE_CHECK
+ * Sequence Check register for ASC. See #SMN_SEQUENCE_END_MASK
+ */
+
+/*! @def SMN_BIT_COUNT
+ * Bit Bank Repository for AIC. See #SMN_BIT_COUNT_MASK
+ */
+
+/*! @def SMN_BITBANK_INC_SIZE
+ * Bit Bank Increment Size for AIC. See #SMN_BITBANK_INC_SIZE_MASK
+ */
+
+/*! @def SMN_BITBANK_DECREMENT
+ * Bit Bank Decrement for AIC. See #SMN_BITBANK_DECREMENT_MASK
+ */
+
+/*! @def SMN_COMPARE_SIZE
+ * Compare Size register for Plaintext/Ciphertext checker.  See
+ * #SMN_COMPARE_SIZE_MASK */
+
+/*! @def SMN_PLAINTEXT_CHECK
+ * Plaintext Check register for Plaintext/Ciphertext checker.
+ */
+
+/*! @def SMN_CIPHERTEXT_CHECK
+ * Ciphertext Check register for Plaintext/Ciphertext checker.
+ */
+
+/*! @def SMN_TIMER_IV
+ * Timer Initial Value register
+ */
+
+/*! @def SMN_TIMER_CONTROL
+ * Timer Control register.
+ * See @ref smntimercontroldefs "SMN Timer Control Register definitions".
+ */
+
+/*! @def SMN_DEBUG_DETECT_STAT
+ * Debug Detector Status Register
+ * See @ref smndbgdetdefs "SMN Debug Detector Status Register"for definitions.
+ */
+
+/*! @def SMN_TIMER
+ * Current value of the Timer Register
+ */
+
+	/*! @} *//* end of SMN group */
+
+/*
+ * SCC MEMORY MAP
+ *
+ */
+
+/* SCM registers */
+#define SCM_RED_START           0x00000000	/*          read/write       */
+#define SCM_BLACK_START         0x00000004	/*          read/write       */
+#define SCM_LENGTH              0x00000008	/*          read/write       */
+#define SCM_CONTROL             0x0000000C	/*          read/write       */
+#define SCM_STATUS              0x00000010	/*          read only        */
+#define SCM_ERROR_STATUS        0x00000014	/*          read/write       */
+#define SCM_INTERRUPT_CTRL      0x00000018	/*          read/write       */
+#define SCM_CONFIGURATION       0x0000001C	/*          read only        */
+#define SCM_INIT_VECTOR_0       0x00000020	/*          read/write       */
+#define SCM_INIT_VECTOR_1       0x00000024	/*          read/write       */
+#define SCM_RED_MEMORY          0x00000400	/*          read/write       */
+#define SCM_BLACK_MEMORY        0x00000800	/*          read/write       */
+
+/* SMN Registers */
+#define SMN_STATUS              0x00001000	/*          read/write       */
+#define SMN_COMMAND             0x00001004	/*          read/write       */
+#define SMN_SEQUENCE_START      0x00001008	/*          read/write       */
+#define SMN_SEQUENCE_END        0x0000100C	/*          read/write       */
+#define SMN_SEQUENCE_CHECK      0x00001010	/*          read/write       */
+#define SMN_BIT_COUNT           0x00001014	/*          read only        */
+#define SMN_BITBANK_INC_SIZE    0x00001018	/*          read/write       */
+#define SMN_BITBANK_DECREMENT   0x0000101C	/*          write only       */
+#define SMN_COMPARE_SIZE        0x00001020	/*          read/write       */
+#define SMN_PLAINTEXT_CHECK     0x00001024	/*          read/write       */
+#define SMN_CIPHERTEXT_CHECK    0x00001028	/*          read/write       */
+#define SMN_TIMER_IV            0x0000102C	/*          read/write       */
+#define SMN_TIMER_CONTROL       0x00001030	/*          read/write       */
+#define SMN_DEBUG_DETECT_STAT   0x00001034	/*          read/write       */
+#define SMN_TIMER               0x00001038	/*          read only        */
+
+/*! Total address space of the SCC, in bytes */
+#define SCC_ADDRESS_RANGE    0x103c
+
+/*!
+ * @defgroup smnstatusregdefs SMN Status Register definitions (SMN_STATUS)
+ */
+/*! @addtogroup smnstatusregdefs */
+/*! @{ */
+/*! SMN version id. */
+#define SMN_STATUS_VERSION_ID_MASK        0xfc000000
+/*!  number of bits to shift #SMN_STATUS_VERSION_ID_MASK to get it to LSB */
+#define SMN_STATUS_VERSION_ID_SHIFT       26
+/*! Cacheable access to SMN attempted.  */
+#define SMN_STATUS_CACHEABLE_ACCESS       0x02000000
+/*! Illegal bus master access attempted. */
+#define SMN_STATUS_ILLEGAL_MASTER         0x01000000
+/*! Scan mode entered/exited since last reset. */
+#define SMN_STATUS_SCAN_EXIT              0x00800000
+/*! Unaligned access attempted. */
+#define SMN_STATUS_UNALIGNED_ACCESS       0x00400000
+/*! Bad byte offset access attempted. */
+#define SMN_STATUS_BYTE_ACCESS            0x00200000
+/*! Illegal address access attempted. */
+#define SMN_STATUS_ILLEGAL_ADDRESS        0x00100000
+/*! User access attempted. */
+#define SMN_STATUS_USER_ACCESS            0x00080000
+/*! SCM is using DEFAULT key.  */
+#define SMN_STATUS_DEFAULT_KEY            0x00040000
+/*! SCM detects weak or bad key.  */
+#define SMN_STATUS_BAD_KEY                0x00020000
+/*! Illegal access to SCM detected. */
+#define SMN_STATUS_ILLEGAL_ACCESS         0x00010000
+/*! Internal error detected in SCM. */
+#define SMN_STATUS_SCM_ERROR              0x00008000
+/*! SMN has an outstanding interrupt. */
+#define SMN_STATUS_SMN_STATUS_IRQ         0x00004000
+/*! Software Alarm was triggered. */
+#define SMN_STATUS_SOFTWARE_ALARM         0x00002000
+/*! Timer has expired. */
+#define SMN_STATUS_TIMER_ERROR            0x00001000
+/*! Plaintext/Ciphertext compare failed. */
+#define SMN_STATUS_PC_ERROR               0x00000800
+/*! Bit Bank detected overflow or underflow */
+#define SMN_STATUS_BITBANK_ERROR          0x00000400
+/*! Algorithm Sequence Check failed. */
+#define SMN_STATUS_ASC_ERROR              0x00000200
+/*! Security Policy Block detected error. */
+#define SMN_STATUS_SECURITY_POLICY_ERROR  0x00000100
+/*! At least one Debug signal is active. */
+#define SMN_STATUS_DEBUG_ACTIVE           0x00000080
+/*! SCM failed to zeroize its memory. */
+#define SMN_STATUS_ZEROIZE_FAIL           0x00000040
+/*! Processor booted from internal ROM. */
+#define SMN_STATUS_INTERNAL_BOOT          0x00000020
+/*! SMN's internal state. */
+#define SMN_STATUS_STATE_MASK             0x0000001F
+/*! Number of bits to shift #SMN_STATUS_STATE_MASK to get it to LSB. */
+#define SMN_STATUS_STATE_SHIFT            0
+/*! @} */
+
+/*!
+ * @defgroup sccscmstates SMN Model Secure State Controller States (SMN_STATE_MASK)
+ */
+/*! @addtogroup sccscmstates */
+/*! @{ */
+/*! This is the first state of the SMN after power-on reset  */
+#define SMN_STATE_START         0x0
+/*! The SMN is zeroizing its RAM during reset */
+#define SMN_STATE_ZEROIZE_RAM   0x5
+/*! SMN has passed internal checks, and is waiting for Software check-in */
+#define SMN_STATE_HEALTH_CHECK  0x6
+/*! Fatal Security Violation.  SMN is locked, SCM is inoperative. */
+#define SMN_STATE_FAIL          0x9
+/*! SCC is in secure state.  SCM is using secret key. */
+#define SMN_STATE_SECURE        0xA
+/*! Due to non-fatal error, device is not secure.  SCM is using default key. */
+#define SMN_STATE_NON_SECURE    0xC
+/*! @} */
+
+/*!
+ * @defgroup scmconfigdefs SCM Configuration Register definitions (SCM_CONFIGURATION)
+ **/
+/*! @addtogroup scmconfigdefs */
+/*! @{ */
+/*! Version number of the Secure Memory. */
+#define SCM_CFG_VERSION_ID_MASK         0xf8000000
+/*! Number of bits to shift #SCM_CFG_VERSION_ID_MASK to get it to LSB. */
+#define SCM_CFG_VERSION_ID_SHIFT        27
+/*! Version one value for SCC configuration */
+#define SCM_VERSION_1    1
+/*! Size, in blocks, of Red memory. */
+#define SCM_CFG_BLACK_SIZE_MASK         0x07fe0000
+/*! Number of bits to shift #SCM_CFG_BLACK_SIZE_MASK to get it to LSB. */
+#define SCM_CFG_BLACK_SIZE_SHIFT        17
+/*! Size, in blocks, of Black memory. */
+#define SCM_CFG_RED_SIZE_MASK           0x0001ff80
+/*! Number of bits to shift #SCM_CFG_RED_SIZE_MASK to get it to LSB. */
+#define SCM_CFG_RED_SIZE_SHIFT          7
+/*! Number of bytes per block. */
+#define SCM_CFG_BLOCK_SIZE_MASK         0x0000007f
+/*! Number of bits to shift #SCM_CFG_BLOCK_SIZE_MASK to get it to LSB. */
+#define SCM_CFG_BLOCK_SIZE_SHIFT        0
+/*! @} */
+
+/*!
+ * @defgroup smncommandregdefs SMN Command Register Definitions (SMN_COMMAND)
+ */
+/*! @addtogroup smncommandregdefs */
+/*! @{ */
+#define SMN_COMMAND_ZEROS_MASK   0xffffff70	/*!< These bits are unimplemented
+						   or reserved */
+#define SMN_COMMAND_TAMPER_LOCK         0x10 /*!< Lock Tamper Detect Bit */
+#define SMN_COMMAND_CLEAR_INTERRUPT     0x8	/*!< Clear SMN Interrupt */
+#define SMN_COMMAND_CLEAR_BIT_BANK      0x4	/*!< Clear SMN Bit Bank */
+#define SMN_COMMAND_ENABLE_INTERRUPT    0x2	/*!< Enable SMN Interrupts */
+#define SMN_COMMAND_SET_SOFTWARE_ALARM  0x1	/*!< Set Software Alarm */
+/*! @} */
+
+/*!
+ * @defgroup smntimercontroldefs SMN Timer Control Register definitions (SMN_TIMER_CONTROL)
+ */
+/*! @addtogroup smntimercontroldefs */
+/*! @{ */
+/*! These bits are reserved or zero */
+#define SMN_TIMER_CTRL_ZEROS_MASK 0xfffffffc
+/*! Load the timer from #SMN_TIMER_IV */
+#define SMN_TIMER_LOAD_TIMER             0x2
+/*! Setting to zero stops the Timer */
+#define SMN_TIMER_STOP_MASK              0x1
+/*! Setting this value starts the timer */
+#define SMN_TIMER_START_TIMER            0x1
+/*! @} */
+
+/*!
+ * @defgroup scminterruptcontroldefs SCM Interrupt Control Register definitions (SCM_INTERRUPT_CTRL)
+ *
+ * These are the bit definitions for the #SCM_INTERRUPT_CTRL register.
+ */
+/*! @addtogroup scminterruptcontroldefs */
+/*! @{ */
+/*! Clear SCM memory */
+#define SCM_INTERRUPT_CTRL_ZEROIZE_MEMORY      0x4
+/*! Clear outstanding SCM interrupt */
+#define SCM_INTERRUPT_CTRL_CLEAR_INTERRUPT     0x2
+/*! Inhibit SCM interrupts */
+#define SCM_INTERRUPT_CTRL_MASK_INTERRUPTS     0x1
+/*! @} */
+
+/*!
+ * @defgroup scmcontrolregdefs SCM Control Register definitions (SCM_CONTROL).
+ * These values are used with the #SCM_CONTROL register.
+ */
+/*! @addtogroup scmcontrolregdefs */
+/*! @{ */
+/*! These bits are zero or reserved */
+#define SCM_CONTROL_ZEROS_MASK    0xfffffff8
+/*! Setting this will start encrypt/decrypt */
+#define SCM_CONTROL_START_CIPHER        0x04
+/*! CBC/ECB flag.
+ * See @ref scmchainmodedefs "Chaining Mode bit definitions."
+ */
+#define SCM_CONTROL_CHAINING_MODE_MASK  0x02
+/*! Encrypt/decrypt choice.
+ * See @ref scmciphermodedefs "Cipher Mode bit definitions." */
+#define SCM_CONTROL_CIPHER_MODE_MASK    0x01
+/*! @} */
+
+/*!
+ * @defgroup scmchainmodedefs  SCM_CHAINING_MODE_MASK - Bit definitions
+ */
+/*! @addtogroup scmchainmodedefs */
+/*! @{ */
+#define SCM_CBC_MODE            0x2	/*!< Cipher block chaining */
+#define SCM_ECB_MODE            0x0	/*!< Electronic codebook. */
+/*! @} */
+
+/* Bit definitions in the SCM_CIPHER_MODE_MASK */
+/*!
+ * @defgroup scmciphermodedefs SCM_CIPHER_MODE_MASK - Bit definitions
+ */
+/*! @{ */
+#define SCM_DECRYPT_MODE        0x1	/*!< decrypt from black to red memory */
+#define SCM_ENCRYPT_MODE        0x0	/*!< encrypt from red to black memory */
+/*! @} */
+
+/*!
+ * @defgroup scmstatusregdefs  SCM Status Register (SCM_STATUS).
+ * Bit and field definitions of the SCM_STATUS register.
+ */
+/*! @addtogroup scmstatusregdefs */
+/*! @{ */
+/*! These bits are zero or reserved */
+#define SCM_STATUS_ZEROS_MASK        0xffffe000
+/*! Ciphering failed due to length error. */
+#define SCM_STATUS_LENGTH_ERROR          0x1000
+/*! SMN has stopped blocking access to the SCM */
+#define SCM_STATUS_BLOCK_ACCESS_REMOVED  0x0800
+/*! Ciphering done. */
+#define SCM_STATUS_CIPHERING_DONE        0x0400
+/*! Zeroizing done. */
+#define SCM_STATUS_ZEROIZING_DONE        0x0200
+/*! SCM wants attention. Interrupt status is available. */
+#define SCM_STATUS_INTERRUPT_STATUS      0x0100
+/*! Secret Key is in use. */
+#define SCM_STATUS_SECRET_KEY            0x0080
+/*! Secret Key is in use.  Deprecated.  Use #SCM_STATUS_SECRET_KEY. */
+#define SCM_STATUS_DEFAULT_KEY           0x0080
+/*! Internal error to SCM. */
+#define SCM_STATUS_INTERNAL_ERROR        0x0040
+/*! Secret key is not valid. */
+#define SCM_STATUS_BAD_SECRET_KEY        0x0020
+/*! Failed to zeroize memory. */
+#define SCM_STATUS_ZEROIZE_FAILED        0x0010
+/*! SMN is blocking access to Secure Memory. */
+#define SCM_STATUS_SMN_BLOCKING_ACCESS   0x0008
+/*! SCM is current encrypting or decrypting data. */
+#define SCM_STATUS_CIPHERING             0x0004
+/*! SCM is currently zeroizing data. */
+#define SCM_STATUS_ZEROIZING             0x0002
+/*! SCM is busy and access to memory is blocked. */
+#define SCM_STATUS_BUSY                  0x0001
+/*! @} */
+
+/*!
+ * @defgroup scmerrstatdefs SCM Error Status Register (SCM_ERROR_STATUS)
+ *
+ * These definitions are associated with the SCM Error Status Register
+ * (SCM_ERROR_STATUS).
+ */
+/*! @addtogroup scmerrstatdefs */
+/*! @{ */
+/*! These bits are zero or reserved */
+#define SCM_ERR_ZEROS_MASK      0xffffc000
+/*! Cacheable access to SCM was attempted */
+#define SCM_ERR_CACHEABLE_ACCESS    0x2000
+/*! Access attempted by illegal bus master */
+#define SCM_ERR_ILLEGAL_MASTER      0x1000
+/*! Unaligned access attempted */
+#define SCM_ERR_UNALIGNED_ACCESS    0x0800
+/*! Byte or half-word access attempted */
+#define SCM_ERR_BYTE_ACCESS         0x0400
+/*! Illegal address attempted */
+#define SCM_ERR_ILLEGAL_ADDRESS     0x0200
+/*! User access attempted */
+#define SCM_ERR_USER_ACCESS         0x0100
+/*! Access attempted while SCM was using default key */
+#define SCM_ERR_SECRET_KEY_IN_USE   0x0080
+/*! Access attempted while SCM had internal error */
+#define SCM_ERR_INTERNAL_ERROR      0x0040
+/*! Access attempted while SCM was detecting Bad Key */
+#define SCM_ERR_BAD_SECRET_KEY      0x0020
+/*! The SCM failed to Zeroize memory */
+#define SCM_ERR_ZEROIZE_FAILED      0x0010
+/*! Access attempted while SMN was Blocking Access */
+#define SCM_ERR_SMN_BLOCKING_ACCESS 0x0008
+/*! Access attempted while SCM was CIPHERING */
+#define SCM_ERR_CIPHERING           0x0004
+/*! Access attempted while SCM was ZEROIZING */
+#define SCM_ERR_ZEROIZING           0x0002
+/*! Access attempted while SCM was BUSY */
+#define SCM_ERR_BUSY                0x0001
+/*! @} */
+
+/*!
+ * @defgroup smndbgdetdefs SMN Debug Detector Status Register
+ * (SCM_DEBUG_DETECT_STAT)
+ */
+/*! @addtogroup smndbgdetdefs */
+/*! @{ */
+#define SMN_DBG_ZEROS_MASK  0xfffff000	/*!< These bits are zero or reserved */
+#define SMN_DBG_D12             0x0800	/*!< Error detected on Debug Port D12 */
+#define SMN_DBG_D11             0x0400	/*!< Error detected on Debug Port D11 */
+#define SMN_DBG_D10             0x0200	/*!< Error detected on Debug Port D10 */
+#define SMN_DBG_D9              0x0100	/*!< Error detected on Debug Port D9 */
+#define SMN_DBG_D8              0x0080	/*!< Error detected on Debug Port D8 */
+#define SMN_DBG_D7              0x0040	/*!< Error detected on Debug Port D7 */
+#define SMN_DBG_D6              0x0020	/*!< Error detected on Debug Port D6 */
+#define SMN_DBG_D5              0x0010	/*!< Error detected on Debug Port D5 */
+#define SMN_DBG_D4              0x0008	/*!< Error detected on Debug Port D4 */
+#define SMN_DBG_D3              0x0004	/*!< Error detected on Debug Port D3 */
+#define SMN_DBG_D2              0x0002	/*!< Error detected on Debug Port D2 */
+#define SMN_DBG_D1              0x0001	/*!< Error detected on Debug Port D1 */
+/*! @} */
+
+/*! Mask for the usable bits of the Sequence Start Register
+    (#SMN_SEQUENCE_START) */
+#define SMN_SEQUENCE_START_MASK    0x0000ffff
+
+/*! Mask for the usable bits of the Sequence End Register
+    (#SMN_SEQUENCE_END) */
+#define SMN_SEQUENCE_END_MASK      0x0000ffff
+
+/*! Mask for the usable bits of the Sequence Check Register
+    (#SMN_SEQUENCE_CHECK) */
+#define SMN_SEQUENCE_CHECK_MASK    0x0000ffff
+
+/*! Mask for the usable bits of the Bit Counter Register
+    (#SMN_BIT_COUNT) */
+#define SMN_BIT_COUNT_MASK         0x000007ff
+
+/*! Mask for the usable bits of the Bit Bank Increment Size Register
+    (#SMN_BITBANK_INC_SIZE) */
+#define SMN_BITBANK_INC_SIZE_MASK  0x000007ff
+
+/*! Mask for the usable bits of the Bit Bank Decrement Register
+    (#SMN_BITBANK_DECREMENT) */
+#define SMN_BITBANK_DECREMENT_MASK 0x000007ff
+
+/*! Mask for the usable bits of the Compare Size Register
+    (#SMN_COMPARE_SIZE) */
+#define SMN_COMPARE_SIZE_MASK      0x0000003f
+
+/* Close out marker for C++ compilers */
+#ifdef __cplusplus
+}
+#endif
+#endif				/* __ASM_ARCH_MXC_SCC_DRIVER_H__ */
diff --git a/include/linux/mxc_si4702.h b/include/linux/mxc_si4702.h
new file mode 100644
index 0000000..e85096c
--- /dev/null
+++ b/include/linux/mxc_si4702.h
@@ -0,0 +1,39 @@
+/*
+ * linux/drivers/char/mxc_si4702.h
+ *
+ * Copyright 2008-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @defgroup Character device driver for SI4702 FM radio
+ */
+
+/*
+ * @file mxc_si4702.h
+ *
+ * @brief SI4702 Radio FM driver
+ *
+ * @ingroup Character
+ */
+
+#ifndef _MXC_SI4702_FM_H
+#define _MXC_SI4702_FM_H
+
+/* define IOCTL command */
+#define SI4702_GETVOLUME	_IOR('S', 0x10, unsigned int)
+#define SI4702_SETVOLUME	_IOW('S', 0x11, unsigned int)
+#define SI4702_MUTEON		_IO('S', 0x12)
+#define SI4702_MUTEOFF		_IO('S', 0x13)
+#define SI4702_SELECT		_IOW('S', 0x14, unsigned int)
+#define SI4702_SEEK		_IOWR('S', 0x15, unsigned int)
+
+#endif				/* _MXC_SI4702_FM_H */
diff --git a/include/linux/mxc_sim_interface.h b/include/linux/mxc_sim_interface.h
new file mode 100644
index 0000000..3e006b5
--- /dev/null
+++ b/include/linux/mxc_sim_interface.h
@@ -0,0 +1,108 @@
+/*
+ * Copyright 2008-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file mxc_sim_interface.h
+ *
+ * @brief Driver for Freescale IMX SIM interface
+ *
+ */
+
+#ifndef MXC_SIM_INTERFACE_H
+#define MXC_SIM_INTERFACE_H
+
+#define SIM_ATR_LENGTH_MAX 32
+
+/* Raw ATR SIM_IOCTL_GET_ATR */
+typedef struct {
+	uint32_t size;		/* length of ATR received */
+	uint8_t t[SIM_ATR_LENGTH_MAX];	/* raw ATR string received */
+} sim_atr_t;
+
+/* Communication parameters for SIM_IOCTL_[GET|SET]_PARAM */
+typedef struct {
+	uint8_t convention;	/* direct = 0, indirect = 1 */
+	uint8_t FI, DI;		/* frequency multiplier and devider indices */
+	uint8_t PI1, II;	/* programming voltage and current indices */
+	uint8_t N;		/* extra guard time */
+	uint8_t T;		/* protocol type: T0 = 0, T1 = 1 */
+	uint8_t PI2;		/* programming voltage 2 value */
+	uint8_t WWT;		/* working wait time */
+} sim_param_t;
+
+/* ISO7816-3 protocols */
+#define SIM_PROTOCOL_T0  0
+#define SIM_PROTOCOL_T1  1
+
+/* Transfer data for SIM_IOCTL_XFER */
+typedef struct {
+	uint8_t *xmt_buffer;	/* transmit buffer pointer */
+	int32_t xmt_length;	/* transmit buffer length */
+	uint8_t *rcv_buffer;	/* receive buffer pointer */
+	int32_t rcv_length;	/* receive buffer length */
+	int type;		/* transfer type: TPDU = 0, PTS = 1 */
+	int timeout;		/* transfer timeout in milliseconds */
+	uint8_t sw1;		/* status word 1 */
+	uint8_t sw2;		/* status word 2 */
+} sim_xfer_t;
+
+/* Transfer types for SIM_IOCTL_XFER */
+#define SIM_XFER_TYPE_TPDU 0
+#define SIM_XFER_TYPE_PTS  1
+
+/* Interface power states */
+#define SIM_POWER_OFF 0
+#define SIM_POWER_ON  1
+
+/* Return values for SIM_IOCTL_GET_PRESENSE */
+#define SIM_PRESENT_REMOVED     0
+#define SIM_PRESENT_DETECTED    1
+#define SIM_PRESENT_OPERATIONAL 2
+
+/* Return values for SIM_IOCTL_GET_ERROR */
+#define SIM_OK                         0
+#define SIM_E_ACCESS                   1
+#define SIM_E_TPDUSHORT                2
+#define SIM_E_PTSEMPTY                 3
+#define SIM_E_INVALIDXFERTYPE          4
+#define SIM_E_INVALIDXMTLENGTH         5
+#define SIM_E_INVALIDRCVLENGTH         6
+#define SIM_E_NACK                     7
+#define SIM_E_TIMEOUT                  8
+#define SIM_E_NOCARD                   9
+#define SIM_E_PARAM_FI_INVALID         10
+#define SIM_E_PARAM_DI_INVALID         11
+#define SIM_E_PARAM_FBYD_WITHFRACTION  12
+#define SIM_E_PARAM_FBYD_NOTDIVBY8OR12 13
+#define SIM_E_PARAM_DIVISOR_RANGE      14
+#define SIM_E_MALLOC                   15
+#define SIM_E_IRQ                      16
+#define SIM_E_POWERED_ON               17
+#define SIM_E_POWERED_OFF              18
+
+/* ioctl encodings */
+#define SIM_IOCTL_BASE 0xc0
+#define SIM_IOCTL_GET_PRESENSE   _IOR(SIM_IOCTL_BASE, 1, int)
+#define SIM_IOCTL_GET_ATR        _IOR(SIM_IOCTL_BASE, 2, sim_atr_t)
+#define SIM_IOCTL_GET_PARAM_ATR  _IOR(SIM_IOCTL_BASE, 3, sim_param_t)
+#define SIM_IOCTL_GET_PARAM      _IOR(SIM_IOCTL_BASE, 4, sim_param_t)
+#define SIM_IOCTL_SET_PARAM      _IOW(SIM_IOCTL_BASE, 5, sim_param_t)
+#define SIM_IOCTL_XFER           _IOR(SIM_IOCTL_BASE, 6, sim_xfer_t)
+#define SIM_IOCTL_POWER_ON       _IO(SIM_IOCTL_BASE, 7)
+#define SIM_IOCTL_POWER_OFF      _IO(SIM_IOCTL_BASE, 8)
+#define SIM_IOCTL_WARM_RESET     _IO(SIM_IOCTL_BASE, 9)
+#define SIM_IOCTL_COLD_RESET     _IO(SIM_IOCTL_BASE, 10)
+#define SIM_IOCTL_CARD_LOCK      _IO(SIM_IOCTL_BASE, 11)
+#define SIM_IOCTL_CARD_EJECT     _IO(SIM_IOCTL_BASE, 12)
+
+#endif
diff --git a/include/linux/pmic_battery.h b/include/linux/pmic_battery.h
new file mode 100644
index 0000000..fe65be5
--- /dev/null
+++ b/include/linux/pmic_battery.h
@@ -0,0 +1,419 @@
+/*
+ * Copyright 2004-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU Lesser General
+ * Public License.  You may obtain a copy of the GNU Lesser General
+ * Public License Version 2.1 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/lgpl-license.html
+ * http://www.gnu.org/copyleft/lgpl.html
+ */
+#ifndef __ASM_ARCH_MXC_PMIC_BATTERY_H__
+#define __ASM_ARCH_MXC_PMIC_BATTERY_H__
+
+/*!
+ * @defgroup PMIC_BATTERY PMIC Battery Driver
+ * @ingroup PMIC_DRVRS
+ */
+
+/*!
+ * @file arch-mxc/pmic_battery.h
+ * @brief This is the header of PMIC Battery driver.
+ *
+ * @ingroup PMIC_BATTERY
+ */
+
+#include <linux/ioctl.h>
+#include <linux/pmic_status.h>
+#include <linux/pmic_external.h>
+
+/*!
+ * @name IOCTL user space interface
+ */
+
+/*! @{ */
+/*!
+ * Enable and disable charger.
+ * Argument type: pointer to t_charger_setting
+ */
+#define PMIC_BATT_CHARGER_CONTROL              _IOW('p', 0xc0, int)
+/*!
+ * Set charger configuration.
+ * Argument type: pointer to t_charger_setting
+ */
+#define PMIC_BATT_SET_CHARGER                  _IOW('p', 0xc1, int)
+/*!
+ * Get charger configuration.
+ * Argument type: pointer to t_charger_setting
+ */
+#define PMIC_BATT_GET_CHARGER                  _IOR('p', 0xc2, int)
+/*!
+ * Get charger current.
+ * Argument type: pointer to t_charger_setting
+ */
+#define PMIC_BATT_GET_CHARGER_CURRENT          _IOR('p', 0xc3, int)
+/*!
+ * Set EOL control
+ * Argument type: pointer to t_eol_setting
+ */
+#define PMIC_BATT_EOL_CONTROL                   _IOW('p', 0xc4, int)
+/*!
+ * Enable and disable charging LED.
+ * Argument type: bool
+ */
+#define PMIC_BATT_LED_CONTROL                   _IOW('p', 0xc5, int)
+/*!
+ * Enable and disable reverse supply.
+ * Argument type: bool
+ */
+#define PMIC_BATT_REV_SUPP_CONTROL              _IOW('p', 0xc6, int)
+/*!
+ * Enable and disable unregulated charging mode.
+ * Argument type: bool
+ */
+#define PMIC_BATT_UNREG_CONTROL                 _IOW('p', 0xc7, int)
+
+/*!
+ * Set the output controls.
+ * Argument type: t_control
+ */
+#define PMIC_BATT_SET_OUT_CONTROL                _IOW('p', 0xc8, int)
+/*!
+ * Set the over voltage threshold.
+ * Argument type: int
+ */
+#define PMIC_BATT_SET_THRESHOLD	                 _IOW('p', 0xc9, int)
+
+/*!
+ * Get the charger voltage.
+ * Argument type: int
+ */
+#define PMIC_BATT_GET_CHARGER_VOLTAGE		_IOR('p', 0xca, int)
+/*!
+ * Get the battery voltage.
+ * Argument type: int
+ */
+#define PMIC_BATT_GET_BATTERY_VOLTAGE		_IOR('p', 0xcb, int)
+/*!
+ * Get the battery current.
+ * Argument type: int
+ */
+#define PMIC_BATT_GET_BATTERY_CURRENT		_IOR('p', 0xcc, int)
+/*!
+ * Get the charger sensor.
+ * Argument type: int
+ */
+#define PMIC_BATT_GET_CHARGER_SENSOR		_IOR('p', 0xcd, int)
+/*!
+ * Get the battery temperature.
+ * Argument type: int
+ */
+#define PMIC_BATT_GET_BATTERY_TEMPERATURE	_IOR('p', 0xce, int)
+/*! @} */
+
+/*!
+ * This enumeration defines battery chargers.
+ */
+typedef enum {
+	BATT_MAIN_CHGR = 0,	/*!< Main battery charger */
+	BATT_CELL_CHGR,		/*!< Cell battery charger */
+	BATT_TRCKLE_CHGR	/*!< Trickle charger (only available on mc13783) */
+} t_batt_charger;
+
+/*!
+ * This enumeration defines the bp threshold.
+ */
+typedef enum {
+	BATT_BP_0 = 0,		/*!< LOBATL UVDET + 0.2 */
+	BATT_BP_1,		/*!< LOBATL UVDET + 0.3 */
+	BATT_BP_2,		/*!< LOBATL UVDET + 0.4 */
+	BATT_BP_3		/*!< LOBATL UVDET + 0.5 */
+} t_bp_threshold;
+
+/*!
+ * This enumeration of all types of output controls
+ */
+typedef enum {
+	/*!
+	 * controlled hardware
+	 */
+	CONTROL_HARDWARE = 0,
+	/*!
+	 * BPFET is driven low, BATTFET is driven high
+	 */
+	CONTROL_BPFET_LOW,
+	/*!
+	 * BPFET is driven high, BATTFET is driven low
+	 */
+	CONTROL_BPFET_HIGH,
+} t_control;
+
+/*!
+ * This enumeration define all battery interrupt
+ */
+typedef enum {
+	/*!
+	 * Charge detection interrupt
+	 */
+	BAT_IT_CHG_DET,
+	/*!
+	 * Charge over voltage detection it
+	 */
+	BAT_IT_CHG_OVERVOLT,
+	/*!
+	 * Charge path reverse current it
+	 */
+	BAT_IT_CHG_REVERSE,
+	/*!
+	 * Charge path short circuitin revers supply mode it
+	 */
+	BAT_IT_CHG_SHORT_CIRCUIT,
+	/*!
+	 * Charger has switched its mode (CC to CV or CV to CC)
+	 */
+	BAT_IT_CCCV,
+	/*!
+	 * Charge current has dropped below its threshold
+	 */
+	BAT_IT_BELOW_THRESHOLD,
+} t_batt_event;
+
+/*!
+ * This structure is used for the following battery changer control
+ * IOCTLs:
+ * - PMIC_BATT_CHARGER_CONTROL
+ * - PMIC_BATT_SET_CHARGER
+ * - PMIC_BATT_GET_CHARGER
+ */
+typedef struct {
+	/*!
+	 * Charger
+	 */
+	t_batt_charger chgr;
+	/*!
+	 * Turn on charger
+	 */
+	bool on;
+	/*!
+	 * Charging voltage
+	 */
+	unsigned char c_voltage;
+	/*!
+	 * Charging current
+	 */
+	unsigned char c_current;
+} t_charger_setting;
+
+/*!
+ * This structure is used for EOL setting IOCTL PMIC_BATT_EOL_CONTROL
+ */
+typedef struct {
+	/*!
+	 * Enable EOL comparator
+	 */
+	bool enable;
+	/*!
+	 * c_voltage threshold - Used on SC55112
+	 */
+	unsigned char threshold;
+	/*!
+	 * bp threshold - Used on mc13783
+	 */
+	t_bp_threshold typical;
+} t_eol_setting;
+
+/* EXPORTED FUNCTIONS */
+
+#ifdef __KERNEL__
+
+/*START: for 3ds hw event*/
+/*!
+ * Battery event type enum
+ */
+enum {
+	BAT_EVENT_CHARGER_PLUG = 0x01,
+	BAT_EVENT_CHARGER_UNPLUG = 0x02,
+	BAT_EVENT_CHARGER_OVERVOLTAGE = 0x04,
+	BAT_EVENT_BATTERY_LOW = 0x08,
+	BAT_EVENT_POWER_FAILED = 0x10,
+	BAT_EVENT_CHARGER_FULL = 0x20,
+} t_bat_event;
+/*END: for 3ds hw event*/
+
+/*!
+ * This function is used to start charging a battery. For different charger,
+ * different c_voltage and current range are supported. \n
+ *
+ *
+ * @param      chgr        Charger as defined in \b t_batt_charger.
+ * @param      c_voltage     Charging voltage.
+ * @param      c_current     Charging current.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_enable_charger(t_batt_charger chgr,
+				     unsigned char c_voltage,
+				     unsigned char c_current);
+
+/*!
+ * This function turns off a charger.
+ *
+ * @param      chgr        Charger as defined in \b t_batt_charger.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_disable_charger(t_batt_charger chgr);
+
+/*!
+ * This function is used to change the charger setting.
+ *
+ * @param      chgr        Charger as defined in \b t_batt_charger.
+ * @param      c_voltage   Charging voltage.
+ * @param      c_current   Charging current.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_set_charger(t_batt_charger chgr,
+				  unsigned char c_voltage,
+				  unsigned char c_current);
+
+/*!
+ * This function is used to retrieve the charger setting.
+ *
+ * @param      chgr        Charger as defined in \b t_batt_charger.
+ * @param      c_voltage   Output parameter for charging c_voltage setting.
+ * @param      c_current   Output parameter for charging current setting.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_get_charger_setting(t_batt_charger chgr,
+					  unsigned char *c_voltage,
+					  unsigned char *c_current);
+
+/*!
+ * This function is retrieves the main battery charging current.
+ *
+ * @param      c_current     Output parameter for charging current setting.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+
+PMIC_STATUS pmic_batt_get_charge_current(unsigned short *c_current);
+
+/*!
+ * This function enables End-of-Life comparator.
+ *
+ * @param      threshold  End-of-Life threshold.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_enable_eol(unsigned char threshold);
+
+/*!
+ * This function enables End-of-Life comparator.
+ *
+ * @param      typical  Falling Edge Threshold threshold.
+ *                      @verbatim
+ *		 BPDET   UVDET   LOBATL
+ *		 ____    _____   ___________
+ *		 0       2.6     UVDET + 0.2
+ *		 1       2.6     UVDET + 0.3
+ *		 2       2.6     UVDET + 0.4
+ *		 3       2.6     UVDET + 0.5
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_bp_enable_eol(t_bp_threshold typical);
+
+/*!
+ * This function disables End-of-Life comparator.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_disable_eol(void);
+
+/*!
+ * This function sets the output controls.
+ * It sets the FETOVRD and FETCTRL bits of mc13783
+ *
+ * @param        control        type of control.
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_batt_set_out_control(t_control control);
+
+/*!
+ * This function sets over voltage threshold.
+ *
+ * @param        threshold      value of over voltage threshold.
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_batt_set_threshold(int threshold);
+
+/*!
+ * This function controls charge LED.
+ *
+ * @param      on   If on is true, LED will be turned on,
+ *                  or otherwise, LED will be turned off.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_led_control(bool on);
+
+/*!
+ * This function sets reverse supply mode.
+ *
+ * @param      enable     If enable is true, reverse supply mode is enable,
+ *                        or otherwise, reverse supply mode is disabled.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_set_reverse_supply(bool enable);
+
+/*!
+ * This function sets unregulated charging mode on main battery.
+ *
+ * @param      enable     If enable is true, unregulated charging mode is
+ *                        enable, or otherwise, disabled.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_set_unregulated(bool enable);
+
+/*!
+ * This function sets a 5K pull down at CHRGRAW.
+ * To be used in the dual path charging configuration.
+ *
+ * @param      enable     If enable is true, 5k pull down is
+ *                        enable, or otherwise, disabled.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_set_5k_pull(bool enable);
+
+/*!
+ * This function is used to subscribe on battery event IT.
+ *
+ * @param        event          type of event.
+ * @param        callback       event callback function.
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_batt_event_subscribe(t_batt_event event, void *callback);
+
+/*!
+ * This function is used to un subscribe on battery event IT.
+ *
+ * @param        event          type of event.
+ * @param        callback       event callback function.
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_batt_event_unsubscribe(t_batt_event event, void *callback);
+
+#endif				/* __KERNEL__ */
+
+#endif				/* __ASM_ARCH_MXC_PMIC_BATTERY_H__ */
diff --git a/include/linux/pmic_light.h b/include/linux/pmic_light.h
new file mode 100644
index 0000000..f26d927
--- /dev/null
+++ b/include/linux/pmic_light.h
@@ -0,0 +1,1082 @@
+/*
+ * Copyright 2004-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU Lesser General
+ * Public License.  You may obtain a copy of the GNU Lesser General
+ * Public License Version 2.1 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/lgpl-license.html
+ * http://www.gnu.org/copyleft/lgpl.html
+ */
+#ifndef __ASM_ARCH_MXC_PMIC_LIGHT_H__
+#define __ASM_ARCH_MXC_PMIC_LIGHT_H__
+
+/*!
+ * @defgroup PMIC_LIGHT PMIC Light Driver
+ * @ingroup PMIC_DRVRS
+ */
+
+/*!
+ * @file arch-mxc/pmic_light.h
+ * @brief This is the header of PMIC Light driver.
+ *
+ * @ingroup PMIC_LIGHT
+ */
+
+#include <linux/ioctl.h>
+#include <linux/pmic_status.h>
+#include <linux/pmic_external.h>
+
+/*!
+ * @name IOCTL user space interface
+ */
+
+/*! @{ */
+/*!
+ * Enable Backlight.
+ * Argument type: none.
+ */
+#define PMIC_BKLIT_ENABLE                   _IO('p', 0xe0)
+/*!
+ * Disable Backlight.
+ * Argument type: none.
+ */
+#define PMIC_BKLIT_DISABLE                  _IO('p', 0xe1)
+/*!
+ * Set backlight configuration.
+ * Argument type: pointer to t_bklit_setting_param
+ */
+#define PMIC_SET_BKLIT                      _IOW('p', 0xe2, int)
+/*!
+ * Get backlight configuration.
+ * Argument type: pointer to t_bklit_setting_param
+ */
+#define PMIC_GET_BKLIT                      _IOWR('p', 0xe3, int)
+/*!
+ * Ramp up configuration.
+ * Argument type: t_bklit_channel
+ */
+#define PMIC_RAMPUP_BKLIT                   _IOW('p', 0xe4, int)
+/*!
+ * Ramp down configuration.
+ * Argument type: t_bklit_channel
+ */
+#define PMIC_RAMPDOWN_BKLIT                 _IOW('p', 0xe5, int)
+/*!
+ * Enable Tri-color LED.
+ * Argument type: t_tcled_enable_param
+ */
+#define PMIC_TCLED_ENABLE                   _IOW('p', 0xe6, int)
+/*!
+ * Disable Tri-color LED.
+ * Argument type: t_funlight_bank
+ */
+#define PMIC_TCLED_DISABLE                  _IOW('p', 0xe7, int)
+/*!
+ * Start Tri-color LED pattern.
+ * Argument type: t_fun_param
+ */
+#define PMIC_TCLED_PATTERN                  _IOW('p', 0xe8, int)
+/*!
+ * Enable Backlight & tcled.
+ * Argument type: none.
+ */
+#define PMIC_BKLIT_TCLED_ENABLE             _IO('p', 0xe9)
+/*!
+ * Disable Backlight & tcled.
+ * Argument type: none.
+ */
+#define PMIC_BKLIT_TCLED_DISABLE            _IO('p', 0xea)
+/*!
+ * Reset ramp up configuration.
+ * Argument type: t_bklit_channel
+ */
+#define PMIC_OFF_RAMPUP_BKLIT               _IOW('p', 0xeb, int)
+/*!
+ * Reset ramp down configuration.
+ * Argument type: t_bklit_channel
+ */
+#define PMIC_OFF_RAMPDOWN_BKLIT             _IOW('p', 0xec, int)
+/*!
+ * Set tcled ind configuration.
+ * Argument type: t_tcled_ind_param
+ */
+#define PMIC_SET_TCLED			    _IOW('p', 0xed, int)
+/*!
+ * Get tcled ind configuration.
+ * Argument type: t_tcled_ind_param
+ */
+#define PMIC_GET_TCLED			    _IOWR('p', 0xee, int)
+/*! @} */
+/*!
+ * @enum t_bklit_mode
+ * @brief Backlight modes.
+ */
+typedef enum {
+	BACKLIGHT_CURRENT_CTRL_MODE,	/*! < Current control mode */
+	BACKLIGHT_TRIODE_MODE	/*! < Triode mode */
+} t_bklit_mode;
+
+/*!
+ * @enum t_bklit_channel
+ * @brief Backlight channels.
+ */
+typedef enum {
+	BACKLIGHT_LED1,		/*! < Backlight channel 1 */
+	BACKLIGHT_LED2,		/*! < Backlight channel 2 */
+	BACKLIGHT_LED3		/*! < Backlight channel 3 */
+} t_bklit_channel;
+
+/*!
+ * @enum t_bklit_strobe_mode
+ * @brief Backlight Strobe Light Pulsing modes.
+ */
+typedef enum {
+	/*!
+	 * No Strobe Light Pulsing
+	 */
+	BACKLIGHT_STROBE_NONE,
+	/*!
+	 * Strobe Light Pulsing at 3.3% duty cycle over 300msec (Driver goes
+	 * into Triode Mode with pulses constrained to 10msec.)
+	 */
+	BACKLIGHT_STROBE_FAST,
+	/*!
+	 * Strobe Light Pulsing at 10% duty cycle over 100msec (Driver goes
+	 * into Triode Mode with pulses constrained to 10msec.)
+	 */
+	BACKLIGHT_STROBE_SLOW
+} t_bklit_strobe_mode;
+
+/*!
+ * @struct t_bklit_setting_param
+ * @brief Backlight setting.
+ */
+
+typedef struct {
+	t_bklit_channel channel;	/*!< Channel */
+	t_bklit_mode mode;	/*!< Mode */
+	t_bklit_strobe_mode strobe;	/*!< Strobe mode */
+	unsigned char current_level;	/*!< Current level */
+	unsigned char duty_cycle;	/*!< Duty cycle */
+	unsigned char cycle_time;	/*!< Cycle time */
+	bool edge_slow;		/*!< Edge Slow */
+	bool en_dis;		/*!< Enable disable boost mode */
+	unsigned int abms;	/*!< Adaptive boost
+				 *   mode selection */
+	unsigned int abr;	/*!< Adaptive
+				 *   boost reference */
+} t_bklit_setting_param;
+
+/*!
+ * @enum t_funlight_bank
+ * @brief Tri-color LED fun light banks.
+ */
+typedef enum {
+	TCLED_FUN_BANK1 = 0,	/*! < Fun light bank 1 */
+	TCLED_FUN_BANK2,	/*! < Fun light bank 2 */
+	TCLED_FUN_BANK3		/*! < Fun light bank 3 */
+} t_funlight_bank;
+
+/*!
+ * @enum t_tcled_mode
+ * @brief Tri-color LED operation modes.
+ *
+ * The Tri-Color LED Driver circuitry includes 2 modes of operation. In LED
+ * Indicator Mode, this circuitry operates as Red and Green LED Drivers with
+ * flasher timing to indicate GSM network status. In Fun Light Mode, this
+ * circuitry provides expanded capability for current control and distribution
+ * that supplements the three channels.
+ */
+typedef enum {
+	TCLED_IND_MODE = 0,	/*! < LED Indicator Mode */
+	TCLED_FUN_MODE		/*! < Fun Light Mode */
+} t_tcled_mode;
+
+/*!
+ * @struct t_tcled_enable_param
+ * @brief enable setting.
+ */
+typedef struct {
+	t_funlight_bank bank;	/*!< Bank */
+	t_tcled_mode mode;	/*!< Mode */
+} t_tcled_enable_param;
+
+/*!
+ * @enum t_ind_channel
+ * @brief Tri-color LED indicator mode channels.
+ *
+ */
+
+typedef enum {
+	TCLED_IND_RED = 0,	/*! < Red LED */
+	TCLED_IND_GREEN,	/*! < Green LED */
+	TCLED_IND_BLUE		/*! < Blue LED */
+} t_ind_channel;
+
+/*!
+ * @enum t_funlight_channel
+ * @brief Tri-color LED fun light mode channels.
+ *
+ */
+typedef enum {
+	TCLED_FUN_CHANNEL1 = 0,	/*! < Fun light channel 1 (Red) */
+	TCLED_FUN_CHANNEL2,	/*! < Fun light channel 2 (Green) */
+	TCLED_FUN_CHANNEL3	/*! < Fun light channel 3 (Blue) */
+} t_funlight_channel;
+
+/*!
+ * @enum t_tcled_ind_blink_pattern
+ * @brief Tri-color LED Indicator Mode blinking mode.
+ */
+typedef enum {
+	TCLED_IND_OFF = 0,	/*! < Continuous off */
+	TCLED_IND_BLINK_1,	/*! < 1 / 31 */
+	TCLED_IND_BLINK_2,	/*! < 2 / 31 */
+	TCLED_IND_BLINK_3,	/*! < 3 / 31  */
+	TCLED_IND_BLINK_4,	/*! < 4 / 31  */
+	TCLED_IND_BLINK_5,	/*! < 5 / 31  */
+	TCLED_IND_BLINK_6,	/*! < 6 / 31  */
+	TCLED_IND_BLINK_7,	/*! < 7 / 31  */
+	TCLED_IND_BLINK_8,	/*! < 8 / 31  */
+	TCLED_IND_BLINK_9,	/*! < 9 / 31  */
+	TCLED_IND_BLINK_10,	/*! < 10 / 31  */
+	TCLED_IND_BLINK_11,	/*! < 11 / 31  */
+	TCLED_IND_BLINK_12,	/*! < 12 / 31  */
+	TCLED_IND_BLINK_13,	/*! < 13 / 31  */
+	TCLED_IND_BLINK_14,	/*! < 14 / 31  */
+	TCLED_IND_BLINK_15,	/*! < 15 / 31  */
+	TCLED_IND_BLINK_16,	/*! < 16 / 31  */
+	TCLED_IND_BLINK_17,	/*! < 17 / 31  */
+	TCLED_IND_BLINK_18,	/*! < 18 / 31  */
+	TCLED_IND_BLINK_19,	/*! < 19 / 31  */
+	TCLED_IND_BLINK_20,	/*! < 20 / 31  */
+	TCLED_IND_BLINK_21,	/*! < 21 / 31  */
+	TCLED_IND_BLINK_22,	/*! < 22 / 31  */
+	TCLED_IND_BLINK_23,	/*! < 23 / 31  */
+	TCLED_IND_BLINK_24,	/*! < 24 / 31  */
+	TCLED_IND_BLINK_25,	/*! < 25 / 31  */
+	TCLED_IND_BLINK_26,	/*! < 26 / 31  */
+	TCLED_IND_BLINK_27,	/*! < 27 / 31  */
+	TCLED_IND_BLINK_28,	/*! < 28 / 31  */
+	TCLED_IND_BLINK_29,	/*! < 29 / 31  */
+	TCLED_IND_BLINK_30,	/*! < 30 / 31  */
+	TCLED_IND_ON		/*! < Continuous on */
+} t_tcled_ind_blink_pattern;
+
+/*!
+ * @enum t_tcled_cur_level
+ * @brief Tri-color LED current levels.
+ */
+typedef enum {
+	TCLED_CUR_LEVEL_1 = 0,	/*! < Tri-Color LED current level 1 */
+	TCLED_CUR_LEVEL_2,	/*! < Tri-Color LED current level 2 */
+	TCLED_CUR_LEVEL_3,	/*! < Tri-Color LED current level 3 */
+	TCLED_CUR_LEVEL_4	/*! < Tri-Color LED current level 4 */
+} t_tcled_cur_level;
+
+/*!
+ * @enum t_tcled_fun_cycle_time
+ * @brief Tri-color LED fun light mode cycle time.
+ */
+typedef enum {
+	TC_CYCLE_TIME_1 = 0,	/*! < Tri-Color LED cycle time 1 */
+	TC_CYCLE_TIME_2,	/*! < Tri-Color LED cycle time 2 */
+	TC_CYCLE_TIME_3,	/*! < Tri-Color LED cycle time 3 */
+	TC_CYCLE_TIME_4		/*! < Tri-Color LED cycle time 4 */
+} t_tcled_fun_cycle_time;
+
+/*!
+ * @enum t_tcled_fun_speed
+ * @brief Tri-color LED fun light mode pattern speed.
+ */
+typedef enum {
+	TC_OFF = 0,		/*! < Tri-Color pattern off */
+	TC_SLOW,		/*! < Tri-Color slow pattern */
+	TC_FAST			/*! < Tri-Color fast pattern */
+} t_tcled_fun_speed;
+
+/*!
+ * @enum t_tcled_fun_speed
+ * @brief Tri-color LED fun light mode pattern speed.
+ */
+typedef enum {
+	TC_STROBE_OFF = 0,	/*! < No strobe */
+	TC_STROBE_SLOW,		/*! < Slow strobe pattern */
+	TC_STROBE_FAST		/*! < fast strobe pattern */
+} t_tcled_fun_strobe_speed;
+
+/*!
+ * @enum t_chaselight_pattern
+ * @brief Tri-color LED fun light mode chasing light patterns.
+ */
+typedef enum {
+	PMIC_RGB = 0,		/*!< R -> G -> B */
+	BGR			/*!< B -> G -> R */
+} t_chaselight_pattern;
+
+/*!
+ * This enumeration of Fun Light Pattern.
+ */
+typedef enum {
+	/*!
+	 * Blended ramps slow
+	 */
+	BLENDED_RAMPS_SLOW,
+	/*!
+	 * Blended ramps fast
+	 */
+	BLENDED_RAMPS_FAST,
+	/*!
+	 * Saw ramps slow
+	 */
+	SAW_RAMPS_SLOW,
+	/*!
+	 * Saw ramps fast
+	 */
+	SAW_RAMPS_FAST,
+	/*!
+	 * Blended bowtie slow
+	 */
+	BLENDED_BOWTIE_SLOW,
+	/*!
+	 * Blended bowtie fast
+	 */
+	BLENDED_BOWTIE_FAST,
+	/*!
+	 * Strobe slow
+	 */
+	STROBE_SLOW,
+	/*!
+	 * Strobe fast
+	 */
+	STROBE_FAST,
+	/*!
+	 * Chasing Light RGB Slow
+	 */
+	CHASING_LIGHT_RGB_SLOW,
+	/*!
+	 * Chasing Light RGB fast
+	 */
+	CHASING_LIGHT_RGB_FAST,
+	/*!
+	 * Chasing Light BGR Slow
+	 */
+	CHASING_LIGHT_BGR_SLOW,
+	/*!
+	 * Chasing Light BGR fast
+	 */
+	CHASING_LIGHT_BGR_FAST,
+} t_fun_pattern;
+
+/*!
+ * @struct t_fun_param
+ * @brief LED fun pattern IOCTL parameter
+ */
+typedef struct {
+	t_funlight_bank bank;	/*!< TCLED bank */
+	t_funlight_channel channel;	/*!< TCLED channel */
+	t_fun_pattern pattern;	/*!< Fun pattern */
+} t_fun_param;
+
+/*!
+ * @enum t_led_channel
+ * @brief LED channels including backlight and tri-color LEDs.
+ */
+typedef enum {
+	AUDIO_LED1,		/*! < Backlight channel 1 */
+	AUDIO_LED2,		/*! < Backlight channel 2 */
+	AUDIO_LEDR,		/*! < Fun light channel 1 (Red) */
+	AUDIO_LEDG,		/*! < Fun light channel 2 (Green) */
+	AUDIO_LEDB		/*! < Fun light channel 3 (Blue) */
+} t_led_channel;
+
+/*!
+ * @enum t_aud_path
+ * @brief LED audio modulation in-out audio channels
+ */
+typedef enum {
+	MIXED_RX = 0,		/*!<  Mixed L & R Channel RX audio */
+	TX			/*!<  TX path */
+} t_aud_path;
+
+/*!
+ * @enum t_aud_gain
+ * @brief LED audio modulation in-out audio channels
+ */
+typedef enum {
+	GAIN_MINUS6DB = 0,	/*!< -6 dB */
+	GAIN_0DB,		/*!< 0 dB */
+	GAIN_6DB,		/*!< 6 dB */
+	GAIN_12DB		/*!< 12 dB */
+} t_aud_gain;
+
+/*!
+ * @struct t_tcled_ind_param
+ * @brief LED parameter
+ */
+typedef struct {
+	t_funlight_bank bank;	/*! < tcled bank */
+	t_ind_channel channel;	/*! < tcled channel */
+	t_tcled_cur_level level;	/*! < tcled current level */
+	t_tcled_ind_blink_pattern pattern;	/*! < tcled dutty cycle */
+	bool skip;		/*! < tcled skip */
+	bool rampup;		/*! < tcled rampup */
+	bool rampdown;		/*! < tcled rampdown */
+	bool half_current;	/*! < tcled half current */
+} t_tcled_ind_param;
+
+#if defined(CONFIG_MXC_PMIC_MC13892)
+
+enum curr_level {
+	LIT_CURR_0 = 0,
+	LIT_CURR_3,
+	LIT_CURR_6,
+	LIT_CURR_9,
+	LIT_CURR_12,
+	LIT_CURR_15,
+	LIT_CURR_18,
+	LIT_CURR_21,
+	/* below setting only used for main/aux/keypad */
+	LIT_CURR_HI_0,
+	LIT_CURR_HI_6,
+	LIT_CURR_HI_12,
+	LIT_CURR_HI_18,
+	LIT_CURR_HI_24,
+	LIT_CURR_HI_30,
+	LIT_CURR_HI_36,
+	LIT_CURR_HI_42,
+};
+
+enum lit_channel {
+	LIT_MAIN = 0,
+	LIT_AUX,
+	LIT_KEY,
+	LIT_RED,
+	LIT_GREEN,
+	LIT_BLUE,
+};
+
+#endif
+
+/* EXPORTED FUNCTIONS */
+#ifdef __KERNEL__
+/*!
+ * This function enables backlight & tcled.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_tcled_master_enable(void);
+
+/*!
+ * This function disables backlight & tcled.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful
+ */
+PMIC_STATUS pmic_bklit_tcled_master_disable(void);
+
+/*!
+ * This function enables backlight.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_master_enable(void);
+
+/*!
+ * This function disables backlight.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_master_disable(void);
+
+/*!
+ * This function sets backlight current level.
+ *
+ * @param        channel   Backlight channel
+ * @param        level     Backlight current level, as the following table.
+ *                         @verbatim
+ *		 level     current
+ *		 ------    -----------
+ *		 0         0 mA
+ *		 1         12 mA
+ *		 2         24 mA
+ *		 3         36 mA
+ *		 4         48 mA
+ *		 5         60 mA
+ *		 6         72 mA
+ *		 7         84 mA
+ *		 @endverbatim
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_set_current(t_bklit_channel channel,
+				   unsigned char level);
+
+/*!
+ * This function retrives backlight current level.
+ *
+ * @param        channel   Backlight channel
+ * @param        level     Pointer to store backlight current level result.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_get_current(t_bklit_channel channel,
+				   unsigned char *level);
+
+/*!
+ * This function sets a backlight channel duty cycle.
+ * LED perceived brightness for each zone may be individually set by setting
+ * duty cycle. The default setting is for 0% duty cycle; this keeps all zone
+ * drivers turned off even after the master enable command. Each LED current
+ * sink can be turned on and adjusted for brightness with an independent 4 bit
+ * word for a duty cycle ranging from 0% to 100% in approximately 6.7% steps.
+ *
+ * @param        channel   Backlight channel.
+ * @param        dc        Backlight duty cycle, as the following table.
+ *                         @verbatim
+ *		 dc        Duty Cycle (% On-time over Cycle Time)
+ *		 ------    ---------------------------------------
+ *		 0        0%
+ *		 1        6.7%
+ *		 2        13.3%
+ *		 3        20%
+ *		 4        26.7%
+ *		 5        33.3%
+ *		 6        40%
+ *		 7        46.7%
+ *		 8        53.3%
+ *		 9        60%
+ *		 10        66.7%
+ *		 11        73.3%
+ *		 12        80%
+ *		 13        86.7%
+ *		 14        93.3%
+ *		 15        100%
+ *		 @endverbatim
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_set_dutycycle(t_bklit_channel channel, unsigned char dc);
+
+/*!
+ * This function retrives a backlight channel duty cycle.
+ *
+ * @param        channel   Backlight channel.
+ * @param        cycle     Pointer to backlight duty cycle.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_get_dutycycle(t_bklit_channel channel,
+				     unsigned char *dc);
+
+/*!
+ * This function sets a backlight channel cycle time.
+ * Cycle Time is defined as the period of a complete cycle of
+ * Time_on + Time_off. The default Cycle Time is set to 0.01 seconds such that
+ * the 100 Hz on-off cycling is averaged out by the eye to eliminate
+ * flickering. Additionally, the Cycle Time can be programmed to intentionally
+ * extend the period of on-off cycles for a visual pulsating or blinking effect.
+ *
+ * @param        period    Backlight cycle time, as the following table.
+ *                         @verbatim
+ *		 period      Cycle Time
+ *		 --------    ------------
+ *		 0          0.01 seconds
+ *		 1          0.1 seconds
+ *		 2          0.5 seconds
+ *		 3          2 seconds
+ *		 @endverbatim
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_set_cycle_time(unsigned char period);
+
+/*!
+ * This function retrives a backlight channel cycle time setting.
+ *
+ * @param        period    Pointer to save backlight cycle time setting result.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_get_cycle_time(unsigned char *period);
+
+/*!
+ * This function sets backlight operation mode. There are two modes of
+ * operations: current control and triode mode.
+ * The Duty Cycle/Cycle Time control is retained in Triode Mode. Audio
+ * coupling is not available in Triode Mode.
+ *
+ * @param        channel   Backlight channel.
+ * @param        mode      Backlight operation mode.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_set_mode(t_bklit_channel channel, t_bklit_mode mode);
+/*!
+ * This function gets backlight operation mode. There are two modes of
+ * operations: current control and triode mode.
+ * The Duty Cycle/Cycle Time control is retained in Triode Mode. Audio
+ * coupling is not available in Triode Mode.
+ *
+ * @param        channel   Backlight channel.
+ * @param        mode      Backlight operation mode.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_get_mode(t_bklit_channel channel, t_bklit_mode *mode);
+/*!
+ * This function starts backlight brightness ramp up function; ramp time is
+ * fixed at 0.5 seconds.
+ *
+ * @param        channel   Backlight channel.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_rampup(t_bklit_channel channel);
+/*!
+ * This function stops backlight brightness ramp up function;
+ *
+ * @param        channel   Backlight channel.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_off_rampup(t_bklit_channel channel);
+/*!
+ * This function starts backlight brightness ramp down function; ramp time is
+ * fixed at 0.5 seconds.
+ *
+ * @param        channel   Backlight channel.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_rampdown(t_bklit_channel channel);
+/*!
+ * This function stops backlight brightness ramp down function.
+ *
+ * @param        channel   Backlight channel.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_off_rampdown(t_bklit_channel channel);
+/*!
+ * This function enables backlight analog edge slowing mode. Analog Edge
+ * Slowing slows down the transient edges to reduce the chance of coupling LED
+ * modulation activity into other circuits. Rise and fall times will be targeted
+ * for approximately 50usec.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_enable_edge_slow(void);
+
+/*!
+ * This function disables backlight analog edge slowing mode. The backlight
+ * drivers will default to an Instant On mode.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_disable_edge_slow(void);
+/*!
+ * This function gets backlight analog edge slowing mode. DThe backlight
+ *
+ * @param        edge      Edge slowing mode.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_get_edge_slow(bool *edge);
+/*!
+ * This function sets backlight Strobe Light Pulsing mode.
+ *
+ * @param        channel   Backlight channel.
+ * @param        mode      Strobe Light Pulsing mode.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_set_strobemode(t_bklit_channel channel,
+				      t_bklit_strobe_mode mode);
+
+/*!
+ * This function enables tri-color LED.
+ *
+ * @param        mode      Tri-color LED operation mode.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_enable(t_tcled_mode mode, t_funlight_bank bank);
+/*!
+ * This function disables tri-color LED.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_disable(t_funlight_bank bank);
+/*!
+ * This function retrives tri-color LED operation mode.
+ *
+ * @param        mode      Pointer to Tri-color LED operation mode.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_get_mode(t_tcled_mode *mode, t_funlight_bank bank);
+/*!
+ * This function sets a tri-color LED channel current level in indicator mode.
+ *
+ * @param        channel      Tri-color LED channel.
+ * @param        level        Current level.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_ind_set_current(t_ind_channel channel,
+				       t_tcled_cur_level level,
+				       t_funlight_bank bank);
+/*!
+ * This function retrives a tri-color LED channel current level in indicator mode.
+ *
+ * @param        channel      Tri-color LED channel.
+ * @param        level        Pointer to current level.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_ind_get_current(t_ind_channel channel,
+				       t_tcled_cur_level *level,
+				       t_funlight_bank bank);
+/*!
+ * This function sets a tri-color LED channel blinking pattern in indication
+ * mode.
+ *
+ * @param        channel      Tri-color LED channel.
+ * @param        pattern      Blinking pattern.
+ * @param        skip         If true, skip a cycle after each cycle.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+
+PMIC_STATUS pmic_tcled_ind_set_blink_pattern(t_ind_channel channel,
+					     t_tcled_ind_blink_pattern pattern,
+					     bool skip, t_funlight_bank bank);
+/*!
+ * This function retrives a tri-color LED channel blinking pattern in
+ * indication mode.
+ *
+ * @param        channel      Tri-color LED channel.
+ * @param        pattern      Pointer to Blinking pattern.
+ * @param        skip         Pointer to a boolean variable indicating if skip
+ *                            a cycle after each cycle.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_ind_get_blink_pattern(t_ind_channel channel,
+					     t_tcled_ind_blink_pattern *
+					     pattern, bool *skip,
+					     t_funlight_bank bank);
+/*!
+ * This function sets a tri-color LED channel current level in Fun Light mode.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ * @param        level        Current level.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_set_current(t_funlight_bank bank,
+				       t_funlight_channel channel,
+				       t_tcled_cur_level level);
+
+/*!
+ * This function retrives a tri-color LED channel current level
+ * in Fun Light mode.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ * @param        level        Pointer to current level.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_get_current(t_funlight_bank bank,
+				       t_funlight_channel channel,
+				       t_tcled_cur_level *level);
+
+/*!
+ * This function sets tri-color LED cycle time in Fun Light mode.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        ct           Cycle time.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_set_cycletime(t_funlight_bank bank,
+					 t_tcled_fun_cycle_time ct);
+
+/*!
+ * This function retrives tri-color LED cycle time in Fun Light mode.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        ct           Pointer to cycle time.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_get_cycletime(t_funlight_bank bank,
+					 t_tcled_fun_cycle_time *ct);
+
+/*!
+ * This function sets a tri-color LED channel duty cycle in Fun Light mode.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ * @param        dc           Duty cycle.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_set_dutycycle(t_funlight_bank bank,
+					 t_funlight_channel channel,
+					 unsigned char dc);
+
+/*!
+ * This function retrives a tri-color LED channel duty cycle in Fun Light mode.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ * @param        dc           Pointer to duty cycle.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_get_dutycycle(t_funlight_bank bank,
+					 t_funlight_channel channel,
+					 unsigned char *dc);
+
+/*!
+ * This function initiates Blended Ramp fun light pattern.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        speed        Speed of pattern.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_blendedramps(t_funlight_bank bank,
+					t_tcled_fun_speed speed);
+
+/*!
+ * This function initiates Saw Ramp fun light pattern.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        speed        Speed of pattern.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_sawramps(t_funlight_bank bank,
+				    t_tcled_fun_speed speed);
+
+/*!
+ * This function initiates Blended Bowtie fun light pattern.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        speed        Speed of pattern.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_blendedbowtie(t_funlight_bank bank,
+					 t_tcled_fun_speed speed);
+
+/*!
+ * This function initiates Chasing Lights fun light pattern.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        pattern      Chasing light pattern mode.
+ * @param        speed        Speed of pattern.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_chasinglightspattern(t_funlight_bank bank,
+						t_chaselight_pattern pattern,
+						t_tcled_fun_speed speed);
+
+/*!
+ * This function initiates Strobe Mode fun light pattern.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ * @param        speed        Speed of pattern.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_strobe(t_funlight_bank bank,
+				  t_funlight_channel channel,
+				  t_tcled_fun_strobe_speed speed);
+
+/*!
+ * This function initiates Tri-color LED brightness Ramp Up function; Ramp time
+ * is fixed at 1 second.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ * @param        rampup       Ramp-up configuration.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_rampup(t_funlight_bank bank,
+				  t_funlight_channel channel, bool rampup);
+/*!
+ * This function gets Tri-color LED brightness Ramp Up function; Ramp time
+ * is fixed at 1 second.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ * @param        rampup       Ramp-up configuration.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_get_fun_rampup(t_funlight_bank bank,
+				      t_funlight_channel channel,
+				      bool *rampup);
+
+/*!
+ * This function initiates Tri-color LED brightness Ramp Down function; Ramp
+ * time is fixed at 1 second.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ * @param        rampdown     Ramp-down configuration.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_rampdown(t_funlight_bank bank,
+				    t_funlight_channel channel, bool rampdown);
+/*!
+ * This function initiates Tri-color LED brightness Ramp Down function; Ramp
+ * time is fixed at 1 second.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ * @param        rampdown     Ramp-down configuration.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_get_fun_rampdown(t_funlight_bank bank,
+					t_funlight_channel channel,
+					bool *rampdown);
+
+/*!
+ * This function enables a Tri-color channel triode mode.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_triode_on(t_funlight_bank bank,
+				     t_funlight_channel channel);
+
+/*!
+ * This function disables a Tri-color LED channel triode mode.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_triode_off(t_funlight_bank bank,
+				      t_funlight_channel channel);
+
+/*!
+ * This function enables Tri-color LED edge slowing.
+ *
+ * @return       This function returns PMIC_NOT_SUPPORTED.
+ */
+PMIC_STATUS pmic_tcled_enable_edge_slow(void);
+
+/*!
+ * This function disables Tri-color LED edge slowing.
+ *
+ * @return       This function returns PMIC_NOT_SUPPORTED.
+ */
+PMIC_STATUS pmic_tcled_disable_edge_slow(void);
+
+/*!
+ * This function enables Tri-color LED half current mode.
+ *
+ * @return       This function returns PMIC_NOT_SUPPORTED.
+ */
+PMIC_STATUS pmic_tcled_enable_half_current(void);
+
+/*!
+ * This function disables Tri-color LED half current mode.
+ *
+ * @return       This function returns PMIC_NOT_SUPPORTED.
+ */
+PMIC_STATUS pmic_tcled_disable_half_current(void);
+
+/*!
+ * This function enables backlight or Tri-color LED audio modulation.
+ *
+ * @return       This function returns PMIC_NOT_SUPPORTED.
+ */
+PMIC_STATUS pmic_tcled_enable_audio_modulation(t_led_channel channel,
+					       t_aud_path path,
+					       t_aud_gain gain,
+					       bool lpf_bypass);
+
+/*!
+ * This function disables backlight or Tri-color LED audio modulation.
+ *
+ * @return       This function returns PMIC_NOT_SUPPORTED.
+ */
+PMIC_STATUS pmic_tcled_disable_audio_modulation(void);
+/*!
+ * This function enables the boost mode.
+ * Only on mc13783 2.0 or higher
+ *
+ * @param       en_dis   Enable or disable the boost mode
+ *
+ * @return      This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_bklit_set_boost_mode(bool en_dis);
+
+/*!
+ * This function gets the boost mode.
+ * Only on mc13783 2.0 or higher
+ *
+ * @param       en_dis   Enable or disable the boost mode
+ *
+ * @return      This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_bklit_get_boost_mode(bool *en_dis);
+
+/*!
+ * This function sets boost mode configuration
+ * Only on mc13783 2.0 or higher
+ *
+ * @param    abms      Define adaptive boost mode selection
+ * @param    abr       Define adaptive boost reference
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_bklit_config_boost_mode(unsigned int abms, unsigned int abr);
+
+/*!
+ * This function gets boost mode configuration
+ * Only on mc13783 2.0 or higher
+ *
+ * @param    abms      Define adaptive boost mode selection
+ * @param    abr       Define adaptive boost reference
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_bklit_gets_boost_mode(unsigned int *abms, unsigned int *abr);
+
+#if defined(CONFIG_MXC_PMIC_MC13892)
+
+PMIC_STATUS mc13892_bklit_set_current(enum lit_channel channel,
+				      unsigned char level);
+PMIC_STATUS mc13892_bklit_get_current(enum lit_channel channel,
+				      unsigned char *level);
+PMIC_STATUS mc13892_bklit_set_dutycycle(enum lit_channel channel,
+					unsigned char dc);
+PMIC_STATUS mc13892_bklit_get_dutycycle(enum lit_channel channel,
+					unsigned char *dc);
+PMIC_STATUS mc13892_bklit_set_ramp(enum lit_channel channel, int flag);
+PMIC_STATUS mc13892_bklit_get_ramp(enum lit_channel channel, int *flag);
+PMIC_STATUS mc13892_bklit_set_blink_p(enum lit_channel channel, int period);
+PMIC_STATUS mc13892_bklit_get_blink_p(enum lit_channel channel, int *period);
+
+#endif
+
+#endif				/* __KERNEL__ */
+
+#endif				/* __ASM_ARCH_MXC_PMIC_LIGHT_H__ */
diff --git a/include/linux/pmic_rtc.h b/include/linux/pmic_rtc.h
new file mode 100644
index 0000000..f0d8742
--- /dev/null
+++ b/include/linux/pmic_rtc.h
@@ -0,0 +1,153 @@
+/*
+ * Copyright 2004-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU Lesser General
+ * Public License.  You may obtain a copy of the GNU Lesser General
+ * Public License Version 2.1 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/lgpl-license.html
+ * http://www.gnu.org/copyleft/lgpl.html
+ */
+
+#ifndef __ASM_ARCH_MXC_PMIC_RTC_H__
+#define __ASM_ARCH_MXC_PMIC_RTC_H__
+
+/*!
+ * @defgroup PMIC_RTC PMIC RTC Driver
+ * @ingroup PMIC_DRVRS
+ */
+
+/*!
+ * @file arch-mxc/pmic_rtc.h
+ * @brief This is the header of PMIC RTC driver.
+ *
+ * @ingroup PMIC_RTC
+ */
+
+/*
+ * Includes
+ */
+#include <linux/ioctl.h>
+#include <linux/pmic_status.h>
+#include <linux/pmic_external.h>
+
+#define         PMIC_RTC_SET_TIME                    _IOWR('p', 0xd1, int)
+#define         PMIC_RTC_GET_TIME                    _IOWR('p', 0xd2, int)
+#define         PMIC_RTC_SET_ALARM		     _IOWR('p', 0xd3, int)
+#define         PMIC_RTC_GET_ALARM		     _IOWR('p', 0xd4, int)
+#define         PMIC_RTC_WAIT_ALARM		     _IOWR('p', 0xd5, int)
+#define         PMIC_RTC_ALARM_REGISTER              _IOWR('p', 0xd6, int)
+#define         PMIC_RTC_ALARM_UNREGISTER            _IOWR('p', 0xd7, int)
+
+/*!
+ * This enumeration define all RTC interrupt
+ */
+typedef enum {
+	/*!
+	 * Time of day alarm
+	 */
+	RTC_IT_ALARM,
+	/*!
+	 * 1 Hz timetick
+	 */
+	RTC_IT_1HZ,
+	/*!
+	 * RTC reset occurred
+	 */
+	RTC_IT_RST,
+} t_rtc_int;
+
+/*
+ * RTC PMIC API
+ */
+
+/* EXPORTED FUNCTIONS */
+#ifdef __KERNEL__
+
+/*!
+ * This function set the real time clock of PMIC
+ *
+ * @param        pmic_time  	value of date and time
+ *
+ * @return       This function returns PMIC_STATUS if successful.
+ */
+PMIC_STATUS pmic_rtc_set_time(struct timeval *pmic_time);
+
+/*!
+ * This function get the real time clock of PMIC
+ *
+ * @param        pmic_time  	return value of date and time
+ *
+ * @return       This function returns PMIC_STATUS if successful.
+ */
+PMIC_STATUS pmic_rtc_get_time(struct timeval *pmic_time);
+
+/*!
+ * This function set the real time clock alarm of PMIC
+ *
+ * @param        pmic_time  	value of date and time
+ *
+ * @return       This function returns PMIC_STATUS if successful.
+ */
+PMIC_STATUS pmic_rtc_set_time_alarm(struct timeval *pmic_time);
+
+/*!
+ * This function get the real time clock alarm of PMIC
+ *
+ * @param        pmic_time  	return value of date and time
+ *
+ * @return       This function returns PMIC_STATUS if successful.
+ */
+PMIC_STATUS pmic_rtc_get_time_alarm(struct timeval *pmic_time);
+
+/*!
+ * This function wait the Alarm event
+ *
+ * @return       This function returns PMIC_STATUS if successful.
+ */
+PMIC_STATUS pmic_rtc_wait_alarm(void);
+
+/*!
+ * This function is used to un/subscribe on RTC event IT.
+ *
+ * @param        event  	type of event.
+ * @param        callback  	event callback function.
+ * @param        sub      	define if Un/subscribe event.
+ *
+ * @return       This function returns PMIC_STATUS if successful.
+ */
+PMIC_STATUS pmic_rtc_event(t_rtc_int event, void *callback, bool sub);
+
+/*!
+ * This function is used to subscribe on RTC event IT.
+ *
+ * @param        event  	type of event.
+ * @param        callback  	event callback function.
+ *
+ * @return       This function returns PMIC_STATUS if successful.
+ */
+PMIC_STATUS pmic_rtc_event_sub(t_rtc_int event, void *callback);
+
+/*!
+ * This function is used to un-subscribe on RTC event IT.
+ *
+ * @param        event  	type of event.
+ * @param        callback  	event callback function.
+ *
+ * @return       This function returns PMIC_STATUS if successful.
+ */
+PMIC_STATUS pmic_rtc_event_unsub(t_rtc_int event, void *callback);
+
+/*!
+ * This function is used to tell if PMIC RTC has been correctly loaded.
+ *
+ * @return       This function returns 1 if RTC was successfully loaded
+ * 		 0 otherwise.
+ */
+int pmic_rtc_loaded(void);
+
+#endif				/* __KERNEL__ */
+
+#endif				/* __ASM_ARCH_MXC_PMIC_RTC_H__ */
diff --git a/include/linux/pxp_dma.h b/include/linux/pxp_dma.h
new file mode 100644
index 0000000..f78e560
--- /dev/null
+++ b/include/linux/pxp_dma.h
@@ -0,0 +1,223 @@
+/*
+ * Copyright (C) 2010-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+#ifndef _PXP_DMA
+#define _PXP_DMA
+
+#include <linux/types.h>
+
+#ifndef __KERNEL__
+typedef unsigned long dma_addr_t;
+typedef unsigned char bool;
+#endif
+
+/*  PXP Pixel format definitions */
+/*  Four-character-code (FOURCC) */
+#define fourcc(a, b, c, d)\
+	(((__u32)(a)<<0)|((__u32)(b)<<8)|((__u32)(c)<<16)|((__u32)(d)<<24))
+
+/*!
+ * @name PXP Pixel Formats
+ *
+ * Pixel formats are defined with ASCII FOURCC code. The pixel format codes are
+ * the same used by V4L2 API.
+ */
+
+/*! @} */
+/*! @name RGB Formats */
+/*! @{ */
+#define PXP_PIX_FMT_RGB332  fourcc('R', 'G', 'B', '1')	/*!<  8  RGB-3-3-2    */
+#define PXP_PIX_FMT_RGB555  fourcc('R', 'G', 'B', 'O')	/*!< 16  RGB-5-5-5    */
+#define PXP_PIX_FMT_RGB565  fourcc('R', 'G', 'B', 'P')	/*!< 1 6  RGB-5-6-5   */
+#define PXP_PIX_FMT_RGB666  fourcc('R', 'G', 'B', '6')	/*!< 18  RGB-6-6-6    */
+#define PXP_PIX_FMT_BGR666  fourcc('B', 'G', 'R', '6')	/*!< 18  BGR-6-6-6    */
+#define PXP_PIX_FMT_BGR24   fourcc('B', 'G', 'R', '3')	/*!< 24  BGR-8-8-8    */
+#define PXP_PIX_FMT_RGB24   fourcc('R', 'G', 'B', '3')	/*!< 24  RGB-8-8-8    */
+#define PXP_PIX_FMT_BGR32   fourcc('B', 'G', 'R', '4')	/*!< 32  BGR-8-8-8-8  */
+#define PXP_PIX_FMT_BGRA32  fourcc('B', 'G', 'R', 'A')	/*!< 32  BGR-8-8-8-8  */
+#define PXP_PIX_FMT_RGB32   fourcc('R', 'G', 'B', '4')	/*!< 32  RGB-8-8-8-8  */
+#define PXP_PIX_FMT_RGBA32  fourcc('R', 'G', 'B', 'A')	/*!< 32  RGB-8-8-8-8  */
+#define PXP_PIX_FMT_ABGR32  fourcc('A', 'B', 'G', 'R')	/*!< 32  ABGR-8-8-8-8 */
+/*! @} */
+/*! @name YUV Interleaved Formats */
+/*! @{ */
+#define PXP_PIX_FMT_YUYV    fourcc('Y', 'U', 'Y', 'V')	/*!< 16 YUV 4:2:2 */
+#define PXP_PIX_FMT_UYVY    fourcc('U', 'Y', 'V', 'Y')	/*!< 16 YUV 4:2:2 */
+#define PXP_PIX_FMT_Y41P    fourcc('Y', '4', '1', 'P')	/*!< 12 YUV 4:1:1 */
+#define PXP_PIX_FMT_YUV444  fourcc('Y', '4', '4', '4')	/*!< 24 YUV 4:4:4 */
+/* two planes -- one Y, one Cb + Cr interleaved  */
+#define PXP_PIX_FMT_NV12    fourcc('N', 'V', '1', '2')	/* 12  Y/CbCr 4:2:0  */
+/*! @} */
+/*! @name YUV Planar Formats */
+/*! @{ */
+#define PXP_PIX_FMT_GREY    fourcc('G', 'R', 'E', 'Y')	/*!< 8  Greyscale */
+#define PXP_PIX_FMT_YVU410P fourcc('Y', 'V', 'U', '9')	/*!< 9  YVU 4:1:0 */
+#define PXP_PIX_FMT_YUV410P fourcc('Y', 'U', 'V', '9')	/*!< 9  YUV 4:1:0 */
+#define PXP_PIX_FMT_YVU420P fourcc('Y', 'V', '1', '2')	/*!< 12 YVU 4:2:0 */
+#define PXP_PIX_FMT_YUV420P fourcc('I', '4', '2', '0')	/*!< 12 YUV 4:2:0 */
+#define PXP_PIX_FMT_YUV420P2 fourcc('Y', 'U', '1', '2')	/*!< 12 YUV 4:2:0 */
+#define PXP_PIX_FMT_YVU422P fourcc('Y', 'V', '1', '6')	/*!< 16 YVU 4:2:2 */
+#define PXP_PIX_FMT_YUV422P fourcc('4', '2', '2', 'P')	/*!< 16 YUV 4:2:2 */
+/*! @} */
+
+#define PXP_LUT_NONE			0x0
+#define PXP_LUT_INVERT			0x1
+#define PXP_LUT_BLACK_WHITE		0x2
+
+#define NR_PXP_VIRT_CHANNEL	16
+
+#define PXP_IOC_MAGIC  'P'
+
+#define PXP_IOC_GET_CHAN      _IOR(PXP_IOC_MAGIC, 0, struct pxp_mem_desc)
+#define PXP_IOC_PUT_CHAN      _IOW(PXP_IOC_MAGIC, 1, struct pxp_mem_desc)
+#define PXP_IOC_CONFIG_CHAN   _IOW(PXP_IOC_MAGIC, 2, struct pxp_mem_desc)
+#define PXP_IOC_START_CHAN    _IOW(PXP_IOC_MAGIC, 3, struct pxp_mem_desc)
+#define PXP_IOC_GET_PHYMEM    _IOWR(PXP_IOC_MAGIC, 4, struct pxp_mem_desc)
+#define PXP_IOC_PUT_PHYMEM    _IOW(PXP_IOC_MAGIC, 5, struct pxp_mem_desc)
+#define PXP_IOC_WAIT4CMPLT    _IOWR(PXP_IOC_MAGIC, 6, struct pxp_mem_desc)
+
+/* Order significant! */
+enum pxp_channel_status {
+	PXP_CHANNEL_FREE,
+	PXP_CHANNEL_INITIALIZED,
+	PXP_CHANNEL_READY,
+};
+
+struct rect {
+	int top;		/* Upper left coordinate of rectangle */
+	int left;
+	int width;
+	int height;
+};
+
+struct pxp_layer_param {
+	unsigned short width;
+	unsigned short height;
+	unsigned int pixel_fmt;
+
+	/* layers combining parameters
+	 * (these are ignored for S0 and output
+	 * layers, and only apply for OL layer)
+	 */
+	bool combine_enable;
+	__u32 color_key_enable;
+	__u32 color_key;
+	bool global_alpha_enable;
+	__u8 global_alpha;
+	bool local_alpha_enable;
+
+	dma_addr_t paddr;
+};
+
+struct pxp_proc_data {
+	/* S0 Transformation Info */
+	int scaling;
+	int hflip;
+	int vflip;
+	int rotate;
+	int yuv;
+
+	/* Source rectangle (srect) defines the sub-rectangle
+	 * within S0 to undergo processing.
+	 */
+	struct rect srect;
+	/* Dest rect (drect) defines how to position the processed
+	 * source rectangle (after resizing) within the output frame,
+	 * whose dimensions are defined in pxp->pxp_conf_state.out_param
+	 */
+	struct rect drect;
+
+	/* Current S0 configuration */
+	__u32 bgcolor;
+
+	/* Output overlay support */
+	int overlay_state;
+
+	/* LUT transformation on Y data */
+	int lut_transform;
+};
+
+struct pxp_config_data {
+	struct pxp_layer_param s0_param;
+	struct pxp_layer_param ol_param[8];
+	struct pxp_layer_param out_param;
+	struct pxp_proc_data proc_data;
+	int layer_nr;
+
+	/* Users don't touch */
+	int chan_id;
+};
+
+struct pxp_mem_desc {
+	__u32 size;
+	dma_addr_t phys_addr;
+	__u32 cpu_addr;		/* cpu address to free the dma mem */
+	__u32 virt_uaddr;		/* virtual user space address */
+};
+
+#ifdef __KERNEL__
+
+struct pxp_tx_desc {
+	struct dma_async_tx_descriptor txd;
+	struct list_head tx_list;
+	struct list_head list;
+	int len;
+	union {
+		struct pxp_layer_param s0_param;
+		struct pxp_layer_param out_param;
+		struct pxp_layer_param ol_param;
+	} layer_param;
+	struct pxp_proc_data proc_data;
+
+	u32 hist_status;	/* Histogram output status */
+
+	struct pxp_tx_desc *next;
+};
+
+struct pxp_channel {
+	struct dma_chan dma_chan;
+	dma_cookie_t completed;	/* last completed cookie */
+	enum pxp_channel_status status;
+	void *client;		/* Only one client per channel */
+	unsigned int n_tx_desc;
+	struct pxp_tx_desc *desc;	/* allocated tx-descriptors */
+	struct list_head active_list;	/* active tx-descriptors */
+	struct list_head free_list;	/* free tx-descriptors */
+	struct list_head queue;	/* queued tx-descriptors */
+	struct list_head list;	/* track queued channel number */
+	spinlock_t lock;	/* protects sg[0,1], queue */
+	struct mutex chan_mutex;	/* protects status, cookie, free_list */
+	int active_buffer;
+	unsigned int eof_irq;
+	char eof_name[16];	/* EOF IRQ name for request_irq()  */
+};
+
+struct pxp_irq_info {
+	wait_queue_head_t waitq;
+	int irq_pending;
+	int hist_status;
+};
+
+#define to_tx_desc(tx) container_of(tx, struct pxp_tx_desc, txd)
+#define to_pxp_channel(d) container_of(d, struct pxp_channel, dma_chan)
+
+void pxp_txd_ack(struct dma_async_tx_descriptor *txd,
+		 struct pxp_channel *pxp_chan);
+#endif
+
+#endif
-- 
1.7.9.5

